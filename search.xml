<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux网络配置工具</title>
      <link href="/2020/05/29/linux-wang-luo-pei-zhi-gong-ju/"/>
      <url>/2020/05/29/linux-wang-luo-pei-zhi-gong-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux网络配置与网络工具"><a href="#Linux网络配置与网络工具" class="headerlink" title="Linux网络配置与网络工具"></a>Linux网络配置与网络工具</h1><h2 id="Linux网络简介"><a href="#Linux网络简介" class="headerlink" title="Linux网络简介"></a>Linux网络简介</h2><h3 id="Linux的网络支持"><a href="#Linux的网络支持" class="headerlink" title="Linux的网络支持"></a>Linux的网络支持</h3><p>Linux支持各种协议类型的网络：</p><ul><li><strong>TCP/IP、NetBIOS/NetBEUI、IPX/SPX、AppleTake</strong>等</li><li>在网络底层也支持<strong>Ethernet、Token Ring、ATM、PPP（PPPoE）、FDDI、Frame Relay</strong>等网络协议。</li></ul><p>这些网络协议是<strong>Linux内核</strong>提供的功能，具体的支持情况由<strong>内核编译参数</strong>决定。</p><p><strong>RHEL/CentOS</strong>的Linux内核默认支持上述的网络协议。</p><h3 id="Linux的网络接口"><a href="#Linux的网络接口" class="headerlink" title="Linux的网络接口"></a>Linux的网络接口</h3><p>Linux支持众多类型的网络接口</p><ul><li>每一个<strong>网络接口设备</strong>在Linux的内核中都有相应的<strong>设备名称</strong></li></ul><p>每一种网络接口设备（网络适配器）都需要相应的<strong>设备驱动程序</strong></p><ul><li>网络接口设备的驱动程序被编译在<strong>系统内核</strong>中</li><li>或者被编译<strong>为系统内核模块</strong>以便让系统内核进行调用</li></ul><p>RHEL/CentOS默认是采用<strong>内核模块</strong>（Module）的方式在系统引导时驱动网络接口的</p><ul><li>在<strong>/lib/modules/$(uname -r)/kernel/drivers/net</strong>目录下可以找到可加载的驱动可以从系统内核模块配置文件/etc/modprobe.conf中查看系统加载的网卡驱动模块</li><li>可以从系统内核模块配置文件<strong>/etc/modprobe.conf</strong>中查看系统加载的网卡驱动模块</li></ul><table><thead><tr><th><strong>接口类型</strong></th><th><strong>接口名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>以太网接口</td><td>ethX</td><td>是最常用的网络接口</td></tr><tr><td>令牌环接口</td><td>trX</td><td>只出现在少数纯IBM环境的网络中</td></tr><tr><td>光纤分布式数据接口</td><td>fddiX</td><td>FDDI接口设备昂贵，通常用于核心网或高速网络中</td></tr><tr><td>点对点协议接口</td><td>pppX</td><td>用于Modem/ADSL拨号网络或基于PPTP协议的VPN等</td></tr><tr><td>本地回环接口</td><td>lo</td><td>用于支持UNIX Domain Socket技术的进程相互通信（IPC）</td></tr></tbody></table><p><strong>X是从0开始的整数。</strong>如：eth0代表第一块以太网卡，eth1代表第二块以太网卡等。</p><h3 id="Linux的网络服务应用"><a href="#Linux的网络服务应用" class="headerlink" title="Linux的网络服务应用"></a>Linux的网络服务应用</h3><p>Linux几乎支持Internet世界里所有的网络服务</p><ul><li><strong>WWW服务</strong>： Apache、Ngnix、Lighttpd</li><li><strong>Email服务</strong>： Postfix、Qmail、Sendmail、Exim</li><li><strong>Dovecot IMAP</strong>、Cyrus IMAP、Courier IMAP</li><li><strong>FTP服务</strong>： Vsftpd、pure-ftpd、Proftpd 、Wu-ftpd</li><li><strong>文件共享服务</strong>：Samba、NFS</li><li><strong>DNS服务</strong>：BIND</li><li><strong>目录服务</strong>：OpenLDAP</li><li><strong>数据库服务</strong>： PostgreSQL、MySQL、 Oracle</li><li><strong>远程登录与管理</strong>：OpenSSH、VNC</li></ul><h2 id="临时性配置网络参数"><a href="#临时性配置网络参数" class="headerlink" title="临时性配置网络参数"></a>临时性配置网络参数</h2><h3 id="配置网络参数的方法"><a href="#配置网络参数的方法" class="headerlink" title="配置网络参数的方法"></a>配置网络参数的方法</h3><p><strong>临时性</strong>网络配置</p><ul><li>通过<strong>命令</strong>修改当前内核中的网络相关参数实现<ul><li>Ifconfig/ip、route、hostname、 sysctl -w</li></ul></li><li><strong>配置后立即生效重新开机后失效</strong></li></ul><p><strong>永久性</strong>网络配置</p><ul><li>通过直接修改网络相关的<strong>配置文件</strong>实现</li><li>修改配置文件后，为了使之立即生效<ul><li>通过重新启动网络服务或指定的网络接口设备实现</li><li>重新开机后保留所有配置</li></ul></li></ul><h3 id="管理以太网接口"><a href="#管理以太网接口" class="headerlink" title="管理以太网接口"></a>管理以太网接口</h3><p><strong>网络接口命名</strong>：eth0、eth1 等等</p><ul><li>使用别名（aliases），单个设备可具备多个地址 </li><li>别名被标识为（eth0:1，eth0:2）等等</li><li>别名被当作单独的接口对待</li><li>基于一块物理网卡的多个别名（包括物理网卡自身）只能有一个接口使用DHCP动态分配网络参数</li></ul><p>查看<strong>网络接口配置</strong></p><ul><li><strong>ifconfig [ethX]</strong></li></ul><p>网络接口的启用与停用</p><ul><li>使用 <strong>ifup ethX</strong> 命令来启用指定的接口 </li><li>使用 <strong>ifdown ethX</strong> 命令来禁用指定的接口</li></ul><h3 id="ifconfig-命令"><a href="#ifconfig-命令" class="headerlink" title="ifconfig 命令"></a>ifconfig 命令</h3><p>ifconfig命令可以<strong>临时地设置网络接口的IP参数</strong></p><p>格式：</p><blockquote><p>ifconfig &lt;网络接口&gt; &lt;IP地址&gt;<br>[Mask &lt;子网掩码&gt;] [Broadcast &lt;广播地址&gt;]</p></blockquote><p>当IP地址使用标准A、B、C类地址时，广播地址和子网掩码可以省略。</p><p>举例：</p><blockquote><p>ifconfig eth0 10.0.0.10 Mask 255.255.255.0 Broadcast 10.0.0.255<br>ifconfig eth0 192.168.0.10<br>ifconfig eth0:0 192.168.1.10</p></blockquote><h3 id="查看Linux内核路由表"><a href="#查看Linux内核路由表" class="headerlink" title="查看Linux内核路由表"></a>查看Linux内核路由表</h3><p>使用route命令，查看路由表。路由表可以包含：<strong>到主机的路由、到网络的路由、默认网关的路由。</strong></p><blockquote><p>route<br>Kernel IP routing table<br>Destination  Gateway      Genmask         Flags Metric Ref Use Iface<br>192.168.0.0  <em>            255.255.255.0   U     0      0     0 eth0<br>192.168.1.0  </em>            255.255.255.0   U     0      0     0 eth1<br>192.19.12    192.168.1.1  255.255.255.0   U     0      0     0 eth1<br>default      localhost    0.0.0.0         UG    0      0     0 eth0</p></blockquote><h3 id="route命令"><a href="#route命令" class="headerlink" title="route命令"></a>route命令</h3><p>route命令可以<strong>临时地设置内核路由表</strong>。</p><p>格式：</p><blockquote><p>route add|del [-net|-host] &lt;target [netmask Netmask]&gt;<br>        [gw Gateway] [[dev] Interface]</p></blockquote><p>选项：</p><ul><li>add或del：表示添加或删除路由</li><li>-net或-host：表示添加到主机或网络的路由</li><li>target：指定目标主机或网络地址，若目标为网络地址时，需使用 netmask 指定子网掩码</li><li>gw：用于指定网关的IP地址</li><li>dev：用于指定路由的网络接口（dev关键字可省略）</li></ul><p>举例：</p><blockquote><p>添加到主机的路由<br>route add -host 192.168.1.2 dev eth0:0<br>route add -host 10.20.30.148 gw 10.20.30.40<br>添加到网络的路由<br>route add -net 10.20.30.40 netmask 255.255.255.248 eth0<br>route add -net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41<br>route add -net 192.168.1.0/24 eth1<br>添加默认网关路由<br>route add default gw 192.168.1.1</p><p>删除到主机的路由<br>route del -host 192.168.1.2 dev eth0:0<br>route del -host 10.20.30.148 gw 10.20.30.40<br>删除到网络的路由<br>route del -net 10.20.30.40 netmask 255.255.255.248 eth0<br>route del -net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41<br>route del -net 192.168.1.0/24 eth1<br>删除默认网关路由<br>route del default gw 192.168.1.1</p></blockquote><h3 id="设置主机名和包转发"><a href="#设置主机名和包转发" class="headerlink" title="设置主机名和包转发"></a>设置主机名和包转发</h3><p><strong>使用hostname命令可以临时地修改主机名</strong></p><p>格式：</p><blockquote><p>hostname &lt;主机名&gt;</p></blockquote><p>例如：</p><blockquote><p>hostname centos1.ls-al.loc</p></blockquote><p><strong>使用sysctl命令可以临时地开启内核的包转发</strong></p><p>sysctl命令用于<strong>临时调整</strong>内核参数</p><p>开启内核的包转发功能使用如下命令</p><blockquote><p>sysctl -w net.ipv4.ip_forward=1</p><p>或</p><p>echo “1” &gt; /proc/sys/net/ipv4/ip_forward</p></blockquote><h3 id="网络设置-ip"><a href="#网络设置-ip" class="headerlink" title="网络设置-ip"></a>网络设置-ip</h3><h4 id="iproute2包，代替传统的net-tools"><a href="#iproute2包，代替传统的net-tools" class="headerlink" title="iproute2包，代替传统的net-tools"></a>iproute2包，代替传统的net-tools</h4><p>格式：</p><blockquote><p>ip [ OPTIONS ] OBJECT { COMMAND | help }</p></blockquote><p>对象OBJECT={ link | addr | addrlabel | route | rule | neigh | ntable | tunnel | maddr | mroute | mrule | monitor | xfrm | token }</p><p>选项OPTIONS={ -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] | -h[uman-readable] | -iec | -f[amily] { inet | inet6 | ipx | dnet | link } | -o[neline] | -t[imestamp] | -b[atch] [filename] | -rc[vbuf] [size] }</p><p>例子：</p><blockquote><p>ip a/addr/address sh/show dev eth1查看指定IP地址</p></blockquote><h4 id="ip命令"><a href="#ip命令" class="headerlink" title="ip命令"></a>ip命令</h4><p>ip是<strong>iproute2软件包</strong>里面的一个强大的网络配置工具</p><p>用来<strong>显示或操作路由、网络设备、策略路由和隧道</strong></p><p>它能够<strong>替代</strong>一些传统的网络管理工具，例如<strong>ifconfig、route</strong>等。</p><p>用ip配置的设备信息，大部分会在设备重启后还原。如果想永久保留配置，需进入<strong>配置文件</strong>修改。</p><h5 id="设置和删除ip地址"><a href="#设置和删除ip地址" class="headerlink" title="设置和删除ip地址"></a>设置和删除ip地址</h5><p>设置一个IP地址，可以使用下列ip命令：</p><blockquote><p> ip addr add 192.168.0.193/24 dev wlan0</p></blockquote><p> 请注意IP地址要有一个后缀，比如<strong>/24</strong>。这种用法用于在<strong>无类域内路由选择（CIDR）中来显示所用的子网掩码</strong>。在这个例子中，子网掩码是<strong>255.255.255.0</strong>。（表示子网掩码前24位为1）</p><h5 id="查看IP地址"><a href="#查看IP地址" class="headerlink" title="查看IP地址"></a>查看IP地址</h5><p>查看一个IP地址，可以使用下列ip命令：</p><blockquote><p> ip addr show wlan0</p></blockquote><h5 id="删除IP地址"><a href="#删除IP地址" class="headerlink" title="删除IP地址"></a>删除IP地址</h5><p>删除一个IP地址，可以使用下列ip命令：</p><blockquote><p> ip addr del 192.168.0.193/24 dev wlan0</p></blockquote><h5 id="路由功能"><a href="#路由功能" class="headerlink" title="路由功能"></a>路由功能</h5><p>列出路由表条目</p><blockquote><p>ip route show</p></blockquote><p>查看路由表</p><blockquote><p>ip route get 119.75.216.20</p></blockquote><p>添加默认路由</p><blockquote><p>ip route add default via 192.168.202.254</p></blockquote><p>添加网络路由</p><blockquote><p>ip route add 192.168.4.0/24 via 192.168.4.1</p></blockquote><p>修改网络路由</p><blockquote><p>ip route change 192.168.4.0/24 dev eth1</p></blockquote><p>设置NAT路由</p><blockquote><p>ip route add nat 192.168.1.100 via 192.168.1.1 </p></blockquote><p>查看某个路由表信息</p><blockquote><p>ip route show table main<br>ip route show table local<br>ip route show table all </p></blockquote><p>擦除路由表</p><ul><li><p>擦除所有路由表</p><blockquote><p>ip route flush</p></blockquote></li><li><p>擦除路由表的缓存</p><blockquote><p>ip route flush cach</p></blockquote></li></ul><h2 id="永久性配置网络参数"><a href="#永久性配置网络参数" class="headerlink" title="永久性配置网络参数"></a>永久性配置网络参数</h2><h3 id="RHEL-CentOS中的TCP-IP配置文件"><a href="#RHEL-CentOS中的TCP-IP配置文件" class="headerlink" title="RHEL/CentOS中的TCP/IP配置文件"></a>RHEL/CentOS中的TCP/IP配置文件</h3><table><thead><tr><th><strong>配置文件</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>/etc/sysconfig/network</td><td><strong>系统网络配置文件</strong>，包含了主机最基本的网络信息用于系统启动</td></tr><tr><td>/etc/sysconfig/network-scripts/ifcfg-ethX</td><td><strong>以太网接口配置文件</strong></td></tr><tr><td>/etc/sysconfig/network-scripts/route-ethX</td><td>以太网接口的<strong>静态路由</strong>配置文件</td></tr><tr><td>/etc/hosts</td><td>完成主机名映射为IP地址的<strong>静态解析功能</strong></td></tr><tr><td>/etc/resolv.conf</td><td>配置域名服务客户端的配置文件，用于指定<strong>域名服务器的位置</strong></td></tr><tr><td>/etc/host.conf</td><td>配置<strong>域名服务客户端</strong>的控制文件</td></tr></tbody></table><h3 id="网络接口配置文件"><a href="#网络接口配置文件" class="headerlink" title="网络接口配置文件"></a>网络接口配置文件</h3><p><strong>网络设备的配置</strong>被保存在文本文件中 <strong>/etc/sysconfig/network-scripts/ifcfg-ethX</strong></p><p>配置文件的语法和完整选项列表参见 <strong>/usr/share/doc/initscripts-*/sysconfig.txt</strong></p><p>常用选项:</p><table><thead><tr><th><strong>选项</strong></th><th><strong>说明</strong></th><th><strong>选项</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Type</td><td>指定网络接口类型</td><td>IPADDR</td><td>指定静态IP地址</td></tr><tr><td>DEVICE</td><td>指定设备名</td><td>NETMASK</td><td>指定子网掩码</td></tr><tr><td>HWADDR</td><td>指定网卡的MAC地址</td><td>BROADCAST</td><td>指定广播地址</td></tr><tr><td>BOOTPROTO</td><td>指定获取网络参数的方式</td><td>GATEWAY</td><td>指定设备的网关</td></tr><tr><td>ONBOOT</td><td>指定是否在启动时启用设备</td><td></td><td></td></tr></tbody></table><pre class="line-numbers language-shell"><code class="language-shell"># vim /etc/sysconfig/network-scripts/ifcfg-eth0Type=EthernetDEVICE=eth0HWADDR=00:02:8A:A6:30:45BOOTPROTO=staticONBOOT=yesIPADDR=192.168.0.123NETMASK=255.255.255.0BROADCAST=192.168.0.255GATEWAY=192.168.0.1#静态配置# vim /etc/sysconfig/network-scripts/ifcfg-eth0    Type=EthernetDEVICE=eth0HWADDR=00:02:8A:A6:30:45BOOTPROTO=dhcpONBOOT=yes# 动态配置（DHCP)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="系统网络配置文件"><a href="#系统网络配置文件" class="headerlink" title="系统网络配置文件"></a>系统网络配置文件</h3><p>系统网络配置文件为<strong>/etc/sysconfig/network</strong>,用于永久性配置<strong>主机名和默认网关</strong>等</p><p>例如：</p><pre class="line-numbers language-shell"><code class="language-shell"># vim /etc/sysconfig/networkNETWORKING=yesHOSTNAME=centos1.ls-al.locGATEWAY=192.168.1.254<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="网络接口的静态路由配置文件"><a href="#网络接口的静态路由配置文件" class="headerlink" title="网络接口的静态路由配置文件"></a>网络接口的静态路由配置文件</h3><p>每个网络接口均可有其静态路由配置文件，如<strong>/etc/sysconfig/network-scripts/route-ethX</strong></p><p>配置网络接口eth0的静态路由：</p><pre class="line-numbers language-shell"><code class="language-shell"># vim /etc/sysconfig/network-scripts/route-eth0192.168.2.0/24  via  172.16.10.88<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="本地域名解析配置文件"><a href="#本地域名解析配置文件" class="headerlink" title="本地域名解析配置文件"></a>本地域名解析配置文件</h3><p>本地域名解析数据库文件为 <strong>/etc/hosts</strong></p><p>例如：</p><pre class="line-numbers language-shell"><code class="language-shell"># vim /etc/hosts127.0.0.1    localhost.localdomain   localhost::1          localhost6.localdomain6 localhost6192.168.1.200    centos1.ls-al.loc   centos1192.168.0.200    soho.mylabs.me      soho<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置远程域名解析器"><a href="#配置远程域名解析器" class="headerlink" title="配置远程域名解析器"></a>配置远程域名解析器</h3><p>设置Linux的DNS客户，可以编辑<strong>/etc/resolv.conf</strong>文件</p><p>举例：</p><pre class="line-numbers language-shell"><code class="language-shell"># vim /etc/resolv.confnameserver  192.168.1.1nameverver  208.67.222.222nameverver  208.67.220.220domain     sinolido.org        # 指定本机所在的域search      sinolido.org        # 指定默认搜索域<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置域名解析顺序"><a href="#配置域名解析顺序" class="headerlink" title="配置域名解析顺序"></a>配置域名解析顺序</h3><p>域名解析的优先顺序，由配置文件<strong>/etc/host.conf</strong>决定</p><p>例如</p><ul><li>首先查找 /etc/hosts 文件进行域名解析</li><li>然后使用/etc/resolv.conf文件中指定的域名服务器进行域名解析</li></ul><pre class="line-numbers language-shell"><code class="language-shell"># vim /etc/host.conforder hosts,bind<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="网络测试工具"><a href="#网络测试工具" class="headerlink" title="网络测试工具"></a>网络测试工具</h2><h3 id="网络检测的常用工具"><a href="#网络检测的常用工具" class="headerlink" title="网络检测的常用工具"></a>网络检测的常用工具</h3><table><thead><tr><th><strong>命令工具</strong></th><th><strong>功能说明</strong></th></tr></thead><tbody><tr><td><strong>ifconfig</strong></td><td><strong>检测网络接口配置</strong></td></tr><tr><td><strong>route</strong></td><td><strong>检测路由配置</strong></td></tr><tr><td><strong>ping</strong></td><td><strong>检测网络连通性</strong></td></tr><tr><td><strong>netstat</strong></td><td><strong>查看网络状态</strong></td></tr><tr><td><strong>lsof</strong></td><td><strong>查看指定IP 和/或 端口的进程的当前运行情况</strong></td></tr><tr><td><strong>host/dig/nslookup</strong></td><td><strong>检测DNS解析</strong></td></tr><tr><td><strong>traceroute</strong></td><td><strong>检测到目的主机所经过的路由器</strong></td></tr><tr><td><strong>tcpdump</strong></td><td><strong>显示本机网络流量的状态</strong></td></tr></tbody></table><h3 id="ping和traceroute（网络层，ICMP协议）"><a href="#ping和traceroute（网络层，ICMP协议）" class="headerlink" title="ping和traceroute（网络层，ICMP协议）"></a>ping和traceroute（网络层，ICMP协议）</h3><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>测试网络的<strong>连通性</strong></p><p>例如：</p><blockquote><p>ping <a href="http://www.sina.con.cn" target="_blank" rel="noopener">www.sina.con.cn</a><br>ping -c 4 192.168.1.12</p></blockquote><h4 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h4><p>显示数据包到达目的主机所<strong>经过的路由</strong></p><p>例如：</p><blockquote><p>traceroute  <a href="http://www.sina.com.cn" target="_blank" rel="noopener">www.sina.com.cn</a></p></blockquote><h3 id="查看网络端口的使用情况"><a href="#查看网络端口的使用情况" class="headerlink" title="查看网络端口的使用情况"></a>查看网络端口的使用情况</h3><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>查看<strong>网络端口</strong> </p><blockquote><p>netstat -an<br>netstat -lunpt</p></blockquote><h4 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h4><p> 查看在<strong>指定IP 和/或 端口上打开的进程</strong></p><blockquote><p>lsof -i @192.168.0.200</p><p>lsof -n -i <a href="mailto:UDP@192.168.0.200" target="_blank" rel="noopener">UDP@192.168.0.200</a></p></blockquote><p>查看<strong>指定端口运行的程序</strong></p><blockquote><p>lsof -i :ssh<br>lsof -i :22</p></blockquote><h4 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h4><p>端口扫描 </p><h2 id="网络客户工具"><a href="#网络客户工具" class="headerlink" title="网络客户工具"></a>网络客户工具</h2><h3 id="图形界面网络客户工具"><a href="#图形界面网络客户工具" class="headerlink" title="图形界面网络客户工具"></a>图形界面网络客户工具</h3><p>图形界面浏览器：Firefox、Mozilla</p><p>图形界面E-mail客户端：Thunderbird、Evolution</p><p>图形界面FTP客户端：Gftp、Konqueror</p><p>图形界面下载工具：WebDownloader for X、Httrack、Getleft</p><h3 id="字符界面网络工具"><a href="#字符界面网络工具" class="headerlink" title="字符界面网络工具"></a>字符界面网络工具</h3><table><thead><tr><th><strong>命令</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><strong>telnet</strong></td><td>远程登录</td></tr><tr><td><strong>ftp /</strong> <strong>lftp</strong> <strong>/</strong> <strong>ncftp</strong></td><td>FTP工具</td></tr><tr><td><strong>smbclient</strong></td><td>存取 SMB/CIFS 共享资源（类似于ftp）</td></tr><tr><td><strong>wget</strong></td><td>下载文件、镜像 WEB站点</td></tr><tr><td><strong>rsync</strong></td><td>远程文件同步</td></tr><tr><td><strong>links / w3m / lynx</strong></td><td>浏览器</td></tr><tr><td><strong>mutt / mail</strong></td><td>邮件客户</td></tr><tr><td><strong>ssh</strong> <strong>/</strong> <strong>scp</strong> <strong>/</strong> <strong>sftp</strong></td><td>基于安全协议的 远程登录/远程复制/远程FTP</td></tr></tbody></table><h4 id="传统的ftp命令"><a href="#传统的ftp命令" class="headerlink" title="传统的ftp命令"></a>传统的ftp命令</h4><p>只支持<strong>交互式</strong>使用方式</p><blockquote><p>$ ftp [ &lt; hostname or IPAddress &gt; ]</p></blockquote><p>常用的交互子命令</p><table><thead><tr><th><strong>子命令</strong></th><th><strong>功能</strong></th><th><strong>子命令</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>?</td><td>获得命令帮助</td><td>lcd</td><td>切换本地目录</td></tr><tr><td>!&lt; CMD &gt;</td><td>执行本地Shell命令</td><td>!ls</td><td>显示本地目录列表</td></tr><tr><td>open/close</td><td>开启/关闭连接会话</td><td>bye/quit</td><td>退出ftp交互</td></tr><tr><td>bin/asc</td><td>指定二进制/文本传输</td><td>get/put</td><td>单文件上传、下载</td></tr><tr><td>pwd、ls、cd、mkdir、rmdir</td><td>远程目录管理</td><td>mget、mput</td><td>多文件上传、下载（支持通配符）</td></tr></tbody></table><h4 id="lftp简介"><a href="#lftp简介" class="headerlink" title="lftp简介"></a>lftp简介</h4><p>lftp是个功能强大的<strong>字符界面文件传输工具</strong></p><p>功能：</p><ul><li>支持交互式和命令行两种工作模式</li><li>支持ftp、ftps、http、https、hftp、fish等传输协议</li><li>支持FXP【File eXchange Protocol】（在两个FTP服务器之间传输文件）</li><li>支持代理、支持多线程传输、支持断点续传</li><li>支持传输队列（queue)、支持书签（bookmark）</li><li>支持镜像（mirror）</li><li>类似bash，提供后台命令、nohop模式、命令历史、命令别名、命令补齐、作业控制、lftp环境设置等支持。</li><li>使用 lftpget 来实现自动化传输</li></ul><h2 id="安全的网络客户工具"><a href="#安全的网络客户工具" class="headerlink" title="安全的网络客户工具"></a>安全的网络客户工具</h2><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>SSH 的英文全称为 <strong>Secure SHell</strong></p><p>SSH 是IETF 的<strong>网络工作组</strong>所制定的协议</p><p>SSH 是建立在<strong>应用层和传输层</strong>基础上的安全协议</p><p>SSH（Secure SHell）协议是 C/S 模式协议，分为 SSH 的客户端和服务器端，一次成功的 SSH 会话需要两端通力合作来完成。</p><p>SSH 目的是要在<strong>非安全网络</strong>上提供<strong>安全的远程登录和其他安全服务</strong></p><p>所有使用 SSH 协议的通信，包括口令，都会<strong>被加密传输</strong></p><p>用于替代传统的 <strong>telnet、ftp、r族命令</strong>（rlogin、rsh、rcp）</p><blockquote><p>ssh [user@]hostname<br>ssh [user@]hostname command </p></blockquote><h3 id="OpenSSH"><a href="#OpenSSH" class="headerlink" title="OpenSSH"></a>OpenSSH</h3><p>OpenSSH 是 SSH 协议的<strong>免费开源实现</strong></p><ul><li>安全、加密的网络连接工具（ssh、scp、sftp）</li><li>代替了 telnet、 rlogin、rsh、rcp 和 ftp 等工具</li></ul><p>OpenSSH 支持 SSH 协议的版本 1和 2。</p><ul><li>自从 OpenSSH 的版本 2.9 以来，默认的协议是版本 2</li><li>版本 2的协议支持 RSA 和 DSA，默认使用 RSA 密钥</li></ul><p>OpenSSH 支持的用户认证方式</p><ul><li>支持基于 PAM 的用户口令认证</li><li>支持用户密钥认证 </li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库复习——基于MySQL</title>
      <link href="/2020/05/29/shu-ju-ku-fu-xi-ji-yu-mysql/"/>
      <url>/2020/05/29/shu-ju-ku-fu-xi-ji-yu-mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库复习笔记"><a href="#数据库复习笔记" class="headerlink" title="数据库复习笔记"></a>数据库复习笔记</h1><p>本文是我复习数据库所做的知识总结，选用的数据库主要为：MySQL。更详细的内容可以看牛客网上这篇<a href="https://www.nowcoder.com/discuss/150059?type=0&amp;order=7&amp;pos=43&amp;page=2&amp;source_id=discuss_center_0&amp;channel=2000。" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/150059?type=0&amp;order=7&amp;pos=43&amp;page=2&amp;source_id=discuss_center_0&amp;channel=2000。</a></p><h2 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h2><h3 id="数据库定义"><a href="#数据库定义" class="headerlink" title="数据库定义"></a>数据库定义</h3><p>数据库（Database）是<strong>按照数据结构来组织、存储和管理数据的仓库</strong>。</p><p>每个数据库都有一个或多个不同的 API 用于<strong>创建，访问，管理，搜索和复制</strong>所保存的数据。</p><p>我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较<strong>慢</strong>。还存在着以下的缺陷:</p><ul><li>共享性差</li><li>安全性差</li><li>数据不一致</li><li>数据独立性差</li><li>数据冗余大</li><li>数据删除、添加、修改等麻烦</li></ul><h3 id="数据库基本概念-1"><a href="#数据库基本概念-1" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h3><p>数据库的四大基本概念为：</p><ul><li><strong>数据</strong>（Data）：数据库中存储的<strong>基本对象</strong>，是事物的<strong>符号记录</strong>。<ul><li>特点：数据的解释是指对<strong>数据含义</strong>的说明。</li></ul></li><li><strong>数据库</strong>（DataBase，DB）：数据库是<strong>长期储存在计算机内、有组织的、可共享的大量数据的集合</strong>。存储的是<strong>数据以及数据之间的联系</strong>。<ul><li>特点：<ul><li><strong>数据结构化</strong>，统一管理和控制</li><li>较小的<strong>冗余度</strong></li><li>较高的<strong>独立性、易扩展性、共享性</strong></li></ul></li></ul></li><li><strong>数据库管理系统</strong>（DBMS）：<strong>位于用户与操作系统之间的一层数据管理软件</strong>。用于科学地组织和存储数据、高效地获取和维护数据。属于<strong>系统软件</strong>。主要功能是<strong>定义数据库</strong>。（MySQL、Oracle、SQL Sever等都属于DBMS）<ul><li>主要功能：<ul><li>数据<strong>定义</strong>功能：DBMS提供<strong>数据描述语言</strong>（DDL），用户可通过它来定义数据对象。</li><li>数据<strong>操纵</strong>功能：DBMS还提供<strong>数据操纵语言</strong>（DML），实现对数据库的基本操作（<strong>CURD</strong>）：查询、插入、删除和修改。</li><li>数据库的<strong>运行管理</strong>：这是DBMS运行时的<strong>核心</strong>部分，它包括<strong>并发控制，安全性检查，完整性约束条件的检查和执行，发生故障后的恢复</strong>等。</li><li>数据库的<strong>建立和维护</strong>功能 ：它包括数据库初始数据的输入及转换，数据库的转储与恢复，数据库的重组功能和性能的监视与分析功能等。</li></ul></li></ul></li><li><strong>数据库系统</strong>（DBS） ：核心是<strong>数据库管理模型</strong>。是在文件系统上发展起来的，计算机系统引用数据库后的系统。 由<strong>DB、DBMS（及其开发工具）、应用系统、DBA（数据库管理员）</strong>构成。能够减少冗余、提高数据独立性、并集中检查数据完整性。<ul><li>DBA数据库管理员的主要职责为：<ul><li>决定DB中的信息内容和结构；</li><li>决定DB的存储结构和存取策略；</li><li>定义数据的安全性要求和完整性约束条件；</li><li>监控数据库的使用和运行。 </li></ul></li></ul></li></ul><h3 id="三级模式结构"><a href="#三级模式结构" class="headerlink" title="三级模式结构"></a>三级模式结构</h3><h4 id="模式（全体数据逻辑结构）"><a href="#模式（全体数据逻辑结构）" class="headerlink" title="模式（全体数据逻辑结构）"></a>模式（全体数据逻辑结构）</h4><p><strong>模式（逻辑模式）</strong>：数据库中<strong>全体</strong>数据<strong>的逻辑结构和特征</strong>的描述。一个数据库只有<strong>一个</strong>模式，定义数据的逻辑结构，如：<strong>数据之间的联系，与数据有关的安全性、完整性要求</strong>。</p><p>关系型数据库中的<strong>表</strong>属于模式。</p><h4 id="外模式（局部数据逻辑结构）"><a href="#外模式（局部数据逻辑结构）" class="headerlink" title="外模式（局部数据逻辑结构）"></a>外模式（局部数据逻辑结构）</h4><p><strong>外模式（子模式）</strong>：数据库中<strong>局部</strong>数据的<strong>逻辑结构和特征的描述</strong>。一个数据库可以有<strong>多个</strong>外模式。保证数据库<strong>安全性</strong>的有力措施。是<strong>模式的逻辑子集</strong>。</p><h4 id="内模式（全体数据物理结构）"><a href="#内模式（全体数据物理结构）" class="headerlink" title="内模式（全体数据物理结构）"></a>内模式（全体数据物理结构）</h4><p><strong>内模式（存储模式）</strong>：数据<strong>物理结构和存储方式</strong>的描述。一个数据库只有<strong>一个</strong>内模式。是数据在数据库内部的表达方式，物理结构指的是<strong>数据在硬盘上是怎么被保存的</strong>。</p><h3 id="二级映象"><a href="#二级映象" class="headerlink" title="二级映象"></a>二级映象</h3><p>三级模式是对数据的<strong>三个抽象级别</strong>，二级映象在DBMS内部实现这三个抽象层次的联系和转换</p><h4 id="外模式-模式映像"><a href="#外模式-模式映像" class="headerlink" title="外模式/模式映像"></a>外模式/模式映像</h4><p>定义<strong>外模式与模式</strong>之间的对应关系。保证数据的<strong>逻辑独立性</strong>。</p><p><strong>逻辑独立性</strong>：用户的应用程序与数据库中的<strong>逻辑结构</strong>是相互独立的。</p><h4 id="模式-内模式映像"><a href="#模式-内模式映像" class="headerlink" title="模式/内模式映像"></a>模式/内模式映像</h4><p>定义数据<strong>全局逻辑结构与存储结构</strong>之间的对应关系。 保证数据的<strong>物理独立性。</strong></p><p><strong>物理独立性</strong>：用户的应用程序与<strong>储存在硬盘上的数据库中的数</strong>据是相互独立的。</p><h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><h3 id="关系模型概述"><a href="#关系模型概述" class="headerlink" title="关系模型概述"></a>关系模型概述</h3><p>关系模型的数据结构是：<strong>二维表结构</strong>，它是<strong>关系型数据库</strong>的基础。</p><p>关系数据模型由<strong>关系数据结构、关系操作和关系完整性约束</strong>三部分组成。</p><p>关系必须是<strong>规范化</strong>的，满足一定的<strong>规范条件</strong>。</p><p>关系数据库必须满足<strong>1NF</strong>范式，即一张表中不包含<strong>子表</strong>。（关系的每一个分量必须是一个<strong>不可分</strong>的数据项, 不允许表中还有表）</p><p>关系模型只是<strong>常用的数据模型</strong>的一种，数据模型按照<strong>数据之间的联系</strong>可以划分为：</p><ul><li><strong>层次</strong>模型</li><li><strong>网状</strong>模型</li><li><strong>关系</strong>模型</li><li><strong>面向对象</strong>模型</li></ul><h3 id="关系模型的基本概念"><a href="#关系模型的基本概念" class="headerlink" title="关系模型的基本概念"></a>关系模型的基本概念</h3><p>关系模型在1970年E.F.Codd提出，操作语言是<strong>结构化查询语言SQL</strong>（Structural Querry Language）</p><ul><li><strong>关系</strong>：通常指一张<strong>表</strong></li><li><strong>元组</strong>：表中的一行<strong>记录</strong></li><li><strong>属性</strong>：表中的一<strong>列</strong>，有<strong>属性名和属性值（分量）</strong></li><li><strong>分量</strong>：元组中的一个<strong>属性值</strong></li><li><strong>关系模式</strong>：对关系的<strong>描述</strong>，通常有几张表就有几个关系模式</li><li><strong>域</strong>：属性值的<strong>取值范围</strong></li><li><strong>键</strong>：<ul><li><strong>超键（关键字）</strong>：在关系中能<strong>唯一标识元组的属性集</strong></li><li><strong>候选键</strong>：不含有<strong>多余属性</strong>的<strong>超键</strong></li><li><strong>主键</strong>：用户<strong>选作</strong>元组标识的<strong>候选键</strong>（<strong>人为设定</strong>）</li><li><strong>外键</strong>：<strong>如果关系模式R中的属性k是其他关系模式的主键，则k是R中的外键</strong>（表与表的关系通过外键来描述）外键表中的外键不能有主键表中<strong>不存在</strong>的数据。（保证数据的完整性和一致性）</li></ul></li><li><strong>主属性</strong>：一个属性只要在<strong>任何一个候选键</strong>中出现过，这个属性就是主属性。</li><li><strong>非主属性</strong>：与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。</li></ul><h3 id="关系的完整性约束"><a href="#关系的完整性约束" class="headerlink" title="关系的完整性约束"></a>关系的完整性约束</h3><ul><li><strong>实体完整性</strong>：关系必须有<strong>主键</strong>，且<strong>主键不能重复</strong>，<strong>不能为空</strong> </li><li><strong>参照完整性</strong>：以<strong>外键</strong>的形式维护实体间的引用关系，可以<strong>为空</strong>或者值为<strong>被参照关系的主键值</strong></li><li><strong>用户自定义完整性</strong>：用户由应用环境决定的针对<strong>具体关系数据库</strong>的约束（属性类型等）</li></ul><h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p>我们以如下的两张表作为原始数据：</p><p><img src="%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0.png" alt="关系代数"></p><h4 id="并操作（Union）"><a href="#并操作（Union）" class="headerlink" title="并操作（Union）"></a>并操作（Union）</h4><p>关系（表） R 与关系 S 的并（∪）由<strong>属于 R 或属于 S</strong> 的元组（记录）组成。</p><p><img src="%E5%B9%B6.png" alt="并"></p><h4 id="差操作（except）"><a href="#差操作（except）" class="headerlink" title="差操作（except）"></a>差操作（except）</h4><p>关系R与关系S的差由<strong>属于R而不属于S</strong>的所有元组组成。</p><p><img src="%E5%B7%AE.png" alt="差"></p><h4 id="交操作（intersection）"><a href="#交操作（intersection）" class="headerlink" title="交操作（intersection）"></a>交操作（intersection）</h4><p>关系R与关系S的差由<strong>属于R且属于S</strong>的所有元组组成。</p><p><img src="%E4%BA%A4.png" alt="交"></p><h4 id="笛卡尔积（cartesian-product）"><a href="#笛卡尔积（cartesian-product）" class="headerlink" title="笛卡尔积（cartesian product）"></a>笛卡尔积（cartesian product）</h4><p>这里的笛卡尔积严格地讲是<strong>广义笛卡尔积</strong>。在不会出现混淆的情况下广义笛卡尔积也称为笛卡尔积。</p><p>两个分别为n目和m目的关系R和S的广义笛卡尔积是一个<strong>n+m列</strong>的元组的集合。元组的前n列是关系R的一个元组，后m列是关系S的一个元组。若R有k1个元组，S有k2个元组，则关系R和关系S的广义笛卡尔积有<strong>k1×k2</strong>个元组。</p><p><strong>R中的每一行元素与S中的每一行元素连接。</strong></p><p>相当于：<strong>select 列名 from 表A，表B</strong> 或者<strong>select 列名 from 表A join 表B</strong></p><p><img src="%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF.png" alt="笛卡尔积"></p><h4 id="投影（projection）"><a href="#投影（projection）" class="headerlink" title="投影（projection）"></a>投影（projection）</h4><p>关系R上的投影是从R中选择出<strong>若干属性列</strong>组成新的关系。</p><p>相当于：<strong>select 列名 from 表名</strong>。</p><h4 id="选择（selection）"><a href="#选择（selection）" class="headerlink" title="选择（selection）"></a>选择（selection）</h4><p>选择又称为限制（Restriction）。它是在关系R中<strong>选择满足给定条件的诸元组</strong>。</p><p>相当于：<strong>select * from 表名 where 条件</strong>。</p><h4 id="除（division）"><a href="#除（division）" class="headerlink" title="除（division）"></a>除（division）</h4><p>除法运算是一个复合的二目运算。如果把笛卡尔积看作“乘法”运算，则除法运算可以看作这个“乘法”的逆运算。</p><p>若T=R÷S，则S×T的结果应该<strong>全部包含</strong>在R中。</p><p><img src="%E9%99%A4.png" alt="除"></p><h4 id="连接（join）"><a href="#连接（join）" class="headerlink" title="连接（join）"></a>连接（join）</h4><p>关系R与关系S的连接运算是从两个关系的<strong>广义笛卡尔积</strong>中选取<strong>属性间满足一定条件</strong>的元组形成一个新的连接。（如果不加任何条件，那么默认的连接就是两张表的广义笛卡尔积）</p><h5 id="等值连接（equal-join）"><a href="#等值连接（equal-join）" class="headerlink" title="等值连接（equal join）"></a>等值连接（equal join）</h5><p>从关系R和S的广义笛卡尔积中选取<strong>A、B属性值</strong>相等的那些元组。</p><p>对应的SQL语句为：<strong>select * from R join S on R.A = S.B</strong></p><h5 id="自然连接（natural-join）"><a href="#自然连接（natural-join）" class="headerlink" title="自然连接（natural join）"></a>自然连接（natural join）</h5><p>自然连接是一种<strong>特殊的等值连接</strong>，它要求两个关系中进行比较的分量必须是<strong>相同的属性组</strong>，并且在结果中把<strong>属性重复的列</strong>去掉。</p><p>对应的SQL语句为：<strong>select * from R natural join S。</strong></p><p>等值连接与自然连接的区别和联系：</p><p>1、自然连接<strong>一定</strong>是等值连接，但等值连接<strong>不一定</strong>是自然连接。</p><p>2、等值连接要求相等的分量，不一定是公共属性；而自然连接要求相等的分量<strong>必须是公共属性</strong>。</p><p>3、等值连接不把重复的属性除去；而自然连接要<strong>把重复的属性除去</strong>。</p><h5 id="内连接（inner-join）"><a href="#内连接（inner-join）" class="headerlink" title="内连接（inner join）"></a>内连接（inner join）</h5><p>内连接是将两张表中<strong>共有某属性值</strong>的记录挑选出来。与等值连接类似，二者都是取<strong>交集</strong>。</p><p><img src="%E5%86%85%E8%BF%9E%E6%8E%A5.png" alt="内连接"></p><h5 id="左外连接（left-join）"><a href="#左外连接（left-join）" class="headerlink" title="左外连接（left join）"></a>左外连接（left join）</h5><p>在自然连接的基础上，保证<strong>左表完全显示</strong>，右表若不存在则<strong>用null填满</strong>。</p><p><img src="%E5%B7%A6%E8%BF%9E%E6%8E%A5.png" alt="左连接"></p><h5 id="右外连接（right-join）"><a href="#右外连接（right-join）" class="headerlink" title="右外连接（right join）"></a>右外连接（right join）</h5><p>在自然连接的基础上，保证<strong>右表完全显示</strong>，左表若不存在则<strong>用null填满</strong>。</p><p><img src="%E5%8F%B3%E8%BF%9E%E6%8E%A5.png" alt="右连接"></p><h5 id="全外连接（OUTER-JOIN）"><a href="#全外连接（OUTER-JOIN）" class="headerlink" title="全外连接（OUTER JOIN）"></a>全外连接（OUTER JOIN）</h5><p><strong>左连接+右连接+去重=全连接</strong></p><p><img src="%E5%85%A8%E8%BF%9E%E6%8E%A5.png" alt="全连接"></p><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><h4 id="平凡的函数依赖"><a href="#平凡的函数依赖" class="headerlink" title="平凡的函数依赖"></a>平凡的函数依赖</h4><p>如果X→Y，但Y∈X，则称X→Y是平凡的函数依赖.</p><h4 id="非平凡的函数依赖"><a href="#非平凡的函数依赖" class="headerlink" title="非平凡的函数依赖"></a>非平凡的函数依赖</h4><p>如果X→Y，但Y∉X，则称X→Y是非平凡的函数依赖。通常情况下总是讨论<strong>非平凡的函数依赖</strong>.</p><h4 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h4><p>如果存在 X 属性集（注意是集合，说明是<strong>联合主键</strong>）决定唯一的 Y ，且 <strong>X 中的任一子集都不能决定 唯一的 Y</strong>，则 Y 完全依赖于 X。</p><p>例子：学生数学成绩完全由该学生的学号和数学课决定，所以<strong>数学课成绩完全依赖于（学号，数学课）</strong></p><h4 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h4><p>如果存在 X 属性集（注意是集合，说明是<strong>联合主键</strong>）决定唯一的 Y ，且 <strong>X 中的任一子集也可以决定 唯一的 Y</strong>，则 Y 部分依赖于 X。</p><p>例子：学生学号和姓名可以决定唯一的学生，但是学生号<strong>也可以</strong>决定唯一的学生。</p><h4 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h4><p> 在R(U,F)中，如果X→Y，Y∉X，Y→Z，Y不完全函数依赖于X，则称Z对X<strong>传递依赖</strong>。</p><p>例如：书的出版编号是唯一，版权归出版社所有，所以只能由该出版社出版。所以存在函数依赖：<strong>书出版编号—&gt;出版社名，出版社名—&gt;出版社地址</strong>，但是出版社名不能决定唯一的出版书编号（除非出版社只出版过一本书，那我没话说?），则有出版书编号传递依赖于出版社地址。</p><h3 id="关系范式"><a href="#关系范式" class="headerlink" title="关系范式"></a>关系范式</h3><p>范式是<strong>符合某一种级别的关系模式的集合</strong>。</p><p>设计<strong>性能较优</strong>的关系模式称为<strong>规范化</strong>，规范化主要的理论依据是关系规范化理论。目的是<strong>消除插入、删除异常和数据冗余，提高数据库性能。</strong></p><p>一般而言，我们只要让数据库中的所有表符合<strong>第三范式或者BCNF</strong>即可。</p><h4 id="数据冗余"><a href="#数据冗余" class="headerlink" title="数据冗余"></a>数据冗余</h4><p>数据冗余是指<strong>各个数据文件中存在重复的数据</strong>。会导致：</p><ul><li><strong>浪费存储空间，降低检索效率</strong>  </li><li><strong>潜在的数据不一致性</strong></li></ul><p>在文件管理系统中各数据文件中难免有许多数据相互重复，数据的冗余度比较大。数据库系统更注重文件之间的联系。数据库系统中的数据具有<strong>共享性</strong>，因而尽可能地避免了数据的重复存储，减少和控制了数据的冗余。</p><p>然而，DBS中也不是不存在数据冗余的现象。当<strong>存在传递依赖或者部分依赖</strong>时，必然会出现数据冗余现象，我们要依据<strong>关系范式</strong>进行<strong>数据表分解</strong>，从而减轻冗余。</p><h4 id="第一范式1NF（原子性）"><a href="#第一范式1NF（原子性）" class="headerlink" title="第一范式1NF（原子性）"></a>第一范式1NF（原子性）</h4><p>表中的每一列都是<strong>不可分解的基本数据项</strong>，每一个属性<strong>不可拥有</strong>多个值。是关系数据库的<strong>基本要求</strong>。需要满足<strong>原子性</strong>。</p><h4 id="第二范式2NF（消除部分依赖）"><a href="#第二范式2NF（消除部分依赖）" class="headerlink" title="第二范式2NF（消除部分依赖）"></a>第二范式2NF（消除部分依赖）</h4><p>前提是满足1NF。此外：一个表必须有主键，<strong>非主属性必须完全依赖于主键。</strong>（<strong>消除非主属性对主键的部分依赖</strong>）</p><p><img src="2NF.png" alt="2NF"></p><h4 id="第三范式3NF（消除传递依赖）"><a href="#第三范式3NF（消除传递依赖）" class="headerlink" title="第三范式3NF（消除传递依赖）"></a>第三范式3NF（消除传递依赖）</h4><p>前提是满足2NF。此外：<strong>任意一个非主属性都不可传递依赖于主键</strong>。（消除非主属性对主键的<strong>传递依赖</strong>）（要求依赖右侧全部为候选键或者它的成员）</p><p><img src="3NF.png" alt="3NF"></p><h4 id="BC范式BCNF（主属性不能依赖于主属性）"><a href="#BC范式BCNF（主属性不能依赖于主属性）" class="headerlink" title="BC范式BCNF（主属性不能依赖于主属性）"></a>BC范式BCNF（主属性不能依赖于主属性）</h4><p>前途是满足3NF。此外：<strong>不能存在主键的一部分被另一部分或者非主键的其它部分所决定</strong>。（消除所有部分依赖与传递依赖）（要求依赖右侧全部为候选键）</p><h4 id="第四范式"><a href="#第四范式" class="headerlink" title="第四范式"></a>第四范式</h4><p>要求把同一表内的多对多关系删除。</p><h4 id="第五范式"><a href="#第五范式" class="headerlink" title="第五范式"></a>第五范式</h4><p>从最终结构重新建立原始结构。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包指的是：<strong>由一个属性或者属性组直接或间接推导出的所有属性的集合</strong>。</p><p>求闭包的算法：<strong>循环迭代</strong>，每一次迭代过程中找到能够被当前闭包中的属性直接推出的属性加入到闭包中。直到无法加入新属性。</p><h3 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a>关系型数据库和非关系型数据库</h3><table><thead><tr><th>数据库 类型</th><th>特性</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>关系型数据库：SQLite、Oracle、mysql</td><td>1、关系型数据库，是指采用了<strong>关系模型</strong>来组织数据的数据库；<br>2、关系型数据库的最大特点就是事务的<strong>一致性</strong>；<br>3、简单来说，关系模型指的就是<strong>二维表格模型</strong>，而一个关系型数据库就是由<strong>二维表及其之间的联系</strong>所组成的一个数据组织。</td><td>1、<strong>容易理解</strong>：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；<br>2、<strong>使用方便</strong>：通用的SQL语言使得操作关系型数据库非常方便；<br>3、<strong>易于维护</strong>：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了<strong>数据冗余和数据不一致</strong>的概率；<br>4、<strong>支持SQL</strong>，可用于复杂的查询。<br></td><td>1、为了维护一致性所付出的巨大代价就是其<strong>读写性能比较差</strong>；<br>2、固定的<strong>表结构</strong>；<br>3、不适合<strong>高并发</strong>读写需求；<br>4、不适合<strong>海量数据</strong>的高效率读写；</td></tr><tr><td>非关系型数据库：MongoDb、redis、HBase</td><td>1、使用<strong>键值对（也可以是文档形式、图片形式等）</strong>存储数据；<br>2、<strong>支持分布式</strong>；<br>3、一般不支持事务的<strong>ACID特性</strong>；<br>4、非关系型数据库严格上不是一种数据库，应该是一种<strong>数据结构化存储方法的集合</strong>。</td><td>1、无需经过sql层的解析，<strong>读写性能很高</strong>；<br>2、基于键值对，数据没有<strong>耦合性</strong>，<strong>容易扩展</strong>；<br>3、存储数据的格式：nosql的存储格式是<strong>key,value形式、文档形式、图片形式</strong>等等，而关系型数据库则只支持基础类型。</td><td>1、不提供sql支持，<strong>学习和使用成本较高</strong>；<br>2、<strong>无事务处理</strong>，附加功能bi和报表等支持也不好；</td></tr></tbody></table><p>数据的持久存储，尤其是<strong>海量数据的持久存储</strong>，还是需要一种<strong>关系数据库</strong>。</p><h2 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>MySQL是一个<strong>关系型数据库管理系统，</strong>由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS 软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</p><h3 id="MySQL权限表"><a href="#MySQL权限表" class="headerlink" title="MySQL权限表"></a>MySQL权限表</h3><p>MySQL服务器通过<strong>权限表</strong>来控制<strong>用户对数据库的访问</strong>，权限表存放在mysql数据库里，由<strong>mysql_install_db</strong>脚本初始化。这些权限表分别为<strong>user，db，table_priv，columns_priv和host</strong>。下面分别介绍一下这些表的结构和内容：</p><ul><li><p><strong>user权限表</strong>：记录<strong>允许</strong>连接到服务器的<strong>用户帐号信息</strong>，里面的权限是<strong>全局级</strong>的。</p></li><li><p><strong>db权限表</strong>：记录各个帐号在各个<strong>数据库</strong>上的操作权限，，里面的权限是<strong>数据库级</strong>的。</p></li><li><p><strong>table_priv权限表</strong>：记录<strong>数据表级</strong>的操作权限。</p></li><li><p><strong>columns_priv权限表</strong>：记录<strong>数据列级</strong>的操作权限。</p></li><li><p><strong>host权限表</strong>：配合db权限表对<strong>给定主机上数据库级操作权限</strong>作更细致的控制。这个权限表不受<strong>GRANT和</strong></p><p><strong>REVOKE语句</strong>的影响。</p></li></ul><p>MySQL中的权限管理：</p><ul><li><p><strong>授予权限</strong>：</p><pre class="line-numbers language-mysql"><code class="language-mysql">grant 权限 on 数据库对象 to 用户<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>撤销权限</strong>：</p><pre class="line-numbers language-mysql"><code class="language-mysql">revoke 权限 on 数据库对象 from 用户<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h3><p>MySQL的常见日志log分为以下类型：</p><table><thead><tr><th>日志类型</th><th>日志内容</th></tr></thead><tbody><tr><td>错误日志</td><td>mysql 启动、停止和运行过程中出现的异常</td></tr><tr><td>常规操作日志</td><td>已创建客户端连接和客户端处理记录</td></tr><tr><td>二进制日志</td><td>数据变更日志(可用于同步)</td></tr><tr><td>转存日志</td><td>从主服务器同步的数据记录</td></tr><tr><td>慢查询日志</td><td>耗时超过 long_query_time 所设置时间的查询</td></tr><tr><td>DDL日志（元日志）</td><td>ddl 语句执行的元数据操作</td></tr></tbody></table><p>其中，<strong>二进制日志binlog</strong>是实际最常使用的日志，因为它可以对数据库进行<strong>恢复</strong>。</p><p>binlog的录入格式为：</p><ul><li><strong>Statement（只记录修改语句）</strong>：只记录<strong>每条修改数据的SQL执行语句</strong>；但还必须记录每条语句在执行的时候的一些相关信息，确保所有语句能在slave得到和在master端（<strong>主从复制</strong>）执行时候相同的结果。但<strong>一些函数功能不能被复制</strong>。</li><li><strong>row（只记录修改结果）</strong>：不记录SQL的上下语句信息，只记录<strong>那一条记录被修改成什么</strong>了；解决了Statement的问题，但单语句更新（删除）表的行数过多，会导致<strong>形成大量binlog</strong>。</li><li><strong>Mixedlevel（混合）</strong>：前两个的混合使用，一般的语句修改用Statement，一些函数复制等用row，根据执行的语句来选择使用哪种方式。</li></ul><h3 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h3><p>MySQL中定义数据字段的类型对<strong>数据库的优化</strong>是非常重要的。</p><p>MySQL支持多种类型，大致可以分为三类：<strong>数值、日期/时间和字符串(字符)类型。</strong></p><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">范围（有符号）</th><th align="left">范围（无符号）</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1 byte</td><td align="left">(-128，127)</td><td align="left">(0，255)</td><td align="left">小整数值</td></tr><tr><td align="left">SMALLINT</td><td align="left">2 bytes</td><td align="left">(-32 768，32 767)</td><td align="left">(0，65 535)</td><td align="left">大整数值</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3 bytes</td><td align="left">(-8 388 608，8 388 607)</td><td align="left">(0，16 777 215)</td><td align="left">大整数值</td></tr><tr><td align="left">INT或INTEGER</td><td align="left">4 bytes</td><td align="left">(-2 147 483 648，2 147 483 647)</td><td align="left">(0，4 294 967 295)</td><td align="left">大整数值</td></tr><tr><td align="left">BIGINT</td><td align="left">8 bytes</td><td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td align="left">(0，18 446 744 073 709 551 615)</td><td align="left">极大整数值</td></tr><tr><td align="left">FLOAT</td><td align="left">4 bytes</td><td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="left">单精度 浮点数值</td></tr><tr><td align="left">DOUBLE</td><td align="left">8 bytes</td><td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">双精度 浮点数值</td></tr><tr><td align="left">DECIMAL</td><td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td align="left">依赖于M和D的值</td><td align="left">依赖于M和D的值</td><td align="left">小数值</td></tr></tbody></table><h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><p>每个时间类型有一个有效值范围和一个”<strong>零”</strong>值，当指定不合法的MySQL不能表示的值时使用”零”值。</p><table><thead><tr><th align="left">类型</th><th align="left">大小 ( bytes)</th><th align="left">范围</th><th align="left">格式</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">3</td><td align="left">1000-01-01/9999-12-31</td><td align="left">YYYY-MM-DD</td><td align="left">日期值</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘-838:59:59’/‘838:59:59’</td><td align="left">HH:MM:SS</td><td align="left">时间值或持续时间</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">1901/2155</td><td align="left">YYYY</td><td align="left">年份值</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">1000-01-01 00:00:00/9999-12-31 23:59:59</td><td align="left">YYYY-MM-DD HH:MM:SS</td><td align="left">混合日期和时间值</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td align="left">YYYYMMDD HHMMSS</td><td align="left">混合日期和时间值，时间戳</td></tr></tbody></table><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">CHAR</td><td align="left">0-255 bytes</td><td align="left">定长字符串</td></tr><tr><td align="left">VARCHAR</td><td align="left">0-65535 bytes</td><td align="left">变长字符串</td></tr><tr><td align="left">TINYBLOB</td><td align="left">0-255 bytes</td><td align="left">不超过 255 个字符的二进制字符串</td></tr><tr><td align="left">TINYTEXT</td><td align="left">0-255 bytes</td><td align="left">短文本字符串</td></tr><tr><td align="left">BLOB</td><td align="left">0-65 535 bytes</td><td align="left">二进制形式的长文本数据</td></tr><tr><td align="left">TEXT</td><td align="left">0-65 535 bytes</td><td align="left">长文本数据</td></tr><tr><td align="left">MEDIUMBLOB</td><td align="left">0-16 777 215 bytes</td><td align="left">二进制形式的中等长度文本数据</td></tr><tr><td align="left">MEDIUMTEXT</td><td align="left">0-16 777 215 bytes</td><td align="left">中等长度文本数据</td></tr><tr><td align="left">LONGBLOB</td><td align="left">0-4 294 967 295 bytes</td><td align="left">二进制形式的极大文本数据</td></tr><tr><td align="left">LONGTEXT</td><td align="left">0-4 294 967 295 bytes</td><td align="left">极大文本数据</td></tr></tbody></table><ul><li>char（n）和 varchar（n） 中括号中 n 代表<strong>字符的个数</strong>，并不代表字节个数</li><li>CHAR 和 VARCHAR 类型类似，但它们<strong>保存和检索的方式</strong>不同。它们的<strong>最大长度和是否尾部空格被保留</strong>等方面也不同。在存储或检索过程中不进行<strong>大小写转换</strong>。<ul><li>定义一个char[10]和varchar[10],如果存进去的是‘abcd’,那么char所占的长度<strong>依然为10</strong>，除了字符‘abcd’外，后面<strong>跟六个空格</strong>，而varchar就立马把长度<strong>变为4</strong>了，取数据的时候，char类型的要用<strong>trim</strong>去掉多余的空格，而varchar是不需要的</li><li>char的存取数度还是要比varchar<strong>要快得多</strong>，因为其<strong>长度固定</strong>，方便程序的存储与查找；但是char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取<strong>时间效率</strong>，而varchar是以<strong>空间效率</strong>为首位的。</li><li>char的存储方式是，<strong>对英文字符（ASCII）占用1个字节，对一个汉字占用2个字节</strong>；而varchar的存储方式是，<strong>对每个英文字符占用2个字节，汉字也占用2个字节</strong>，两者的存储数据都非unicode的字符数据。</li></ul></li></ul><h2 id="MySQL基本操作"><a href="#MySQL基本操作" class="headerlink" title="MySQL基本操作"></a>MySQL基本操作</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>我们可以在登陆 MySQL 服务后，使用 <strong>create</strong> 命令<strong>创建数据库</strong>，语法如下:</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE DATABASE 数据库名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在<strong>删除数据库</strong>过程中，务必要十分谨慎，因为在执行删除命令后，所有数据将会消失。我们使用<strong>drop</strong>命令删除数据库：</p><pre class="line-numbers language-mysql"><code class="language-mysql">drop database 数据库名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>修改数据库属性</strong>，包括更改数据库名称、数据库所有者等等：</p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER DATABASE yyDB RENAME TO yyDBnew;ALTER DATABASE yyDB OWNER TO yy;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h3><h4 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h4><p>我们使用<strong>create命令</strong>创建数据表，同时可以<strong>指定每一列的数据类型和属性等</strong>。</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE IF NOT EXISTS `runoob_tbl`(   `runoob_id` INT UNSIGNED AUTO_INCREMENT,   `runoob_title` VARCHAR(100) NOT NULL,   `runoob_author` VARCHAR(40) NOT NULL,   `submission_date` DATE,   PRIMARY KEY ( `runoob_id` ))ENGINE=InnoDB DEFAULT CHARSET=utf8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意，这里的列名被<strong>反引号</strong>框了起来，而不是单引号。</p><p>实例解析：</p><ul><li>如果你不想字段为 <strong>NULL</strong> 可以设置字段的属性为 <strong>NOT NULL</strong>， 在操作数据库时如果输入该字段的数据为<strong>NULL</strong> ，就会报错。</li><li>AUTO_INCREMENT定义列为<strong>自增</strong>的属性，一般用于主键，数值会<strong>自动加1</strong>。</li><li>PRIMARY KEY关键字用于定义列为<strong>主键</strong>。 您可以使用多列来定义主键，列间以逗号分隔。</li><li>ENGINE 设置<strong>存储引擎</strong>，CHARSET 设置<strong>编码</strong>。</li></ul><p>MySQL 字段属性应该尽量设置为 <strong>NOT NULL</strong>，NULL类型的字段会导致种种弊端，例如：</p><ul><li>含有空值的列很难进行<strong>查询优化</strong>，而且对表索引时不会存储 NULL 值的，所以如果索引的字段可以为 NULL，<strong>索引的效率会下降很多</strong>。因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用 0、一个特殊的值或者一个空串代替空值。</li><li>联表查询的时候，例如 LEFT JOIN table2，若没有记录，则查找出的 table2 字段都是 null。假如 table2 有些字段本身可以是 null，那么除非把 table2 中 not null 的字段查出来，否则就<strong>难以区分到底是没有关联记录还是其他情况。</strong></li></ul><p>实际上，<strong>空串“”不等于NULL。</strong>任何数跟 NULL 进行运算都是 NULL, 判断值是否等于 NULL，不能简单用 =，而要用 <strong>IS NULL</strong>关键字。</p><p>可以看到，我们在定义数据表时，为每个列都定义了一些约束，<strong>列完整性约束包括：</strong></p><ul><li><code>PRIMARY Key</code>（主键）、<code>NULL</code>（空值）、<code>NOT NULL</code>（非空值）、<code>UNIQUE</code>（值唯一）、<code>CHECK</code>（有效性检查）、<code>DEFAULT</code>（缺省值）</li></ul><p>使用<strong>列约束</strong>定义单个主键，若要定义<strong>多个列构成的复合主键、代理键、外键</strong>时，需要使用<strong>表约束</strong>关键词：<code>CONSTRAINT</code></p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE Plan(CourseID         char(4)         NOT NULL,TeacherID         char(4)         NOT NULL,CourseName         varchar(20),CourseRoom         varchar(30),CONSTRAINT         CoursePlan_PK         PRIMARY Key(CourseID, TeacherID)   --定义复合主键);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义<strong>外键</strong>也需要使用<strong>CONSTRAINT表约束</strong>关键字：</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE Register(CourseRegID        serial            NOT NULL,CoursePlanID    int                NOT NULL,  StudentID         char(13)         CONSTRAINT         CourseRegID_PK         PRIMARY Key(CourseRegID),   --定义代理键CONSTRAINT CoursePlanID_FK FOREIGN Key(CoursePlanID)  --定义外键1REFERENCES Plan(CoursePlanID)  --参考表的主键列 ON DELETE CASCADE,  --级联删除CONSTRAINT StudentID_FK FOREIGN Key(StudentID)  --定义外键2REFERENCES Student(StudentID)  --参考表的主键列 ON DELETE CASCADE  --级联删除);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>级联删除<code>DELETE CASCADE</code>：是指当主表(parent table)中的一条记录被删除，子表中关联的记录也相应的<strong>自动删除</strong>。</p><p>外键的约束：</p><p>1.在对<strong>子表</strong>（有<code>FOREIGN KEY</code>关键词的表）进行数据操作时，外键的取值或者变更必须与其关联表的主键的列值一致。（不能是不存在的值）</p><p>2.<strong>主表</strong>元素删除或者主键值变更，子表中参照的外键值应对应变更，要么取空值，要么引用主表中存在的主键值，以保持关联数据表数据一致。</p><h4 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h4><p>MySQL中<strong>删除数据表</strong>是非常容易操作的， 但是你再进行删除表操作时要非常小心，因为执行删除命令后所有数据都会消失。</p><p>我们有以下几种不同的方式对表进行删除：</p><ul><li><strong>drop命令</strong>：删除<strong>表全部数据和表结构</strong>，立刻<strong>释放磁盘空间</strong>，不管是 <strong>Innodb 和 MyISAM;</strong></li></ul><pre class="line-numbers language-mysql"><code class="language-mysql">drop table student;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>truncate命令</strong>：删除<strong>表全部数据</strong>，<strong>保留表结构</strong>，立刻<strong>释放磁盘空间</strong> ，不管是 <strong>Innodb 和 MyISAM;</strong></li></ul><pre class="line-numbers language-mysql"><code class="language-mysql">truncate table student;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>delete命令</strong>： 删除<strong>表全部数据</strong>，<strong>表结构不变</strong>，对于 <strong>MyISAM</strong> 会立刻释放磁盘空间，<strong>InnoDB</strong> 不会释放磁盘空间;</li></ul><pre class="line-numbers language-mysql"><code class="language-mysql">delete from student;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>需要注意</strong>： 不能直接删除由<code>FOREIGN KEY</code>约束引用的表。只有先删除<code>FOREIGN KEY</code>约束或引用的表后，才能删除本表。即：<strong>先删子表（有FOREIGN Key关键词的表）再删主表（被关联的表）</strong>。</p><h3 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h3><p>与修改数据库、列类似，我们可以使用一个<strong>ALTER关键字</strong>对数据表的属性进行替换。    </p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE Student ADD StudentGender char(2) NULL;ALTER TABLE Student DROP COLUMN BirthDay;ALTER TABLE Student RENAME TO StudentNew;ALTER TABLE Student ALTER COLUMN StudentName TYPE varchar(12);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>MySQL 表中使用 <strong>INSERT INTO</strong> SQL语句来插入数据。</p><pre class="line-numbers language-mysql"><code class="language-mysql">INSERT INTO table_name ( field1, field2,...fieldN )                       VALUES                       ( value1, value2,...valueN );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果数据是<strong>字符型</strong>，必须使用<strong>单引号或者双引号</strong>，如：”value”。</p><p>插入数据的格式必须与表结构中固定的数据格式<strong>一致</strong>。</p><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><p>查询数据是MYSQL数据库中最为常用的操作之一，使用<strong>SELECT</strong>语句：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT column_name,column_nameFROM table_name[WHERE Clause][LIMIT N][ OFFSET M]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>查询语句中你可以使用<strong>一个或者多个表</strong>，表之间使用<strong>逗号</strong>分割，并使用WHERE语句来设定查询条件。</p></li><li><p>SELECT 命令可以读取<strong>一条或者多条记录</strong>。</p></li><li><p>你可以使用<strong>星号（*）</strong>来代替其他字段，SELECT语句会返回表的<strong>所有字段数据</strong></p></li><li><p>你可以使用 <strong>WHERE 语句</strong>来包含任何条件。</p></li><li><p>你可以使用 <strong>LIMIT 属性</strong>来设定返回的记录数，也可以<strong>截取</strong>一定的记录返回。</p><pre class="line-numbers language-mysql"><code class="language-mysql">select * from table limit 5; --返回前5行select * from table limit 0,5; --同上，返回前5行select * from table limit 5,10; --返回6-10行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>你可以通过<strong>OFFSET</strong>指定SELECT语句开始查询的<strong>数据偏移量</strong>。默认情况下<strong>偏移量为0</strong>。</p></li></ul><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>你可以使用 SQL 的 <strong>DELETE FROM</strong> 命令来删除 MySQL 数据表中的记录。</p><pre class="line-numbers language-mysql"><code class="language-mysql">DELETE FROM table_name [WHERE Clause]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不指定条件语句，那么DELETE命令会将表中的全部数据都删除。</p><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p>如果我们需要修改或更新 MySQL 中的数据，我们可以使用 SQL <strong>UPDATE 命令</strong>来操作。</p><pre class="line-numbers language-mysql"><code class="language-mysql">UPDATE table_name SET field1=new-value1, field2=new-value2[WHERE Clause]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>你可以同时更新一个或多个字段。</li><li>你可以在 WHERE 子句中指定任何条件。</li><li>你可以在一个单独表中同时更新数据。</li></ul><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>MySQL中常用的<strong>聚合函数</strong>主要有：</p><ul><li><code>AVG()</code>：计算<strong>平均值</strong></li><li><code>MIN()</code>：计算<strong>最小值</strong></li><li><code>MAX()</code>：计算<strong>最大值</strong></li><li><code>SUM()</code>：计算该列所有值的<strong>和</strong></li><li><code>COUNT()</code>：计算<strong>结果集行数</strong></li></ul><p><strong>聚合函数只能出现在having条件语句中，而不能出现在where条件语句中，因为它的执行晚于where。</strong></p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>MySQL中的条件语句主要分为两种类型，分别是：</p><ul><li><strong>where</strong>：是一个<strong>约束声明</strong>，是在<strong>查询之前</strong>约束来自数据库的数据。</li><li><strong>having</strong>：是一个<strong>过滤声明</strong>，是在<strong>查询结果集返回以后</strong>对查询结果进行的过滤操作。HAVING语通常与<strong>GROUP BY</strong>语句联合使用，用来<strong>过滤由GROUP BY语句返回的记录集</strong>。HAVING语句的存在<strong>弥补</strong>了WHERE关键字不能与聚合函数联合使用的<strong>不足</strong>。</li></ul><p>where和having的差别本质上来源于<strong>MySQL关键字执行顺序</strong>的差别：</p><blockquote><p>MySQL关键字的执行顺序：<strong>from、where、group by、聚集函数、having、select、order by、limit</strong></p></blockquote><p>例子：</p><pre class="line-numbers language-mysql"><code class="language-mysql">select goods_name,goods_number from sw_goods where goods_price > 100#只可以使用where，不能改成having，因为查询的结果中不包含goods_price列select goods_category_id , avg(goods_price) as ag from sw_goods group by goods_category having ag > 1000#只可以使用having，不可以使用where，因为原数据表中不存在ag列，且聚集函数的执行晚于where<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT Major AS 专业, COUNT(StudentID) AS 学生人数FROM StudentWHERE StudentGender='女'  --过滤数据集：性别为女GROUP BY Major  --根据专业来分组HAVING COUNT(*)>3;  --限定分组数据：行数大于3的#筛选出女同学数目大于3的专业<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="常用关系运算符"><a href="#常用关系运算符" class="headerlink" title="常用关系运算符"></a>常用关系运算符</h4><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">等号，检测两个值是否相等，如果相等返回true。</td><td align="left">A = B 返回false。</td></tr><tr><td align="left">&lt;&gt;, !=</td><td align="left">不等于，检测两个值是否相等，如果不相等返回true</td><td align="left">A != B 返回 true。</td></tr><tr><td align="left">&gt;</td><td align="left">大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true</td><td align="left">A &gt; B 返回false。</td></tr><tr><td align="left">&lt;</td><td align="left">小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true</td><td align="left">A &lt; B 返回 true。</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true</td><td align="left">A &gt;= B 返回false。</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于号，检测左边的值是否小于或等于右边的值, 如果左边的值小于或等于右边的值返回true</td><td align="left">A &lt;= B 返回 true。</td></tr><tr><td align="left">IS NULL</td><td align="left">当列的值是 NULL,此运算符返回 true。</td><td align="left">A = NULL 返回true</td></tr><tr><td align="left">IS NOT NULL</td><td align="left">当列的值不是 NULL,此运算符返回 true。</td><td align="left">A != NULL 返回true</td></tr><tr><td align="left">&lt;=&gt;</td><td align="left">比较操作符（不同于 = 运算符），<strong>当比较的的两个值相等或者都为 NULL 时返回 true。</strong></td><td align="left">NULL &lt;=&gt; NULL 返回true</td></tr></tbody></table><h4 id="BETWEEN运算符"><a href="#BETWEEN运算符" class="headerlink" title="BETWEEN运算符"></a>BETWEEN运算符</h4><p>我们可以利用<code>BETWEEN...AND</code>限定范围，相比于常规的比较操作符（&gt;,&lt;,=），<strong>BETWEEN关键字可以运用在更广阔的范围内，如时间范围、字符范围等。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT *FROM StudentWHERE BirthDay BETWEEN '1999-01-01' AND '1999-12-31';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="LIKE运算符"><a href="#LIKE运算符" class="headerlink" title="LIKE运算符"></a>LIKE运算符</h4><p>我们可以利用<code>LIKE</code>与通配符限定范围。</p><p>常见的通配符有：</p><ul><li><p><code>通配符 _</code>代表一个未指定的字符，</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT *FROM StudentWHERE StudentName LIKE '袁_';#找到姓袁且名字共两个字的人<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>通配符 %</code>代表任意个未指定的字符。</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT *FROM StudentWHERE Major LIKE '软件%';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="GREATEST关键字"><a href="#GREATEST关键字" class="headerlink" title="GREATEST关键字"></a>GREATEST关键字</h4><p>语法格式为：GREATEST（值1，值2，…值n），其中n表示参数列表中有n个值。当有2个或多个参数时，返回值为<strong>最大值</strong>，假如任意一个自然变量为NULL，则GREATEST（）的返回值<strong>为NULL</strong>。</p><pre class="line-numbers language-mysql"><code class="language-mysql">select greatest(2,0),greatest(20.0,3.0,100.5),greatest(10,NULL);#返回值=2,100.5，null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="LEAST关键字"><a href="#LEAST关键字" class="headerlink" title="LEAST关键字"></a>LEAST关键字</h4><p>语法格式为：LEAST（值1，值2，…值n），其中值n表示参数列表中有n个值。在有两个或多个参数的情况下，返回<strong>最小值</strong>。假如任意一个自变量为NULL，则LEAST（）的返回值为NULL。</p><pre class="line-numbers language-mysql"><code class="language-mysql">select least(2,0),least(20.0,3.0,100.5),least(10,NULL);　#返回值=0,3.0，null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="IN、NOT-IN运算符。"><a href="#IN、NOT-IN运算符。" class="headerlink" title="IN、NOT IN运算符。"></a>IN、NOT IN运算符。</h4><p>IN运算符用来判断操作数<strong>是否为列表中的其中一个值</strong>，如果是，返回值为1；否则返回值为0。</p><pre class="line-numbers language-mysql"><code class="language-mysql">select 2 IN(1,3,5,'thks'),'thks' IN(1,3,5,'thks');  #返回值=0,1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="REGEXP运算符"><a href="#REGEXP运算符" class="headerlink" title="REGEXP运算符"></a>REGEXP运算符</h4><p>REGEXP运算符用来<strong>用正则表达式匹配字符串</strong>，语法格式为：expr REGEXP 匹配条件，如果expr满足匹配条件，返回1；如果不满足，则返回0；若expr或匹配条件任意一个为NULL，则结果为NULL。</p><h3 id="结果排序"><a href="#结果排序" class="headerlink" title="结果排序"></a>结果排序</h3><p>如果我们需要对select读取的数据进行<strong>排序</strong>，我们就可以使用 MySQL 的 <strong>ORDER BY</strong> 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT field1, field2,...fieldN FROM table_name1, table_name2...ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>你可以使用<strong>任何字段</strong>来作为排序的条件，从而返回排序后的查询结果。</li><li>你可以设定<strong>多个字段</strong>来排序。</li><li>你可以使用 <strong>ASC（升序） 或 DESC（降序）</strong> 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是<strong>按升序排列</strong>。</li><li>你可以添加 <strong>WHERE…LIKE 子句</strong>来设置条件。</li></ul><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>GROUP BY 语句根据一个或多个列对结果集进行<strong>分组</strong>。</p><p>在分组的列上我们可以使用 <strong>聚集函数</strong>，如果要<strong>对分组结果进行筛选</strong>，必须<strong>使用having</strong>。</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT Major AS 专业, COUNT(StudentID) AS 学生人数FROM StudentGROUP BY Major;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>当要查询的数据涉及到多个表时，我们可以通过<strong>嵌套查询或者连接</strong>的方式进行多表查询。</p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>在使用 MySQL查询时，当<strong>表名很长或者执行一些特殊查询</strong>的时候，为了<strong>方便操作或者需要多次使用相同的表</strong>时，可以为表指定<strong>别名</strong>，用这个别名代替表原来的名称。需要注意的是，这个新指定的临时别名<strong>不能与数据库中已有的表重名。</strong></p><p>格式为：</p><blockquote><p>&lt;表名&gt; [AS] &lt;别名&gt;</p></blockquote><p>例如：</p><pre class="line-numbers language-mysql"><code class="language-mysql">select * from stu as a join stu as b where a.friendid = b.id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样，在使用 SELECT 语句显示查询结果时，MySQL 会显示每个 SELECT 后面指定输出的列，在有些情况下，显示的列名称会<strong>很长或者名称不够直观</strong>，MySQL 可以<strong>指定列的别名</strong>，替换字段或表达式。</p><p>格式为：</p><blockquote><p>&lt;列名&gt; [AS] &lt;列别名&gt;</p></blockquote><p>例如：</p><pre class="line-numbers language-mysql"><code class="language-mysql">select count(*) as boy_num from stu where sex = '男'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="过滤重复数据"><a href="#过滤重复数据" class="headerlink" title="过滤重复数据"></a>过滤重复数据</h3><p>如果你需要读取不重复的数据可以在 SELECT 语句中使用 <strong>DISTINCT 关键字</strong>来过滤重复数据。</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT DISTINCT last_name, first_name FROM person_tbl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="MySQL-临时表"><a href="#MySQL-临时表" class="headerlink" title="MySQL 临时表"></a>MySQL 临时表</h3><p>MySQL 临时表在我们需要保存一些<strong>临时数据</strong>时是非常有用的。<strong>临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。</strong></p><p>临时表在<strong>MySQL 3.23版本</strong>中添加，如果你的MySQL版本低于 3.23版本就无法使用MySQL的临时表。不过现在一般很少有再使用这么低版本的MySQL数据库服务了。</p><pre class="line-numbers language-mysql"><code class="language-mysql">mysql> CREATE TEMPORARY TABLE SalesSummary (    -> product_name VARCHAR(50) NOT NULL    -> , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00    -> , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00    -> , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0);mysql> INSERT INTO SalesSummary    -> (product_name, total_sales, avg_unit_price, total_units_sold)    -> VALUES    -> ('cucumber', 100.25, 90, 2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MySQL复制表"><a href="#MySQL复制表" class="headerlink" title="MySQL复制表"></a>MySQL复制表</h3><p>如果我们需要完全的复制MySQL的数据表，包括表的结构，索引，默认值等。 如果仅仅使用<strong>CREATE TABLE … SELECT</strong> 命令，是无法实现的，<strong>该命令只复制数据</strong>。</p><p>我们可以通过先创建相同结构的表，再复制数据的形式进行表复制：</p><ul><li>使用 <strong>SHOW CREATE TABLE</strong> 命令获取创建数据表(<strong>CREATE TABLE</strong>) 语句，该语句包含了原数据表的结构，索引等。</li><li>复制以下命令显示的SQL语句，修改数据表名，并执行SQL语句，通过以上命令 将完全的复制数据表结构。</li><li>如果你想复制表的内容，你就可以使用 <strong>INSERT INTO … SELECT</strong> 语句来实现。</li></ul><p>也可以使用如下方法：</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE targetTable LIKE sourceTable;INSERT INTO targetTable SELECT * FROM sourceTable;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><h3 id="什么是数据库索引"><a href="#什么是数据库索引" class="headerlink" title="什么是数据库索引"></a>什么是数据库索引</h3><p>数据库索引，类似于<strong>书籍的目录</strong>，可以根据目录的某个页码立即找到对应的内容。很多存储数据的情况下都使用了索引结构，比如操作系统逻辑文件系统的索引文件，既保留了顺序文件的空间优点，也保留了直接文件的访问优点。</p><p>数据库只做两件事情：存储数据、检索数据。而<strong>索引</strong>是在你存储的数据之外，额外保存一些<strong>路标</strong>（一般是<strong>B+树</strong>），以<strong>减少检索数据的时间</strong>。所以索引是主数据衍生的附加结构。</p><p>一个索引是存储的表中<strong>一个或多个特定列的值</strong>数据结构（最常见的是<strong>B+Tree和hash表</strong>）。索引是在表的列上创建。所以，要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中。<strong>请记住记住这一点：索引是一种数据结构 。</strong></p><p>索引是一种典型的“<strong>以空间换时间</strong>”的优化方法，类似的方法还有Cache等。</p><p>SQL数据库的常用索引有：</p><ul><li><strong>B+树结构</strong></li><li><strong>Hash结构</strong></li></ul><h3 id="MySQL的数据库存储结构"><a href="#MySQL的数据库存储结构" class="headerlink" title="MySQL的数据库存储结构"></a>MySQL的数据库存储结构</h3><p>MySQL的基本存储结构：<strong>页</strong>，记录都存储在页里面。（类似于操作系统的概念）</p><ul><li>各个数据页可以组成一个<strong>双向链表</strong>。</li><li>每个数据页中的行记录组成<strong>单向链表</strong>。</li><li>每个数据页都会为存储在它里边儿的记录生成一个<strong>页目录</strong>，在通过<strong>主键（聚集索引）</strong>查找某条记录的时候可以在页目录中使用<strong>二分法</strong>快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li><li>以<strong>其他列</strong>作为搜索条件：只能从最小记录开始<strong>依次遍历</strong>单链表中的每条记录。</li></ul><p>MySQL的索引存储的是<strong>创建索引的列上的属性值和对应记录所在物理存储位置的指针</strong>。</p><h3 id="什么时候使用索引"><a href="#什么时候使用索引" class="headerlink" title="什么时候使用索引"></a>什么时候使用索引</h3><p><strong>频繁查询，很少修改</strong>：一张表可以建立<strong>任意多个索引，</strong>每个索引可以是<strong>任意多个字段</strong>的组合。索引<strong>可能会提高查询速度</strong>（避免全表扫描，如果查询时使用了索引），但<strong>一定会减慢写入速度，并会占用额外的空间</strong>，因为每次写入时都需要更新索引，所以索引只应该加在<strong>经常需要搜索</strong>的列上，不要加在<strong>写多读少</strong>的列上。</p><p><strong>中大规模</strong>：索引不应该用于<strong>小规模</strong>的表，当字段用于WHERE子句作为过滤器会<strong>返回表里的大部分记录</strong>时，该字段就不适合设置索引。<strong>小规模的表无需维护索引，直接全表扫描即可。超大规模的表，索引也会失效。</strong></p><p>基本原则：</p><ul><li>在经常用作<strong>过滤器</strong>的字段上建立索引；</li><li>在SQL语句中经常进行<strong>GROUP BY、ORDER BY</strong>的字段上建立索引；</li><li>在不同值较少的字段上不必要建立索引，如<strong>性别字段</strong>，性别字段无非男女两种值，区分度不好，建立索引效果不好，要选择<strong>区分度高</strong>的字段；</li><li>对于<strong>经常存取</strong>的列避免建立索引；</li><li>用于<strong>联接</strong>的列（主健/<strong>外健</strong>）上建立索引</li></ul><h3 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h3><h4 id="聚集索引（主键索引）"><a href="#聚集索引（主键索引）" class="headerlink" title="聚集索引（主键索引）"></a>聚集索引（主键索引）</h4><p>聚集（clustered）索引，也叫聚簇索引。它的定义为：数据行的<strong>物理顺序</strong>与<strong>列值（一般是主键的那一列）的逻辑顺序</strong>相同，一个表中只能拥有<strong>一个</strong>聚集索引。</p><p>聚集索引的定义看上去比较抽象，我们可以举个例子：</p><blockquote><p>一个表就像是我们以前用的新华字典，聚集索引就像是拼音目录，而每个字存放的页码就是我们的数据物理地址，我们如果要查询一个“哇”字，我们只需要查询“哇”字对应在新华字典拼音目录对应的页码，就可以查询到对应的“哇”字所在的位置，而拼音目录对应的A-Z的字顺序，和新华字典实际存储的字的顺序A-Z也是一样的，如果我们中文新出了一个字，拼音开头第一个是B，那么他插入的时候也要按照拼音目录顺序插入到A字的后面</p></blockquote><p>聚集索引的<strong>可以根据主键的逻辑顺序快速地搜索到对应的记录</strong>。因为如果我们查询id比较靠后的数据，那么这行数据的地址在磁盘中的物理地址也会比较靠后。而且由于物理排列方式与聚集索引的顺序相同，所以也就只能建立一个聚集索引了。</p><p>通常来说，聚集索引在<strong>创建表的时候</strong>指定，MySQL默认指定<strong>主键</strong>为一张表的聚集索引。如果在表创建完成后指定聚集索引，那么将会根据指定的列的逻辑顺序调整数据行的物理位置，<strong>非常耗费时间</strong>。所以，<strong>聚集索引也会被叫做主键索引。</strong></p><p>定义聚集索引的方式有两种：</p><ul><li>创建表时直接指定主键，就等于指定聚集索引：</li></ul><pre class="line-numbers language-mysql"><code class="language-mysql">create table t1(    id int primary key,    name nvarchar(255))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>创建表后修改主键：</li></ul><pre class="line-numbers language-mysql"><code class="language-mysql">alter table table_name add primary key(colum_name)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>MySQL最常用的引擎<strong>InnoDB</strong>中，对于聚集索引的存储是这样的：</p><p><img src="InnoDB%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.png" alt="聚集索引"></p><p><strong>InnoDB使用B+树存储聚集索引，叶子节点就是对应的数据节点。</strong>正是因为聚集索引逻辑顺序和实际物理顺序一致的特点，所以才能直接用叶子节点存储记录。“聚集”就是<strong>指数据行和相邻的键值紧密地存储在一起</strong>。</p><p>而MySQL的MyISAM除外，<strong>此存储引擎的聚集索引和非聚集索引只多了个唯一约束，其他没什么区别</strong>。无论是否为聚集索引，<strong>MyISAM都只在B+树的叶子节点存放指向对应记录物理地址的指针。</strong></p><p>所以，在InnoDB中使用聚集索引非常<strong>高效</strong>，因为可以<strong>直接获取</strong>想要记录，而如果使用非聚集索引查询对应的记录，只能获取对应记录的<strong>主键</strong>，还需要<strong>到主键索引B+树中进行二次查询，这一过程也被称作是“回表”。</strong>（PS：InnoDB的非聚集索引叶子结点存放的是对应记录的主键，而MyISAM无论是否聚集索引，存放的都是对应记录的指针）</p><h4 id="非聚集索引（非主键索引）"><a href="#非聚集索引（非主键索引）" class="headerlink" title="非聚集索引（非主键索引）"></a>非聚集索引（非主键索引）</h4><p>与聚集索引相反，该索引中索引的<strong>逻辑顺序与磁盘上行的物理存储顺序不同</strong>，一个表中可以拥有<strong>多个</strong>非聚集索引。</p><p>按照定义，<strong>除了聚集索引以外的索引都是非聚集索引</strong>，非聚集索引可以细分为：</p><ul><li>UNIQUE（<strong>唯一索引</strong>）：不可以出现<strong>相同的值</strong>，可以有<strong>NULL值</strong></li><li>INDEX（<strong>普通索引</strong>）：允许出现<strong>相同的索引内容</strong></li><li>fulltext index（<strong>全文索引</strong>）：可以针对值中的<strong>某个单词</strong>，但<strong>效率不是很好</strong></li></ul><p>此外，有的博客认为主键索引也可以被当做是一种非聚集索引。我认为，一般来说，主键索引就是聚集索引，不需要强调特殊情况。</p><p>非聚集索引就像新华字典的<strong>偏旁字典</strong>，他结构顺序与实际存放顺序不一定一致。</p><p>下图是MyISAM中对于非聚集索引的存储，它在B+树的叶子节点中存放了对应记录的<strong>指针</strong>。</p><p><img src="%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.png" alt="非聚集索引"></p><p>正如我们之前所说的，<strong>非聚集索引在InnoDB引擎的B+树中只会存放所在记录的主键，查询完整的记录需要二次查询主键索引树（回表）。</strong></p><p>但是，当需要查询的列位于索引中时，我们可以使用<strong>覆盖索引</strong>而无需回表：</p><blockquote><p>覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。 如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。当我们通过SQL语句：select key2 from covering_index_sample where key1 = ‘keytest’;的时候，就可以通过覆盖索引查询，无需回表。</p></blockquote><p>何时使用两类索引，有如下的一张表格：</p><p><img src="%E7%B4%A2%E5%BC%95.png" alt="索引"></p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>联合索引，顾名思义，实质上是将<strong>多个字段</strong>建到一个索引里，列值的组合必须<strong>唯一</strong>。</p><p>如果我们尝试建立<strong>联合的聚集索引</strong>，那么使用过程中，MySQL会遵循<strong>最左匹配原则</strong>：</p><ul><li>mysql会一直<strong>向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配</strong>，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立（a,b,c,d）顺序的索引，那么后面的d是用不到索引的，如果建立（a,b,d,c）的索引就可以用到。</li><li>上述情况的原因是：B+树按照联合聚集索引的逻辑顺序，将记录在物理空间进行排序，排序时，优先按照前面的列。例如（a,b,c,d）顺序就是先按照 a 列的值，再按照 b 列的值直到 d 列的值。当我们遇到范围查询时，只需要定位到 a = 1 and b = 2 and c = 3的记录位置，然后<strong>在B+树的叶子节点中直接向右遍历</strong>所有c&gt;3的记录，直到b&gt;2为止。这种定位到最左边，然后向右遍历寻找，就是我们所说的<strong>最左前缀原则</strong>。</li><li>由于聚集索引的特性，所以可以<strong>较为方便地使用B+树进行范围查询。</strong></li><li>根据最左前缀匹配原则，我们创建联合索引时，<strong>多个字段之间顺序应该按照使用频繁的程度放置</strong>，这样可以提升查询效率。</li></ul><h3 id="索引底层实现"><a href="#索引底层实现" class="headerlink" title="索引底层实现"></a>索引底层实现</h3><h4 id="FULLTEXT索引"><a href="#FULLTEXT索引" class="headerlink" title="FULLTEXT索引"></a>FULLTEXT索引</h4><p><strong>全文索引</strong>，目前只有<strong>MyISAM引擎</strong>支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 <strong>CHAR、VARCHAR ，TEXT</strong> 列上可以创建全文索引。</p><p>全文索引并不是和MyISAM一起诞生的，它的出现是为了解决<strong>WHERE name LIKE “%word%”</strong>这类针对文本的模糊查询效率较低的问题。</p><h4 id="RTREE索引"><a href="#RTREE索引" class="headerlink" title="RTREE索引"></a>RTREE索引</h4><p>RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。相对于BTREE，<strong>RTREE的优势在于范围查找</strong>。</p><h4 id="HASH索引"><a href="#HASH索引" class="headerlink" title="HASH索引"></a>HASH索引</h4><p>由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。</p><p>HASH索引可以<strong>一次定位（哈希函数）</strong>，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在<strong>“=”和“in</strong>”条件下高效，对于<strong>范围查询、排序及组合索引</strong>仍然效率不高。</p><h4 id="BTREE索引"><a href="#BTREE索引" class="headerlink" title="BTREE索引"></a>BTREE索引</h4><p>BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf（这里指的是B+树，常规B树的键值对存放在每一个节点中）<strong>这是MySQL里默认和最常用的索引类型。</strong></p><h3 id="B树简介"><a href="#B树简介" class="headerlink" title="B树简介"></a>B树简介</h3><p>B+树是Mysql顶层最常用的索引数据结构，它是由B树演变而来的。</p><p>B树是一种<strong>多路平衡查找树。</strong>与常规的二叉查找树相比，它的优势在于<strong>尽可能少的磁盘 IO，加快了检索速度</strong>：</p><ul><li>常规的二叉查找树，如：基础二叉查找树、AVL、RBT等，由于都是<strong>二叉</strong>的，也就是每个父节点最多只有两个孩子，所以通常是“<strong>高瘦</strong>”的，也就是<strong>层数较多</strong>。但我们知道，数据库中的数据大都存放在外存上。磁盘IO的一个特性是<strong>按照磁盘块进行IO</strong>，所以即使是访问一个节点，也需要<strong>读取一个完整的磁盘块。</strong>如果我们使用高瘦的二叉查找树，那么访问的层数较多，读取的磁盘块数目也较多，降低了时间效率。相反，B树的每个内部节点能够指向多个孩子节点，它的搜索过程是：<strong>从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的孩子结点；重复，直到所对应的孩子指针为空，或已经是叶子结点。</strong></li><li>由于每一层的节点数增多，所以查找树的高度降低，也就是说<strong>平均每一次搜索需要读取的节点数减少，</strong>从而让<strong>磁盘IO次数减少</strong>，降低了时间消耗。（B树是“<strong>矮胖</strong>”的）</li><li>在数据较小，可以完全放到内存中时，RBT的时间复杂度比B树低（<strong>RBT是二叉的，直接根据当前节点值和目标值的大小关系即可决定进入哪个子树，而B-TREE是多叉的，在每一个节点内部需要进行二分查找，才能决定进入哪个子树</strong>）。反之，数据量较大，<strong>外存中占主要部分</strong>时，B树因其读磁盘次数少，<strong>而具有更快的速度。</strong></li></ul><p>下面是一个存储了 16 个数据的 二叉查找树，同样每个节点最多存储 2 个 key，查询 id=16 这个数据需要查询比较 4 个节点，也就是经过 4 次磁盘 IO：</p><p><img src="%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png" alt="二叉查找树"></p><p>考虑到磁盘 IO 读同一块上的1个数据和读 100 个数据都需要读取完整的磁盘块，消耗的时间基本一致，那我们的优化思路就可以改为：<strong>尽可能在一次磁盘 IO 中多读一点数据到内存</strong>。这个直接反映到树的结构就是，每个节点能存储的 key 可以适当增加。我们可以使用一个6阶的B树进行检索，只需要进行 2 次磁盘 IO.</p><p><img src="B%E6%A0%911.png" alt="B树"></p><p>B树的特点是：</p><ul><li>关键字集合分布在整个树中；</li><li>任何一个关键字出现且只出现在一个结点中；</li><li>搜索有可能在非叶子结点结束；</li><li>其搜索性能等价于在关键字全集内做一次二分查找；</li><li>自动层次控制；</li></ul><p>它的定义为：</p><ul><li>每个节点最多有m-1个<strong>关键字</strong>（可以存有的键值对）。</li><li>根节点最少可以只有1个<strong>关键字</strong>。</li><li>非根节点至少有m/2个<strong>关键字</strong>。</li><li>每个节点中的关键字都按照<strong>从小到大的顺序</strong>排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。（<strong>方便二分查找</strong>）</li><li>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。（<strong>完全二叉树</strong>）</li><li><strong>每个节点都存有索引和数据，也就是对应的key和value。（B树和B+树最大的区别）</strong></li></ul><p><img src="B%E6%A0%91.png" alt="B树"></p><h3 id="B-树简介"><a href="#B-树简介" class="headerlink" title="B+树简介"></a>B+树简介</h3><p>上面介绍了B树的优势，实际上，我们可以对B树进行进一步改进，使其更适合数据库索引的需求。</p><p>与B树相比，B+树的特点在于：</p><ul><li><strong>B 树的非叶子节点里既存索引也存数据，而 B+只存索引（地址）</strong>，所以 B 树里非叶子节点存不了很多个键值对，但是 B+树一个非叶子节点能存很多索引，<strong>B+树将所有的数据存放在叶子节点中</strong>。</li><li><strong>B+树的叶子节点用了一个链表串联起来，便于范围查找</strong>。</li></ul><p><img src="B+%E6%A0%91.png" alt="B+树"></p><p>由于上述特点，B+树存在着以下的优势： </p><ul><li>在<strong>单个节点存储容量有限</strong>的情况下，B+树的内部节点也能<strong>存储大量索引，</strong>使得整个 B+树高度<strong>进一步降低</strong>，<strong>进一步减少了磁盘 IO</strong>。</li><li>B+树的叶子节点是真正数据存储的地方，叶子节点<strong>用了链表连接起来</strong>，这个链表本身就是有序的，<strong>在数据范围查找</strong>时，更具备效率。（<strong>InnoDB的B+树聚集索引的范围查找优势原因，最左前缀匹配原则的原理</strong>）</li><li>B+树的<strong>查询效率更加稳定</strong> 。由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。 所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li></ul><h4 id="为什么不使用哈希索引"><a href="#为什么不使用哈希索引" class="headerlink" title="为什么不使用哈希索引"></a>为什么不使用哈希索引</h4><ul><li>哈希索引适合<strong>等值查询</strong>，可以直接使用哈希函数运算找到记录。但是<strong>无法进行范围查询</strong> 。</li><li>哈希索引没办法利用索引<strong>完成排序</strong>。</li><li>哈希索引不支持多列联合索引的<strong>最左匹配规则</strong> 。</li><li>如果有大量重复键值得情况下，哈希索引的效率<strong>会很低</strong>，因为存在<strong>哈希碰撞问题</strong>。</li></ul><h2 id="MySQL引擎InnoDB和MyISAM对比"><a href="#MySQL引擎InnoDB和MyISAM对比" class="headerlink" title="MySQL引擎InnoDB和MyISAM对比"></a>MySQL引擎InnoDB和MyISAM对比</h2><h3 id="索引区别"><a href="#索引区别" class="headerlink" title="索引区别"></a>索引区别</h3><p>在MySQL最常用的两类引擎InnoDB、MyISAM中都使用了B+树作为默认的索引数据结构。但我们之前说过，他们在底层的实现方法略有不同，这里再总结一下：</p><ul><li><p>InnoDB对于聚集索引，B+树的叶子节点会存放对应Key的<strong>完整记录</strong>，访问时可以直接获取所有的列，十分方便。但对于非聚集索引，B+树的叶子结点只存放对应Key的记录的<strong>主键</strong>，如果需要访问完整的记录，必须进行<strong>回表</strong>，依据主键<strong>二次访问</strong>聚集索引树。</p><ul><li>之所以只在非聚集索引中存放主键，是因为防止数据冗余，减少空间浪费。<strong>在牺牲较少查询的性能下节省了巨大的磁盘空间。</strong></li></ul><p><img src="InnoDB%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.png" alt="InnoDB索引"></p></li><li><p>MyISAM对于非聚集索引和聚集索引，无一例外都只在叶子节点中存放<strong>指向对应记录物理位置的指针</strong>，所以如果根据<strong>非聚集索引</strong>访问记录，<strong>MyISAM将会比InnoDB耗时更短</strong>，因为它只需要一次访问，直接找到物理地址后就可以直接定位到数据记录。但是很明显，MyISAM的<strong>插入删除数据性能更差</strong>。我们如果要在InnoDB中添加数据，只需要修改B+树的叶子结点（<strong>链接存储</strong>），但如果要在MyISAM中添加数据，需要移动磁盘上很多条记录（<strong>顺序存储</strong>）。</p><p><img src="MyISAM%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.png" alt="MyISAM索引"></p></li></ul><h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><ul><li>若数据库平台<strong>读多写少</strong>，可以选择MyISAM引擎，如<strong>博客系统、学习网站</strong>等；</li><li>若数据库平台<strong>更新操作（增删改）较多</strong>，则选择InnoDB，如<strong>信息管理系统</strong>等。</li></ul><h3 id="完整区别"><a href="#完整区别" class="headerlink" title="完整区别"></a>完整区别</h3><ul><li><strong>InnoDB支持事务，MyISAM不支持</strong>，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li><li><strong>InnoDB支持外键，而MyISAM不支持</strong>。对一个包含外键的InnoDB表转为MYISAM会失败</li><li>InnoDB使用B+Tree作为索引结构，<strong>数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构）</strong>，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，<strong>主键不应该过大，因为主键太大，其他索引也都会很大</strong>。而MyISAM也是使用B+Tree作为索引结构，<strong>索引和数据文件是分离的，索引保存的是数据文件的指针</strong>。**主键索引和辅助索引是独立的。</li><li><strong>InnoDB不保存表的具体行数</strong>，执行select count(*) from table时需要全表扫描。<strong>而MyISAM用一个变量保存了整个表的行数</strong>，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）</li><li><strong>MyISAM表格可以被压缩后进行查询操作</strong></li><li><strong>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁</strong></li><li><strong>InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有</strong></li></ul><p>如何选择：</p><ul><li><strong>是否要支持事务</strong>，如果要请选择innodb，如果不需要可以考虑MyISAM</li><li>如果表中绝大多数都只是<strong>读查询</strong>，可以考虑MyISAM，如果<strong>既有读也有写</strong>，请使用InnoDB</li><li><strong>系统崩溃后，MyISAM恢复起来更困难，能否接受；</strong></li><li><strong>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎</strong>，建议使用InnoDB</li></ul><h3 id="InnoDB的四大特性"><a href="#InnoDB的四大特性" class="headerlink" title="InnoDB的四大特性"></a>InnoDB的四大特性</h3><ul><li><strong>插入缓冲</strong>（insert buffer）</li><li><strong>二次写</strong>（double write）</li><li><strong>自适应哈希索引</strong>（ahi）</li><li><strong>预读</strong>（read ahead）</li></ul><h3 id="自增ID（-AUTO-INCREMENT）"><a href="#自增ID（-AUTO-INCREMENT）" class="headerlink" title="自增ID（ AUTO_INCREMENT）"></a>自增ID（ AUTO_INCREMENT）</h3><p>InnoDB推荐使用<strong>自增ID</strong>作为主键，自增ID可以保证每次插入时B+索引是从<strong>右边</strong>扩展的，可以避免B+树和频繁<strong>合并和分裂</strong>（对比使用UUID）。如果使用<strong>字符串主键和随机主键</strong>，会使得数据<strong>随机插入</strong>，<strong>效率比较差</strong>。</p><h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>事务是一个<strong>不可分割</strong>的数据库操作序列，也是数据库<strong>并发控制的基本单位</strong>，其执行的结果必须使数据库从<strong>一种一致性状态变到另一种一致性状态</strong>（<strong>事务的一致性</strong>）。事务是逻辑上的一组操作，<strong>要么都执行，要么都不执行</strong>。</p><p>有一个经典的例子就是转账，比如小明要给小方转100块钱，如果成功了，那么小明的账户余额信息和小方的账户余额信息都需要更新；但是如果转账过程中突然银行系统崩溃，导致小明的余额少了，小方的余额却不变，这就不对了。<strong>事务就是保证这两个关键操作要么都成功，要么都要失败。</strong></p><p>一个完整的业务需要批量的DML（数据库管理语言，如insert、update、delete）语句共同联合完成</p><h3 id="事务的四大特性ACID"><a href="#事务的四大特性ACID" class="headerlink" title="事务的四大特性ACID"></a>事务的四大特性ACID</h3><ul><li><strong>Atomicity原子性</strong>：事务中包括的所有操作<strong>要么都做，要么都不做</strong>。<ul><li>实现事务的原子性，要支持<strong>回滚操作</strong>，在某个操作失败后，回滚到<strong>事务执行之前</strong>的状态。需要使用<strong>undolog回滚日志</strong>实现。</li></ul></li><li><strong>Consistency一致性</strong>：事务必须使数据库<strong>从一个一致性状态变到另一个一致性状态。</strong>（例如上面的银行转账例子，<strong>总钱数在事务执行前后发生了变化</strong>，说明事务完成后，不符合逻辑运算，状态不一致了）其实也就是说：保证事务只能把数据库从<strong>一个有效（正确）的状态“转移”到另一个有效（正确）的状态</strong>，什么是正确的状态，其实<strong>是用户自己指定的</strong>，所以说一致性其实是一个<strong>用户层</strong>的概念。<ul><li>事务的一致性决定了一个<strong>系统设计和实现的复杂</strong>度，也导致了<strong>事务的不同隔离级别</strong>。</li><li><strong>一致性是事务的最终目的，原子性、隔离性、持久性都是为了实现一致性。</strong>（AID是为了C）</li></ul></li><li><strong>隔离性 Isolation</strong>：隔离性是指多个事务<strong>并发执行</strong>的时候，事务内部的操作与其他事务是隔离的，<strong>并发执行的各个事务之间不能互相干扰</strong>。</li><li><strong>duration持久性</strong>：根据定义，持久性是指事务<strong>一旦提交</strong>，它对数据库的改变就应该是<strong>永久性</strong>的。接下来的其他操作或故障不应该对其有任何影响。<ul><li>事务的持久性是<strong>通过redo log恢复日志实现的</strong>。Mysql是先把磁盘上的数据<strong>加载到内存</strong>中，在内存中对数据进行修改，再<strong>刷回磁盘</strong>上。如果此时突然宕机，内存中的数据就会丢失。为了防止上述故障造成数据不一致，我们使用<strong>redo log日志记录下每一条数据库修改操作</strong>，从而保证数据库宕机重启的时候能够选择是否将数据恢复。</li></ul></li></ul><h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p>我们在前面已经介绍了两种日志：</p><ul><li><p><strong>undolog</strong> 记录某<strong>数据被修改前的值</strong>。类似于Word中的<strong>撤销</strong>操作，<strong>用于事务的回滚，为了保证原子性。</strong></p></li><li><p><strong>redolog</strong> 记录某 <strong>数据块</strong> 被修改 <strong>后</strong> 的值，可以用来恢复未写入 data file 的已成功事务更新的数据。类似于Word中的<strong>恢复</strong>操作。<strong>用于事务的重做，为了保证持久性。</strong></p></li><li><p>redolog和undolog是<strong>InnoDB事务机制中的日志</strong>，与MySQL级别的日志不同（如binlog）：</p><ul><li>redo/undo 是 innodb 引擎层维护的。而 binlog 是 mysql server 层维护的，跟采用何种引擎没有关系，记录的是<strong>所有引擎的更新操作的日志记录</strong>。</li><li>redo/undo 记录的是 <strong>每个页/每个数据 的修改情况</strong>，属于<strong>物理日志+逻辑日志结合</strong>的方式（<strong>redo log 是物理日志，undo log 是逻辑日志</strong>）。binlog 记录的都是事务操作内容，属于<strong>逻辑日志</strong>。<ul><li>redo log通常是<strong>物理日志</strong>，记录的是<strong>数据页的物理修改</strong>，而不是某一行或某几行修改成怎样怎样，它用来<strong>恢复提交后的物理数据页</strong>（恢复数据页，且只能恢复到最后一次提交的位置)）。</li></ul></li><li>undo用来回滚行记录到某个版本。undo log一般是<strong>逻辑日志</strong>，<strong>符合SQL的逻辑特性，根据每行记录进行记录</strong>。</li><li>redo/undo 在 <strong>事务执行过程中</strong> 会不断的写入，而 binlog 是在 <strong>事务最终提交前</strong> 写入的。binlog 什么时候刷新到磁盘跟参数 <code>sync_binlog</code> 相关</li></ul></li></ul><p>事务日志的详细内容可以参考：<a href="https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html</a></p><h3 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h3><p>我们知道，数据库显然是一个常常需要<strong>高并发</strong>的场景，例如：<strong>淘宝网的秒杀活动</strong>，需要支持多个用户购买后同时修改商品的库存量，如果数据库不支持并行，只支持串行，那么同一时刻只能有一个用户进行购买，这将导致用户的阻塞，显然是不好。</p><p>所以，我们需要让数据库使用并发技术。但是，我们知道，并发技术往往会带来<strong>数据的不一致性</strong>的问题，这点在多线程、多进程编程中是非常常见。</p><p>并发事务不加以控制可能导致的问题主要有：</p><ul><li><strong>脏读(Drity Read）</strong>：某个事务读取的数据正在被另一个<strong>未提交事务</strong>所处理，而另一个事务可能会<strong>回滚</strong>，导致该事务读取的数据是<strong>错误</strong>的。</li><li><strong>不可重复读</strong>：在<strong>同一个事务</strong>内，读取数据后，该数据被<strong>另一个事务</strong>所修改，导致<strong>无法重现</strong>前一次读取结果。</li><li><strong>丢失修改</strong>：多个事务读入<strong>同一个数据</strong>并修改，一个事务的修改结果被另一个事务的提交所<strong>覆盖</strong>。</li><li><strong>幻读</strong>：<strong>同一事务</strong>两次读取之间，其他事务<strong>插入或删除</strong>一条数据。例如：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li></ul><p>幻读和不可重复读很容易混淆，实际上，<strong>幻读侧重于数据的增添和删除，而不可重复读侧重于数据的修改</strong>。</p><p><strong>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</strong>。</p><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>考虑到上述的并发事务问题，最简单粗暴的解决方案是让所有事务都串行化处理，不允许并发。这将导致数据库的效率大大降低。为了<strong>平衡数据库的效率和隔离性Isolation</strong>，我们提出了几种事务的隔离级别，也就是<strong>并发事务之间相互影响的程度。</strong></p><p>隔离级别<strong>从低到高</strong>：</p><ul><li><strong>READ Uncommitted未提交读</strong>：事务中的修改，即使<strong>未提交</strong>，对其他事务也都<strong>是可见</strong>的；本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也会导致<strong>脏读（Dirty Read）</strong>。</li><li><strong>Read Committed提交读</strong>：一个事务<strong>从开始直到提交之前</strong>，所做的任何修改对其他事务都是<strong>不可见</strong>的；<strong>大多数数据</strong>库默认采用此级别；也就是说：<strong>一个事务只能看见已经提交事务所做的改变</strong>。但是，该级别未解决<strong>不可重复读</strong>的问题，因为同一事务的多次读数据之间，别的事务对该数据的修改也可能进行提交，导致数据不一致。</li><li><strong>Repeatable Read可重复读</strong>（<strong>MYSQL默认</strong>)：解决了<strong>脏读问题和不可重复读问题</strong>；该级别保证了在<strong>同一事务中多次读取同样记录的结果是一致的</strong>；<strong>MySQL默认为此级别；</strong>但是，此级别<strong>没有解决幻读问题</strong>，如果其它事务插入或者删除了记录。（MySQL的InnoDB引擎使用<strong>快照读的机制</strong>使得可重复读隔离级别也解决了幻读）</li><li><strong>Serializable可串行化</strong>：<strong>最高</strong>的隔离级别。该级别会在读取的<strong>每一行数据</strong>上都加锁，导致大量的<strong>超时和锁争用</strong>的问题。但用的比较少，只有在<strong>非常需要确保数据的一致性而且可以接受没有并发</strong>的情况下，才考虑此级别。它解决了<strong>幻读问题</strong>。</li></ul><p>√: 可能出现  ×: 不会出现</p><table><thead><tr><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable read</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p><strong>我们需要平衡数据库的安全性和效率，选择当前场景最优的事务隔离级别。</strong></p><p>MySQL默认：<strong>可重复读Repeatable read</strong>。</p><h2 id="MySQL锁机制"><a href="#MySQL锁机制" class="headerlink" title="MySQL锁机制"></a>MySQL锁机制</h2><h3 id="锁的概念"><a href="#锁的概念" class="headerlink" title="锁的概念"></a>锁的概念</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。锁保证数据并发访问的一致性、有效性；锁冲突也是影响数据库并发访问性能的一个重要因素。<strong>锁是Mysql在服务器层和存储引擎层的的并发控制</strong>。</p><p>加锁是<strong>消耗资源</strong>的，锁的各种操作，包括<strong>获得锁、检测锁是否是否已解除、释放锁</strong>等。</p><h3 id="Latch和Lock"><a href="#Latch和Lock" class="headerlink" title="Latch和Lock"></a>Latch和Lock</h3><p>有两种锁，一种是<strong>Latch闩锁（轻量级的锁）</strong>，它要求锁定的时间非常短，若持续时间长，则其应用性能会很差（<strong>有点类似于OS中的自旋锁，会忙等</strong>）。在InnoDB引擎中，Latch分为<strong>rwlock（读写锁）和mutex（互斥锁）</strong>，其目的是用来保证<strong>并发线程操作临界资源的正确性</strong>，并且通常<strong>没有死锁检测的机制</strong>。</p><p>还有一种是<strong>Lock</strong>，它的对象是<strong>事务</strong>，用来<strong>锁定数据库中的对象</strong>，如<strong>表、页、行</strong>。并且lock的对象<strong>commit或rollback后进行释放</strong>（不同事物隔离级别释放的时间可能不同）。</p><p>在MySQL中的引擎中主要是<strong>Lock</strong>。</p><h3 id="按照粒度划分锁"><a href="#按照粒度划分锁" class="headerlink" title="按照粒度划分锁"></a>按照粒度划分锁</h3><p>Lock锁根据粒度主要分为<strong>表锁、行锁、页锁</strong>，不同的存储引擎拥有的锁粒度都不同。</p><ol><li><p><strong>表锁</strong>：表级锁就是一次会将<strong>整个表</strong>进行锁定，是个存储引擎中最大颗粒度的锁机制；它的特点是<strong>实现逻辑简单，资源消耗较少，获取锁和释放锁的速度很快，很好的解决了死锁问题</strong>。使用表锁的主要是<strong>MyISAM、MEMORY，CSV</strong>等一些<strong>非事务性存储引擎</strong>。但是，它<strong>发生锁冲突的概率最高，并发度最低。</strong></p><ol><li>表级锁更适合于<strong>以查询为主，并发用户少，只有少量按索引条件更新数据的应用</strong>，如Web 应用</li></ol></li><li><p><strong>行锁</strong>：MySQL中<strong>锁定粒度最小</strong>的锁机制，特点是<strong>发生锁定资源争用的概率小，能给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能</strong>，但<strong>资源消耗较大，且可能会产生死锁</strong>。使用行锁的主要是<strong>InnoDB引擎</strong>。</p><ol><li>行级锁更适合于有<strong>大量按索引条件并发更新少量不同数据，同时又有并发查询的应用</strong>，如一些在线事务处理（OLTP）系统.</li></ol></li><li><p><strong>页锁</strong>：它的锁定颗粒度介于<strong>表锁和行锁之间</strong>，它的并发能力与资源开销也是<strong>介于两者之间</strong>，另外，它与行锁一样，<strong>会发生死锁</strong>。使用页锁的主要是<strong>BerkeleyDB存储引擎</strong>。</p></li></ol><p>默认情况下，<strong>表锁和行锁都是自动获得的， 不需要额外的命令</strong>。</p><p>但是在有的情况下， 用户需要明确地<strong>进行锁表或者进行事务的控制</strong>， 以便确保<strong>整个事务的完整性</strong>，这样就需要使用<strong>事务控制和锁定语句</strong>来完成。</p><h3 id="按照共享性划分锁"><a href="#按照共享性划分锁" class="headerlink" title="按照共享性划分锁"></a>按照共享性划分锁</h3><p>从类别上锁分为：<strong>共享锁（S Lock）和排它锁（X Lock）</strong>。</p><p><strong>共享锁</strong>: 又叫做<strong>读锁</strong>。 当用户要<strong>进行数据的读取</strong>时，对数据加上<strong>共享锁</strong>。共享锁可以<strong>同时加上多个</strong>。加了共享锁的数据对象<strong>可以被其他事务读取，但不能修改。</strong></p><p><strong>排他锁</strong>: 又叫做<strong>写锁</strong>。 当用户要<strong>进行数据的写入</strong>时，对数据加上<strong>排他锁</strong>。排他锁<strong>只可以加一个</strong>，他和其他的<strong>排他锁，共享锁都相斥</strong>。</p><p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的<strong>意向锁（Intention Locks）</strong>，这两种意向锁都是<strong>表锁</strong>：</p><ul><li><strong>意向共享锁（IS）</strong>：事务打算给数据行加<strong>行共享锁</strong>，事务在给一个数据行加共享锁前必须先取得<strong>该表的 IS 锁。</strong></li><li><strong>意向排他锁（IX）</strong>：事务打算给数据行加<strong>行排他锁，</strong>事务在给一个数据行加排他锁前必须先取得<strong>该表的 IX 锁。</strong></li></ul><p>InnoDB引擎的表意向锁之间<strong>互相兼容。</strong></p><p><img src="InnoDB%E9%94%81%E6%A8%A1%E5%BC%8F.png" alt="InnoDB锁模式"></p><h3 id="InnoDB加锁机制"><a href="#InnoDB加锁机制" class="headerlink" title="InnoDB加锁机制"></a>InnoDB加锁机制</h3><p><strong>隐式加锁</strong>：</p><ul><li>首先，意向锁是 InnoDB 在行锁之前<strong>自动加</strong>的， 不需用户干预。</li><li>对于 UPDATE、 DELETE 和 INSERT 语句（<strong>写操作</strong>）， InnoDB会<strong>自动</strong>给涉及数据集加<strong>排他锁（X)</strong></li><li>对于普通 SELECT 语句，<strong>InnoDB 不会加任何锁</strong></li></ul><p><strong>显式加锁</strong>：</p><ul><li><p>事务可以通过以下语句<strong>显式</strong>给记录集加共享锁或排他锁：</p><pre class="line-numbers language-mysql"><code class="language-mysql">select ... lock in share mode //共享锁 select ... for update //排他锁 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p><strong>性能影响</strong>：</p><ul><li>select for update 语句，相当于一个 update 语句。在业务繁忙的情况下，<strong>如果事务没有及时的commit或者rollback 可能会造成其他事务长时间的等待，从而影响数据库的并发使用效率。</strong></li><li>select lock in share mode 语句是一个给查找的数据上一个共享锁（S 锁）的功能，它允许其他的事务也对该数据上S锁，但是<strong>不能够允许对该数据进行修改</strong>。<strong>如果不及时的commit 或者rollback 也可能会造成大量的事务等待。</strong></li></ul><h3 id="InnoDB行锁的实现"><a href="#InnoDB行锁的实现" class="headerlink" title="InnoDB行锁的实现"></a>InnoDB行锁的实现</h3><p>虽然<strong>InnoDB默认使用行锁</strong>，但是InnoDB 行锁是通过给<strong>索引上的索引项加锁</strong>来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：<strong>只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">select * from tab_with_index where id = 1 for update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>如果上述id列不是索引键，那么InnoDB只能创建表锁，并发性将大打折扣。</strong></p><p>MySQL InnoDB支持三种行锁定方式：</p><ul><li><strong>行锁（Record Lock）</strong>:锁直接加在<strong>索引记录</strong>上面，<strong>锁住的是key。</strong></li><li><strong>间隙锁（Gap Lock）</strong>:锁定<strong>索引记录间隙</strong>，<strong>确保索引记录的间隙不变</strong>。间隙锁是针对事务隔离级别为<strong>可重复读以上级别</strong>而言的。目的：<strong>gap lock的机制主要是解决可重复读模式下的幻读问题</strong></li><li><strong>Next-Key Lock</strong> ：<strong>行锁和间隙锁</strong>组合起来就叫Next-Key Lock；InnoDB对于<strong>行的查询</strong>都是采用这种锁定算法，既锁定间隙和锁定行。</li></ul><h3 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h3><p>InnoDB在事务执行过程中，使用<strong>两阶段锁协议</strong>：</p><ul><li><strong>随时都可以执行锁定</strong>，InnoDB会根据隔离级别在需要的时候自动加锁；</li><li>锁只有在执行<strong>commit或者rollback</strong>的时候才会释放，并且所有的锁都是在<strong>同一时刻</strong>被释放。</li></ul><p>两阶段锁协议将一个事务分为两阶段。第一阶段为<strong>加锁阶段</strong>，只可以申请锁，当释放的一个锁后进入<strong>解锁阶段</strong>，只可以释放锁。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p> 指<strong>多个事务在执行过程中因为争夺锁资源而产生的相互等待现象。</strong></p><p>死锁的原因：</p><ul><li><strong>真正的数据冲突</strong>；</li><li><strong>存储引擎的实现方式</strong>。</li></ul><p><strong>检测死锁：</strong>数据库系统实现了各种<strong>死锁检测和死锁超时</strong>的机制。InnoDB存储引擎能检测到死锁的循环依赖并<strong>立即返回一个错误</strong>。</p><p><strong>死锁恢复：</strong>死锁发生以后，只有<strong>部分或完全回滚其中一个事务</strong>，才能打破死锁，InnoDB目前处理死锁的方法是，将持有<strong>最少行级排他锁的事务进行回滚</strong>。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p><p><strong>外部锁的死锁检测：</strong>发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置<strong>锁等待超时参数 innodb_lock_wait_timeout 来解决</strong>（<strong>外部死锁不通过死锁检测，而是死锁超时机制控制</strong>）</p><p><strong>死锁影响性能：</strong>死锁会影响性能而不是会产生严重错误，<strong>因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务</strong>。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，<strong>禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，</strong>这时可以依赖innodb_lock_wait_timeout设置进行事务回滚。（等待时间超过限制，就进行事务回滚，实现简单，开销小）</p><h3 id="优化锁的性能"><a href="#优化锁的性能" class="headerlink" title="优化锁的性能"></a>优化锁的性能</h3><ul><li>尽量使用<strong>较低的隔离级别</strong>；</li><li><strong>精心设计索引</strong>， 并尽量<strong>使用索引访问数据</strong>， 使加锁更精确， 从而减少锁冲突的机会</li><li>选择<strong>合理的事务大小</strong>，小事务发生锁冲突的几率也更小</li><li>给记录集显示加锁时，最好<strong>一次性请求足够级别的锁</strong>。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁</li><li>不同的程序访问一组表时，应尽量<strong>约定以相同的顺序访问各表</strong>，对一个表而言，尽可能<strong>以固定的顺序存取表中的行</strong>。这样可以大大减少死锁的机会</li><li>尽量用<strong>相等条件</strong>访问数据，这样可以避免<strong>间隙锁对并发插入的影响</strong></li><li>不要申请<strong>超过实际需要的锁级别</strong></li><li>除非必须，<strong>查询时不要显式加锁</strong>。 MySQL的<strong>MVCC（多版本并发控制机制）</strong>可以实现事务中的查询不用加锁，优化事务性能；MVCC只在COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作</li><li>对于一些特定的事务，可以使用<strong>表锁</strong>来提高处理速度或减少死锁的可能</li></ul><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><h4 id="乐观锁（不加锁，直到提交时再检查是否有“写-写”冲突）"><a href="#乐观锁（不加锁，直到提交时再检查是否有“写-写”冲突）" class="headerlink" title="乐观锁（不加锁，直到提交时再检查是否有“写-写”冲突）"></a>乐观锁（不加锁，直到提交时再检查是否有“写-写”冲突）</h4><p><strong>乐观锁（Optimistic Lock）</strong>：从名字上看，就是很乐观，每次去<strong>拿数据的时候认为别人不会改，所以不会上锁</strong>，但是在<strong>提交更新的时候会判断一下在此期间别人有没有去更新数据</strong>，乐观也严谨。乐观锁适用于<strong>读多写少</strong>的场景，这样可以提高<strong>吞吐量</strong>。乐观锁总是假设<strong>不会发生并发冲突</strong>，只在提交操作时检查是否<strong>违反数据完整性（覆盖写）</strong>。</p><p>乐观锁通过使用<strong>数据版本（Version）记录机制（最常用）和时间戳（timestamp）</strong>来实现。确保<strong>事务提交之前，所读取的数据没有被更新。</strong></p><p><strong>数据版本机制</strong>：是通过为数据库表增加一个数字类型“version”字段来实现。当读取数据时，将version字段的值一同读出，数据没更新一次，version值加1.当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，<strong>如果数据库表当前版本号与第一次取出来的version值相等，则予以更新</strong>，否则认为是过期数据。</p><p><strong>时间戳机制</strong>：时间戳的方式与前者实现方式差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是<strong>在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比</strong>，如果一致则OK，否则就是版本冲突。</p><h4 id="悲观锁（操作之前先加锁，避免一切冲突）"><a href="#悲观锁（操作之前先加锁，避免一切冲突）" class="headerlink" title="悲观锁（操作之前先加锁，避免一切冲突）"></a>悲观锁（操作之前先加锁，避免一切冲突）</h4><p><strong>悲观锁（Pessimistic Lock）</strong>：就是比较悲观，每次去<strong>拿数据的时候都认为别人会修改</strong>，所以<strong>每次拿数据的时候都会对数据上锁</strong>，这样别人想拿这个数据的时候就会先block，然后获得锁之后再对数据进行操作。总的来说就是<strong>悲观锁总是假定会发生并发冲突，然后屏蔽一切可能违反数据完整性的操作。</strong></p><p>悲观锁大多数情况下依靠<strong>数据库的锁机制</strong>实现，例如使用Select … for update语句，以<strong>保证操作最大程度的独占性</strong>。但如果采用悲观锁，则整个操作过程中，<strong>数据库始终处于加锁状态</strong>（从操作员读出数据、开始修改直至提交修改结果的全过程，甚至还包括操作员中途去煮咖啡的时间），而面对成百上千万的并发，就会导致灾难性的后果，因此采用悲观锁进行控制时要考虑清楚。</p><h3 id="MVCC机制（无锁并发控制，基于快照）"><a href="#MVCC机制（无锁并发控制，基于快照）" class="headerlink" title="MVCC机制（无锁并发控制，基于快照）"></a>MVCC机制（无锁并发控制，基于快照）</h3><p>多版本并发控制（MVCC）是一种用来<strong>解决读-写冲突</strong>的<strong>无锁并发控制</strong>，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读<strong>该事务开始前的数据库的快照</strong>（<strong>快照读</strong>）。 这样在<strong>读操作不用阻塞写操作，写操作不用阻塞读操作</strong>的同时，避免了<strong>脏读和不可重复读。</strong></p><p>MVCC机制只能应用在<strong>RC和RR两种事务隔离级别</strong>下，由于使用了<strong>快照读</strong>机制，读取的内容始终是<strong>事务开始前的数据库快照</strong>，所以其它事务的修改和回滚对它没有影响，解决了<strong>脏读和不可重复读。</strong></p><h2 id="MySQL视图机制"><a href="#MySQL视图机制" class="headerlink" title="MySQL视图机制"></a>MySQL视图机制</h2><h3 id="什么是视图"><a href="#什么是视图" class="headerlink" title="什么是视图"></a>什么是视图</h3><p><strong>视图（View）</strong>是从<strong>一个或多个基本表（或视图）导出的表</strong>，它与基本表不同，是一个<strong>虚表</strong>，数据库中只存放<strong>视图的定义</strong>，而<strong>不存放视图对应的数据</strong>；当基本表中的数据发生变化，从视图中查询出的数据也就随之改变；</p><ul><li><strong>单表视图</strong>：一般用于<strong>查询和修改</strong>，会<strong>改变</strong>基本表的数据；</li><li><strong>多表视图</strong>：一般用于<strong>查询</strong>，<strong>不会改变</strong>基本表的数据。</li></ul><h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><p>1.视图能够<strong>简化</strong>用户的操作；</p><p>2.视图使用户能以<strong>多种角度</strong>看待同一数据；</p><p>3.视图对重构数据库提供了一定程度的<strong>逻辑独立性</strong>；</p><p>4.视图能够对机密数据提供<strong>安全</strong>保护；</p><p>具体到实际应用中，视图的优点有：</p><ul><li><strong>提高了重用性，就像一个函数</strong>。如果需要频繁获取特定的数据集，只需要创建对应的视图即可。（对应上述第二点）</li><li><strong>对数据库重构，却不影响程序的运行</strong>。对于删除的表，可以创建一个对应的视图，保证程序中读取它不会出错。（对应上述第三点）</li><li><strong>提高了安全性能。可以对不同的用户，设定不同的视图。</strong>（对应上述第四点）</li></ul><p>当需要多次重复输入相同的语句、需要不同的表字段聚合，进行信息重组、安全需要或需要兼容老的表等情况，就可以利用视图来<strong>简化sql查询，提高开发效率</strong>。</p><p>不过事物皆有两面性，视图也存在它的缺点：</p><ul><li><strong>视图的性能差</strong>，数据库必须<strong>把视图查询转化成对基本表的查询（视图不存放数据，只存定义）</strong>，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也要把它变成一个复杂的结合体，需要花费一定的时间。</li><li><strong>视图也存在着修改限制</strong>，当用户试图修改视图的某些信息时，数据库必须<strong>把它转化为对基本表的某些信息的修改</strong>，对于简单的视图来说，这是很方便的，但是，对于比较复杂的试图，<strong>可能是不可修改的</strong>。</li></ul><h2 id="MySQL存储过程"><a href="#MySQL存储过程" class="headerlink" title="MySQL存储过程"></a>MySQL存储过程</h2><p><strong>MySQL 5.0 版本</strong>开始支持存储过程。</p><p>存储过程是用户定义的一系列<strong>SQL语句的集合</strong>，<strong>涉及特定表或其他对象</strong>（表、视图、索引、序列、目录、同义词、数据库用户、存储过程、函数、触发器等）的任务，用户可以<strong>调用存储过程进行对表或其他对象的操作。</strong></p><p>存储过程思想上很简单，就是<strong>数据库 SQL 语言层面的代码封装与重用。</strong></p><p>存储过程定义的一个实例（需要使用<strong>execute调用</strong>）：</p><pre class="line-numbers language-mysql"><code class="language-mysql">mysql> delimiter $$　　#将语句的结束符号从分号;临时改为两个$$(可以是自定义)mysql> CREATE PROCEDURE delete_matches(IN p_playerno INTEGER)    -> BEGIN    -> 　　DELETE FROM MATCHES    ->    WHERE playerno = p_playerno;    -> END$$Query OK, 0 rows affected (0.01 sec)mysql> delimiter;　　#将语句的结束符号恢复为分号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>存储过程<strong>可封装</strong>，并隐藏<strong>复杂的商业逻辑</strong>。</li><li>存储过程可以<strong>回传值</strong>，并可以<strong>接受参数</strong>。</li><li>存储过程<strong>无法使用 SELECT 指令</strong>来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。</li><li>存储过程可以用在<strong>数据检验，强制实行商业逻辑</strong>等。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>存储过程，往往定制化于<strong>特定的数据库</strong>上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要<strong>重写原有的存储过程。</strong></li><li>存储过程的性能调校与撰写，<strong>受限于各种数据库系统。</strong></li></ul><h3 id="存储过程和MySQL函数的区别"><a href="#存储过程和MySQL函数的区别" class="headerlink" title="存储过程和MySQL函数的区别"></a>存储过程和MySQL函数的区别</h3><ul><li>存储过程<strong>涉及表或者其他对象</strong>，而函数通常<strong>不涉及特定的用户表。</strong></li><li>存储过程<strong>功能复杂强大</strong>，可以执行包括<strong>修改表</strong>等一系列数据库操作；而函数实现的功能<strong>针对性比较强；</strong></li><li>对于存储过程来说可以<strong>返回参数</strong>，如记录集，而函数只能<strong>返回值或者表对象</strong>。</li><li>函数只能返回<strong>一个变量</strong>；而存储过程可以<strong>返回多个</strong>。</li><li>存储过程的参数可以有<strong>IN,OUT,INOUT三种类型</strong>，而函数只能有<strong>IN类</strong>；<ul><li><strong>IN 输入参数</strong>：表示调用者向过程<strong>传入值</strong>（<strong>传入值可以是字面量或变量</strong>）</li><li><strong>OUT 输出参数</strong>：表示过程向调用者<strong>传出值</strong>(可以返回多个值)（<strong>传出值只能是变量</strong>）</li><li><strong>INOUT 输入输出参数</strong>：既表示<strong>调用者向过程传入值，又表示过程向调用者传出值</strong>（<strong>值只能是变量</strong>）</li></ul></li><li>存储过程可以使用<strong>非确定函数</strong>，而不允许用户在函数定义<strong>非确定函数</strong>；</li><li>存储过程一般作为一个<strong>独立的部分</strong>来执行（<strong>EXECUTE语句执行</strong>），而函数可以作为<strong>查询语句的一部分</strong>来调用（<strong>SELECT调用</strong>）；</li></ul><h2 id="MySQL触发器"><a href="#MySQL触发器" class="headerlink" title="MySQL触发器"></a>MySQL触发器</h2><p>例如在数据库中有两个表，一个用户信息表，一个账号表，账号表用来账号的注册，密码的修改等操作，信息表用来保存用户 的信息（姓名、年龄等）；当账号在账号表中注册成功后，如何在用户表中同时添加用户的相关信息以保证数据的准确性和实时性呢。通常我们在注册成功时可以insert用户的信息到用户信息表中，但如果用户数量过多，SQL语句则过于繁琐，怎么办。这时我们就可以使用触发器。</p><p><strong>触发器（trigger）是一种特殊的存储过程</strong>，它可以在对一个表上<strong>进行INSERT、UPDATE和DELETE操作中的任一种或几种操作时被自动调用执行</strong>。它SQL server 提供给程序员和数据分析员来保证<strong>数据完整性</strong>的一种方法。</p><p>当需要<strong>实现多个表的级联更改或实时监控表中字段的更改作出处理时</strong>就可以使用触发器来完成。</p><h3 id="MySQL中都有哪些触发器"><a href="#MySQL中都有哪些触发器" class="headerlink" title="MySQL中都有哪些触发器"></a>MySQL中都有哪些触发器</h3><p>Before Insert、After Insert、Before Update、After Update、Before Delete、After Delete</p><h2 id="MySQL数据库优化"><a href="#MySQL数据库优化" class="headerlink" title="MySQL数据库优化"></a>MySQL数据库优化</h2><p>随着系统规模的不断增加，数据量和并发量不断增大，整个系统架构中最先受到冲击而形成瓶颈的，定然是数据库，数据库中数据存储的位置（<strong>磁盘而非内存</strong>），数据量的大以及系统的吞吐量都影响了数据的访问速度和读写速度，因此数据库层面的优化也显得尤为重要。</p><h3 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h3><ul><li>当只有一行数据时使用<strong>limit 1</strong>。查询时如果已知<strong>只会得到一条数据</strong>，则加上limit 1会<strong>提高效率</strong>。因为mysql数据库引擎会在找到一条结果后停止搜索，而不是继续查询下一条或直至所有记录查询完毕。</li><li><strong>选择正确的数据库引擎</strong>。MySQL中都MyISAM和InnoDB都各有利弊，因此选择正确的引擎很重要。MyISAM适用于<strong>读多写少</strong>的应用，而且它对于<strong>select count(*)类似操作（会使用专门变量存放记录数目）</strong>速度非常快；InnoDB是一个复杂的存储引擎，它在<strong>写多的应用中</strong>占优势，并且它支持很多<strong>高级应用（事务等）</strong>。</li><li><strong>用not exists代替not in。</strong>Not exists用到了连接，能够发挥<strong>已经建立好的索引的作用</strong>，not in<strong>不能使用索引</strong>。Not in是最慢的方式<strong>要同每条记录比较</strong>，在数据量比较大的操作中不建议使用这种方式。</li><li>对操作符的优化，尽量<strong>不采用不利于索引的操作符</strong>。如：<strong>in、not in、is null、is not null、&lt;&gt; 等</strong></li><li><strong>选取最适用的字段属性</strong>。例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。</li><li><strong>使用连接（JOIN）来代替子查询(Sub-Queries)</strong>。连接（JOIN）之所以更有效率一些，是因为MySQL不需要<strong>在内存中创建临时表</strong>来完成这个逻辑上的需要两个步骤的查询工作。</li><li><strong>使用联合(UNION)来代替手动创建的临时表</strong>。</li><li><strong>多使用事务，它具有ACID特性</strong>。尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。</li><li><strong>创建索引。</strong>对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。</li><li><strong>复合索引。</strong>比如有一条语句是这样的：select * from users where area=’beijing’ and age=22;<br>如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age, salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。</li><li><strong>索引不会包含有NULL值的列。</strong>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</li><li><strong>使用短索引。</strong>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</li><li><strong>排序的索引问题。</strong>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</li><li><strong>like语句操作。</strong>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。</li><li><strong>不要在列上进行运算。</strong>select <em> from users where YEAR(adddate)&lt;2007;将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成select </em> from users where adddate&lt;‘2007-01-01’;</li><li><strong>不使用NOT IN和&lt;&gt;操作。</strong>NOT IN和&lt;&gt;操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替，id&lt;&gt;3则可使用id&gt;3 or id&lt;3来代替。</li></ul><h3 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h3><ul><li><strong>将字段很多的表分解成多个表</strong>。因为字段很多的表中存在一些使用频率低的字段，这些字段的存在就会大大影响访问速度；</li><li><strong>增加一些中间表</strong>。对于需要经常联合多个表进行查询时，可以建立一个中间表，将需要通过联合查询的数据插入到中间表，来提高效率；</li><li><strong>读写分离</strong>。在数据库并发大的情况下，最好的做法就是进行横向扩展，增加机器，以提升抗并发能力，而且还兼有数据备份功能。</li></ul><h2 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h2><p>所谓SQL注入，就是通过<strong>把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串</strong>，最终达到<strong>欺骗服务器执行恶意的SQL命令</strong>。</p><p>我们永远不要信任用户的输入，我们必须认定用户输入的数据都是不安全的，我们都需要对用户输入的数据进行过滤处理。</p><p>防止SQL注入，我们需要注意以下几个要点：</p><ul><li><strong>永远不要信任用户的输入</strong>。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双”-“进行转换等。</li><li><strong>永远不要使用动态拼装sql</strong>，可以使用<strong>参数化的sql或者直接使用存储过程进行数据查询存取</strong>。</li><li>永远不要使用<strong>管理员权限</strong>的数据库连接，<strong>为每个应用使用单独的权限有限的数据库连接</strong>。</li><li><strong>不要把机密信息直接存放</strong>，加密或者hash掉密码和敏感的信息。</li><li><strong>应用的异常信息应该给出尽可能少的提示</strong>，最好使用自定义的错误信息对原始错误信息进行包装</li><li>sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。</li></ul><p>一个mysql注入攻击的例子：在用户名输入框中输入:’ or 1=1#,密码随便输入.</p><pre class="line-numbers language-mysql"><code class="language-mysql">select * from users where username='' or 1=1#' and password=md5('') <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>语义分析：“#”在mysql中是注释符，这样井号后面的内容将被mysql视为注释内容，这样就不会去执行了，导致黑客会成功登陆网站。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构复习</title>
      <link href="/2020/05/29/shu-ju-jie-gou-fu-xi/"/>
      <url>/2020/05/29/shu-ju-jie-gou-fu-xi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划经典问题《背包九讲》整理</title>
      <link href="/2020/05/26/dong-tai-gui-hua-jing-dian-wen-ti-bei-bao-jiu-jiang-zheng-li/"/>
      <url>/2020/05/26/dong-tai-gui-hua-jing-dian-wen-ti-bei-bao-jiu-jiang-zheng-li/</url>
      
        <content type="html"><![CDATA[<h1 id="背包九讲"><a href="#背包九讲" class="headerlink" title="背包九讲"></a>背包九讲</h1><p>背包问题是动态规划问题中最为经典的问题之一，可以说完全弄明白了背包问题，能够很大程度上帮助我们了解动态规划转移方程的基本推导。背包问题的经典讲义为浙江大学崔添翼同学撰写的《背包九讲》，本文是我阅读该文章过程中的笔记和感想。</p><p>动态规划的思路其实并不难想到，大多数问题只需要看一眼就能知道是否可以采用动规求解了，难点在于如何推导出合适的状态矩阵和状态转移方程。这需要我们<strong>多手写DP表，仔细找规律</strong>。</p><h2 id="动态规划问题基本概念"><a href="#动态规划问题基本概念" class="headerlink" title="动态规划问题基本概念"></a>动态规划问题基本概念</h2><p>动态规划方法要寻找符合“<strong>最优子结构</strong>“的状态和<strong>状态转移方程</strong>的定义<strong>，</strong>在找到之后，这个问题就可以以“<strong>记忆化地求解递推式</strong>”的方法来解决。而寻找到的定义，才是动态规划的本质。 </p><p>一般来说，当问题具有以下三个特点的时候，适用动态规划方法解决：</p><ul><li><strong>最优子结构</strong>： 大问题的<strong>最优解</strong>可以由小问题的<strong>最优解</strong>推出 </li><li><strong>无后效性</strong>： 如果给定某一阶段的状态，则在这一阶段以后过程的发展<strong>不受这阶段以前各段状态的影响</strong>。 </li><li><strong>重叠子问题</strong>：相同的子问题可能被<strong>重复求解</strong>多次</li></ul><p>其实，上述前两个特点准确说是<strong>分治算法</strong>的特点。动态规划和递归算法本质上都是分治算法的一个<strong>子集</strong>，它们都是将大问题分解为小问题进行求解。而第三个特点区分了使用递归和使用动态规划的情况：<strong>一般来说，子问题独立的情况我们使用递归算法解决即可，而子问题重叠必须使用动态规划，否则时间复杂度会大大升高。</strong></p><p>我们以最简单的斐波那契数列为例，当求解第101项时，我们需要计算第100项和第99项，而当求解第102项时，我们需要求解100项和第101项。如果我们直接使用递归算法，那么求解第101项和第102项会重复计算第100项两次，这将白白浪费许多时间。</p><p>实际上，如果我们对递归算法稍作修改，就可以让其变为动态规划的形式，即<strong>另加一个用于记忆的数据结构</strong>。这种做法叫做<strong>记忆化搜索</strong>，它本质上就是一种<strong>自顶向下的动态规划算法</strong>（从大问题到小问题）。如果我们<strong>从小问题开始求解</strong>，最终递推出所要求的大问题结果，那么这也是一种动态规划的实现方法（<strong>自底向上</strong>）。有不少博客都将记忆化搜索和自底向上的动态规划区分开来，将后者定义为动态规划，实际上我认为<strong>二者都是动态规划的不同实现形式。</strong></p><p>如果我们使用动态规划算法，它将在计算的过程中将得到的第100项的结果存储起来，从而<strong>避免重复计算</strong>，这也是为什么动态规划算法能够大大减少运行时间的原因。</p><p>动态规划算法的关键点总结为：</p><ul><li>动态规划法试图只解决每个子问题<strong>一次</strong></li><li>一旦某个给定子问题的解已经算出，则将其<strong>记忆化存储</strong>，以便下次需要同一个子问题解之时直接查表。</li></ul><p>动态规划算法往往还会被拿来和贪心算法比较，但贪心算法只会关注<strong>局部最优解</strong>，当局部最优无法达到全局最优时，贪心算法将出错。实际上，如何选择各种策略可以总结为：</p><blockquote><p>每个阶段只有一个状态-&gt;递推；<br>每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；<br>每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；<br>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。</p></blockquote><p>同时，我们也要注意，尽管动态规划具有无后效性，但并不代表我们不可以用动态规划解决求解需要获取过程组合的问题，例如：<a href="https://leetcode-cn.com/problems/word-break-ii/" target="_blank" rel="noopener">140. 单词拆分 II</a>。</p><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是$C_i^1$，得到的价值是$W_i$。求解将哪些物品装入背包可使价值总和最大。 </p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>最基础的背包问题，每件物品只有1个，也只有一种选择：<strong>放或者不放</strong>。</p><p>我们可以定义状态矩阵：F[i, v] 表示前 i 件物品恰放入一个容量为 v 的背包可以获得的最大价值。则其状态转移方程便是：<br>$$<br>F[i, v] = max\{F[i-1, v],F[i-1, v-C_i]+W_i\}<br>$$<br>简单解析一下上述方程：给定了背包容量 v 的情况下，前 i 个物品恰放入背包的最大总价值这个子问题只需要考虑<strong>第 i 个物品是否放入背包</strong>。当前物品不放入背包的情况下，当前总价值与前 i -1 个物品恰放入容量 v 的背包的总价值相等；而如果放入背包，则留给前 i-1 个物品将会减小，当前总价值与前 i -1 个物品恰放入容量 $v-C_i$ 的背包的总价值加上当前物品价值$W_i$相等。</p><p><strong>我们将”给定了背包容量 v 的情况下，前 i 个物品恰放入背包的最大总价值“这个子问题转化为了只和前 i-1 个物品相关的子问题</strong>。同时，我们使用<strong>二维数组</strong>来存储状态矩阵 F[i, v] ，减少了重叠子问题带来的重复计算时间。</p><h3 id="空间复杂度优化"><a href="#空间复杂度优化" class="headerlink" title="空间复杂度优化"></a>空间复杂度优化</h3><p>上述问题的空间复杂度为$O(VN)$，时间复杂度已经达到了最优，但空间复杂度存在着优化空间。</p><p>我们通过观察状态转移矩阵发现，第 i 个物品的状态往往只依赖于第 i-1 个物品的状态，那么我们可以很轻松地想到<strong>只使用两行数组存储两个时刻的状态</strong>，每次更新到 i+1 个物品时，我们让第 i 个物品的状态覆盖第 i-1 个物品的状态，同时让当前物品的状态填充第二行数组即可。这一方法叫做<strong>滚动数组</strong>法。</p><p>但其实，我们可以进一步优化到只使用一行数组来表示状态。观察状态转移方程，我们发现，F[i, v] 只和F[i-1, v]与F[i-1, v-C]有关 ，即当前状态所依赖的子状态，其列数必然小于等于当前状态（v和v-c)。也就是说： 在”<strong>填写DP表</strong>“的时候，<strong>当前行总是参考了它上面一行 “头顶上” 那个位置和“左上角”某个位置的值</strong>。因此，我们可以只开一个一维数组，<strong>从后向前依次填表</strong>即可。 </p><p>之所以需要从后向前更新状态，是因为我们需要使用到之前的状态。如果从前向后更新，<strong>原先的状态F[i-1,v]会被新状态F[i,v]覆盖掉</strong>，导致在后面需要使用F[i-1,v]时无法找到，从而出现计算错误。</p><p>通过状态压缩，我们可以将空间复杂度优化为$O(V)$，只用一个数组F[v]解决01背包问题。</p><ul><li>空间复杂度：$O(VN)$</li><li>时间复杂度：$O(V)$</li></ul><h3 id="初始化的细节问题"><a href="#初始化的细节问题" class="headerlink" title="初始化的细节问题"></a>初始化的细节问题</h3><p>我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是<strong>在初始化的时候有所不同</strong>。 </p><p>如果要求恰好装满背包，那么在初始化时除了 F[0] 为 0，<strong>其它 F[1..V] 均设为 −∞</strong>，这样可以保证最终得到的 F[ V ] 是一种恰好装满背包的最优解。</p><p>如果并没有要求必须把背包装满，而是只希望价格尽量大，<strong>初始化时应该将 F[0..V ] 全部设为 0</strong>。 这是为什么呢？可以这样理解：初始化的 <em>F</em> 数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有<strong>容量为 0 的背包</strong>可以在什么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包<strong>均没有合法</strong>的解，属于<strong>未定义的状态</strong>，应该被赋值为 -∞ 了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“<strong>什么都不装</strong>”，这个解的价值为 0，所以初始时状态的值也就全部为 0了。 </p><h3 id="一个例题"><a href="#一个例题" class="headerlink" title="一个例题"></a>一个例题</h3><p>一个01背包问题的实例是：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集</a></p><p>这道题目的问题是： 给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 </p><p>做这道题需要做这样一个等价转换：<strong>是否可以从这个数组中挑选出一些正整数，使得这些数的和等于整个数组元素的和的一半。</strong>前提条件是：数组的和一定得是偶数，即数组的和一定得被 2 整除，这一点是特判。</p><p>我们将其抽象为01背包问题：<strong>每个正整数可以看作是一个价值和重量相等的物品，假设存在一个最大容量为二分之数组元素总和的背包，是否可以挑选一些物品，恰好填满这个背包，也就是这些物品的价值总和等于背包最大容量。</strong></p><p>按照01背包问题求解的代码为：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canPartition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>                c<span class="token operator">=</span>sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> c<span class="token operator">%</span><span class="token number">2</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            c<span class="token operator">//=</span><span class="token number">2</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#状态压缩</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#需要先初始化0号物品的情况，0号物品可以正向计算</span>            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">>=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#当前背包容量可以放入的最大价值物品（可以选取的最大整数和）</span>            <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>c<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果前i个物品恰好能填满容量为c的背包，即可选择一些整数，和为总元素和的一半</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，我们还可以将01背包问题在本题条件下进一步优化，<strong>不需要求解出实际的价值，只需要判断能否选取一些物品填满当前背包容量即可。</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canPartition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>                c<span class="token operator">=</span>sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> c<span class="token operator">%</span><span class="token number">2</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            c<span class="token operator">//=</span><span class="token number">2</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#需要先初始化0号物品的情况，0号物品可以正向计算</span>            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span> <span class="token keyword">if</span> j<span class="token operator">==</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token boolean">False</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">or</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#选或不选当前整数的两种情况下，只要有一种能填满当前背包容量即可将当前状态设为True</span>            <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果dp[c]为True，则说明可以选择一些整数，和为总元素和的一半</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是$C_i^1$，得到的价值是$W_i$。<strong>每个物品有无限个可用</strong>。求解将哪些物品装入背包可使价值总和最大。 </p><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>完全背包问题看上去只和01背包问题有很小的区别，区别在于完全背包问题每种物品可选的数目是任意的。</p><p>我们很容易想到一种贪心的思路：<strong>优先选择性价比较高的物品</strong>。但仍旧有一个问题，那就是同一种物品虽然可以选择任意多件，但仍旧只能以件为单位，也就是说单个物品是无法拆分的，不能选择半件，只能多选一件或者少选一件。这样就造成了一个问题，往往无法用性价比最高的物品来装满整个背包，比如背包空间为10，性价比最高的物品占用空间为7，那么剩下的空间该如何填充呢？ </p><p>你当然会想到用性价比第二高的物品填充，如果仍旧无法填满，那就依次用第三、第四性价比物品来填充。 </p><p>想要举反例很简单，比如只有两个物品：物品A：价值5，体积5，物品B：价值8：体积7，背包容量为10，物品B的性价比显然要比物品A高，那么用贪心算法必然会选择放入一个物品B，此时，剩余的空间已无法装下A或者B，所以得到的最高价值为8，而实际上，选择放入两个物品A即可得到更高的价值10。<strong>所以这里贪心算法并不适用。</strong> </p><p>我们从每种物品的角度考虑，与它相关的策略已并非取或不取两种，<strong>而是有取 0 件、取 1 件、取 2 件……直至取 [V /Ci]件等许多种。</strong> 我们基于01背包问题，可以推导出它的动态规划转移公式为：<br>$$<br>F[i, v] = max\{F[i-1, v-kC_i]+kW_i|0&lt;=kC_i&lt;=v\}<br>$$<br>不难看出，<strong>01背包问题是完全背包问题的一种特殊情况。</strong></p><p>由于此时需要遍历0到[V /Ci]种策略，所以需要三层枚举，总的时间复杂度为$O(VN\frac{V}{C_i})$。</p><p>一个简单有效的优化是：若两件物品 i、j 满足 Ci <em>≤</em> Cj 且 Wi≥Wj，则将可以将物品 j 直接去掉，不用考虑。<strong>任何情况下都可将价值小费用高的 j  换成物美价廉的 i，得到的方案至少不会更差。</strong>这和贪心算法不一样，因为这里不仅要求性价比高，且物品的重量还需要更小。</p><h3 id="转化为01背包问题"><a href="#转化为01背包问题" class="headerlink" title="转化为01背包问题"></a>转化为01背包问题</h3><p>实际上，我们可以将完全背包问题转化为一个01背包问题，转化的方法为：<strong>将一种物品的不同选择次数拆成多件只能选 0 件或 1 件的 01 背包中的物品。</strong> </p><p>考虑到第 i 种物品最多选[V /Ci]件，<strong>于是可以把第 i 种物品转化为 [V /Ci] 件费用及价值均不变的物品。</strong></p><p>更进一步优化，我们知道，考虑到二进制数的性质，任意1个数都可以表示为若干个$2^k$的组合。<strong>所以，我们只需要将物品拆分为 log[V /Ci]  件物品即可。</strong></p><h3 id="空间复杂度优化-1"><a href="#空间复杂度优化-1" class="headerlink" title="空间复杂度优化"></a>空间复杂度优化</h3><p>与01背包问题类似，完全背包问题的空间复杂度依然可以使用<strong>状态压缩</strong>进行空间优化。</p><p>我们同样可以使用类似的方法将空间复杂度降为$O(N)$，它和01背包问题唯一的区别在于：<strong>不需要反向遍历填充DP表，正向填充即可。</strong></p><p><strong>这是因为，01背包问题中，我们最多可以添加1个同种物品，所以我们只能在前 i-1 个物品的结果上进行添加，倒序遍历是防止这个结果被覆盖掉。而完全背包问题中，我们最多可以添加无限个物品，我们可以在前 i 个物品的结果上继续添加，而想要使用前 i 个物品的放置结果，必须正向遍历。</strong></p><h3 id="一个例题-1"><a href="#一个例题-1" class="headerlink" title="一个例题"></a>一个例题</h3><p>一个完全背包问题的实例是：<a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">面试题 08.11. 硬币</a></p><p>这道题的目的是： 给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。 很明显，这是一个完全背包问题，背包容量为n，有四种物品，我们可以将它们的价值和重量看作是相同的。这里我们要求的不是最大价值，而是恰好能填满背包的组合数目。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">waysToChange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        coins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> coin <span class="token keyword">in</span> coins<span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>coin<span class="token punctuation">]</span> <span class="token keyword">if</span> i<span class="token operator">-</span>coin<span class="token operator">>=</span><span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">0</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是：<strong>常规完全背包问题，可以调换上述两层循环的位置，但是在这道题里不可以，会导致重复的组合，而先遍历币值可以保证结果组合的币值升序，从而不会重复。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络全部复习笔记</title>
      <link href="/2020/05/22/ji-suan-ji-wang-luo-quan-bu-fu-xi-bi-ji/"/>
      <url>/2020/05/22/ji-suan-ji-wang-luo-quan-bu-fu-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络复习笔记"><a href="#计算机网络复习笔记" class="headerlink" title="计算机网络复习笔记"></a>计算机网络复习笔记</h1><p>本文是我学习谢希仁版《计算机网络》的核心部分笔记。比较全，如果要面向面试的话可以看牛客网上这篇 <a href="https://www.nowcoder.com/discuss/429605?type=0&amp;order=7&amp;pos=5&amp;page=1&amp;channel=1000&amp;source_id=discuss_center_0" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/429605?type=0&amp;order=7&amp;pos=5&amp;page=1&amp;channel=1000&amp;source_id=discuss_center_0</a>  。WEB安全的内容也是常考点，但我暂时没有整理，面试前要看一下。    </p><h2 id="第一章-计算机网络概述"><a href="#第一章-计算机网络概述" class="headerlink" title="第一章 计算机网络概述"></a>第一章 计算机网络概述</h2><h3 id="重要内容"><a href="#重要内容" class="headerlink" title="重要内容"></a>重要内容</h3><ul><li><strong>互联网边缘部分和核心部分的作用。</strong></li><li><strong>分组交换的概念</strong>。</li><li><strong>计算机网络的性能指标</strong>。</li><li><strong>计算机网络的分层次的体系结构的概念、协议和服务</strong>。</li></ul><h3 id="核心知识点"><a href="#核心知识点" class="headerlink" title="核心知识点"></a>核心知识点</h3><ol><li><p>网络的类别：</p><ol><li>电信网络</li><li>有线电视网络</li><li><strong>计算机网络</strong></li></ol></li><li><p>互联网的特点：</p><ol><li><strong>连通性</strong></li><li><strong>共享性</strong></li></ol></li><li><p>基本概念：</p><ol><li><strong>计算机网络</strong>：是由<strong>分布在不同地理位置，功能独立</strong>的多台计算机，使用<strong>网络设备和线路</strong>连接而成的网络系统，主要目的是<strong>信息交换和资源共享</strong>。</li><li><strong>互连网</strong>（<strong>internet</strong>）：使用<strong>路由器和线路</strong>将多个计算机网络连接起来，构成的覆盖范围更广的网络，叫作互连网，<strong>小写字母开头</strong>。所以，互连网是“<strong>网络的网络</strong>”。</li><li><strong>互联网</strong>（<strong>Internet</strong>）：也称<strong>因特网</strong>，指当今全球最大的、开放的、由众多网络相互连接而成的<strong>特定互连网</strong>，它采用<strong>TCP/IP协议族</strong>作为通信的规则，其前身是美国的<strong>ARPANET</strong>。</li></ol></li><li><p>互联网和互连网的区别：</p><ol><li><strong>互联网是特定的互连网</strong>。任意把几个网络通过路由器互连起来，并且能相互通信，这样只是互连网，而不是互联网。</li><li>互联网必须采用<strong>TCP/IP协议族</strong>作为通信规则，而互连网可以选用<strong>任意的</strong>通信协议。</li></ol></li><li><p>网络由若干节点和连接这些节点的链路组成（节点可以是计算机，集线器，交换机，路由器等）；网络和网络之间通过路由器连接起来，构成了互连网——即网络的网络；因此，网络把许多计算机连接在一起，互连网将许多网络连接在一起。</p></li><li><p>互联网发展的三个阶段：</p><ol><li><strong>单个网络APRANET向互连网发展</strong>。<strong>1969年</strong>，美国国防部创建了第一个分组交换网<strong>ARPANET</strong>，<strong>计算机网络诞生</strong>。<strong>1983年</strong>TCP/IP协议成为ARPANET上的标准通信协议，<strong>互联网诞生</strong>。</li><li>建成了三级结构的网络，即<strong>主干网、地区网、校园网</strong>。</li><li>逐渐形成了<strong>多层次ISP结构</strong>的互联网。<strong>ISP是互联网服务提供者（互联网服务提供商）</strong>。</li></ol><p><img src="isp.png" alt="isp"></p></li><li><p><strong>因特网交换点IXP</strong>：（更快的转发分组，更有效地利用网络资源）允许两个网络直接相连并交换分组，不需要其他网络来转发分组，IXP常采用工作在数据链路层的网络交换机，这些网络交换机都用局域网互连起来（典型的IXP由一个或多个网络交换机组成）</p></li><li><p><strong>WWW</strong>：<strong>万维网</strong>，侧重于指互联网上的网页。使用<strong>HTTP协议</strong>工作。</p></li><li><p>制定互联网的标准的阶段：</p><ol><li>互联网草案。</li><li>建议标准（RFC文档）。</li><li>互联网标准。</li></ol></li><li><p>所有互联网标准都是以<strong>RFC形式</strong>在互联网上发表的。管理互联网的组织是互联网协会ISOC。管理互联网协议开发的组织是互联网体系结构委员会IAB，IAB下辖互联网工程部IETF和互联网研究部IRTF。</p></li><li><p>互联网的组成：</p><ol><li><strong>边缘部分</strong>：由所有连接在互联网上的<strong>主机</strong>组成，这部分是用户直接使用的。其目的是进行<strong>通信和资源共享。</strong></li><li><strong>核心部分</strong>：由<strong>大量网络和连接这些网络的路由器</strong>组成。这部分是为边缘部分提供服务的，提供<strong>连通性和交换。</strong></li></ol><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.png" alt="计算机网络"></p></li><li><p>端系统之间通信的含义：</p><ol><li>“主机 A 和主机 B 进行通信”实际上是指：<strong>“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”</strong>。简称：“计算机之间通信”。</li></ol></li><li><p>端系统的通信方式：</p><ol><li><p><strong>客户端/服务器方式（C/S方式）</strong>：一方是<strong>客户</strong>，一方是<strong>服务器。</strong></p><ol><li>客户端：被用户调用后运行，在打算通信时<strong>主动</strong>向远地服务器发起通信（请求服务）。因此，客户程序<strong>必须知道服务器程序的地址</strong>。不需要特殊的硬件和很复杂的操作系统。 </li><li>服务器：一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序<strong>不需要知道客户程序的地址</strong>。一般需要强大的硬件和高级的操作系统支持。</li></ol><p><img src="CS.png" alt="CS"></p></li><li><p><strong>对等连接方式（P2P方式）</strong>：本质上看仍然是使用客户服务器方式，只是对等连接中的每一个主机<strong>既是客户又是服务器。</strong></p><p><img src="P2P.png" alt="P2P"></p></li></ol></li></ol><ol start="14"><li><p>互联网的核心部分：</p><ol><li><p>在互联网核心部分中起特殊作用的是<strong>路由器</strong>，它是一种专用计算机，是实现<strong>分组交换</strong>的关键构件，作用是按<strong>存储转发</strong>方式进行分组交换。其任务是<strong>转发收到的分组</strong>，这是网络核心部分最重要的功能。</p></li><li><p>交换方式：</p><ol><li><strong>电路交换</strong>：整个报文的比特流<strong>连续地</strong>从源点直达终点，好像在一个管道中传送。缺点是<strong>在通话的全部时间里，通话的两个用户需要始终占用端到端的通信资源。</strong>这在计算机网络中<strong>效率很低</strong>，因为计算机数据往往是<strong>突发式</strong>的出现在传输线路上的。</li><li><strong>报文交换</strong>：<strong>整个报文</strong>先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。<strong>一旦出错将使整个报文失效，不够灵活。</strong></li><li><strong>分组交换</strong>：<strong>分组（报文的一部分）</strong>先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。最终，接收方接收所有的分组，并将其还原为最初的报文。优点是<strong>时延小，灵活性好，是计算机网络中最常用的交换方式。</strong></li></ol><p><img src="%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F.png" alt="交换方式"></p></li><li><p>互联网核心部分中的<strong>路由器之间一般都用高速链路</strong>相连接，而在网络边缘的<strong>主机</strong>接入到核心部分则通常以相对<strong>较低速率的链路</strong>相连接。</p></li><li><p>主机的用途是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。路由器的用途则是用来转发分组的，即进行分组交换的。 </p></li></ol></li><li><p><strong>计算机网络的定义</strong>：</p><ol><li>计算机网络主要是由一些<strong>通用的、可编程（必然含有CPU）的硬件</strong>互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</li><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机。</li><li>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。</li></ol></li><li><p><strong>计算机网络的类别</strong>：</p><ol><li>按照作用范围划分：<ol><li><strong>广域网（wide area net，wan）</strong>：范围几十到几千公里。</li><li><strong>城域网（metropolitan area net，man）</strong>：范围5-50公里。</li><li><strong>局域网 LAN (Local Area Network)</strong> ：局限在较小的范围（如 1 公里左右）。</li><li><strong>个人区域网 PAN (Personal Area Network)</strong> ：范围很小，大约在 10 米左右。</li></ol></li><li>按照网络使用者划分：<ol><li><strong>公用网</strong>：所有人都能用。</li><li><strong>专用网</strong>：只有单位内部人员能用。</li></ol></li></ol></li><li><p>计算机网络的性能指标：</p><ol><li><p><strong>速率</strong>：单位时间内的数据传送速率，也叫数据率或比特率（<strong>单位：bit/s</strong>)。速率往往是指<strong>额定速率或标称速率</strong>，非实际运行速率。 </p></li><li><p><strong>带宽</strong>：“带宽”(bandwidth) 本来是指信号具有的频带宽度（<strong>频域称谓</strong>），其单位是赫（或千赫、兆赫、吉赫等）。在计算机网络中，带宽用来表示网络中某通道传送数据的能力。表示在单位时间内网络中的某信道所能通过的<strong>“最高数据率”</strong>。单位是 <strong>bit/s</strong> ，即 “比特每秒”。   （<strong>时域称谓</strong>）</p><ol><li>PS：速率VS.带宽：速率指的是信道传输的标准速率，而带宽指的是最高速率。例如，电信公司安装的宽带，通常会说带宽为100兆，但实际上速率只有10兆左右。</li></ol></li><li><p><strong>吞吐率</strong>：单位时间内通过某个网络（信道、接口）的实际数据量。</p></li><li><p><strong>时延</strong>：<strong>数据（一个报文或分组，甚至比特）从网络的一端传到另一端所需要的时间</strong>，又称延迟或者迟延。它由四个部分组成：</p><ol><li><p><strong>发送时延</strong>：主机或路由器发送数据帧所需要的时间。计算方式为：<strong>数据帧长度（bit）除以发送速率（bit/s）</strong></p></li><li><p><strong>传播时延</strong>：电磁波在信道中传输所需的时间。计算方式为：<strong>信道长度（m）除以电磁波在信道上的传输速度（m/s）</strong></p></li><li><p><strong>排队时延</strong>：分组在路由器中需要先排队等待处理，再排队等待发送。</p></li><li><p><strong>处理时延</strong>：主机或路由器收到数据帧处理所需要的时间。</p><p><img src="%E6%97%B6%E5%BB%B6.png" alt="时延"></p></li></ol></li><li><p><strong>时延带宽积</strong>：时延乘以带宽。<strong>又称以比特为单位的链路长度。</strong> </p></li><li><p><strong>往返时间 RTT</strong>：<strong>双向交互</strong>一次所需要的时间。</p></li><li><p><strong>利用率</strong>：利用率并非越高越好，高利用率会导致高时延（排队理论）。</p><ol><li><strong>信道利用率</strong>：某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。</li><li><strong>网络利用率</strong>：全网络的信道利用率的加权平均值。</li></ol></li></ol></li><li><p>计算机网络体系结构：</p><ol><li><p>1974年，美国IBM公司宣布了<strong>系统网络体系结构SNA。</strong></p></li><li><p>1977年，国际标准化组织ISO提出了<strong>开放系统互连基本参考模型OSI/RM（Open Systems Interconnection Reference Model)</strong>，1983年出台了正式文件，即ISO7498国际标准，将通信协议划分为<strong>7层。</strong></p></li><li><p>由于OSI模型过于复杂，难以市场化，目前主要的国际标准为：<strong>TCP/IP</strong>。他将计算机网络的通信协议划分为<strong>4层。</strong></p></li><li><p><strong>网络协议：为实现网络中的数据交换而建立的规则标准或约定。</strong></p><ol><li>三要素：<ol><li><strong>语法</strong>：数据与控制信息的格式。</li><li><strong>语义</strong>：需要发出何种控制信息，完成何种动作，做出何种响应。</li><li><strong>同步</strong>：事件实现顺序的详细说明。</li></ol></li></ol></li><li><p><strong>分层的优势</strong>：</p><ol><li>各层独立。</li><li>灵活性好。</li><li>结构上可分割开。</li><li>易于实现与维护。</li><li>能促进标准化工作。</li></ol></li><li><p><strong>各层的主要功能</strong>：</p><ol><li><strong>差错控制</strong>：使相应层次对等方的通信更加可靠。</li><li><strong>流量控制</strong>：发送端的发送速率必须使接收端来得及接收，不要太快。</li><li><strong>分段和重装</strong>：发送端将要发送的数据块划分为更小的单位，在接收端将其还原。</li><li><strong>复用和分用</strong>：发送端几个高层会话复用一条低层的连接，在接收端再进行分用。</li><li><strong>连接建立和释放</strong>：交换数据前先建立一条逻辑连接，数据传送结束后释放连接。</li></ol></li><li><p>主要概念：</p><ol><li><strong>实体</strong>：任何可发送或接受信息的硬件或软件进程。</li><li><strong>协议</strong>：控制两个对等实体（或多个实体）进行通信的规则的集合。<strong>是水平的</strong>。</li><li><strong>服务</strong>：本层服务的实体只能向上一层提供服务，使用下一层的服务。<strong>是垂直的。</strong></li></ol></li><li><p>OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。TCP/IP 是四层体系结构：应用层、运输层、网际层和网络接口层。但最下面的网络接口层并没有具体内容。因此往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有<strong>五层协议</strong>的体系结构 。 </p><p><img src="%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="体系结构"></p></li></ol></li><li><p>七层协议示意图：</p></li></ol><p><img src="osi.jpg" alt="osi"></p><ol start="20"><li><p>五层协议内容（自顶向下）：</p><ol><li>应用层：<ol><li>功能：<strong>通过应用进程之间的交互来完成特定的网络应用。</strong></li><li>交换的数据单元：<strong>报文。</strong></li><li>协议：域名系统DNS、支持万维网应用的HTTP协议，支持电子邮件的SMTP等。</li></ol></li><li>运输层：<ol><li>功能：<strong>负责向两台主机中进程之间的通信提供通用的数据传输服务。具有复用和分用的功能。</strong></li><li>协议：<ol><li><strong>传输控制协议TCP</strong>：提供<strong>面向连接的、可靠</strong>的数据传输服务。交换的数据单元是：<strong>TCP报文段</strong>。</li><li><strong>用户数据报协议UDP</strong>：提供<strong>无连接的尽最大努力的</strong>数据传输服务（不确保数据的可靠性）。交换的数据单元是：<strong>用户数据报。</strong></li><li>不同的应用层协议基于不同的传输层协议。例如：HTTP协议、SMTP协议基于TCP协议，DNS协议、RTP协议基于UDP协议。</li></ol></li></ol></li><li>网络层：<ol><li>功能：<strong>为互联网内任意两台主机提供分组交换的通信服务。</strong>（路由器是网络层设备）</li><li>交换数据单元：<strong>分组（IP数据报）</strong>。</li><li>协议：网际协议IP。</li></ol></li><li>数据链路层：<ol><li>功能：<strong>为局域网内任意两台主机提供数据帧传输</strong>。</li><li>交换的数据单元：<strong>数据帧</strong>。</li></ol></li><li>物理层：<ol><li>功能；<strong>提供原始的比特流传输</strong>。</li></ol></li><li>从上至下的每一层的<strong>协议数据单元PDU</strong>，都在上一层的基础上，<strong>加上自己的控制信息</strong>。</li></ol><p><img src="%E9%A6%96%E9%83%A8%E5%8F%98%E5%8C%96.png" alt="首部变化"></p></li><li><p><strong>TCP/IP协议族</strong>：<strong>沙漏型</strong>，有很多协议，其中最主要的是<strong>运输层的TCP协议，网络层的IP协议</strong>。</p></li></ol><p><img src="TCPIP.png" alt="TCP/IP"></p><ol start="22"><li><strong>两军对垒问题</strong>：无法实现100%确保报文正确收到的协议。</li></ol><p><img src="%E4%B8%A4%E5%86%9B%E5%AF%B9%E5%9E%92.png" alt="两军对垒"></p><h2 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h2><h3 id="重要内容-1"><a href="#重要内容-1" class="headerlink" title="重要内容"></a>重要内容</h3><ul><li><strong>物理层的任务</strong></li><li><strong>几种常用的信道复用技术</strong></li><li><strong>几种常用的宽带接入技术，主要是ADSL、FTTx</strong></li></ul><h3 id="核心知识点-1"><a href="#核心知识点-1" class="headerlink" title="核心知识点"></a>核心知识点</h3><ol><li>物理层的基本功能：<strong>提供原始的比特流传输。尽可能地屏蔽掉不同传输媒体和通信手段的差异。</strong></li><li>物理层的主要任务：<ol><li><strong>确定与传输媒体的接口有关的一些特性，如机械特性、电气特性、功能特性、过程特性。</strong>（下层传输媒体不属于物理层，只有接口属于物理层）</li><li>完成数据在计算机内部（并行传输）与通信线路上（串行传输）之间的<strong>串并传输方式的转换</strong>。</li></ol></li><li>一个数据通信系统可分为：<ol><li><strong>源系统</strong>，包括源点和发送器。</li><li><strong>传输系统</strong>。</li><li><strong>目的系统</strong>：包括接收器和终点。</li></ol></li></ol><p><img src="%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F.png" alt="数据通信系统"></p><ol start="4"><li><p>常用概念：</p><ol><li><p>通信的目的是<strong>传送消息</strong>。</p></li><li><p>数据是<strong>运送消息的实体</strong>。数据是<strong>使用特定方式表示的信息</strong>，通常是有意义的符号序列。</p></li><li><p>信号则是<strong>数据的电气或电磁表现</strong>。可分为：</p><ol><li><strong>模拟信号（连续信号）</strong>。</li><li><strong>数字信号（离散信号）</strong>。</li></ol></li><li><p><strong>信道</strong>是向某一个方向传送信息的媒体。</p></li><li><p>通信可分为:</p><ol><li><strong>单向通信（单工通信）</strong>：只有<strong>一个方向</strong>的通信。<strong>如电视广播</strong>。</li><li><strong>双向交替通信（半双工通信）</strong>：通信双方都可以发送消息，但<strong>不能同时发送</strong>。</li><li><strong>双向同时通信（全双工通信）</strong>：通信双方都可以<strong>同时发送消息</strong>。</li></ol></li><li><p><strong>调制</strong>：将来自信源的低频甚至直流信号（基带信号）进行变换，使得这种低频直流信号可以便于在信道内传输。基带信号（即基本频带信号）—— 来自信源的信号。<strong>像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号</strong>。基带信号往往包含有较多的<strong>低频成分，甚至有直流成分</strong>，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行调制 (modulation)。 </p><ol><li><p><strong>基带调制（编码）</strong>：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。把这种过程称为<strong>编码 (coding)</strong>。（<strong>数字信号到数字信号</strong>）</p><ol><li><strong>不归零制</strong>：正电平代表 1，负电平代表 0。</li><li><strong>归零制</strong>：正脉冲代表 1，负脉冲代表 0。</li><li><strong>曼彻斯特编码</strong>：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。</li><li><strong>差分曼彻斯特编码</strong>：在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。</li></ol><p><img src="%E5%9F%BA%E5%B8%A6%E8%B0%83%E5%88%B6.png" alt="基带调制"></p></li><li><p><strong>带通调制</strong>：使用<strong>载波</strong>进行调制，调制后的信号是模拟信号。（<strong>数字信号到模拟信号）</strong></p><ol><li><strong>调幅AM</strong>：载波的振幅随基带数字信号而变化。 </li><li><strong>调频FM</strong>：载波的频率随基带数字信号而变化。</li><li><strong>调相PM</strong>：载波的初始相位随基带数字信号而变化。</li></ol></li></ol></li></ol></li><li><p>信噪比：<strong>信号的平均功率和噪声的平均功率之比</strong>。常记为 S/N，S为信号平均功率，N为噪声平均功率，并用<strong>分贝 (dB)</strong> 作为度量单位。即：</p><blockquote><p> 信噪比(dB) = 10 log10(S/N)    (dB) </p></blockquote></li><li><p>香农公式：1984年，香农 (Shannon) 用信息论的理论推导出了<strong>带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率（香农公式）</strong>。</p><p>信道的极限信息传输速率 C 可表达为：</p><blockquote><p>C = W log2(1+S/N)    (bit/s) </p></blockquote><ul><li>W 为信道的带宽（以 Hz 为单位）；</li><li>S 为信道内所传信号的平均功率；</li><li>N 为信道内部的高斯噪声功率。  </li></ul></li><li><p><strong>信道复用技术：允许多个用户使用共享信道通信，降低成本，提高利用率。</strong></p><ol><li><strong>频分复用FDM</strong>：用户在同样的时间内占用不同的频率带宽而复用同一个信道  </li><li><strong>时分复用TDM</strong>：将时间划分为相同的时分复用帧TDM，用户在不同的时间占用相同的频带宽度。</li><li><strong>统计时分复用STDM</strong> ：改进的时分复用，按需动态分配时隙，而不是固定分配时隙。</li><li><strong>波分复用WDM</strong>：光的频分复用，利用在光纤技术通信中。</li><li><strong>码分复用CDM</strong>: 每个用户在相同的时间使用相同的频带进行通信，但各用户使用经过挑选的不同码型，从而使得个用户之间可以进行独立的通信。</li></ol></li></ol><h2 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h2><h3 id="重要内容-2"><a href="#重要内容-2" class="headerlink" title="重要内容"></a>重要内容</h3><ul><li>数据链路层<strong>点对点信道和广播信道</strong>的特点，以及这两种信道使用的协议的特点。</li><li>数据链路层的三个基本问题：<strong>封装成帧、差错检测、透明传输</strong>。</li><li>以太网<strong>MAC层</strong>的硬件地址。</li><li><strong>适配器、转发器、集线器、网桥、以太网交换机</strong>的作用和使用场合。</li></ul><h3 id="核心知识点-2"><a href="#核心知识点-2" class="headerlink" title="核心知识点"></a>核心知识点</h3><ol><li><p>数据链路层主要使用两种信道：</p><ol><li><strong>点对点信道</strong>：这种信道使用<strong>一对一的点对点</strong>通信方式。主要使用<strong>PPP协议</strong>。</li><li><strong>广播信道</strong>：这种信道使用<strong>一对多的广播</strong>通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的<strong>共享信道协议</strong>来协调这些主机的数据发送。主要使用<strong>MAC协议。</strong></li></ol></li><li><p>数据链路层在分组交换中的地位：</p><p>​    <img src="%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91.png" alt="分组转发"></p><p>可以看到，路由器是互联网核心部分的最重要设备，但是<strong>不包含运输层和应用层</strong>，只负责以<strong>IP数据报（分组）</strong>的形式转发收到的分组。</p></li><li><p>数据链路层的主要功能：<strong>局域网内主机之间的数据帧传输。</strong></p></li><li><p>数据链路层的主要概念：</p><ol><li><strong>链路</strong>：又称<strong>物理链路</strong>，是一条无源的点到点的<strong>物理线路段</strong>，中间没有任何其他的交换结点。一条链路只是一条通路的一个组成部分。</li><li><strong>数据链路</strong>：又称<strong>数据链路</strong>，是物理链路加上必要的<strong>通信协议</strong>控制数据的传输。通常使用<strong>网络适配器</strong>来实现这些通信协议。</li><li><strong>协议数据单元</strong>：数据链路层的协议数据单元是<strong>数据帧</strong>，简称<strong>帧</strong>。</li></ol></li><li><p><strong>主要任务</strong>：</p><ol><li>将网络层的IP数据报加上数据链路层的控制信息，<strong>封装成帧</strong>，通过物理层发送到数据链路上。（对下层的服务）</li><li>从物理层传输的帧中<strong>提取IP数据报内容</strong>，交给网络层。（对上层的服务）</li></ol></li><li><p>数据链路层的3个基本问题：</p><ol><li><p><strong>封装成帧</strong>：将<strong>IP数据报</strong>作为帧的数据部分，再加上<strong>首部和尾部</strong>，即可封装成帧。</p><ol><li><p>作用：</p><ol><li><strong>帧定界</strong>：采用<strong>SOH、EOT帧定界符</strong>，放在帧的前后，标志帧的边界。可能存在<strong>歧义</strong>的问题，因为数据中也可能出现SOH、EOT，所以需要<strong>转义（字符填充）</strong>。</li><li><strong>MTU</strong>：<strong>最大传送单元</strong>，表示帧的<strong>数据部分（IP数据报）</strong>的最大长度，为<strong>1500字节</strong>。（PPP协议：加上8个字节的首部和尾部，帧的最大长度为<strong>1508字节</strong>。MAC协议：加上18个字节的首部和尾部，帧的最大长度为<strong>1518字节</strong>。）</li></ol><p><img src="%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7.png" alt="封装成帧"></p></li></ol></li><li><p><strong>透明传输</strong>：在数据链路层传输时，所传输的数据在数据链路层没有任何的阻挡，接收方所收到的数据和发送方发送的数据没有任何差别，也就是说，<strong>数据链路层对其传输的数据帧是完全透明的。</strong></p><ol><li><p>存在的问题：如果数据中的<strong>某个字节的二进制代码恰好和 SOH 或 EOT 一样</strong>，数据链路层就会<strong>错误地“找到帧的边界”。</strong></p><p><img src="%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93.png" alt="透明传输"></p></li><li><p>解决方案——<strong>字节填充（也称字符填充）</strong>：传输的过程中，为防止数据部分出现帧定界符，使得接收方误以为收到的数据提前结束，所以采用<strong>转义字符</strong>的方法，将在数据部分出现的控制字符前<strong>插入转义字符“ESC”</strong>，在接收方的数据链路层将插入的转义字符<strong>删除</strong>。（<strong>如果原字节流中已经存在转义字符，则需要再加上一个转义字符。</strong>）（字节填充用于并行传输，即<strong>异步传输</strong>，一个字节一个字节传输，如果使用的是<strong>同步传输</strong>，即连续的比特流传输，需要使用<strong>零比特填充</strong>）</p><p><img src="%E5%AD%97%E8%8A%82%E5%A1%AB%E5%85%85.png" alt="字节填充"></p></li></ol></li><li><p><strong>差错检测</strong>：数据链路层的差错检测只能保证<strong>帧内部</strong>无差错，即<strong>无比特差错</strong>。帧之间的差错，如<strong>帧丢失、帧冗余、帧失序</strong>，通常交给<strong>TCP协议（运输层）</strong>来保证（<strong>可靠的，面向连接</strong>）。</p><ol><li><p><strong>比特差错</strong>：物理层传输时，比特可能出现错误，比如比特丢失，比特冗余，比特失序。</p></li><li><p><strong>误码率BER</strong>：在单位时间内，传输错误的比特占所有比特的比率就是误码率。</p></li><li><p><strong>循环冗余检验 CRC</strong> ：</p><ol><li><p>在发送端，先把比特数据<strong>划分为组</strong>。假定每组数据M长度为 k 个比特。 </p></li><li><p>根据<strong>生成多项式</strong>（如$x^5+x^3+1$）获取<strong>除数P</strong>（101001）。</p></li><li><p><strong>在数据M的尾部加上n个0作为被除数</strong>（<strong>n的位数比p小1</strong>）。</p></li><li><p>将被除数除以除数P（<strong>模二运算</strong>），得到余数R，<strong>R即为帧检测序列FCS</strong>，将其<strong>添加到M的尾部</strong>发送出去。</p></li><li><p><strong>检验方法</strong>：在接收端将收到的数据<strong>除以除数P</strong>，<strong>看余数是否等于0</strong>，等于0则认为帧没有差错，进行接收；否则出错，进行丢弃。（<strong>只能保证无差错接收，如果要保证无差错传输，还需要加上确认和重传机制</strong>）</p></li><li><p><strong>CRC与FCS的区别</strong>：</p><ol><li>CRC 是一种常用的<strong>检错方法</strong>，而 FCS 是<strong>添加在数据后面的冗余码</strong>。</li><li>FCS 可以用 CRC 这种方法得出，但 <strong>CRC 并非用来获得 FCS 的唯一方法</strong>。  </li></ol><p><img src="CRC.png" alt="CRC"></p></li></ol></li></ol></li><li><p><strong>差错纠正</strong>：还要知道差错的位置并进行修改，在数据链路层确保可靠传输，一般用于无线传输链路。有线传输链路一般只进行差错检测，只是简单地丢弃出错的帧，差错纠正一般由<strong>上层协议（如运输层的TCP协议</strong>）完成（网络层一般不提供可靠服务）。</p></li></ol></li><li><p><strong>PPP点对点协议</strong>：最常用的<strong>点对点（一对一）链路</strong>的数据链路层协议。是<strong>端计算机和ISP</strong>进行通信时所使用的数据链路层协议（<strong>拨号上网</strong>）。</p><ol><li><p>特点：</p><ol><li><strong>简单</strong> —— 这是首要的要求。</li><li><strong>封装成帧</strong> —— 必须规定特殊的字符作为帧定界符。</li><li><strong>透明性</strong> —— 必须保证数据传输的透明性。</li><li><strong>多种网络层协议</strong> —— 能够在同一条物理链路上同时支持多种网络层协议。</li><li><strong>多种类型链路</strong> —— 能够在多种类型的链路上运行。</li><li><strong>差错检测</strong> —— 能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</li><li><strong>检测连接状态</strong> —— 能够及时自动检测出链路是否处于正常工作状态。</li><li><strong>最大传送单元</strong> —— 必须对每一种类型的点对点链路设置最大传送单元  MTU 的标准默认值，促进各种实现之间的互操作性。</li><li><strong>网络层地址协商</strong> —— 必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址。</li><li><strong>数据压缩协商</strong> —— 必须提供一种方法来协商使用数据压缩算法。</li></ol></li><li><p>组成：</p><ol><li>一个将IP数据报封装到串行链路的方法（<strong>封装成帧</strong>）。</li><li>一个用来建立、配置和测试数据链路连接的<strong>链路控制协议LCP。</strong></li><li>一套<strong>网络控制协议NCP。</strong></li></ol></li><li><p>PPP帧的格式：</p><p><img src="PPP%E6%A0%BC%E5%BC%8F.png" alt="PPP格式"></p><ol><li>控制字段总长度：<strong>8个字节。</strong></li><li>PPP 是<strong>面向字节</strong>的，所有的 PPP 帧的长度都是<strong>整数字节。</strong></li><li>字段含义：<ol><li>F（1字节）：<strong>标志字段</strong>，代表<strong>定界符</strong>。</li><li>A、C（1字节）<strong>：A为地址字段，C为控制字段，但暂时没有含义。</strong></li><li>协议字段（2字节）：表示当前信息部分是<strong>IP数据报还是LCP的控制数据还是NCP的控制数据</strong>。</li><li>FCS（2字节）：<strong>帧检测序列</strong>，用于差错检测中的循环冗余检测CRC方法。</li></ol></li></ol></li><li><p>透明传输问题：</p><ol><li><p><strong>字节填充</strong>：</p><ol><li>使用场景：PPP使用<strong>异步传输</strong>，即<strong>一个字节一个字节</strong>传输。</li><li>实现方式：<strong>软件。</strong></li><li>做法：当信息字段中出现和标志字段相同的比特组合时，则进行字节填充的办法使得数据部分能够完整的传送到接收端。<strong>（添加转义字符）</strong></li></ol></li><li><p>零比特填充：</p><ol><li>使用场景：PPP使用<strong>同步传输</strong>，即<strong>连续的比特流传输</strong>。</li><li>实现方式：<strong>硬件</strong>。</li><li>做法：当信息字段出现了<strong>5个连续的1</strong>，那么就<strong>插入一个0</strong>，在接收时再将5个连续的1后的0删除。</li></ol><p><img src="%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85.png" alt="零比特填充"></p></li><li><p>PPP协议的<strong>工作状态：</strong>用户拨号接入ISP→端机向ISP发送一系列链路控制协议LCP分组→进行网络层配置→网络层协议NCP向端机分配IP地址。（<strong>可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</strong>)</p><p><img src="PPP%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81.png" alt="PPP工作状态"></p></li></ol></li></ol></li><li><p>使用<strong>广播信道</strong>的数据链路层（<strong>一对多</strong>）：</p><ol><li><p>使用场景：<strong>局域网</strong>（点对点是端主机同ISP进行通信，拨号上网时使用的）,也称<strong>以太网（Ethernet）</strong></p></li><li><p>局域网的优点：</p><ol><li><strong>广播功能</strong>。从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 </li><li>便于系统的<strong>扩展和演变</strong>。</li><li>提高了系统的<strong>可用性、可靠性和生存性</strong>。</li></ol></li><li><p>局域网的拓扑结构：</p><ol><li><p><strong>星形网</strong>：目前最常用。</p><p><img src="%E6%98%9F%E5%BD%A2%E7%BD%91.png" alt="星形网"></p></li><li><p><strong>环形网</strong></p><p><img src="%E7%8E%AF%E5%BD%A2%E7%BD%91.png" alt="环形网"></p></li><li><p><strong>总线网</strong>：传统局域网常用。</p><p><img src="%E6%80%BB%E7%BA%BF%E7%BD%91.png" alt="总线网"></p></li><li><p><strong>树形网</strong></p></li><li><p><strong>网状结构</strong></p></li></ol></li><li><p>以太网的两个标准：</p><ol><li><strong>DIX Ethernet V2</strong> 是世界上<strong>第一个</strong>局域网产品（以太网）的规约。</li><li><strong>IEEE 802.3</strong> 是第一个 IEEE 的以太网标准。</li></ol></li><li><p>局域网的数据链路层的子层：为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成两个子层。</p><ol><li><strong>逻辑链路控制层 LLC （Logical Link Control）</strong>子层</li><li><strong>媒体接入控制 MAC（Medium Access Control）</strong>子层</li><li>与<strong>接入到传输媒体有关</strong>的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。</li></ol></li><li><p><strong>共享信道</strong>：由于局域网使用的是广播信道，所以需要媒体共享技术，防止因为共享信道产生的错误。</p><ol><li><strong>静态划分信道</strong>：用户一旦分到信道，就不会和其他用户发生冲突，如<strong>频分复用、时分复用、码分复用、波分复用等</strong>。缺点是：<strong>代价高、效率低、不适用于局域网。</strong>特点：<strong>固定分配</strong>。</li><li><strong>动态媒体接入控制</strong>：信道并非在通信时固定分配给用户。特点：<strong>动态分配</strong>。<ol><li><strong>随机接入</strong>：所有用户可以在信道中<strong>随机</strong>地发送信息，占用此信道，而不用遵守静态划分的某种规则。但如果多个用户在同一时间发送信息，那么共享媒体就会产生<strong>碰撞</strong>，所有的用户发送都失败。（需要控制协议：CSMA/CD协议）</li><li><strong>受控接入</strong>。多点线路探询 (polling)，或轮询。  </li></ol></li></ol></li><li><p>CSMA/CD协议：即<strong>载波监听多点接入碰撞检测</strong>协议。在广播信道中实现<strong>动态媒体共享技术的随机接入</strong>必须使用的控制协议，确保<strong>不会有多个站点发送的信息同时出现在总线上</strong>。</p><ol><li>要点：<ol><li><strong>载波监听（Carrier Sense）</strong>：利用电子技术检测总线上有没有其他计算机也在发送。不管在<strong>发送前还是发送中</strong>，每个站都必须不停地检测信道，以<strong>防止出现碰撞（发送前），检测碰撞发生并及时丢弃信息（发送中，由于发送的不确定性，发送前检测不能百分百防止碰撞，因为存在传播时延）</strong>。</li><li><strong>多点接入（Multiple Access）</strong>：说明这是<strong>总线型网络（传统以太网）</strong>，计算机以多点接入的方式连接。实际上，星形网也可以采用类似的方式进行随机接入，本质类似。</li><li><strong>碰撞检测（Collision Detection）</strong>：<strong>边发送边监听</strong>。    若在信道上有<strong>至少两个</strong>站点同时发送信息便发生碰撞，这时很容易<strong>信号失真</strong>，要使两边发送的信息都<strong>作废</strong>。</li></ol></li><li>使用CSMA/CD协议的局域网的站不能同时进行发送和接收，所以只能进行<strong>半双工通信（双向交替通信）。</strong></li><li><strong>发送的不确定性</strong>：由于电磁波的<strong>传播时延</strong>，每个站发送数据后的一小段时间内，可能会有其他站无法及时检测到信道上已有数据在发送，从而发送数据，产生碰撞。<ol><li>解决方案：<strong>争用期，又叫碰撞窗口。</strong>即<strong>以太网的端到端往返时间</strong>。如果一个站发送数据后，在碰撞窗口内没有检测到碰撞，才能确定这次发送不会产生碰撞。通常规定为<strong>512比特时间，即64字节时间。</strong></li><li>重传机制：<strong>截断二进制指数退避算法</strong>。使发生碰撞的站再次发生冲突的概率减小。<ol><li>发生碰撞的站在停止发送数据后，要<strong>推迟（退避）一个随机时间</strong>才能再发送数据。</li><li><strong>K=MIN[10，重传次数]，</strong>每次重传时每个站从<strong>[0,1,…,2的K次方-1]</strong>中随机选一个数字<strong>r</strong>，重传推后的时间为<strong>r倍争用期</strong>。</li><li>重传<strong>达到16次</strong>时，则站丢弃该帧，并向高层报告。</li></ol></li><li><strong>帧的最小长度</strong>：以太网规定有效帧的最小长度为<strong>64字节（512bit）</strong>，即<strong>争用期内发送的字节数。</strong>如果接收到的某个帧长度小于64字节，说明<strong>它在争用期内出现问题，需要丢弃</strong>，大于等于64字节说明该帧<strong>通过了争用期，不会再出现问题</strong>。</li><li><strong>帧间最小间隔</strong>：<strong>96bit时间</strong>，使刚刚收到数据帧的站的<strong>缓存</strong>来得及清理，做好接受下一帧的准备。</li><li><strong>强化碰撞</strong>：在发生碰撞之后除了立即停止发送数据之外，还要发送<strong>32bit或48bit 的人为干扰信号</strong>，目的是为了能够<strong>让所有站点都知道发生了碰撞</strong>。</li></ol></li><li>要点：<br><img src="CSMA.png" alt="CSMA/CD"></li></ol></li><li><p>网络适配器（<strong>网卡</strong>）的作用：</p><ol><li>适配器用来连接<strong>计算机与局域网</strong>；同时要能够实现<strong>以太网协议</strong>；</li><li>适配器和局域网之间的通信是通过双绞线或者电缆以串行传输的方式进行的；而适配器与计算机之间的通信是并行方式进行的，所以适配器要能够进行两种数据传送方式之间的<strong>串并行转化</strong>；</li><li>网络上的数据率与计算机总线上的<strong>数据率</strong>不同，因此适配器要安装内存储器以进行两种速率下的缓存功能</li><li>适配器要能够实现<strong>以太网协议</strong></li><li><strong>计算机的硬件地址（MAC地址）就在适配器的ROM中；（计算机的软件地址IP地址，在计算机的存储器中）</strong></li></ol><p><img src="%E7%BD%91%E5%8D%A1.png" alt="网卡"></p></li><li><p>使用<strong>集线器</strong>的星形拓扑：</p><ol><li><strong>双绞线以太网</strong>的出现，是局域网发展史上的一个重要的里程碑，从此以太网的拓扑结构从传统的总线型变为更为方便的<strong>星形网络。</strong></li><li>优势：<ol><li><strong>价格便宜；</strong></li><li><strong>使用方便。</strong></li></ol></li><li>特点：<ol><li>集线器使用电子器件模拟实际电缆线的工作，所以使用集线器的以太网在逻辑上还是一个总线网，各站逻辑上共享总线。而且是用的还是<strong>CSMA/CD协议</strong>，同一时刻至多允许一个站发送数据（防止碰撞）；</li><li>集线器的接口通过两对双绞线与计算机上的适配器相连；一个集线器像是一个多接口的转发器；</li><li>集线器工作在物理层，每个接口只简单地转发比特，不进行碰撞检测；</li><li>集线器采用专门的芯片，进行自适应串音回波抵消。</li></ol></li></ol></li></ol></li><li><p>局域网数据链路层的子层——<strong>媒体接入控制层MAC层</strong>：</p><ol><li><strong>硬件地址（物理地址或MAC地址）</strong>：IEEE802为局域网规定了一种<strong>48位</strong>的全球地址，是指局域网上每台计算机中固化在<strong>适配器（网卡）</strong>的ROM中的地址。（软件地址是IP地址，计算机的硬件地址只要适配器不更换，就不会改变，而软件地址可以随时变更）。总共<strong>48位（6字节）</strong>前三字节由管理全球硬件地址的机构——注册管理机构RA向适配器制造公司出售称为组织唯一标识符OUI，后三字节由制造公司自行分配，称为扩展标识符，（其中前三字节中有两位是用来标识是否位单播地址和是否属于全球管理的）。</li><li><strong>MAC帧</strong>的格式：<ol><li>前两个字段为<strong>6字节的目的地址和6字节的源地址</strong>。第三个字段为<strong>2字节的类型字段</strong>，表示上一层的协议。第四个字段是<strong>数据字段，长度为46到1500字节</strong>，一般是网络层交付的<strong>IP数据报</strong>。第五个字段是长度为<strong>4个字节的帧检测序列FCS</strong>。</li><li>MAC帧的长度范围是：<strong>64字节到1518字节。</strong>首尾部分的控制信息占<strong>18字节。</strong>其中，64字节的最小长度是CSMA/CD协议的规定（<strong>确保通过争用期</strong>）</li><li>当MAC帧向下交付给物理层时，需要加上<strong>7个字节的前同步码（实现发送端和接收端之间的位同步）和1个字节的帧开始定界符（无结束定界符，直接观察曼彻斯特编码即可）</strong>。</li><li>MAC帧中并没有<strong>数据长度</strong>的标识，但由于传输时使用的是曼彻斯特编码的方式，所以通过对曼彻斯特编码的信号特点的观察便可确定是否传送完毕；（曼彻斯特编码信号的码元正中间有一次电压转换）</li></ol></li><li>对于检查出的无效 MAC 帧就<strong>简单地丢弃</strong>。以太网<strong>不负责重传</strong>丢弃的帧。 </li></ol><p><img src="MAC%E5%B8%A7.png" alt="MAC帧"></p></li><li><p>以太网的扩展:</p><ol><li>在<strong>物理层</strong>扩展以太网</li><li>在<strong>数据链路层</strong>扩展以太网<ol><li>通过<strong>网桥</strong>扩展以太网</li><li>通过<strong>以太网交换机</strong>扩展</li><li><strong>虚拟局域网</strong></li></ol></li></ol></li></ol><p><strong>(集线器是物理层设备，网桥是数据链路层设备</strong>)</p><h2 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h2><h3 id="重要内容-3"><a href="#重要内容-3" class="headerlink" title="重要内容"></a>重要内容</h3><ul><li><strong>虚拟互联网</strong>的概念</li><li><strong>IP地址与物理地址</strong>的关系</li><li>传统的分类的IP地址（包括子网掩码）和无分类域间路由选择</li><li><strong>路由选择协议</strong>的工作方式</li></ul><h3 id="核心知识点-3"><a href="#核心知识点-3" class="headerlink" title="核心知识点"></a>核心知识点</h3><ol><li><p>网络层的功能：</p><ol><li>网络层<strong>面向无连接，不负责提供可靠的服务</strong>。将确保数据可靠的任务交给了上层的<strong>运输层（TCP协议</strong>）。</li><li>数据链路层是局域网内，而网络层将范围扩大至互联网，即世界上最大的互连网。<strong>负责为互联网上任意两台主机提供分组交换服务。</strong></li></ol></li><li><p>网络层向上只提供<strong>简单灵活的、无连接的、尽最大努力交付的</strong>数据报服务。不提供<strong>服务质量的承诺</strong>，使路由器比较简单。</p><ol><li>原因：计算机网络的端系统是<strong>具有智能的计算机</strong>，具有很强的<strong>差错处理能力</strong>。而传统电信网络的端系统是电话机，没有差错处理能力，所以要将确保可靠的任务交给网络层。</li><li>优点：<strong>网络造价大大降低，运行方式灵活，能够适应多种应用。</strong></li><li>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责可靠交付（包括差错处理、流量控制等） 。</li></ol><p><img src="%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%9C%8D%E5%8A%A1%E5%AF%B9%E6%AF%94.png" alt="服务对比"></p></li><li><p>主要协议：</p><ol><li><strong>网际协议IP（Internet Protocol）</strong>：Robert Kahn和Vint Cerf共同研发。</li><li><strong>地址解析协议ARP（Address Resolvotion Protocol）</strong>。</li><li><strong>网际控制报文协议ICMP（Internet Control Message Protocol）</strong>。</li><li><strong>网际组管理协议IGMP（Internet Group Management Protocol）</strong>。</li></ol></li><li><p><strong>虚拟互联网络</strong>的概念：</p><ol><li>即逻辑互联网络<strong>,忽略物理层的客观异构性,在网络层看起来好像是一个统一的网络</strong>,即互联网可以有多种异构的网络组成。（就像操作系统的逻辑设备一样，屏蔽差异）如果在这种覆盖全球的 IP 网的上层使用 TCP 协议，那么就是现在的<strong>互联网 (Internet)。</strong></li><li>网络互联的一些中间设备：<ol><li><strong>物理层：转发器、集线器</strong></li><li><strong>数据链路层：网桥（扩展局域网）</strong></li><li><strong>网络层：路由器（连接局域网）</strong></li><li><strong>网络层以上：网关、桥路器</strong></li></ol></li></ol></li><li><p>IP地址（<strong>RFC 791</strong>）:</p><ol><li><p>IP地址是给互联网上<strong>每一个主机（或路由器）的每一个接口</strong>分配一个在全世界范围内是<strong>唯一</strong>的<strong>32位（IPV4）</strong>的标识符。（<strong>MAC地址对每个计算机是固定的，IP地址不固定</strong>）。IP 地址现在由<strong>互联网名字和数字分配机构ICANN</strong>进行分配。<strong>每台主机或者路由器可以有多个IP地址。</strong></p></li><li><p>历史阶段：</p><ol><li><strong>分类的IP地址；</strong></li><li><strong>子网的划分；</strong></li><li><strong>构成超网。</strong></li></ol></li><li><p>组成：<strong>网络号net-id+主机号host-id。</strong></p><ol><li><strong>A类地址</strong>：<strong>8位网络号</strong>，第一位是标识位<strong>0</strong>；24位主机号。</li><li><strong>B类地址</strong>：<strong>16位网络号</strong>，前两位是标识位<strong>10</strong>；16位主机号。</li><li><strong>C类地址</strong>：<strong>24位网络号</strong>，前三位是标识位<strong>110</strong>；8位主机号。</li><li><strong>D类地址</strong>：前四位是标识位<strong>1110</strong>，用于<strong>一对多通信</strong>。</li><li><strong>E类地址</strong>：前四位是标识位<strong>1111</strong>，留作<strong>以后使用。</strong></li></ol><p><img src="%E5%90%84%E7%B1%BBIP%E5%9C%B0%E5%9D%80.png" alt="各类IP地址"></p></li><li><p>IP地址的表示方法：<strong>点分十进制。</strong>每8个二进制转换为一个三位十进制数（0-255），插入一个点。IP地址在计算机中以二进制形式存储，但为了<strong>方便人类记忆</strong>，采用点分十进制的形式表示。</p><p><img src="%E7%82%B9%E5%88%86%E5%8D%81%E8%BF%9B%E5%88%B6.png" alt="点分十进制"></p></li><li><p>IP地址的指派范围：</p><ol><li>A类地址网络号占用<strong>一个字节</strong>，但是由于有一位是类别位，<strong>只有7位可供使用</strong>，但是由于规定，<strong>网络字段全0是个保留字段表示本网络，而127（01111111）是另外一个保留字段，作为本地软件的环回测试。</strong>我们常见的127.0.0.1表示本机，原因也是出自这里。所以A类地址可以指派的网络号个数为<strong>（2^7-2）</strong>.</li><li>B类网络地址网络号有<strong>两个字节</strong>，前两位为10已经固定，<strong>只剩下14位可用</strong>，由于这14位无论怎么取值都不会使得网络号为全0或者全1，但实际上规定，<strong>规定B类最小网络地址为128.1.0.0</strong>。因此B类地址可指派的网络号个数为<strong>（2^14-1）.</strong></li><li>C类地址有<strong>3个字节</strong>的网络字段号，前三位固定110，<strong>只有剩下21位可用</strong>，同样C类地址可指派的最小网络地址也是<strong>192.0.1.0</strong>。因此C类地址可指派的网络号个数为<strong>（2^21-1）.</strong></li><li>A、B、C三类地址的主机号，<strong>全0或全1均有特殊作用</strong>，分别表示本主机和当前网络内全部主机，所以可用的主机号为<strong>（2^（n-1））</strong>。</li></ol><p><img src="IP%E5%9C%B0%E5%9D%80%E8%8C%83%E5%9B%B4.png" alt="IP地址范围"></p></li><li><p>一般不使用的特殊IP地址：</p><ol><li><strong>网络号全0：当前网络。</strong></li><li><strong>网络号全1：在本网络上进行广播。</strong></li><li><strong>网络号127：用于本地环回测试（自己连接自己）。</strong></li><li><strong>主机号全0：当前主机。</strong></li><li><strong>主机号全1：所有主机。</strong></li></ol><p><img src="%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%9A%84IP%E5%9C%B0%E5%9D%80.png" alt="不使用的IP地址"></p></li><li><p>IP地址的重要特点：</p><ol><li>IP地址是一种<strong>分等级</strong>的地址结构。好处是：<ol><li>IP 地址管理机构在分配 IP 地址时<strong>只分配网络号</strong>，而剩下的主机号则由得到该网络号的单位自行分配。这样就<strong>方便了 IP 地址的管理</strong>。</li><li>路由器仅<strong>根据目的主机所连接的网络号</strong>来转发分组（而不考虑目的主机号），这样就可以<strong>使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间</strong>。 （转发到目的网络后，由目的网络的路由器转发至具体的主机）</li></ol></li><li>实际上 IP 地址是<strong>标志一个主机（或路由器）和一条链路的接口。</strong><ol><li><strong>多归属主机</strong>：当一个主机同时连接到两个网络上时，该主机就必须<strong>同时具有两个相应的 IP 地址</strong>，其网络号 net-id 必须是不同的。</li><li><strong>路由器</strong>：由于一个路由器<strong>至少应当连接到两个网络</strong>（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此一个路由器<strong>至少应当有两个不同的 IP 地址</strong>。</li></ol></li><li>用<strong>转发器（物理层）或网桥（数据链路层）</strong>连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id。（<strong>网络层的路由器才是连接不同网络的中继系统</strong>）前者仅仅是<strong>扩展局域网</strong>，后者是<strong>连通局域网</strong>。</li><li>所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是<strong>平等的。</strong></li></ol></li><li><p>IP地址与硬件地址的区别：</p><ol><li><strong>硬件地址（或物理地址、MAC地址）</strong>是<strong>数据链路层和物理层</strong>使用的地址。而<strong>IP 地址</strong>是<strong>网络层和以上各层</strong>使用的地址，是一种<strong>逻辑地址</strong>（称 IP 地址是逻辑地址是因为 IP 地址是用软件实现的）</li><li><strong>IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC 帧的首部</strong>。当已知主机或路由器的IP地址后，需要通过<strong>ARP地址</strong>解析协议得出其MAC地址。</li><li>网络层只能看见IP地址，数据链路层只能看见硬件地址。</li><li>分组每次经过路由器转发时都要将MAC帧的首部和尾部丢弃重新封装——<strong>变换MAC帧中的目的MAC地址和源MAC地址。而IP数据报中的源IP地址和目的IP地址始终不变。</strong></li></ol><p><img src="IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%9C%B0%E5%9D%80.png" alt="IP地址与硬件地址"></p></li></ol></li><li><p><strong>地址解析协议ARP</strong>：</p><ol><li><p>ARP 作用：<strong>从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。</strong></p></li><li><p><strong>ARP高速缓存</strong>：每一个主机都设有一个 <strong>ARP 高速缓存 (ARP cache)</strong>，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表，条目为<strong>&lt; IP address；MAC address；TTL &gt;</strong>，其中<strong>TTL为地址映射有效时间</strong> 。<strong>ARP高速缓存动态更新</strong>。</p></li><li><p>ARP流程：</p><ol><li>当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先<strong>在其 ARP 高速缓存中查看有无主机 B 的 IP 地址</strong>。</li><li>如有，就可查出其对应的硬件地址，再将此硬件地址<strong>写入 MAC 帧，</strong>然后通过局域网将该 MAC 帧发往此硬件地址。</li><li>如没有， ARP 进程在本局域网上<strong>广播</strong>发送一个 <strong>ARP 请求分组</strong>。收到 <strong>ARP 响应分组</strong>后，将得到的 IP 地址到硬件地址的映射写入 <strong>ARP 高速缓存</strong>。并写入MAC帧进行发送。</li></ol></li><li><p>要点：</p><ol><li><strong>ARP请求分组</strong>：包含发送方硬件地址 / 发送方 IP 地址 / <strong>目标方硬件地址(未知时填 0，由接收方填写)</strong> / 目标方 IP 地址。</li><li><strong>ARP 响应分组</strong>：包含发送方硬件地址 / 发送方 IP地址 / 目标方硬件地址 / 目标方 IP 地址。</li><li>ARP 分组封装在物理网络的<strong>帧</strong>中传输。</li><li>本地广播 ARP 请求（<strong>路由器不转发ARP请求</strong>）。<strong>ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题</strong>。一个主机想解析出另一个局域网上主机的MAC地址，需要先通过ARP找到当前局域网的一个路由器的MAC地址并发送，再通过它的转发表层层进行ARP操作并转发，直到找到目的主机所在的网络的一个路由器，由它广播ARP请求分组，获取目的主机的硬件地址。</li><li>从硬件地址到IP地址的解析每次转发分组时都要重复进行，但这种开销是不可避免的，是为<strong>方便的在各种异构网络之间进行转发工作而屏蔽网络硬件之间的异构性</strong>，从而体现出虚拟网络的含义。</li><li>为什么不统一使用硬件地址进行通信？<strong>由于全世界存在着各式各样的网络，它们使用不同的硬件地址。</strong>要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此几乎是不可能的事。IP 编址把这个复杂问题解决了。因此，<strong>在虚拟的 IP 网络上用 IP 地址进行通信给广大的计算机用户带来了很大的方便。</strong>（<strong>IP地址是虚拟网络的重要手段，屏蔽了不同网络之间的硬件地址差异）</strong></li></ol><p><img src="ARP.png" alt="ARP"></p></li></ol></li><li><p><strong>IP数据报（又称分组</strong>）：</p><ol><li><p>由<strong>首部和数据部分</strong>组成。首部固定长度为<strong>20字节</strong>，此外还可加入长度可变的<strong>可选字段</strong>，总长度必须是<strong>4字节的倍数</strong>，最大为<strong>60字节</strong>。数据报总长度最大不能超过数据链路层协议规定的<strong>最大传送单元MTU，即1500字节</strong>，否则需要进行<strong>分片处理</strong>。</p><p><img src="IP%E6%95%B0%E6%8D%AE%E6%8A%A5.png" alt="IP数据报"></p></li><li><p>首部固定字段：</p><ol><li><p><strong>版本</strong>——<strong>占 4 位</strong>，指 <strong>IP 协议的版本</strong>。目前的 IP 协议版本号为 <strong>4 (即 IPv4)</strong>。</p></li><li><p><strong>首部长度</strong>——<strong>占 4 位</strong>，可表示的最大数值是 <strong>15 个单位(一个单位为 4 字节)</strong>，因此 IP 的首部长度的最大值是 <strong>60 字节</strong>。（<strong>最小值为固定长度20字节</strong>）</p></li><li><p><strong>区分服务</strong>——<strong>占 8 位</strong>，用来获得更好的服务。只有在使用区分服务（DiffServ）时，这个字段才起作用。在一般的情况下都<strong>不使用</strong>这个字段 。</p></li><li><p><strong>总长度——占 16 位</strong>，<strong>指首部和数据之和的长度</strong>，单位为字节，因此数据报的理论最大长度为 <strong>65535 字节</strong>。但实际上，总长度必须不超过最大传送单元 MTU，否则需要<strong>分片</strong>。例如，<strong>以太网的MTU规定为1500字节</strong>。</p></li><li><p><strong>标识(identification)</strong> ——<strong>占 16 位</strong>，它是一个计数器，用来产生 <strong>IP 数据报的标识</strong>。作用是：分片时，为各数据报片设定一个标识，<strong>相同标识的数据报片最终可被重新拼接起来</strong>。</p></li><li><p><strong>标志(flag)</strong> ——<strong>占 3 位</strong>，目前只有低两位有意义。同样是为了分片。</p><ol><li>标志字段的最低位是 <strong>MF (More Fragment)</strong>。<strong>MF=1 表示后面“还有分片”。MF=0 表示最后一个分片。</strong></li><li>标志字段中间的一位是 <strong>DF (Don’t Fragment)</strong> 。只有当 <strong>DF=0 时才允许分片。</strong> </li></ol></li><li><p><strong>片偏移——占13 位</strong>，指出：<strong>较长的分组在分片后某片在原分组中的相对位置</strong>。片偏移以 <strong>8 个字节</strong>为偏移单位，除最后一个数据报片外，所有数据报片的长度都是<strong>8字节的倍数</strong>。保证最后数据报片可按照正确的顺序拼接回来。</p><ol><li>各片可以继承原IP数据报的首部，但必须更改以下字段：<ol><li>修改各数据报片的<strong>总长度字段。</strong></li><li>修改各数据报片的<strong>标识字段。</strong></li><li>修改各数据报片的<strong>片偏移字段。</strong></li><li>修改各数据报片的<strong>标志字段。</strong></li></ol></li></ol><p><img src="%E5%88%86%E7%89%87.png" alt="分片"></p><p><img src="%E5%88%86%E7%89%87%E7%BB%93%E6%9E%9C.png" alt="分片结果"></p></li><li><p><strong>协议——占8 位</strong>，指出此数据报携带的数据<strong>使用何种协议（TCP/UDP）</strong>，以便目的主机的 IP 层将数据部分上交给那个处理过程。</p></li><li><p><strong>生存时间——占8 位</strong>，记为 <strong>TTL (Time To Live)</strong>，指示数据报在网络中<strong>可通过的路由器数</strong>的最大值。</p></li><li><p><strong>首部检验和——占16 位</strong>，为了减少工作量，只检验数据报的首部，不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法</p><ol><li>方法：IP 数据报首部检验和的计算采用 <strong>16 位二进制反码求和算法</strong></li><li>过程：在发送方将IP数据报的首部<strong>划分为许多16位的字序列</strong>；并把检验和字段置零，用<strong>反码运算术将字相加</strong>之后，将得到的和的<strong>反码</strong>写入检验和位置；在接受方接收到数据报之后，使用相同的方法将首部所有的字（包括检验和）相加一次，若没有出错则得到的结果<strong>必然为零</strong>，最后的结果便可作为是否出错的判断标志；</li><li><strong>反码运算</strong>：在普通的二进制加法的基础上，最高位如果产生进位，需要将最后的结果加1。</li></ol></li><li><p><strong>源IP地址和目的IP地址都各占 4 字节，32位。</strong></p></li></ol></li><li><p><strong>首部可变字段</strong>：IP 首部的可变部分就是一个选项字段，用来支持<strong>排错、测量以及安全</strong>等措施，内容很丰富。0到40字节。</p></li></ol></li><li><p>网络层转发分组的流程：</p><ol><li><p>每一台主机都有一个<strong>路由表</strong>。按主机所在的网络地址来制作路由表.</p></li><li><p>在路由表中，对每一条路由，最主要的是<strong>（目的网络地址，下一跳地址）</strong>。具体如何选择路径需要依据<strong>路由选择协议</strong>，如内部网关协议<strong>RIP或OSPF。</strong></p></li><li><p>根据目的网络地址就能确定下一跳路由器，这样做的结果是：</p><ol><li>IP 数据报最终一定可以找到<strong>目的主机所在目的网络上的路由器</strong>（可能要通过多次的间接交付）。</li><li>只有到达最后一个路由器时，才试图向目的主机进行<strong>直接交付</strong>。 </li></ol><p><img src="%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91.png" alt="路由转发"></p></li><li><p><strong>特定主机路由</strong>：虽然互联网所有的分组转发都是基于目的主机所在的网络，但在大多数情况下都允许有这样的特例，<strong>即为特定的目的主机指明一个路由</strong>。采用特定主机路由可使网络管理人员能更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。 </p></li><li><p><strong>默认路由</strong>：路由器还可采用默认路由以<strong>减少路由表所占用的空间和搜索路由表所用的时间。</strong></p><p><img src="%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1.png" alt="默认路由"></p></li><li><p>每一次转发分组时，<strong>IP数据报中的IP源、目的地址不变，变的只是MAC地址</strong>。路由器的网络接口软件使用 ARP 负责将下一跳路由器的 IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。</p></li><li><p>路由器分组转发算法：</p><ol><li>从数据报的首部提取目的主机的 IP 地址 D, 根据<strong>子网掩码</strong>得出目的网络地址为 N。</li><li>若网络 N 与此路由器<strong>直接相连</strong>，则把数据报直接交付目的主机 D；否则是间接交付，执行 (3)。</li><li>若路由表中有<strong>目的地址为 D 的特定主机路由</strong>，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 (4)。</li><li>若路由表中有<strong>到达网络 N 的路由</strong>，则把数据报传送给路由表指明的下一跳路由器；否则，执行 (5)。</li><li>若路由表中有一个<strong>默认路由</strong>，则把数据报传送给路由表中所指明的默认路由器；否则，执行 (6)。</li><li>报告转发分组出错。</li></ol></li><li><p>路由表的作用：<strong>指出到某个网络应当先到某个路由器（即下一跳路由器）。</strong>它没有给分组指明到某个网络的完整路径，而是指引分组<strong>一步步</strong>进行查找和转发，直到到达目的网络。</p></li></ol></li><li><p><strong>划分子网</strong>：</p><ol><li><p>从<strong>两级</strong> IP 地址<strong>（网络号+主机号）</strong>到<strong>三级</strong> IP 地址<strong>（网络号+子网号+主机号）</strong> </p><ol><li>原因：在 ARPANET 的早期，IP 地址的设计确实不够合理：<ol><li>IP 地址空间的<strong>利用率有时很低</strong>。 </li><li>给每一个物理网络分配一个网络号会<strong>使路由表变得太大</strong>因而使网络性能变坏</li><li>两级的 IP 地址<strong>不够灵活</strong></li></ol></li><li>从 1985 年起在 IP 地址中又增加了一个“子网号字段”，使两级的 IP 地址变成为三级的 IP 地址。</li></ol></li><li><p>划分子网纯属一个<strong>单位内部</strong>的事情。单位对外仍然表现为没有划分子网的网络。<strong>子网对外部透明</strong>。外部主机只需要将IP数据报发送给该单位的网络，发送到具体的子网由该单位自己负责。</p></li><li><p>方法：<strong>从主机号借用若干个位作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个位</strong>。凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器。然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网。最后就将 IP 数据报直接交付目的主机。（子网号全0或者全1表示特殊含义，所以n位的子网号，对应的子网数目为$2^{n-1}$。</p><p><img src="%E5%AD%90%E7%BD%91.png" alt="子网"></p></li><li><p>优点</p><ol><li><strong>减少了 IP 地址的浪费</strong></li><li><strong>使网络的组织更加灵活</strong></li><li><strong>更便于维护和管理</strong></li></ol></li><li><p><strong>子网掩码</strong>：存放在路由器中，路由器在与相邻路由器交换信息时，需要给出所在网络的子网掩码，路由表中每一个目的网络地址后面也需要给出该目的网络的子网掩码。</p><ol><li><p>规则：</p><ol><li>子网掩码长度 ＝ 32 位（IPv4）</li><li>某位 ＝ 1：IP地址中的对应位为网络号和子网号</li><li>某位 ＝ 0：IP地址中的对应位为主机号 </li></ol></li><li><p>使用时，计算机将子网掩码和目的地址进行<strong>按位与</strong>运算。</p><p><img src="%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.png" alt="子网掩码"></p></li><li><p>划分方法：</p><ol><li><strong>固定长度子网</strong>：所有子网的子网掩码都是相同的。</li><li><strong>变长子网</strong></li></ol></li><li><p>划分子网增加了灵活性，但却<strong>减少了能够连接在网络上的主机总数</strong>。（<strong>每个子网的主机号全0或全1均保留</strong>）</p></li></ol></li></ol></li><li><p><strong>ICMP协议：网际控制报文协议Internet Control Message Protocol</strong></p><ol><li><p>ICMP<strong>允许主机或路由器报告差错情况和提供有关异常情况的报告</strong>。从而更有效地转发IP数据报和提高交付成功的机会。</p><p><img src="ICMP%E6%8A%A5%E6%96%87.png" alt="ICMP报文"></p></li><li><p>ICMP属于<strong>网络层协议</strong>，<strong>ICMP报文存在于IP数据报的数据部分。</strong>ICMP报文分为差错报告报文和询问报文。</p></li><li><p><strong>ICMP差错报告报文</strong>：</p><ol><li>类型：<ol><li><strong>终点不可达</strong> </li><li><strong>时间超过</strong> </li><li><strong>参数问题</strong> </li><li><strong>改变路由</strong>（重定向）(Redirect)（存在更好的路径）</li></ol></li><li><strong>首部8个字节</strong>，数据部分<strong>为需要进行差错报告的IP数据报的首部和数据部分前8个字节。</strong></li></ol></li><li><p><strong>ICMP 询问报文</strong>：</p><ol><li>回送请求和回答报文（PING命令）</li><li>时间戳请求和回答报文</li></ol></li><li><p>ICMP举例：</p><ol><li><p><strong>PING</strong>：用来测试<strong>两个主机之间的连通性</strong>。PING 使用了 <strong>ICMP 回送请求与回送回答报文</strong>。PING 是<strong>应用层直接使用网络层 ICMP 的例子</strong>，它没有通过运输层的 TCP 或UDP。 </p><p><img src="PING.png" alt="PING"></p></li><li><p><strong>Traceroute</strong>：Windows 操作系统中这个命令是 tracert。<strong>用来跟踪一个分组从源点到终点的路径</strong>。它利用 IP 数据报中的 TTL 字段和 ICMP 时间超过差错报告报文实现对从源点到终点的路径的跟踪。</p><p><img src="traceroute.png" alt="traceroute"></p></li></ol></li></ol></li><li><p>互联网的路由选择协议：</p><ol><li><p>路由route：<strong>为分组找路径。</strong></p></li><li><p>理想的路由算法：</p><ol><li>算法必须是正确的和完整的。 </li><li>算法在计算上应简单。 </li><li>算法应能适应通信量和网络拓扑的变化，这就是说，要有自适应性。 </li><li>算法应具有稳定性。 </li><li>算法应是公平的。 </li><li>算法应是最佳的。 </li></ol></li><li><p>按照路由选择算法是否能<strong>随着网络的通信量或者拓扑自适应地进行调整变化</strong>来划分：</p><ol><li><strong>静态路由选择策略</strong>——即非自适应路由选择，其特点是<strong>简单和开销较小</strong>，但<strong>不能及时适应网络状态的变化。</strong> </li><li><strong>动态路由选择策略</strong>——即自适应路由选择，其特点是<strong>能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。</strong>、、</li></ol></li><li><p>互联网采用<strong>自适应的（动态）、分层次的</strong>路由选择协议。</p><ol><li>互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。</li><li>许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议（这属于本部门内部的事情），但同时还希望连接到互联网上。</li></ol></li><li><p><strong>自治系统AS Autonomous System **：</strong>在单一的技术管理下的一组路由器<strong>，而这些路由器使用</strong>一种 AS 内部的路由选择协议（如RIP和OSPF）和共同的度量<strong>以确定分组在该 AS 内的路由，同时还使用</strong>一种 AS 之间的路由选择协议（如BGP-4）<strong>用以确定分组在 AS之间的路由。一个 AS 对其他 AS 表现出的是一个单一的和一致的路由选择策略。（自治系统相连采用的是</strong>网关Gateway）**</p><p><img src="%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F.png" alt="AS"></p></li><li><p><strong>内部网关协议 IGP</strong> (Interior Gateway Protocol)  （自治系统内部）</p><ol><li>在一个<strong>自治系统内部</strong>使用的路由选择协议。</li><li>目前这类路由选择协议使用得最多，如 <strong>RIP 和 OSPF 协议。</strong></li></ol></li><li><p><strong>外部网关协议 EGP</strong> (External Gateway Protocol) （自治系统之间）</p><ol><li>若源站和目的站<strong>处在不同的自治系统</strong>中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。</li><li>在外部网关协议中目前使用最多的是 <strong>BGP-4</strong>。 </li></ol></li><li><p>内部网关协议 <strong>RIP（路由信息协议）</strong></p><ol><li><p><strong>路由信息协议 RIP (Routing Information Protocol)</strong> 是内部网关协议 IGP 中<strong>最先</strong>得到广泛使用的协议。</p></li><li><p>RIP 是一种<strong>分布式的、基于距离向量的</strong>路由选择协议。</p></li><li><p>RIP 协议要求网络中的每一个路由器都要维护<strong>从它自己到其他每一个目的网络的距离记录</strong>。</p></li><li><p>RIP中的距离也称为<strong>“跳数”(hop count)</strong>，<strong>因为每经过一个路由器，跳数就加 1。直接相连的路由器跳数为1。</strong></p></li><li><p>RIP 认为一个好的路由就是<strong>它通过的路由器的数目少，即“距离短”</strong>。（但其实不一定，<strong>有的路径可能速度更快但路由数较多</strong>）</p></li><li><p>RIP 允许一条路径最多只能包含 <strong>15 个</strong>路由器。“距离”的最大值为 16 时即相当<strong>于不可达</strong>。可见 RIP 只适用于<strong>小型互联网</strong>。</p></li><li><p>RIP协议的特点：</p><ol><li>仅和<strong>相邻路由器</strong>交换信息。 </li><li>交换的信息是当前本路由器所知道的全部信息，即<strong>自己的路由表</strong>。 </li><li>按<strong>固定的时间间隔</strong>交换路由信息，例如，每隔 30 秒。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。</li></ol></li><li><p>路由器在刚刚开始工作时，只知道<strong>到直接连接的网络的距离（此距离定义为 1）</strong>。它的路由表是空的。经过若干次<strong>交换信息和更新</strong>后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。<strong>这个若干次更新的过程即为RIP的收敛</strong>。</p></li><li><p>RIP协议的路由器之间交换信息的方式是：<strong>RIP报文</strong>。它使用运输层的<strong>用户数据报协议UDP</strong>进行传送。</p></li><li><p>RIP协议的更新路由表算法：<strong>距离向量算法</strong>：</p><ol><li>路由器收到<strong>相邻路由器</strong>（其地址为 X）的一个 RIP 报文。</li><li>先修改此 RIP 报文中的所有项目：<strong>把“下一跳”字段中的地址都改为 X，并把所有的“距离”字段的值加 1。</strong></li><li>对修改后的 RIP 报文中的每一个项目，重复以下步骤：<ol><li>若项目中的目的网络<strong>不在路由表</strong>中，则把该项目加到路由表中。（<strong>新的目的网络</strong>）</li><li>否则：<ol><li>若下一跳字段给出的<strong>路由器地址是同样的</strong>，则把收到的项目<strong>替换</strong>原路由表中的项目。（<strong>网络动态更新后的最新的消息</strong>）</li><li>否则：<ol><li>若收到项目中的距离<strong>小于</strong>路由表中的距离，则进行更新（<strong>更好的路径</strong>）</li><li>否则，什么也不做。</li></ol></li></ol></li></ol></li><li>若 <strong>3 分钟</strong>还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即将距离<strong>置为 16</strong>（表示不可达）。</li><li>返回。</li></ol></li><li><p>距离向量算法的基础就是 <strong>Bellman-Ford 算法</strong>（<strong>SPFA算法前身</strong>）</p></li><li><p>RIP 协议特点：<strong>好消息传播得快，坏消息传播得慢。</strong>当网络出现故障时，要经过比较长的时间 (例如数分钟) 才能将此信息传送到所有的路由器。（<strong>故障的链路对路由表的修改在还未发送出去时，可能被收到的相邻路由器尚未更新的路由表信息覆盖掉</strong>）</p></li><li><p>优点：</p><ol><li><strong>实现简单，开销较小。</strong></li></ol></li><li><p>缺点：</p><ol><li>RIP <strong>限制了网络的规模</strong>，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是<strong>路由器中的完整路由表</strong>，因而随着网络规模的扩大，<strong>开销也就增加。</strong> </li><li>“坏消息传播得慢”，使<strong>更新过程的收敛时间过长</strong>。</li></ol><p><img src="%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F.png" alt="距离向量算法"></p></li></ol></li><li><p>内部网关协议 OSPF（<strong>开放最短路径优先协议</strong>）</p><ol><li><p><strong>开放最短路径优先 OSPF (Open Shortest Path First)</strong>是为<strong>克服 RIP 的缺点</strong>在 1989 年开发出来的。</p><ol><li>“开放”表明 OSPF 协议不是受某一家厂商控制，而是<strong>公开发表</strong>的。</li><li>“最短路径优先”是因为使用了 <strong>Dijkstra 提出的动态规划的最短路径算法 SPF</strong>。注意：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</li><li>采用<strong>分布式</strong>的链路状态协议 (link state protocol)。 </li></ol></li><li><p>三大要点：</p><ol><li>向本自治系统中所有路由器发送信息，这里使用的方法是<strong>洪泛法</strong>。路由器通过所有的端口向所有的相邻路由器发送信息，而所有的相邻路由器也是同样的做法，（但发送的对象不包括之前向他发送信息的那个路由器），从而最终<strong>使得整个局域网都得到该信息的一个副本。</strong></li><li>发送的信息就是<strong>与本路由器相邻的所有路由器的链路状态</strong>，但这只是路由器所知道的部分信息。（Dijkstra算法只需要相邻链路状态即可获取最短路径）</li><li>只有<strong>当链路状态发生变化</strong>时，路由器才用洪泛法向所有路由器发送此信息。 </li></ol></li><li><p>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个<strong>链路状态数据库</strong>。这个数据库实际上就是全网的拓扑结构图，它在全网范围内是<strong>一致</strong>的（<strong>这称为链路状态数据库的同步</strong>）。OSPF 的链路状态数据库能<strong>较快地进行更新</strong>，使各个路由器能及时更新其路由表。</p></li><li><p>优点：</p><ol><li><p>OSPF 的更新过程<strong>收敛得快</strong>；</p></li><li><p>OSPF 没有“<strong>坏消息传播得慢</strong>”的问题</p></li><li><p>OSPF 能够用于<strong>规模很大</strong>的网络，采用<strong>划分区域</strong>的方式。</p><ol><li>划分区域的好处就是<strong>将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统</strong>，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。</li></ol><p><img src="%E5%88%92%E5%88%86%E5%8C%BA%E5%9F%9F.png" alt="划分区域"></p></li></ol></li><li><p>OSPF 不用 UDP 而是直接用 <strong>IP 数据报</strong>传送。（<strong>RIP使用UDP</strong>）</p><p><img src="OSPF%E5%88%86%E7%BB%84.png" alt="OSPF分组"></p></li></ol></li><li><p><strong>路由器</strong>：</p><ol><li><p>路由器是一种典型的<strong>网络层设备</strong>。<strong>作用是连通不同的网络（局域网），进行分组转发</strong>。</p></li><li><p>路由器是互联网的核心部分中的关键设备。</p></li><li><p>路由器的主要作用是：</p><ol><li><strong>连通不同的网络。</strong></li><li><strong>选择信息传送的线路（路由选择协议）</strong>。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率，从而让网络系统发挥出更大的效益来。</li></ol><p><img src="%E8%B7%AF%E7%94%B1%E5%99%A8.png" alt="路由器"></p></li><li><p>“转发”和“路由选择”的区别 :</p><ol><li>“转发”(forwarding) 就是路由器根据转发表将用户的 IP 数据报<strong>从合适的端口</strong>转发出去。</li><li>“路由选择”(routing) 则是按照<strong>分布式算法</strong>，根据从各相邻路由器得到的关于网络拓扑的变化情况，<strong>动态地改变所选择的路由</strong>。</li><li><strong>路由表是根据路由选择算法得出的。而转发表是从路由表得出的。</strong></li></ol></li></ol></li><li><p>IPv6:</p><ol><li>网际协议IP 是互联网的核心协议。</li><li>互联网经过几十年的飞速发展，<strong>到 2011 年 2 月，IPv4 的 32 位地址已经耗尽。</strong></li><li>解决 IP 地址耗尽的根本措施就是<strong>采用具有更大地址空间的新版本的 IP，即 IPv6。</strong></li><li>所引进的主要变化：<ol><li><strong>更大的地址空间。IPv6 将地址从 IPv4 的 32 位 增大到了 128 位。</strong> </li><li><strong>扩展的地址层次结构。</strong> </li><li><strong>灵活的首部格式</strong>。 IPv6 定义了许多可选的扩展首部。</li><li><strong>改进的选项</strong>。 IPv6 允许数据报包含有选项的控制信息，其选项放在有效载荷中。</li><li><strong>允许协议继续扩充</strong>。 </li><li><strong>支持即插即用（即自动配置）</strong>。因此 IPv6 不需要使用 DHCP。</li><li><strong>支持资源的预分配</strong>。  IPv6 支持实时视像等要求，保证一定的带宽和时延的应用。</li><li><strong>IPv6 首部改为 8 字节对齐</strong>。首部长度必须是 8 字节的整数倍。原来的 IPv4 首部是 4 字节对齐。</li></ol></li><li>由于IPv6改为了128位，所以并没有采用和IPv4相同的点分十进制表示法，而是采用<strong>冒号十六进制记法</strong>。</li></ol></li></ol></li></ol><h2 id="第五章-运输层"><a href="#第五章-运输层" class="headerlink" title="第五章  运输层"></a>第五章  运输层</h2><h3 id="重要内容-4"><a href="#重要内容-4" class="headerlink" title="重要内容"></a>重要内容</h3><ul><li><strong>运输层的作用</strong></li><li><strong>端口和套接字</strong>的意义</li><li><strong>无连接的UDP</strong>的特点</li><li><strong>面向连接的TCP</strong>的特点</li><li>在不可靠网络上实现<strong>可靠传输</strong>的原理</li><li>TCP的<strong>滑动窗口、流量控制、拥塞控制和连接管理</strong></li></ul><h3 id="核心知识点-4"><a href="#核心知识点-4" class="headerlink" title="核心知识点"></a>核心知识点</h3><ol><li><p>运输层功能：<strong>互联网</strong>内任意两台主机上的<strong>进程（应用程序）</strong>之间的<strong>数据传输</strong>（不是分组传输，网络层才有分组）</p></li><li><p>从通信和信息处理的角度看，运输层向它上面的<strong>应用层</strong>提供通信服务，它属于<strong>面向通信部分的最高层，</strong>同时也是<strong>用户功能中的最低层。</strong></p><ol><li>只有位于网络边缘部分的<strong>主机的协议栈</strong>才有运输层。（<strong>主机-五层</strong>）</li><li>而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 （<strong>路由器-三层</strong>）</li><li>运输层与网络层的区别在于：运输层为<strong>主机上的进程间</strong>提供数据传输服务，而网络层为<strong>主机</strong>提供分组传输服务。</li></ol><p><img src="%E8%BF%90%E8%BE%93%E5%B1%82.png" alt="运输层"></p></li><li><p>网络层与运输层：</p><ol><li>网络层的作用是为<strong>互联网上的主机</strong>之间提供逻辑通信。</li><li>运输层的作用是为<strong>互联网上的主机上的应用进程</strong>之间提供端到端的逻辑通信。</li><li>网络层的差错检测仅检测IP数据报首部的内容是否出错（<strong>通过首部检验和</strong>），而运输层可以提供<strong>可靠的信道（TCP）或不可靠的信道（UDP）</strong>。</li></ol></li><li><p>主要作用：</p><ol><li>为<strong>互联网上的主机上的应用进程</strong>之间提供<strong>端到端</strong>的<strong>逻辑通信</strong>。</li><li><strong>复用 (multiplexing)和分用 (demultiplexing)。</strong>（通过<strong>端口</strong>）</li><li><strong>屏蔽作用</strong>：运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。</li></ol></li><li><p>运输层的两种协议：</p><ol><li><p><strong>用户数据报协议 UDP</strong> (User Datagram Protocol)：</p><ol><li><strong>无连接，不可靠</strong>，协议数据单元为<strong>用户数据报</strong>。<strong>可靠性差，但传输效率好，实时性好</strong>。适用于只对数据传输的实时性要求较高，但对传输质量要求低的场景，如<strong>在线语音、视频聊天</strong>等。</li><li>在传送数据之前<strong>不需要先建立连接。</strong>发送完数据后，不需要接到对方的确认。</li><li>虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式（例如<strong>流式媒体运输</strong>，如视频电话等）</li><li>常用UDP的应用和应用层协议：<strong>DNS、TFTP、RIP、DHCP、SNMP、NFS、IGMP等。</strong></li></ol></li><li><p>传输控制协议TCP（Transition Control Protocol）：</p><ol><li><strong>有连接，可靠</strong>，协议数据单元为<strong>TCP报文段</strong>。<strong>传输效率低，实时性差，但可靠性高</strong>，适用于对数据传输的质量有较高要求，但对实时性要求不高的场景，如<strong>传输文件</strong>（HTTP、HTTPS、FTP）、<strong>发送邮件</strong>（SMTP）、<strong>远程登录</strong>（SSH、TELNET）等协议。</li><li><strong>需要先建立连接</strong>。对方收到TCP报文段后需<strong>要给出确认</strong>。</li><li>TCP 不提供<strong>广播或多播</strong>服务。</li><li>由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地<strong>增加了许多的开销</strong>， 如<strong>确认、流量控制、计时器以及连接管理</strong>等 。这不仅<strong>使协议数据单元的首部增大很多</strong>，还要<strong>占用许多的处理机资源</strong>。（<strong>用户数据报的首部仅为8个字节，而TCP报文段的首部为20到60个字节</strong>）</li><li>常用TCP的应用和应用层协议：<strong>SMTP、TELNET、HTTP、FTP等。</strong></li></ol></li><li><table><thead><tr><th>序号</th><th>对比项</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>1</td><td>可靠性</td><td><strong>可靠</strong></td><td><strong>不可靠</strong></td></tr><tr><td>2</td><td>连接性</td><td><strong>面向连接</strong></td><td><strong>无连接</strong></td></tr><tr><td>3</td><td>报文（Message）</td><td>面向<strong>字节流</strong>（Byte Stream，可以对过长报文分片）</td><td>面向<strong>报文</strong>（Message）（保留报文的边界，不可分）</td></tr><tr><td>4</td><td>效率</td><td>传输效率<strong>低</strong></td><td>传输效率<strong>高</strong></td></tr><tr><td>5</td><td>双工性</td><td><strong>全双工，但不提供广播或多播服务</strong></td><td><strong>一对一、一对多、多对一，多对多</strong></td></tr><tr><td>6</td><td>流量控制</td><td><strong>有（滑动窗口）</strong></td><td><strong>无</strong></td></tr><tr><td>7</td><td>拥塞控制</td><td><strong>有（慢开始、拥塞避免、快重传、快恢复）</strong></td><td><strong>无</strong></td></tr><tr><td>8</td><td>传输速度</td><td><strong>慢</strong></td><td><strong>快</strong></td></tr><tr><td>9</td><td>应用场合</td><td><strong>（1）对效率要求相对低，但对准确性要求相对高的场景（2）有连接的场景</strong></td><td><strong>对效率要求相对高，但对准确性要求相对低的场景</strong>。或者需要<strong>广播</strong>的场景，如DHCP和SNMP。</td></tr><tr><td>10</td><td>应用实例</td><td>（1）<strong>文件传输</strong>（FTP，HTTP 对数据的准确性要求高，速度可以相对慢）；（2）<strong>发送或接收邮件</strong>（SMTP、POP3，IMAP 对数据准确性要求高，非紧急应用）（3）<strong>远程登录</strong>（SSH，TELNET 对数据准确性有一定要求，有连接概念）等等</td><td>（1）<strong>即时通信</strong>（QQ聊天，对数据准确性和丢包要求比较低，但速度必须快）；（2）<strong>在线视频</strong>（RTSP 速度一定要快，保证视频连续，但是偶尔花了一个图像帧，人们还是能接受的）（3）<strong>网络语音电话</strong>（VoIP 语音数据包一般比较小，需要高速发送，偶尔断音或串音也没有问题）等等</td></tr></tbody></table></li></ol></li><li><p>运输层的端口（<strong>软件端口</strong>）：解决分用问题。</p><ol><li><p>解决的问题：运行在计算机中的进程是用<strong>进程标识符PID</strong>来标志的。但运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为在互联网上使用的计算机的操作系统种类很多，而<strong>不同的操作系统又使用不同格式的进程标识符</strong>。为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用<strong>统一的方法</strong>对 TCP/IP 体系的应用进程进行标志。</p></li><li><p>两个不同的概念：</p><ol><li><strong>在协议栈层间的抽象的协议端口是软件端口。</strong></li><li><strong>路由器或交换机上的端口是硬件端口。</strong></li><li>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的<strong>一种地址</strong>。 </li></ol></li><li><p>端口的注意事项：</p><ol><li>端口用一个 <strong>16 位端口号（0到65535）</strong>进行标志。</li><li>端口号只具有<strong>本地意义</strong>，即端口号只是为了标志本计算机应用层中的各进程。</li><li>在互联网中，不同计算机的相同端口号是<strong>没有联系</strong>的。</li><li>由此可见，两个计算机中的进程要互相通信，<strong>不仅必须知道对方的 IP 地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）</strong>。</li></ol></li><li><p>常见的端口：服务器端进程一般保持使用<strong>确定的端口号</strong>，方便客户端进程请求和使用。而客户端进程的端口号<strong>不确定</strong>，可以随时改变。</p><ol><li><p><strong>服务器端</strong>使用的端口号：</p><ol><li><p><strong>熟知端口</strong>，数值一般为 <strong>0~1023</strong>。</p><p><img src="%E7%86%9F%E7%9F%A5%E7%AB%AF%E5%8F%A3%E5%8F%B7.png" alt="熟知端口"></p></li><li><p><strong>登记端口号</strong>，数值为 <strong>1024~49151</strong>，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 <strong>IANA</strong> 登记，以防止重复。</p></li></ol></li><li><p><strong>客户端</strong>使用的端口号：</p><ol><li>又称为<strong>短暂端口号</strong>，数值为 <strong>49152~65535</strong>，留给客户进程选择暂时使用。</li><li>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的<strong>动态端口号</strong>。通信结束后，这个端口号<strong>可供其他客户进程以后使用</strong>。 </li></ol></li></ol></li></ol></li><li><p>UDP用户数据报协议：</p><ol><li>UDP 只在 IP 的数据报服务之上增加了<strong>很少一点的功能</strong>：<ol><li><strong>复用和分用</strong>的功能</li><li><strong>差错检测</strong>的功能</li></ol></li><li>虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。例如<strong>开销相对较小，无拥塞控制</strong>等，适用于某些特定的场景。所传输的数据可能出现差错或丢失，应用进程本身可以在不影响应用的实时性前提下，采取一些措施提高UDP的可靠性，如<strong>向前纠错或重传报文</strong>。</li><li>UDP的特点：<ol><li>UDP 是<strong>无连接</strong>的，发送数据之前不需要建立连接，因此<strong>减少了开销和发送数据之前的时延</strong>。</li><li>UDP 使用<strong>尽最大努力</strong>交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</li><li>UDP 是<strong>面向报文</strong>的。UDP 对应用层交下来的报文，既不合并，也不拆分，而是<strong>保留这些报文的边界</strong>。UDP 一次交付一个<strong>完整的报文</strong>。</li><li>UDP 没有<strong>拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。<strong>很适合多媒体通信（如IP电话、视频会议）的要求</strong>。 （但是，如果多个源主机上的进程使用UDP同时向网络发送实时视频流时，可能导致拥塞）</li><li>UDP 支持<strong>一对一、一对多、多对一和多对多</strong>的交互通信，而TCP不支持广播和多播。</li><li>UDP 的<strong>首部开销小</strong>，只有 <strong>8 个字节</strong>，比 TCP 的 20 个字节的首部要短。</li></ol></li><li><strong>面向报文</strong>：UDP交付和接收的单位是一个报文，<strong>不会对报文进行分段</strong>。所以采用UDP发送的报文段<strong>需要长度适中</strong>。</li><li><img src="UDP.png" alt="UDP"></li><li>UDP首部有<strong>8个字节</strong>，此外还需要<strong>12字节的伪首部</strong>，作用是用于<strong>计算检验和</strong>。伪首部不向上传送也不向下递交。UDP计算检验和的方法与IP数据报基本相同，唯一的区别在于<strong>UDP把首部（包含伪首部）和数据部分一起检验。</strong></li></ol></li><li><p><strong>传输控制协议TCP</strong>：</p><ol><li><p>最主要的特点：</p><ol><li>TCP 是<strong>面向连接</strong>的运输层协议。发送前需要先建立连接。</li><li>每一条 TCP 连接只能有<strong>两个端点 (endpoint)</strong>，每一条 TCP 连接只能是<strong>点对点</strong>的（一对一）。</li><li>TCP 提供<strong>可靠交付</strong>的服务。</li><li>TCP 提供<strong>全双工通信</strong>。</li><li><strong>面向字节流</strong>：<ol><li>TCP 中的“流”(stream)指的是<strong>流入或流出进程的字节序列</strong>。</li><li>“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。<strong>TCP可以对报文的字节流进行分段形成报文段，而UDP不对报文进行分段。</strong></li><li>TCP不保证数据块的一致性，但<strong>保证数据块中的字节流的一致性。</strong></li></ol></li></ol></li><li><p>注意：</p><ol><li>TCP 连接是一条<strong>虚连接</strong>而不是一条真正的物理连接。</li><li>TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是<strong>不关心</strong>的。</li><li>TCP 根据<strong>对方给出的窗口值（流量控制）和当前网络拥塞的程度（拥塞控制）来</strong>决定一个报文段应包含多少个字节（<strong>UDP 发送的报文长度是应用进程给出的</strong>）。</li><li>TCP 可把太长的数据块划分<strong>短一些</strong>再传送。</li><li>TCP 也可等待积累有<strong>足够多</strong>的字节后再构成报文段发送出去。 </li></ol></li><li><p>TCP 的连接：</p><ol><li>TCP 把连接作为最基本的抽象。</li><li>每一条 TCP 连接<strong>有两个端点（套接字</strong>）。</li><li>TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。<strong>TCP 连接的端点叫做套接字 (socket) 或插口。</strong></li><li>端口号拼接到 (contatenated with) IP 地址即构成了套接字。  </li><li>套接字 <strong>socket = （IP地址 : 端口号）</strong>；</li><li>TCP 连接 ::= {socket1, socket2}= {(IP1: port1)，(IP2: port2)}  </li></ol></li><li><p><strong>可靠传输</strong>的工作原理：确认机制+重传机制</p><ol><li><p>理想传输条件的特点：</p><ol><li>传输信道<strong>不产生差错</strong>。</li><li>不管发送方以多快的速度发送数据，接收方总是<strong>来得及</strong>处理收到的数据。</li></ol></li><li><p><strong>停止等待协议（最基本的ARQ协议，滑动窗口协议的基础）</strong>：</p><ol><li><p>“停止等待”就是<strong>每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。如果在规定时间内没有收到确认，那么需要进行超时重传。</strong></p></li><li><p>四种情况下发送方和接收方如何处理：</p><ol><li><p><strong>无差错</strong>：传输的TCP报文段没问题</p><p><img src="%E6%97%A0%E5%B7%AE%E9%94%99.png" alt="无差错"></p></li><li><p><strong>出现差错</strong>：传输的TCP报文段出现了错误或者丢失了</p><p><img src="%E5%87%BA%E7%8E%B0%E5%B7%AE%E9%94%99.png" alt="出现差错"></p></li><li><p><strong>确认丢失</strong>：对方的确认报文段丢失</p><p><img src="%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1.png" alt="确认丢失"></p></li><li><p><strong>确认迟到</strong>：对方的确认报文段迟到了</p><p><img src="%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0.png" alt="确认迟到"></p></li></ol></li><li><p>通常 A 最终总是可以收到对所有发出的分组的确认。如果 A 不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。</p><p>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。</p><p>像上述的这种可靠传输协议常称为<strong>自动重传请求 ARQ  (Automatic Repeat reQuest)</strong>。意思是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。（<strong>停止等待协议是ARQ协议的一种，十分简单，但是信道利用率很低，传输效率低，高效的ARQ协议采用流水线方式发送数据，称为连续ARQ协议，它的详细版本即滑动窗口协议</strong>）</p></li><li><p>注意点：</p><ol><li>在发送完一个分组后，必须<strong>暂时保留已发送的分组的副本（保留在发送缓存中）</strong>，以备出现问题后<strong>重发</strong>。</li><li>分组和确认分组都必须<strong>进行编号</strong>（<strong>字节流中字节的序号</strong>）。</li><li>超时计时器的重传时间应当比<strong>数据在分组传输的平均往返时间</strong>更长一些。 </li></ol></li><li><p>停止等待协议的优点是<strong>简单</strong>，缺点是<strong>信道利用率太低</strong>。原因是需要耗费大量的时间在每一个分组发送后的等待确认上，解决的办法是<strong>滑动窗口协议</strong>，通过<strong>连续窗口发送和累积确认</strong>，提高信道利用率。</p><p><img src="%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE.png" alt="停止等待协议"></p></li></ol></li><li><p><strong>连续ARQ协议——滑动窗口协议</strong>：</p><ol><li><p>滑动窗口协议就是一种连续ARQ协议，但它的内容比较详细。</p></li><li><p>发送方维持的发送窗口，它的意义是：<strong>位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认</strong>。这样，信道利用率就提高了。（基础的ARQ协议，即停止等待协议，需要每发送一个分组就等待一次确认，效率很低）</p></li><li><p><strong>滑动窗口</strong>：连续 ARQ 协议规定，发送方每<strong>收到一个确认</strong>，就把<strong>发送窗口向前滑动一个分组</strong>的位置。</p></li><li><p><strong>累积确认</strong>：接收方一般采用<strong>累积确认</strong>的方式。即不必对收到的分组逐个发送确认，而是对<strong>按序到达的最后一个分组</strong>发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。（规定时间内，没有继续收到按序到达的分组，就依据当前按序到达的最后一个分组发送确认）</p><ol><li>优点：<strong>容易实现，即使确认丢失也不必重传。</strong></li><li>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。当按序到达的分组中间某处发生分组丢失时，需要进行<strong>Go-back-N（回退 N）</strong>，表示需要再退回来重传已发送过的 N 个分组。</li></ol></li><li><p><strong>重传机制</strong>：</p><ol><li><strong>选择重传</strong>：<ol><li>优点：<strong>提高信道效率。</strong>（不必重传已发送成功的分组）</li><li>缺点：接收方需要<strong>更大缓存</strong>。（需要将丢失分组后面序号的分组暂时保存在接收方的缓存区，等待重传的分组到达，再一起接收）</li></ol></li><li><strong>回退N步</strong>：<ol><li>优点：<strong>接收方缓存区小</strong>。</li><li>缺点：<strong>信道效率低</strong>，需要重传正确的分组。</li></ol></li></ol></li><li><p>具体实现：TCP 的滑动窗口是<strong>以字节为单位（TCP面向字节流）</strong>的。现假定 A 收到了 B 发来的确认报文段，其中窗口是 20 字节（<strong>流量控制</strong>），而确认号是 31（这表明 B 期望收到的下一个序号是 31，而序号 30 为止的数据已经收到了）。根据这两个数据，A 就构造出自己的发送窗口(实际情况下,还需要考虑<strong>拥塞窗口</strong>):</p><p><img src="%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png" alt="滑动窗口"></p><p><img src="1.png" alt="1"></p><p><img src="2.png" alt="2"></p></li><li><p>TCP 连接的每一端都必须设有两个窗口——<strong>一个发送窗口和一个接收窗口</strong>。总共有4个窗口，窗口的大小根据拥塞控制和流量控制动态改变。</p><ol><li>发送窗口表示：<strong>在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。</strong></li><li>接收窗口表示：<strong>接收方允许接收的字节序号</strong>。</li></ol></li><li><p>TCP连接的每一端都拥有<strong>发送缓存和接收缓存。</strong></p><ol><li><p>发送缓存用来暂时存放：</p><ol><li>发送应用程序传送给发送方 TCP <strong>准备发送</strong>的数据</li><li>TCP 已发送出但<strong>尚未收到确认的</strong>数据。</li></ol><p><img src="%E5%8F%91%E9%80%81%E7%BC%93%E5%AD%98.png" alt="发送缓存"></p></li><li><p>接收缓存用来暂时存放：</p><ol><li>按序到达的、但尚未<strong>被接收应用程序读取</strong>的数据；</li><li><strong>不按序到达</strong>的数据。（<strong>选择重传</strong>）</li></ol><p><img src="%E6%8E%A5%E6%94%B6%E7%BC%93%E5%AD%98.png" alt="接收缓存"></p></li></ol></li><li><p>注意点:</p><ol><li>A 的发送窗口并不总是和 B 的接收窗口<strong>一样大</strong>（因为有一定的<strong>时间滞后</strong>）。</li><li>TCP 标准没有规定对不按序到达的数据应如何处理。通常是<strong>先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程</strong>。</li><li>TCP 要求接收方必须有<strong>累积确认</strong>的功能，这样可以减小传输开销。  </li></ol></li><li><p><strong>捎带确认</strong>:接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带.但要注意:第一，接收方不应<strong>过分推迟</strong>发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源。第二，捎带确认实际上<strong>并不经常发生</strong>，因为大多数应用程序很少同时在两个方向上发送数据.</p></li></ol></li><li><p><strong>超时重传时间RTO</strong>的计算：ARQ协议的重传机制使用的超时重传时间RTO不是固定的，而是<strong>动态变化</strong>的，往往比数据在信道中传输的平均往返时间RTT略大一些。</p><ol><li><p>超时重传时间是指：<strong>TCP发送方在超时重传时间内没有收到接收方发送的确认就要重传已发送的TCP报文段。</strong></p></li><li><p>超时重传时间设置的困难：</p><ol><li>如果把超时重传时间设置得太短，就会引起很多报文段的<strong>不必要的重传</strong>，<strong>使网络负荷增大</strong>。</li><li>但若把超时重传时间设置得过长，则又使网络的空闲时间增大，<strong>降低了传输效率。</strong></li></ol></li><li><p>TCP选择的<strong>自适应算法：</strong></p><ol><li><p><strong>往返时间RTT</strong>：记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 RTT。</p></li><li><p><strong>加权平均往返时间 RTTS</strong>（这又称为平滑的往返时间，指数加权平均，就像机器学习中的动量梯度下降算法）：</p><ol><li><p>第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。</p></li><li><p>以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTS。RFC 2988 推荐的$\alpha$值为 1/8，即 0.125：</p><p><img src="RTTS.png" alt="RTTS"></p></li><li><p>超时重传时间 RTO：应略大于上面得出的加权平均往返时间 RTTS。RFC 2988 建议使用下式计算 RTO：</p><p><img src="RTO.png" alt="RTO"></p></li><li><p>RTTD 是 RTT 的偏差的加权平均值：</p><ol><li><p>第一次测量时，RTTD 值取为测量到的 RTT 样本值的一半。</p></li><li><p>在以后的测量中，则使用下式计算加权平均的 RTTD。RFC 2988 推荐的$\beta$值为 1/4，即 0.25：</p><p><img src="RTTD.png" alt="RTTD"></p></li></ol></li><li><p><strong>Karn 算法</strong>：在计算平均往返时间 RTT 时，只要<strong>报文段重传</strong>了，就不采用其往返时间样本。</p></li></ol></li></ol></li></ol></li></ol></li><li><p>TCP报文段的<strong>首部格式</strong>：</p><ol><li><p>TCP 报文段首部的<strong>前 20 个字节</strong>是固定的，后面有 <strong>4n 字节</strong>是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的<strong>最小长度是 20 字节。最长为60字节。</strong>（与IP数据报的首部类似）</p><p><img src="TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E9%A6%96%E9%83%A8.png" alt="TCP报文段首部"></p></li><li><p>字段：</p><ol><li><strong>源端口和目的端口字段</strong>——各占 <strong>2 字节</strong>。端口是运输层与应用层的服务接口。运输层的<strong>复用和分用</strong>功能都要通过端口才能实现。  </li><li><strong>序号字段</strong>——占 <strong>4 字节</strong>。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的<strong>第一个字节的序号</strong>。 </li><li><strong>确认号字段ack</strong>——占 <strong>4 字节</strong>，是期望收到对方的下一个报文段的数据的第一个字节的序号。 </li><li><strong>数据偏移（即首部长度）</strong>——占 <strong>4 位</strong>，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。<strong>“数据偏移”的单位是 32 位字（以 4 字节为计算单位）</strong>。  </li><li><strong>保留字段</strong>——<strong>占 6 位</strong>，保留为今后使用，但目前应置为 0。 </li><li><strong>紧急 URG</strong> —— 当 <strong>URG=1</strong> 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应<strong>尽快传送</strong>(相当于高优先级的数据)。 例如，向远程主机发送Control+c的中断命令。</li><li><strong>确认 ACK（注意大小写，大写为确认位，小写为确认号）</strong> —— 只有当 <strong>ACK=1</strong> 时确认号字段才有效。当 ACK=0 时，确认号无效。 例如，<strong>停止等待协议的确认分组。</strong></li><li><strong>推送 PSH (PuSH)</strong> —— 接收 TCP 收到 <strong>PSH = 1</strong> 的报文段，就<strong>尽快地交付</strong>接收应用进程，而不再等到整个缓存都填满了后再向上交付。  </li><li><strong>复位 RST (ReSeT)</strong> —— 当 <strong>RST=1</strong> 时，表明 TCP 连接中出现<strong>严重差错</strong>（如由于主机崩溃或其他原因），必须<strong>释放连接</strong>，然后再<strong>重新建立运输连接</strong>。 </li><li><strong>同步 SYN</strong> —— <strong>同步 SYN = 1 表示这是一个连接请求或连接接受报文</strong>。 </li><li><strong>终止 FIN (FINish)</strong> —— 用来<strong>释放一个连接</strong>。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 </li><li><strong>窗口字段</strong> —— 占 <strong>2 字节</strong>，用来让对方设置发送窗口的依据，单位为<strong>字节</strong>。指的是发送本报文段的一方的接收窗口。（<strong>发送方的发送窗口应小于等于拥塞窗口cnwd和接收方的接收窗口中的最小值</strong>）</li><li><strong>检验和</strong> —— 占 <strong>2 字节</strong>。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 <strong>12 字节的伪首部</strong>。（和UDP基本类似，但伪首部略有区别）</li><li><strong>紧急指针字段</strong> —— <strong>占 16 位</strong>，指出在本报文段中<strong>紧急数据共有多少个字节</strong>（紧急数据放在本报文段数据的最前面）。<strong>和URG字段配合使用</strong>。</li><li><strong>选项字段</strong> —— 长度可变。TCP 最初只规定了一种选项，即<strong>最大报文段长度 MSS</strong>。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。” <ol><li>MSS 与接收窗口值没有关系。</li><li>若选择较小的 MSS 长度，网络的利用率就降低。</li><li>MSS 应尽可能大些，最佳的 MSS 是很难确定的. </li></ol></li><li>其他选项:<ol><li><strong>窗口扩大选项</strong> ——<strong>占 3 字节</strong>，其中有一个字节表示移位值 S。新的窗口值等于 TCP 首部中的窗口位数增大到 (16 + S)，相当于把窗口值向左移动 S 位后获得实际的窗口大小。</li><li><strong>时间戳选项</strong>——占 10 字节，其中最主要的字段时间戳值字段（4 字节）和时间戳回送回答字段（4 字节）。</li><li><strong>选择确认选项</strong>——在后面的 5.6.3 节介绍。 </li></ol></li><li><strong>填充字段</strong> —— 这是为了使整个首部长度<strong>是 4 字节的整数倍</strong>。</li></ol></li></ol></li><li><p>TCP的<strong>流量控制</strong>：</p><ol><li><p><strong>流量控制</strong>：让发送方的发送速率<strong>不要太快</strong>，既要<strong>让接收方来得及接收，也不要使网络发生拥塞</strong>。（<strong>点对点，使用接收窗口控制</strong>）</p></li><li><p>利用<strong>滑动窗口机制</strong>可以很方便地在 TCP 连接上实现流量控制。</p></li><li><p>方法：不断<strong>减少接收窗口</strong>，即可降低数据发送速率。</p></li><li><p><strong>死锁</strong>：发送方因接收方的接收窗口为0，一直等待。此时，接收方有了一些窗口，但<strong>发送的非零窗口报文段丢失</strong>，导致双方互相等待死锁（<strong>发送方等待接收方的接收窗口大于0，而接收方等待发送方发送数据</strong>）。</p></li><li><p><strong>死锁的解决方案</strong>：TCP 为每一个连接设有一个<strong>持续计时器</strong>。只要 TCP 连接的一方收到对方的零窗口通知，就<strong>启动该持续计时器</strong>。若持续计时器设置的时间到期，就发送一个<strong>零窗口探测报文段</strong>（仅携带 <strong>1 字节</strong>的数据），而对方就在确认这个探测报文段时<strong>给出了现在的窗口值</strong>。若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。<strong>若窗口不是零，则死锁的僵局就可以打破了</strong>。</p><p><img src="%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png" alt="流量控制"></p></li></ol></li><li><p>TCP的拥塞控制：</p><ol><li><p><strong>拥塞</strong>：在某段时间，若对网络中<strong>某资源的需求超过了该资源所能提供的可用部分</strong>，网络的性能就要变坏。这种现象称为拥塞 (congestion)。简单的增加网络中的资源并不能解决拥塞问题。换句话说，就是<strong>网络中的数据量太大</strong>。</p></li><li><p><strong>拥塞控制</strong>：<strong>防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。</strong></p></li><li><p>拥塞控制与流量控制的区别：</p><ol><li>流量控制往往指<strong>点对点通信量</strong>的控制，是个端到端的问题（接收端控制发送端）。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 </li><li>拥塞控制是一个<strong>全局性（整个网络）</strong>的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 </li><li>二者的共同点就是：目的都是<strong>降低数据发送速率。</strong>都是<strong>基于窗口</strong>的，<strong>接收窗口rwnd和拥塞窗口cwnd</strong>。</li></ol></li><li><p>TCP 的拥塞控制方法：</p><ol><li><p>TCP 采用<strong>基于窗口</strong>的方法进行拥塞控制。该方法属于闭环控制方法。</p></li><li><p>TCP发送方维持一个<strong>拥塞窗口 CWND (Congestion Window)</strong>。拥塞窗口的大小取决于<strong>网络的拥塞程度</strong>，并且<strong>动态地</strong>在变化。发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。所以，发送窗口大小不仅取决于接收方公告的接收窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：<strong>min（接收窗口，拥塞窗口）</strong>。</p></li><li><p>如何判断出现了拥塞：</p><ol><li><strong>重传定时器超时（整个网络出现了拥塞，需要重新慢开始）</strong></li><li><strong>收到三个相同（重复）的 ACK（某个字节序号的数据丢失，跟快重传机制有关，需要进行快开始）</strong></li></ol></li><li><p>TCP拥塞控制算法：</p><ol><li><p><strong>慢开始 (slow-start)</strong>：</p><ol><li>算法的思路：<strong>由小到大逐渐增大拥塞窗口数值，每一个传输轮次对拥塞窗口进行加倍</strong>。</li><li>初始拥塞窗口 cwnd 设置：<ol><li>旧的规定：在刚刚开始发送报文段时，先把初始拥塞窗口cwnd 设置为 <strong>1 至 2 个</strong>发送方的最大报文段 SMSS (Sender Maximum Segment Size) 的数值。</li><li>新的 RFC 5681 把初始拥塞窗口 cwnd 设置为<strong>不超过2至4个</strong>SMSS 的数值。</li></ol></li><li><strong>慢开始门限 ssthresh（状态变量）</strong>：防止拥塞窗口cwnd 增长过大引起网络拥塞。到达ssthresh就由<strong>慢开始算法变为拥塞控制算法</strong>（<strong>指数增加到线性增加</strong>）</li><li>拥塞窗口 cwnd  控制方法：在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个 SMSS 的数值。<strong>发送方每收到一个对新报文段的确认（重传的不算在内）就使 cwnd 加 1。 每经过一个传输轮次，拥塞窗口就加倍。拥塞窗口的大小指数增加。</strong></li><li>“传输轮次”更加强调：<strong>把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认</strong>。</li></ol></li><li><p><strong>拥塞避免 (congestion avoidance)</strong></p><ol><li>思路：让拥塞窗口 cwnd 缓慢地增大，即每经过一个传输轮次就把发送方的拥塞窗口 cwnd <strong>加 1</strong>，而不是加倍，使拥塞窗口 cwnd 按<strong>线性规律</strong>缓慢增长。</li><li>每当在<strong>慢开始阶段或者拥塞避免阶段</strong>出现了<strong>网络拥塞（确认超时）</strong>：<ol><li>ssthresh = max（cwnd/2，2）</li><li>cwnd = 1</li><li>执行慢开始算法</li></ol></li><li>ssthresh一开始是默认的，后面根据拥塞发生时的窗口大小动态改变<strong>（乘以1/2）</strong></li></ol></li><li><p><strong>快重传 (fast retransmit)</strong>：</p><ol><li><strong>快重传</strong>：算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要<strong>立即发送确认</strong>，即使收到了失序的报文段也要立<strong>即发出对已收到的最后一个报文段的重复确认</strong>。（原先的接收方如果收到了失序的报文段是仅仅收下而不反馈任何信息的。这样会导致无法区分<strong>到底是个别报文段因某些因素丢失了还是整个网络出现了拥塞</strong>。这样会使发送方超时，从而<strong>错误地开启慢开始算法</strong>）</li><li>发送方只要<strong>一连收到三个重复确认</strong>，就知道接收方确实没有收到报文段，因而应当<strong>立即进行重传（即“快重传”）</strong>，这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。</li></ol></li><li><p><strong>快恢复 (fast recovery)</strong></p><ol><li>当发送端收到<strong>连续三个重复的确认</strong>时，由于发送方现在认为网络很可能没有发生拥塞，而是<strong>报文产生了丢失</strong>，问题没有那么严重。因此现在不执行慢开始算法，而是执行<strong>快恢复算法 FR (Fast Recovery) 算法</strong>：<ol><li>慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2 ；</li><li><strong>新拥塞窗口 cwnd = 慢开始门限 ssthresh</strong> ；（超时导致的重新慢开始，cnwd=1）</li><li>开始执行拥塞避免算法，使拥塞窗口缓慢地<strong>线性增大</strong>。 </li></ol></li><li>又称<strong>AIMD 算法</strong>：<ol><li>可以看出，在拥塞避免阶段，拥塞窗口是按照线性规律增大的。这常称为“<strong>加法增大</strong>”。</li><li>当出现超时或3个重复的确认时，就要把门限值设置为当前拥塞窗口值的<strong>一半</strong>，并大大减小拥塞窗口的数值。这常称为“<strong>乘法减小</strong>”。</li></ol></li></ol><p><img src="%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png" alt="拥塞控制"></p></li><li><p>流程图：</p><p><img src="TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png" alt="TCP拥塞控制"></p></li><li><p>TCP连接中，发送方发送窗口的最大值<strong>等于拥塞窗口cwnd（拥塞控制）和接收窗口rwnd（流量控制）二者的最小值。</strong></p></li></ol></li></ol></li></ol></li><li><p><strong>主动队列管理AQM（主动丢弃分组）</strong>：</p><ol><li><p>网络层的<strong>路由器分组丢弃策略</strong>对TCP拥塞控制影响很大。</p></li><li><p><strong>尾部丢弃策略</strong>：当发生拥塞后，路由器将队列尾部的分组<strong>全部</strong>丢弃。这可能导致<strong>全局同步</strong>。</p></li><li><p><strong>全局同步</strong>：若发生了路由器中的尾部丢弃，就可能会同时影响到很多条 TCP 连接，结果使这许多 TCP 连接在同一时间突然都进入到<strong>慢开始</strong>状态。全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很多。</p></li><li><p>AQM：在队列长度达到某个<strong>值得警惕的数值</strong>时（即当网络拥塞有了某些拥塞征兆时），就<strong>主动丢弃</strong>到达的分组。</p></li><li><p>AQM的实现方法：<strong>RED随机早期检测</strong>。</p><ol><li>使路由器的队列维持两个参数：<strong>队列长度最小门限 THmin 和最大门限 Thmax</strong> 。</li><li>RED 对每一个到达的分组都先计算当前路由器队列的<strong>平均队列长度 LAV</strong> 。</li><li>若平均队列长度小于<strong>最小门限 THmin</strong>，则将新到达的分组放入队列进行<strong>排队</strong>。</li><li>若平均队列长度超过<strong>最大门限 THmax</strong>，则将新到达的分组<strong>丢弃</strong>。</li><li>若平均队列长度在最小门限 THmin 和最大门限THmax 之间，则按照<strong>某一概率 p</strong> 将新到达的分组丢弃。</li></ol><p><img src="RED.png" alt="RED"></p></li></ol></li><li><p><strong>TCP运输连接</strong>：</p><ol><li><p>TCP 是<strong>面向连接</strong>的协议，需要<strong>在客户端和服务器之间</strong>建立连接。运输连接有三个阶段：</p><ol><li>连接建立</li><li>数据传送</li><li>连接释放</li></ol><p>运输连接的管理就是使运输连接的<strong>建立和释放</strong>都能正常地进行。</p></li><li><p>TCP建立连接：</p><ol><li><p><strong>三报文握手</strong>（三次握手）</p><ol><li><p>A 的 TCP 向 B 发出<strong>连接请求报文段</strong>，其首部中的同步位 <strong>SYN = 1（表明是一个连接请求报文段）</strong>，并选择序号 <strong>seq = x</strong>，表明传送数据时的<strong>第一个数据字节的序号是 x</strong>。</p></li><li><p>B 的 TCP 收到连接请求报文段后，如同意，则<strong>发回确认</strong>。B 在确认报文段中应使 <strong>SYN = 1（表明是一个连接接受报文段）</strong>，使 <strong>ACK = 1（表示当前为确认请求报文段）</strong>，其确认号<strong>ack = x + 1</strong>，自己选择的序号 <strong>seq = y</strong>。</p></li><li><p>A 收到此报文段后向 B <strong>给出确认</strong>，其 <strong>ACK = 1</strong>，确认号 <strong>ack = y + 1</strong>。A 的 TCP <strong>通知上层应用进程</strong>，连接已经建立。B 的 TCP 收到主机 A 的确认后，也<strong>通知其上层应用进程</strong>：TCP 连接已经建立。</p><p><img src="%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p></li></ol></li><li><p>为什么要三次握手：</p><ol><li>第一次握手是为了<strong>请求建立TCP连接</strong>，显然是必须的。</li><li>第二次握手是为了<strong>让客户端知道连接已经成功建立</strong>。如果没有第二次握手，假如连接建立失败，此时客户端<strong>不知情</strong>，会继续发送数据，导致出错。</li><li>第三次握手是<strong>防止失效了的连接建立请求再次到达服务端，导致服务端试图再次建立连接，从而产生错误</strong>。所以，B建立连接时需要再次向A进行确认。</li></ol></li></ol></li><li><p>TCP释放连接：</p><ol><li><p><strong>四报文握手</strong>（四次挥手）</p><ol><li><p>数据传输结束后，通信的<strong>双方</strong>都可释放连接。现在 A 的应用进程先向其 TCP 发出<strong>连接释放</strong><br><strong>报文段</strong>，并<strong>停止再发送数据</strong>，主动关闭 TCP 连接。A 把连接释放报文段首部的 <strong>FIN = 1</strong>，其序号<strong>seq = u</strong>，等待 B 的确认。</p></li><li><p>B 发出<strong>确认</strong>，<strong>ACK = 1</strong>，确认号 <strong>ack = u + 1</strong>，而这个报文段自己的序号 <strong>seq = v</strong>。TCP 服务器进程通知高层应用进程。<strong>从 A 到 B 这个方向</strong>的连接就释放了，TCP 连接处于<strong>半关闭状态</strong>。B 若发送数据，A 仍要接收。</p></li><li><p>此时，从B到A这个方向的连接尚未释放，<strong>B可以发送剩余的数据给A</strong>（因为是A发起的关闭连接，所以A到B的数据必然已经传输完，但B到A的不一定）。等B发送完剩余的数据，向A发送<strong>连接释放报文段</strong>，并<strong>停止再发送</strong>。该报文段首部的 <strong>FIN = 1，ACK = 1</strong>（<strong>表示是响应的释放连接，而不是主动释放</strong>），确认号 <strong>ack = u + 1</strong>。</p></li><li><p>A 收到连接释放报文段后，必须发出<strong>确认</strong>。 在确认报文段中 <strong>ACK = 1</strong>，确认号 <strong>ack = w + 1</strong>，自己的序号 <strong>seq = u + 1</strong>。 此时，A在等待<strong>2MSL（最长报文寿命，RFC793中设为2min）</strong>后，<strong>彻底释放TCP连接</strong>。</p><p><img src="%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p></li></ol></li><li><p>为什么A要等待2MSL才能宣布TCP彻底释放：</p><ol><li>为了保证 <strong>A 发送的最后一个 ACK 报文段能够到达 B。</strong>即A等到2MSL后，当出现A发送的确认报文段丢失时，可以收到B超时重传报文段，从而<strong>再次确认</strong>，使连接正常释放。</li><li><strong>防止 “已失效的连接请求报文段”出现在本连接中</strong>。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以<strong>使本连接持续的时间内所产生的所有报文段，都从网络中消失。</strong>这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</li></ol></li></ol></li></ol></li></ol></li></ol><h2 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h2><h3 id="重要内容-5"><a href="#重要内容-5" class="headerlink" title="重要内容"></a>重要内容</h3><ul><li>域名系统DNS</li><li>万维网和HTTP协议、HTTPS协议</li><li>电子邮件协议</li><li>动态主机配置协议DHCP</li><li>文件系统</li><li>其他协议</li></ul><h3 id="核心知识点-5"><a href="#核心知识点-5" class="headerlink" title="核心知识点"></a>核心知识点</h3><ol><li><p>应用层的功能：<strong>通过互联网上任意两台主机的应用进程之间的交互来完成特定网络应用。</strong> 协议数据单元是<strong>报文</strong>。</p></li><li><p>域名系统：<strong>DNS</strong>（UDP，53端口）：</p><ol><li><p>作用：将<strong>难以记忆的定长的IP地址</strong>转化为<strong>容易记忆的不定长的域名（机器名字）</strong>，方便人的使用。</p></li><li><p>许多应用层软件经常直接使用<strong>域名系统 DNS (Domain Name System)</strong>，但计算机的用户只是<strong>间接</strong>而不是直接使用域名系统。</p></li><li><p>名字到 IP 地址的解析是由<strong>若干个域名服务器程序完成</strong>的。域名服务器程序在专设的结点上运行，运行该程序的机器称为<strong>域名服务器</strong>。</p></li><li><p>任何一个连接在互联网上的主机或路由器，都有一个<strong>唯一的层次结构的名字</strong>，即域名。</p></li><li><p>域名只是个<strong>逻辑概念</strong>，并不代表计算机所在的物理地点。</p></li><li><p>DNS可以将域名解析为IP地址，也可以将IP地址解析为域名（<strong>反向解析</strong>）。</p><p><img src="%E5%9F%9F%E5%90%8D%E7%A9%BA%E9%97%B4.png" alt="域名空间"></p></li><li><p>域名服务器：一个服务器所负责管辖的（或有权限的）范围叫做<strong>区 (zone)</strong>。每一个区设置相应的权限域名服务器，用来<strong>保存该区中的所有主机的域名到 IP 地址的映射</strong>。DNS 服务器的管辖范围不是以“域”为单位，而是<strong>以“区”为单位</strong>。 </p><p><img src="%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E6%9E%84.png" alt="域名服务器结构"></p><ol><li><p>域名服务器类型：</p><ol><li><strong>根域名服务器</strong> ：<ol><li>根域名服务器是<strong>最高层次</strong>的域名服务器，也是<strong>最重要</strong>的域名服务器。所有的根域名服务器都知道所有的<strong>顶级域名服务器的域名和 IP 地址</strong>。</li><li>不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析，只要自己无法解析，就<strong>首先求助于根域名服务器</strong>。</li><li>根域名服务器共有 <strong>13 套</strong>装置。</li></ol></li><li><strong>顶级域名服务器</strong> ：<ol><li><strong>顶级域名服务器（即 TLD 服务器）</strong>负责管理在该顶级域名服务器注册的所有<strong>二级域名</strong>。</li><li>当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）（<strong>迭代查询而非递归查询</strong>）。</li></ol></li><li><strong>权限域名服务器</strong> ：<ol><li>负责<strong>一个区</strong>的域名服务器。</li><li>当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，<strong>下一步应当找哪一个权限域名服务器</strong>。 </li></ol></li><li><strong>本地域名服务器</strong>：<ol><li>本地域名服务器对域名系统非常重要。</li><li>当一个主机发出 DNS 查询请求时，这个查询请求报文就<strong>首先发送给本地域名服务器</strong>。</li><li>每一个互联网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，</li><li>这种域名服务器有时也称为<strong>默认域名服务器</strong>。</li></ol></li></ol></li><li><p>域名解析过程：</p><ol><li><p>主机向<strong>本地域名服务器</strong>的查询一般都是采用<strong>递归查询</strong>。（被请求的域名服务器若无法给出所需的IP地址，就以DNS客户的身份<strong>帮忙</strong>继续发送查询请求报文）</p></li><li><p>本地域名服务器向根域名服务器的查询通常是采用<strong>迭代查询。</strong>（被请求的域名服务器若无法给出所需的IP地址，不帮忙继续发送查询请求报文，而是返回给请求者“<strong>它下一步应当向哪一个域名服务器查询</strong>”）</p><p><img src="%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png" alt="域名解析过程"></p></li><li><p>每个域名服务器都维护一个<strong>高速缓存</strong>，存放最近用过的名字以及从何处获得名字映射信息的记录。每次域名解析时，先看高速缓存里有没有对应的记录（就像ARP协议一样）</p></li></ol></li></ol></li></ol></li><li><p><strong>文件传送协议FTP</strong>（基于有连接的可靠传输<strong>TCP</strong>，20、21端口）</p><ol><li><p>文件传送协议 FTP (File Transfer Protocol) 是互联网上使用得<strong>最广泛</strong>的文件传送协议。</p></li><li><p>FTP 提供<strong>交互式</strong>的访问，允许客户指明文件的<strong>类型与格式</strong>，并允许文件具有<strong>存取权限</strong>。</p></li><li><p>FTP 屏蔽了<strong>各计算机系统的细节</strong>，因而适合于在<strong>异构网络</strong>中任意计算机之间传送文件。</p></li><li><p>RFC 959 很早就成为了互联网的正式标准。</p></li><li><p>主要功能：<strong>减少或消除在不同操作系统下处理文件的不兼容性</strong>。</p></li><li><p>工作方式：FTP 使用<strong>客户服务器</strong>方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：<strong>一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求。</strong></p></li><li><p>一个 FTP 服务器进程可以同时为<strong>多个客户进程</strong>提供服务，在进行文件传输时，FTP 的客户和服务器之间要建立两个<strong>并行的 TCP 连接</strong>：<strong>控制连接和数据连接</strong>，实际用于传输文件的是<strong>数据连接</strong>。 FTP使用了两个不同的端口号，分别为：<strong>20和21</strong>。分别用于传输数据和控制连接，<strong>使协议更容易实现，可以在传输数据的同时控制连接。</strong></p><p><img src="FTP.png" alt="FTP"></p></li></ol></li><li><p><strong>网络文件系统协议NFS</strong>（TCP）：</p><ol><li>网络文件系统，NFS 允许应用进程打开一个<strong>远地文件</strong>，并能在该文件的<strong>某一个特定的位置上</strong>开始读写数据。NFS 可使用户只复制一个大文件中的一个<strong>很小的片段</strong>，而不需要复制整个大文件。</li><li>NFS 在网络上传送的只是<strong>少量的修改数据</strong>。 </li></ol></li><li><p><strong>简单文件传送协议 TFTP</strong> （基于不可靠的UDP，69端口）：</p><ol><li>TFTP (Trivial File Transfer Protocol) 是一个<strong>很小且易于实现</strong>的文件传送协议。</li><li>TFTP 使用<strong>客户服务器方式</strong>和<strong>使用 UDP 数据报</strong>，因此 TFTP 需要有自己的<strong>差错改正措施</strong>。</li><li>TFTP 只支持文件传输而<strong>不支持交互</strong>。</li><li>TFTP的<strong>首部很简单</strong>，传输效率较高，但是不可靠，使用<strong>类似于停止等待协议</strong>的方式进行差错控制。</li></ol></li><li><p><strong>远程终端协议 TELNET</strong>（TCP，23端口）：</p><ol><li>TELNET 是一个<strong>简单的远程终端协议</strong>，也是互联网的正式标准。主要用来<strong>远程登录和操控目的主机。</strong></li><li>用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是<strong>透明</strong>的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。 </li><li>TELNET 也使用<strong>客户-服务器</strong>方式。和 FTP 的情况相似，服务器中的<strong>主进程</strong>等待新的请求，并产生<strong>从属进程</strong>来处理每一个连接。 </li><li>TELNET很简单，<strong>不够安全</strong>，所以现在很少使用了，通常使用<strong>安全的SSH协议</strong>进行远程登录。</li></ol></li><li><p><strong>万维网（WWW，World Wide Web）</strong>：</p><ol><li>万维网概述：<ol><li>万维网 WWW (World Wide Web) 并非某种特殊的计算机网络。万维网是一个<strong>大规模的、联机式的信息储藏所</strong>。万维网上的不同站点之间按照<strong>链接</strong>相互连接。万维网是<strong>分布式超媒体 (hypermedia) 系统</strong>，它是<strong>超文本 (hypertext) 系统</strong>的扩充。一个超文本由多个信息源链接成，包含<strong>文本+链接</strong>。超媒体与超文本的区别是<strong>文档内容不同，如图形、图像、声音、动画，甚至活动视频图像</strong>。</li><li>万维网的工作方式：<strong>客户服务器方式</strong>（浏览器服务器方式）。</li><li>怎样标志分布在整个互联网上的万维网文档？<ol><li>使用<strong>统一资源定位符 URL (Uniform Resource Locator)</strong> 来标志万维网上的各种文档。</li><li>使每一个文档在整个互联网的范围内具有<strong>唯一</strong>的标识符 URL。 </li></ol></li><li>用何协议实现万维网上各种超链的链接？ <ol><li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议 HTTP (HyperText Transfer Protocol)</strong>。</li><li>HTTP 是一个应用层协议，它使用 <strong>TCP 连接</strong>进行可靠的传送。 </li></ol></li><li>怎样使各种万维网文档都能在互联网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链？ <ol><li><strong>超文本标记语言 HTML (HyperText Markup Language)</strong> 使得万维网页面的设计者可以很方便地用一个超链从本页面的某处链接到互联网上的任何一个万维网页面，并且能够在自己的计算机屏幕上将这些页面显示出来。 </li></ol></li></ol></li></ol></li><li><p><strong>统一资源定位符URL：</strong></p><ol><li>作用：<strong>用于在全网范围内确定一个网页</strong></li><li>格式：<strong>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</strong> </li><li><strong>端口和路径</strong>可省略。</li><li>例子：<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></li><li>用户点击URL后发生的事情（<strong>8步</strong>）：<ol><li>浏览器分析超链指向页面的 URL，看其<strong>是否合法</strong>，如果合法，先在<strong>浏览器缓存中查询</strong>，如果有对应页面直接返回。</li><li>浏览器通过DNS域名解析服务<strong>解析IP地址</strong>，先从<strong>浏览器缓存查询、然后是操作系统和hosts文件的缓存</strong>，如果没有查询<strong>本地域名服务器的缓存</strong>。 </li><li>域名系统 DNS 解析出对应网站服务器的 <strong>IP 地址</strong>。</li><li>浏览器与服务器进行<strong>三次握手</strong>，<strong>建立 TCP 连接</strong>。</li><li>浏览器发出<strong>取页面文件命令</strong>。</li><li>服务器给出<strong>响应</strong>，把页面文件发给客户端浏览器。</li><li>TCP 连接进行<strong>四次挥手释放</strong>。</li><li>浏览器<strong>渲染并显示</strong>页面文件中的所有文本。</li></ol></li></ol></li><li><p>超文本传输协议HTTP（TCP，80端口）：</p><ol><li><p>HTTP是<strong>超文本传输协议</strong>，规范了浏览器如何向万维网服务器请求万维网文档，服务器如何向浏览器发送万维网文档。从层次的角度看，HTTP是<strong>面向事务</strong>的应用层协议，是浏览器和服务器之间的传送数据文件的重要基础。 </p></li><li><p>HTTP是<strong>无状态</strong>的，之所以说无状态是因为<strong>HTTP对事务没有记忆性</strong>。<strong>同一个客户第二次访问同一个服务器，服务器的响应结果和第一次是一样的</strong>。HTTP的无状态简化了服务器的设计，允许服务器支持<strong>高并发</strong>的HTTP请求。如果要解决无状态的问题，可以使用<strong>cookie和session</strong>。</p><ol><li>Cookie存放在<strong>客户端的文件</strong>中，而Session存放在<strong>服务器端的内存</strong>中。</li><li>Cookie只能存储<strong>ASCII 码字符串</strong>，而 Session 则可以存储<strong>任何类型的数据</strong>，因此在考虑数据复杂性时<strong>首选Session</strong>。 </li><li>Cookie 存储在<strong>客户端的浏览器文件</strong>中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行<strong>加密</strong>，然后在服务器进行<strong>解密</strong>。 </li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么<strong>开销是非常大</strong>的，因此不建议将所有的用户信息都存储到 Session 中。 </li></ol></li><li><p><strong>HTTP1.0/1.1/2</strong>的主要区别：</p><ol><li>HTTP1.0：<ol><li>HTTP1.0默认<strong>不支持长连接</strong>，每一次请求都需要<strong>重新建立TCP连接</strong>。</li><li>HTTP1.0中认为每台服务器都绑定一个<strong>唯一</strong>的IP地址，因此，请求消息中的URL并没有传递<strong>主机名（hostname）</strong>  。但随着虚拟主机技术的发展，在一台物理服务器上可以存在<strong>多个虚拟主机（Multi-homed Web Servers）</strong>，并且它们共享一个IP地址。 </li></ol></li><li>HTTP1.1:<ol><li>HTTP 1.1支持<strong>持久连接</strong>（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，<strong>减少了建立和关闭连接的消耗和延迟</strong>。 </li><li>HTTP 1.1还允许客户端<strong>不用等待</strong>上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地<strong>减少了整个下载过程所需要的时间。</strong></li><li>HTTP 1.1中增加<strong>Host请求头字段</strong> ， 实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建<strong>多个虚拟WEB站点</strong> 。</li><li>HTTP 1.1还提供了与<strong>身份认证、状态管理和Cache缓存</strong>等机制相关的请求头和响应头 ，支持<strong>断点续传</strong>。</li></ol></li><li>HTTP2.0：<ol><li><strong>header压缩</strong>：我们在传输文本等静态资源的时候，一般会开启压缩，gzip等，这样会减少宽带的占用，对于一些较大的文本文件，压缩后会减少的特别明显，相应也会感觉提升了很多。而header头信息的传输却一直使用字符串来传输，<strong>HTTP2.0使用HPACK算法对header的数据进行压缩</strong>，这样数据体积小了，在网络上传输就会更快。 </li><li><strong>服务器推送</strong>： 当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。 </li><li><strong>多路复用</strong>： 多个请求可同时在一个连接上<strong>并行执行</strong>。某个请求任务耗时严重，不会影响到其它连接的正常执行； 而HTTP1.1的长连接是若干个请求排队<strong>串行化单线程处理</strong>，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的<strong>线头阻塞</strong>。</li></ol></li></ol><table><thead><tr><th></th><th>HTTP1.0</th><th>HTTP1.1</th><th>HTTP2.0</th></tr></thead><tbody><tr><td>Host头</td><td>✗</td><td>✔</td><td>✔</td></tr><tr><td>Range头</td><td>✗</td><td>✔</td><td>✔</td></tr><tr><td>长连接</td><td>✗</td><td>✔</td><td>✔</td></tr><tr><td>request method</td><td>GET HEAD POST</td><td>以上+ OPTIONS PUT DELETE TRACE CONNECT</td><td>以上全部</td></tr><tr><td>cache</td><td>Expire Last-Modefied Pragma</td><td>以上+ETag Cache-Control</td><td>以上全部</td></tr><tr><td>header压缩</td><td>✗</td><td>✗</td><td>✔</td></tr><tr><td>多路复用</td><td>✗</td><td>✗</td><td>✔</td></tr><tr><td>服务器推送</td><td>✗</td><td>✗</td><td>✔</td></tr></tbody></table></li><li><p>HTTP协议主要的请求方法：</p><ol><li><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">GET</td><td align="left">请求指定的页面信息，并返回实体主体。</td></tr><tr><td align="left">2</td><td align="left">HEAD</td><td align="left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="left">3</td><td align="left">POST</td><td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr><tr><td align="left">4</td><td align="left">PUT</td><td align="left">从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td align="left">5</td><td align="left">DELETE</td><td align="left">请求服务器删除指定的页面。</td></tr><tr><td align="left">6</td><td align="left">CONNECT</td><td align="left">HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td align="left">7</td><td align="left">OPTIONS</td><td align="left">允许客户端查看服务器的性能。</td></tr><tr><td align="left">8</td><td align="left">TRACE</td><td align="left">回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td align="left">9</td><td align="left">PATCH</td><td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table></li></ol></li><li><p>GET方法和POST方法的区别：</p><ol><li>GET方法是在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。<strong>GET是用于获取数据的，POST一般用于将数据发给服务器之用</strong>。</li><li>GET和POST的请求都能使用额外的参数，但是 GET 的参数是以<strong>查询字符串</strong>出现在 <strong>URL</strong> 中，而POST的参数<strong>存储在实体主体（body）</strong>中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些<strong>抓包工具</strong>查看。 但实际上，私密内容的传输尽量还是使用<strong>POST+Body</strong>的形式传输，毕竟这样做参数不会明文显示在URL中，如果要加强传输安全性，需要使用<strong>HTTPS</strong>协议。此外，由于浏览器的限制，URL的长度通常是<strong>限长</strong>的，这将导致GET方法的参数<strong>有限</strong>，而POST方法无限。</li><li>针对<strong>服务器</strong>来说，安全的HTTP方法<strong>不会改变服务器状态</strong>，也就是说它只是<strong>可读</strong>的。GET方法是安全的，而POST却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 </li><li>GET方法是<strong>幂等</strong>的，而POST方法<strong>不幂等</strong>。所谓幂等指的是<strong>同一个请求方法执行多次和仅执行一次的效果完全相同。</strong> </li></ol></li><li><p><strong>Ajax技术</strong>：<strong>不用刷新网页即可改变网页内容</strong>。<strong>XMLHttpRequest</strong>是一个 API，在Ajax中大量使用。它为客户端提供了在客户端和服务器之间传输数据的功能。<strong>它提供了一个通过URL 来获取数据的简单方式，并且不会使整个页面刷新</strong>。这使得网页只更新一部分页面而不会打扰到用户。</p></li><li><p>HTTP状态码：</p><ol><li><table><thead><tr><th align="left">分类</th><th align="left">分类描述</th></tr></thead><tbody><tr><td align="left">1**</td><td align="left">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="left">2**</td><td align="left">成功，操作被成功接收并处理</td></tr><tr><td align="left">3**</td><td align="left">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="left">4**</td><td align="left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="left">5**</td><td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table></li><li><p>具体的状态码： <a href="https://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">https://www.runoob.com/http/http-status-codes.html</a> </p></li></ol></li></ol></li><li><p><strong>安全的HTTP协议——HTTPS</strong>（TCP，443端口）：</p><ol><li><p>HTTP有很大的安全隐患：<strong>使用明文进行通信</strong>，内容可能会被窃听。<strong>不验证通信方的身份</strong>，通信方的身份有可能遭遇伪装。<strong>无法证明报文的完整性</strong>，报文有可能遭篡改。 </p></li><li><p>HTTPS是以<strong>安全</strong>为目标的HTTP通道，<strong>S代表security</strong>，<strong>让HTTP先和SSL通信，再由SSL和TCP 通信，也就是说 HTTPS使用了隧道进行通信</strong>。通过使用 SSL，HTTPS 具有了<strong>加密（防窃听）、认证（防伪装）和完整性保护（防篡改）</strong>。 </p></li><li><p>流程：</p><ol><li><p>加密算法主要有<strong>对称加密</strong>和<strong>非对称加密</strong>，对称加密的<strong>运算速度快</strong>，但<strong>安全性不高</strong>。非对称密钥加密，<strong>加密和解密使用不同的密钥</strong>。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用<strong>私有密钥</strong>解密。</p></li><li><p>非对称密钥除了用来加密还可以用来进行<strong>签名</strong>。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。非对称加密的运算速度慢，但是更安全。<strong>HTTPS采用混合的加密机制</strong>，使用<strong>非对称密钥加密</strong>用于传输对称密钥来保证传输过程的<strong>安全性</strong>，之后使用<strong>对称密钥加密</strong>进行通信来保证通信过程的<strong>效率</strong>。 </p></li><li><p>浏览器和服务器建立TCP连接后，会发送一个<strong>证书请求</strong>，其中包含了自己可以实现的算法列表和一些必要信息，用于商议双方使用的加密算法。 （请求证书）</p></li><li><p>服务器收到请求后会<strong>选择加密算法</strong>，然后返回<strong>证书</strong>，包含了服务器的信息，域名、申请证书的公司、加密的公钥以及加密的算法等。 （发还证书）</p></li><li><p>浏览器收到之后，检查签发该证书的机构是否正确，该机构的公钥签名是否有效，如果有效就生成对称密钥，并利用<strong>公钥</strong>对其加密，然后发送给服务器。（公钥加密）</p></li><li><p>服务器收到密钥后，利用自己的<strong>私钥</strong>解密。之后浏览器和服务器就可以基于<strong>对称加密</strong>对数据进行加密和通信。 （<strong>建立连接是非对称加密，传输数据是对称加密，兼顾效率和安全性</strong>）（私钥解密，创建安全连接）</p></li></ol></li></ol></li><li><p>电子邮件（采用TCP）：</p><ol><li><p><strong>发送邮件</strong>的协议：<strong>SMTP简单邮件传输协议</strong></p></li><li><p><strong>读取邮件</strong>的协议：<strong>POP3邮局协议3.0 和 IMAP</strong></p></li><li><p><strong>通用互联网邮件扩展MIME</strong> 在其邮件首部中说明了邮件的数据类型(如文本、声音、图像、视像等)，使用 MIME 可在邮件中同时传送多种类型的数据。</p></li><li><p>电子邮件系统的组成：</p><ol><li><p><strong>两个用户代理</strong>（发送方用户代理、接收方用户代理）</p></li><li><p><strong>两个邮件服务器（</strong>发送方邮件服务器、接收方邮件服务器）</p></li><li><p><strong>两个协议</strong>（SMTP：发送方用户代理到发送方邮件服务器，发送方邮件服务器到接收方邮件服务器、POP3：接收方邮件服务器到接收方用户代理）</p><p><img src="%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6.png" alt="电子邮件系统"></p></li></ol></li><li><p>用户代理 UA ：</p><ol><li>就是用户与电子邮件系统的接口，是<strong>电子邮件客户端软件</strong>。</li><li>用户代理的功能：撰写、显示、处理和通信。</li></ol></li><li><p>发送邮件的步骤:</p><ol><li>发件人调用 PC 中的用户代理撰写和编辑要发送的邮件。</li><li>发件人的用户代理把邮件用 SMTP 协议发给发送方邮件服务器，</li><li>SMTP 服务器把邮件临时存放在邮件缓存队列中，等待发送。</li><li>发送方邮件服务器的 SMTP 客户与接收方邮件服务器的 SMTP 服务器建立 TCP 连接，然后就把邮件缓存队列中的邮件依次发送出去。</li><li>运行在接收方邮件服务器中的SMTP服务器进 程收到邮件后，把邮件放入收件人的用户邮箱中，等待收件人进行读取。 </li><li>收件人在打算收信时，就运行 PC 机中的用户代理，使用 POP3（或 IMAP）协议读取发送给自己的邮件。 </li></ol></li><li><p>基于万维网的电子邮件系统（<strong>不需要下载客户端</strong>）：</p><p><img src="%E4%B8%87%E7%BB%B4%E7%BD%91%E9%82%AE%E4%BB%B6.png" alt="万维网电子邮件系统"></p></li></ol></li><li><p><strong>简单网络管理协议 SNMP（由于需要管理网络内的多个主机，需要广播，使用UDP，端口号：161）</strong>： </p><ol><li>SNMP 由三部分组成，<strong>SNMP 本身</strong>，负责读取和改变各代理中的对象名及其状态数值；<strong>管理信息结构 SMI</strong>，定义命名对象和对象类型的通用规则，以及把对象之间值进行编码的基本编码规范 BER；<strong>管理信息库 MIB</strong>，在被管理的实体中创建命名对象并规定其类型。 </li></ol></li><li><p><strong>动态主机配置协议 DHCP</strong>：可以自动设置<strong>IP地址、域名和本地DNS服务器</strong>等。<strong>使用UDP</strong>，需要配置多台主机。</p></li></ol><h2 id="第七章-网络安全"><a href="#第七章-网络安全" class="headerlink" title="第七章 网络安全"></a>第七章 网络安全</h2><p> <a href="https://www.nowcoder.com/discuss/429605?type=0&amp;order=7&amp;pos=11&amp;page=1&amp;channel=1000&amp;source_id=discuss_center_0" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/429605?type=0&amp;order=7&amp;pos=11&amp;page=1&amp;channel=1000&amp;source_id=discuss_center_0</a> </p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java SE复习笔记</title>
      <link href="/2020/05/22/java-se-fu-xi-bi-ji/"/>
      <url>/2020/05/22/java-se-fu-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaSE复习笔记"><a href="#JavaSE复习笔记" class="headerlink" title="JavaSE复习笔记"></a>JavaSE复习笔记</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="什么是变量？"><a href="#什么是变量？" class="headerlink" title="什么是变量？"></a>什么是变量？</h3><p>变量是用来命名一个数据的标识符。</p><h3 id="Java的基本数据类型（8种）"><a href="#Java的基本数据类型（8种）" class="headerlink" title="Java的基本数据类型（8种）"></a>Java的基本数据类型（8种）</h3><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>Java的整型主要有四类，分别为：</p><ul><li>字节型byte：8位。</li><li>短整型short：16位。</li><li>整型int：32位。</li><li>长整形long：64位。</li></ul><p>我们可以根据实际情况选择不同的整型，能一定程度上节约空间。</p><p>Java中，可以使用Integer类对整型进行操作。</p><h4 id="字符型Java的字符型为char，用于存放一个字符。长度与short类型一样，是16位（两个字节，底层的一个字）。"><a href="#字符型Java的字符型为char，用于存放一个字符。长度与short类型一样，是16位（两个字节，底层的一个字）。" class="headerlink" title="字符型Java的字符型为char，用于存放一个字符。长度与short类型一样，是16位（两个字节，底层的一个字）。"></a>字符型Java的字符型为char，用于存放一个字符。长度与short类型一样，是16位（两个字节，底层的一个字）。</h4><p>char类型的赋值必须用单引号’’，且最多只能存放一个字符。双引号用于字符串的赋值。</p><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>Java的浮点型（即小数）主要有两类，分别为：</p><ul><li>单精度浮点型float：32位。</li><li>双精度浮点型double：64位。</li></ul><p>double类型的精度比float类型的高。<strong>默认的小数类型为double</strong>，所以 float f = 1.1 会出现编译错误。需要显式地对小数进行声明才行，如 ：float f = 1.1f。</p><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><p>Java的布尔型为boolean，长度为1位。主要用于判断真假。</p><p>布尔型实际存放的数据为0（false）和1（true），但不能直接用0、1进行赋值，需要使用保留字false和true。</p><h4 id="注"><a href="#注" class="headerlink" title="注"></a>注</h4><p>需要注意的是，许多人会误以为String类型是Java的基本类型，因为它经常被使用，并且其赋值可以直接通过等号进行，如：String s = “123”。但是，它本身不属于基本类型，且是Immutable的（不可更改）。我会在后面进行说明。</p><h3 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h3><p>Java的基本变量类型属于内置的特殊数据类型，不属于任何一个类，所以与类的实例化创建不同，为一个基本变量类型赋值直接使用字面值的方式进行。</p><h4 id="整数字面值"><a href="#整数字面值" class="headerlink" title="整数字面值"></a>整数字面值</h4><ul><li>byte、short、int类型的赋值使用int类型的字面值，可以采用四种进制进行赋值：<ul><li>2进制：前缀为0b，如：int binVal = 0b1010；</li><li>8进制：前缀为0，如：int oxVal = 032；</li><li>10进制：无前缀，如：int decVal= 26；</li><li>16进制：前缀为0x，如 int hexVal = 0x1a。</li></ul></li><li>long类型的赋值需要在int类型后加上 L 或 l ，其余与int类型一样。如：long val = 123L。</li></ul><h4 id="浮点数字面值："><a href="#浮点数字面值：" class="headerlink" title="浮点数字面值："></a>浮点数字面值：</h4><ul><li>float类型的赋值必须是以 f 或 F 结尾的小数，如：float f =1.23f。</li><li>double类型的赋值可以是以 d 或 D 结尾的小数，也可以不加 d 或者 D，如：double d1 = 1.23D；double d2 = 1.23。</li></ul><h4 id="字符字面值"><a href="#字符字面值" class="headerlink" title="字符字面值"></a>字符字面值</h4><p>char类型的字面值放在单引号内进行赋值，如：char ch = ‘a’;</p><h4 id="字符串字面值"><a href="#字符串字面值" class="headerlink" title="字符串字面值"></a>字符串字面值</h4><p>String类型的字面值放在双引号内进行赋值，如：String s = “Hello”。</p><p>特别需要说明的是，String类型不属于基本类型，所以它也可以使用常规创建对象的方式进行引用赋值。如：String s = new String(“Hello”)。</p><p>此外，字符串中的反斜杠\表示转义，用于标识特殊含义的字符。如制表符、换行符等。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="低精度转高精度"><a href="#低精度转高精度" class="headerlink" title="低精度转高精度"></a>低精度转高精度</h4><p>由于低精度数据类型取值范围必然小于高精度，所以从低精度转向高精度不需要担心溢出问题。在Java中，可以自动进行转换。如：char c = 1 ；int i = c。</p><h4 id="高精度转低精度"><a href="#高精度转低精度" class="headerlink" title="高精度转低精度"></a>高精度转低精度</h4><p>高精度数据的取值范围大于低精度，所以从高精度转向低精度存在溢出的可能性。在Java中，必须使用<strong>强制类型转换</strong>的方式，当转换时出现了溢出现象，将产生报错。</p><p>强制类型转换的形式为：”(要转换的数据类型)”，如：int i =1 ; char c =（char ）i。</p><p>强制类型转换除了转换基本数据类型外，还可以用于其他类型之间的转换，如子类到父类。它的含义是：强行进行转换，但不确保转换之后的正确性。所以使用强制类型转换时可能出现各种报错信息。</p><h4 id="一个特例"><a href="#一个特例" class="headerlink" title="一个特例"></a>一个特例</h4><p>如果变量类型的位数相等，是否还需要使用强制类型转换呢？</p><p>例如：我们需要从short类型（16位）转至char类型（16位），此时，我们依然需要进行强制类型转换。转换完成后，原short类型的数字将成为char类型的字符的ASCII码。</p><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>这一部分，其实Java与其他类型的语言没有不同，主要注意以下几点：</p><ul><li>只能使用数字、字母、$、_ 四种字符，Java中还特别支持中文，但不推荐使用。</li><li>尽量使用完整的单词命名，少用缩写。</li><li>不能使用保留的关键字，如final、class等。</li></ul><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><h4 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h4><p>类变量指的是Java中定义在类中的变量，且被static关键字修饰，也称静态变量。它的使用不需要将类实例化为对象，直接用类名.变量名即可调用，但也可以被对象调用。</p><ul><li>它的生命周期为：随着类的加载而出现，随着类的消失而消失。</li><li>它的数据存放位置为：<strong>方法区的静态区</strong>，被所有该类的对象<strong>共享</strong>，一个对象改变类变量，其他所有对象的该类变量同步改变。</li><li>它的作用域为：整个类中都可以访问。</li></ul><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>成员变量指的是Java中定义在类中的变量，但没有被static关键字修饰，也称实例变量。它的使用必须要将类实例化为对象后，通过对象进行调用。它也被称作：属性、字段或Field。</p><ul><li>它的生命周期为：随着对象的创建而出现，随着对象的回收而消失。</li><li>它的数据存放位置为：<strong>堆内存的对象中</strong>，被对象所<strong>独占</strong>，一个对象改变成员变量，其他所有对象的该成员变量不会改变。</li><li>它的作用域为：整个类中都可以访问。</li></ul><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>局部变量指的是Java中定义在局部范围中的变量，特别地，方法的形参也是一种局部变量。Java中的局部变量使用的是块级作用域，仅在所在的块内有效。Java的块指的是被花括号”{}”括起来的范围。</p><ul><li>它的生命周期为：局部范围的块级作用域结束，局部变量将自动消失。</li><li>它的数据存放位置为：<em><em>栈内存中 </em></em>，仅在块内存在。</li><li>它的作用域为：仅在所在的块中可被访问。</li></ul><p>顺便提一下，Java中可以自定义子块，从而更进一步区分作用域。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i  <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//其作用范围是从声明的第4行，到其所处于的块结束12行位置</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//子块</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//可以访问i</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//可以访问j</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//不能访问j,因为其作用域到第10行就结束了</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="作用域冲突"><a href="#作用域冲突" class="headerlink" title="作用域冲突"></a>作用域冲突</h4><p>Java中的同名变量可能产生作用域冲突问题。对于该问题，Java采取<strong>就近原则</strong>：先在当前块内查询，如果不存在则层层向外查询，一旦找到目标变量就立刻使用。</p><p>所以，假如在某个类的实例方法中有一个局部变量name，同时存在一个成员变量name。在该方法中直接使用name，调用的是局部变量。如果想使用成员变量，必须利用关键字<strong>this</strong>，将当前类进行实例化。（this类似于python中的self，都是当前类默认的实例化对象的引用）</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h3><p>Java的算术操作符主要有：</p><ul><li>加法：+</li><li>减法：-</li><li>乘法：*</li><li>除法：/</li><li>取余：%</li><li>自加：++</li><li>自减：–</li></ul><p>如果运算过程中，某个变量的长度超过int，那么结果的长度按照<strong>最长的长度</strong>计算。</p><p>如果运算过程中，所有变量的长度都不超过int，那么结果的长度按照<strong>int</strong>计算。</p><p>整数和浮点数相乘或相除，结果是浮点数。整数与整数相乘或相除，结果是整数。所以Java中不像Python，有整除号，它是直接通过<strong>参与运算的变量类型</strong>来判断是否为整除的。</p><p>自增、自减操作符置前和置后结果不同。置前是<strong>先运算，再取值</strong>。置后是<strong>先取值，再运算</strong>。如i++和++i。</p><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>关系操作符比较的是两个变量的关系，Java的关系操作符主要有：</p><ul><li>大于：&gt;</li><li>大于等于：&gt;=</li><li>小于：&lt;</li><li>小于等于：&lt;=</li><li>等于：==</li><li>不等于：!=</li></ul><p>特别地，关系运算符的==和类的方法.equals（），二者的比较结果不一定相同，一些类中的.equals（）可能被重写。如String类。使用==号去比较两个对象，比较的是他们的地址，也就是是否为同一个对象。而两个字符串，通过.equals（）比较，比较的是字符串的值是否相等，即使不是同一个字符串对象，也可以返回True。（Object类默认的.equals()方法其实就是==）</p><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p>逻辑操作符主要针对的是布尔类型，Java主要的逻辑操作符有：</p><ul><li>长路与：&amp;</li><li>短路与：&amp;&amp;</li><li>长路或：|</li><li>短路或：||</li><li>取反：!</li><li>异或：^</li></ul><p>主要要说一下长路与/或和短路与/或。长路和短路的区别在于：</p><ul><li>短路与：一旦某个运算单元为False，由于与运算必然为False，所以后面的运算单元将不继续执行。</li><li>短路或：一旦某个运算单元为True，由于或运算必然为True，所以后面的运算单元将不继续执行。</li><li>长路与/或：无论运算结果为何，都将执行完所有的运算单元。</li></ul><h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><p>一些算法题可能会考。Java中需要先将整型数转成二进制字符串，再进行位运算。这一点不像python那么智能。python默认的数字类型为整型数，参与位运算前，会自动将其转换为二进制数。</p><ul><li>非二进制整型数转成二进制字符串：Integer.toBinaryString（）</li><li>按位或：|</li><li>按位与：&amp;</li><li>按位异或：^</li><li>按位取非：~</li><li>左移：&gt;&gt;</li><li>右移：&lt;&lt;</li><li>带符号左移：&gt;&gt;&gt;</li></ul><p>位运算可以加速一些操作，算法题中常考。比如LeetCode里的经典题目只出现一次的数字就可以通过异或运算来完成。</p><h3 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h3><p>Java中可以将条件判断语句写在一行，从而简化程序，是一种语法糖。形式为：</p><ul><li>（条件表达式）? A ： B</li></ul><p>含义为：如果条件表达式为真，那么取A值，否则取B值。</p><p>例如 ：int a = i&lt;j  ? 99 : 88</p><h2 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h2><p>Scanner类主要用于读取用户的输入。使用前需要导入Java.util.Scanner包，并且实例化一个Scanner对象，实例化时，需要在构造函数内传入控制台的输入流：</p><ul><li>Scanner sc = new Scanner（System.in）; </li></ul><p>其主要方法及功能如下所示。</p><h3 id="Scanner-next（）"><a href="#Scanner-next（）" class="headerlink" title="Scanner.next（）"></a>Scanner.next（）</h3><p>从遇到的第一个有效字符（非空格、非换行）开始扫描，直到遇到空格或者换行符。 将这段内容以 String 返回。 如果用户没有输入，那么将一直堵塞。</p><h3 id="Scanner-nextLine（）"><a href="#Scanner-nextLine（）" class="headerlink" title="Scanner.nextLine（）"></a>Scanner.nextLine（）</h3><p>从遇到的第一个有效字符（非空格、非换行）开始扫描，直到遇到换行符。 将这段内容以 String 返回。</p><p>它与next区别在于，next只要遇到空格或者换行符就返回，nextLine则是返回一整行。</p><h3 id="Scanner-nextInt（）"><a href="#Scanner-nextInt（）" class="headerlink" title="Scanner.nextInt（）"></a>Scanner.nextInt（）</h3><p> 跟 next() 方法很像，都是以空格或者换行符作为扫描终点 。读取的返回数据类型为int。其他的nextLong、nextFloat等方法同理。</p><p>由于nextXXX返回的值类型可能和接收的变量类型不匹配，所以可能出现java.util.InputMismatchException异常。我们一般要使用hasNextXXX来先判断一下。</p><h3 id="Scanner-hasNext（）"><a href="#Scanner-hasNext（）" class="headerlink" title="Scanner.hasNext（）"></a>Scanner.hasNext（）</h3><p>查看输入流中是否还有内容，有则返回True，无则返回False。hasNextInt是查看输入流中是否还有int类型，其他的hasNextXXX同理。</p><h3 id="读取整数后读取字符串"><a href="#读取整数后读取字符串" class="headerlink" title="读取整数后读取字符串"></a>读取整数后读取字符串</h3><p>需要注意的是，如果在通过nextInt读取了整数后，再接着读取字符串，读出来的是回车换行:”\r\n”,因为nextInt仅仅读取数字信息，而不会<strong>读取</strong>回车换行”\r\n”. </p><p>所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次nextLine，第一次是取走回车换行，第二次才是读取真正的字符串 </p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Java中的数组是一个固定长度的，包含了相同类型数据的容器。Java中的数组没有python中的列表那么灵活，无法动态扩容和存放不同类型的数据。与Python中列表对应的应该是Java的Collection类中的List数据结构，如顺序表ArrayList和单链表LinkedList。</p><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><p>数组的初始化需要实例化一个数组，并给定初始长度，如：</p><blockquote><p>int[] a = new int [5];</p><p>int[] [] a = new int[3] [4];</p></blockquote><p>也可以直接为数组的引用赋值，如：</p><blockquote><p>int[] a = {1,2,3,4};</p><p>int[] [] a = { { 1,2,3 },{ 1,2,3 } };</p></blockquote><h3 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h3><p>数组的排序属于算法范畴，在本博客的排序算法中有介绍。通常有八种最常用的排序算法，都需要熟练使用并会编写。</p><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>数组的遍历可以使用常规For循环，也可以使用增强型for循环，类似于Python中迭代器的形式。如：</p><blockquote><p>for (int i : arr)</p></blockquote><p>即可遍历数组中的全部元素，但是无法获取其对应的下标。</p><h3 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h3><p>直接采用创建新的引用指向数组的方式，将只是浅拷贝。浅拷贝的数组共享同一块内存，一个改变，另外所有的都要改变。</p><p>如果我们想要对数组进行深拷贝，有以下几种方法：</p><ul><li>数组的复制可以使用System类中的arraycopy方法：<ul><li>System.array（src，srcPos，dest，destPos，length），src为源数组，srcPos为源数组拷贝起始位置，dest为目标数组，destPos为拷贝到目标数组起始位置，length为长度。</li></ul></li><li>for循环拷贝，直接赋值</li><li>类自带的clone方法：<ul><li>int[] new_a = a.clone（）</li></ul></li><li>Arrays类的copyOf方法<ul><li>int[] new_a = Arrays.copyOf（a,a.length）</li></ul></li></ul><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p>Arrays类是针对数组的工具类，可以进行排序、查找、复制填充等功能。大大提高了开发人员的工作效率。</p><p>常用的方法有：</p><ul><li>Arrays.copyOfRange（src，strat，end）：用于复制数组，返回复制后的数组。</li><li>Arrays.toString（src）：用于返回一个数组的字符串形式。</li><li>Arrays.sort（src）：用于对数组进行原地排序，默认是降序，采用双轴快排。如果需要修改为升序，可以传入一个自定义的匿名内部类Comparator进行重写。</li><li>Arrays.binarySearch（src，target）：二分查找某个元素的下标，需要数组有序。</li><li>Arrays.equals（arr1，arr2）：判断两个数组的内容是否相等，类似于String类的equals。直接使用==比较的是两个数组的地址，Arrays的equals方法通过重写，可以比较内容。</li><li>Arrays.fill（src，val）：使用某个值填充数组。</li></ul><h2 id="JAVA修饰符"><a href="#JAVA修饰符" class="headerlink" title="JAVA修饰符"></a>JAVA修饰符</h2><p>Java提供了很多修饰符，通常放在类、方法、变量定义的最前端，主要有两类：</p><ul><li>访问修饰符</li><li>非访问修饰符</li></ul><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>访问修饰符用来控制类、变量、方法和构造方法的访问权限，Java支持四种类型的访问权限。</p><h4 id="默认访问修饰符"><a href="#默认访问修饰符" class="headerlink" title="默认访问修饰符"></a>默认访问修饰符</h4><p>默认访问修饰符即default，通常不用额外添加任何内容，即默认的访问权限。该权限对当前包内的所有类都是可见的。接口中，默认的变量修饰符隐式声明为 public static final ，默认的类修饰符隐式声明为public。</p><h4 id="私有访问修饰符"><a href="#私有访问修饰符" class="headerlink" title="私有访问修饰符"></a>私有访问修饰符</h4><p>私有访问修饰符private，是最严格的访问级别，所有被声明为private的方法、变量都只能在当前类中被访问，它是Java面向对象<strong>封装</strong>的基础。private不能修饰类、接口。</p><p>声明为private的变量，只能通过自定义的get、set函数被外界所访问。private的好处是实现了封装，隐藏类的实现细节，保护类的数据。想要在类的外部获取私有变量和方法，也可以通过<strong>反射</strong>机制。</p><p>父类中被修饰为private的方法和变量，即使是在子类中，也无法访问。</p><h4 id="公有访问修饰符"><a href="#公有访问修饰符" class="headerlink" title="公有访问修饰符"></a>公有访问修饰符</h4><p>公有访问修饰符public，是最宽松的访问级别，该权限对所有的类都是可见的，即使在不同的包中。</p><p>如果几个需要互相访问的public类在不同包中，只需要使用import关键字即可调用。</p><p>一个Java文件中只能有一个public类，主类的main方法必须被修饰为public，否则Java解释器将不会执行。</p><p>父类中被修饰为public的方法和变量，将被子类完全继承，但同时，他们对其他任意的类也是可见的。</p><h4 id="受保护的访问修饰符"><a href="#受保护的访问修饰符" class="headerlink" title="受保护的访问修饰符"></a>受保护的访问修饰符</h4><p>受保护的访问修饰符protected只能修饰方法和变量，它的权限需要从两点来说明：</p><ul><li>protected修饰的方法和变量，对所在包内的所有类可见。</li><li>protected修饰的方法和变量，对当前类的子类可见，即使子类与当前类不在同一包中。</li></ul><p>也就是说protected对本包及其子类可见。</p><h4 id="四种访问修饰符比较"><a href="#四种访问修饰符比较" class="headerlink" title="四种访问修饰符比较"></a>四种访问修饰符比较</h4><p>访问权限从大到小依次为：public、default、protected、private。</p><p>此外，还要注意，继承时，如果要对方法进行重写，那么子类中的访问权限一定不能小于父类。</p><h3 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h3><h4 id="static修饰符"><a href="#static修饰符" class="headerlink" title="static修饰符"></a>static修饰符</h4><p>static修饰符用于修饰类方法和类变量。类方法和类变量无需实例化即可使用，存放在堆内存的静态区，其生命周期与类的生命周期一致。</p><p>被static修饰的方法和变量又叫做静态方法和静态变量：</p><ul><li>静态变量只能是static修饰的成员变量，该类的所有对象共享同一个静态变量，在一个对象中被改变，所有对象中均会改变（内存地址相同）。</li><li>静态方法是static修饰的方法，只能使用静态变量，或者通过传参获得变量。</li></ul><p><strong>静态方法和静态变量可以被继承但不可以被重写。</strong></p><h4 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h4><p>final修饰符主要可以对类、方法和变量起作用：</p><ul><li>final类无法被继承</li><li>final方法无法被重写</li><li>final变量无法被修改，可以与static一起创建类常量</li></ul><h4 id="abstract修饰符"><a href="#abstract修饰符" class="headerlink" title="abstract修饰符"></a>abstract修饰符</h4><p>abstract修饰符用于修饰抽象类和抽象方法：</p><ul><li>抽象方法：没有具体实现，等待子类的实现。一个抽象方法必须不能是final和static（因为需要被子类实现，必须可以被重写，final和static无法被重写）。以分号结尾。</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">SuperClass</span><span class="token punctuation">{</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//抽象方法</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">SuperClass</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//实现抽象方法</span>      <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>抽象类：抽象类不可以被实例化，只能等待子类的扩充，所以抽象类不能是final。如果一个类包含抽象方法，必须被声明为抽象类。继承了抽象类的子类必须实现父类的所有方法，除非它也是abstract的。</li></ul><h4 id="synchronized-修饰符"><a href="#synchronized-修饰符" class="headerlink" title="synchronized 修饰符"></a>synchronized 修饰符</h4><p>synchronized修饰符用于多线程编程中，Java的多线程编程后面会提及。</p><p>synchronized修饰符的作用是：修饰的方法只能同时被一个线程所访问。有些类似于操作系统中的互斥信号量，将整个方法声明为一个互斥区。</p><p>Java中的每个对象都拥有一个内置锁，当程序运行到对象的synchronized方法上时，自动获取当前对象的锁。由于一个对象只有一个锁，所以一个线程获得锁，就没有其他任何线程可以再访问该方法，将会阻塞在临界区外，直到该进程执行完该方法并退出，它才会释放锁。</p><p>Java中锁和同步的要点有以下几个：</p><ul><li>锁只能同步方法，不能同步类和对象。</li><li>每个类，每个对象都有一个锁，当在方法或者代码块中添加了synchronized关键字时，要访问这个方法或者这个代码块时就需要获取对应的锁，没有添加synchronized则不受影响。 </li><li>synchronized对应实例锁（对象锁），static synchronized对应全局锁 （类锁）。  实例锁定义在线程对象上，不被其他线程对象共享，而共享锁定义在线程类上，被所有线程对象所共享。</li><li>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。 </li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">BuyTicketThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 假设一共有5张票</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> ticket <span class="token operator">=</span> <span class="token number">5</span> <span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//有这些人进行抢票</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//判断是否有票</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 要对当前对象进行同步，获取当前对象的锁</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>ticket<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 还有票</span>                    <span class="token keyword">try</span><span class="token punctuation">{</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 加入延迟</span>                    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>InterruptedException e<span class="token punctuation">)</span><span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    ticket<span class="token operator">--</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//输出目前的票数</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"得到一张票，现在票数：ticket = "</span> <span class="token operator">+</span> ticket <span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BuyTicket</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 定义线程对象</span>        BuyTicketThread mt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BuyTicketThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 定义Thread对象代表不同的售票点</span>        Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>mt<span class="token punctuation">)</span> <span class="token punctuation">;</span>            Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>mt<span class="token punctuation">)</span> <span class="token punctuation">;</span>            Thread t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>mt<span class="token punctuation">)</span> <span class="token punctuation">;</span>            t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>        t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>synchronized关键字虽然是Java的内置特性，但它其实也有很大的不足：</p><ul><li>由于我们没办法设置synchronized关键字在获取锁的时候等待时间，所以synchronized可能会导致线程为了加锁而无限期地处于阻塞状态（<strong>死锁</strong>）。</li><li>使用synchronized关键字等同于使用了互斥锁，即其他线程都无法获得锁对象的访问权。这种策略对于读多写少的应用而言是很不利的，因为即使多个读者看似可以并发运行，但他们实际上还是串行的，并将最终导致并发性能的下降（<strong>损害并发性</strong>）。 </li></ul><p>我们在Java中可以使用java.util.concurrent.locks包下的各种LOCK机制进行并发控制，详细内容在 <a href="https://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3923167.html</a> ，找工作前需要好好看一下。</p><h4 id="transient-修饰符"><a href="#transient-修饰符" class="headerlink" title="transient 修饰符"></a>transient 修饰符</h4><p>transient修饰符主要用在Java的序列化中。Java的序列化和反序列化分别指的是把对象的状态转化为字节流和把字节流恢复成对象状态的机制，可以方便地对对象进行持久化存储和传输。我们需要先让类实现Serializable接口，再使用文件对象（File）构造文件输入/输出流（FileInputStream/FileOutputStream），再将其传入对象输入/输入流（ObjectInputStream/ ObjectOutputStream），才能进行序列化和反序列化。详细内容在：<a href="https://blog.csdn.net/qq_19782019/article/details/80422143" target="_blank" rel="noopener">https://blog.csdn.net/qq_19782019/article/details/80422143</a> 。</p><p>那么transient修饰符究竟有什么用呢？ 序列化的对象包含被 transient 修饰的实例变量时，JVM会跳过该特定的变量。也就是序列化过程中不会涉及此变量。 </p><h4 id="violatile修饰符"><a href="#violatile修饰符" class="headerlink" title="violatile修饰符"></a>violatile修饰符</h4><p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 </p><p>它的作用是保证了数据在各线程执行时的可见性。在读操作很多的读者-写者进程中，它的性能优于synchronized，因为synchronized关键字无法使读者进程并行。</p><p>violatile关键字无法保证数据的一致性 ，因为volatile不能保证操作的原子性 ，即使只是i++，实际上也是由多个原子操作组成：read i; inc; write i，假如多个线程同时执行i++，依然可能由于不同线程交替执行而出现写入脏数据的情况。  需要用sychronized，或者使用atomic类型（java.util.concurrent.atomic.*）设置原子操作 。下面是一个使用violatile的经典场景：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> active<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        active <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>active<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 第一行</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 代码</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        active <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 第二行</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>Java是一门面向对象语言，类和对象是它最为重要的概念之一。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>Java中对象的创建可以使用new关键字进行，创建完对象后，我们还需要声明一个<strong>引用</strong>来指向它。引用的概念有些类似于C++中的指针。new一个对象则是在堆内存中开辟一块空间。JVM的知识我会在另一篇博客中介绍。</p><ul><li>ArrayList li = new ArrayList（）；其中，等号前的部分为创建引用，后半部分为创建对象。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>Java的构造方法是<strong>创建对象</strong>时运行的方法，方法名通常是类名，用于初始化对象，且不需要指定返回值类型。</p><p> 如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个<strong>默认构造方法</strong>。 构造方法可以进行重载（Overload），即可以通过传入不同的参数执行不同的方法。</p><pre class="line-numbers language-python"><code class="language-python">public <span class="token keyword">class</span> <span class="token class-name">Puppy</span><span class="token punctuation">{</span>    public Puppy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    public Puppy<span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token operator">//</span> 这个构造器仅有一个参数：name    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="析构方法"><a href="#析构方法" class="headerlink" title="析构方法"></a>析构方法</h3><p>Java的析构方法是<strong>销毁对象</strong>时运行的方法，方法名为finalize，用于释放对象占用的相关资源，进行垃圾回收。每个类都默认继承了Object类中的finalize析构方法，且权限为protected。任何Java类都可以对析构方法进行重写，但一般不需要重写。</p><p>JVM中自带了<strong>垃圾回收器（ Garbage Collection ）</strong>，用于回收不再使用的资源，一般会自动执行回收。它调用被回收的对象的finalize析构方法，对其进行释放。但我们也可以调用System.gc（）或Runtime.gc（）进行显式地垃圾回收。</p><p>需要注意，Java代码对GC是不可见的，所以无论是自动还是我们在程序中调用，都不能保证百分之百释放掉所有垃圾。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Java中允许子类使用<strong>extends</strong>关键字继承父类，继承就是<strong>子类继承父类的属性（成员变量）和行为（方法）</strong>。一般来说，子类会有自己独有的属性和行为。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> 父类 <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">class</span> 子类 <span class="token keyword">extends</span> 父类 <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继承的好处是提高了代码的复用性，可以将相似的类共有的属性和行为放在父类中定义。</p><p>Java中的继承只支持多重继承，而不支持多继承。也就是说，Java中一个子类只能拥有一个父类。如果想要实现多重继承，可以使用接口的implements来实现。</p><p><img src="%E7%BB%A7%E6%89%BF.png" alt="继承"></p><h4 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h4><ul><li>子类继承父类所有非私有private的方法和成员变量。</li><li>子类可以额外拥有自己的属性和方法。</li><li>子类可以对父类的方法进行<strong>重写（Override）</strong>。</li><li>只支持单继承。</li><li>提高了代码的复用性，提高了代码的耦合性，但也降低了独立性，属于继承的缺点。</li></ul><h4 id="super和this关键字"><a href="#super和this关键字" class="headerlink" title="super和this关键字"></a>super和this关键字</h4><p>super关键字提供了<strong>当前类的父类的一个实例化对象的引用</strong>，而this关键字提供了<strong>当前类本身的一个实例化对象的引用</strong>。</p><h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>final关键字有如下作用：</p><ul><li>将类定义为不可以被继承（final类的方法自动变成final方法，但属性并不是final）</li><li>将方法定义为不可以被重写</li><li>将成员变量定义为不可以被修改</li></ul><h4 id="构造方法的继承"><a href="#构造方法的继承" class="headerlink" title="构造方法的继承"></a>构造方法的继承</h4><p>子类并不直接继承父类的构造方法，只是使用super（）的形式调用。</p><ul><li>如果父类的构造方法没有参数，且在子类的构造方法中没有显式地调用构造方法，那么系统将<strong>自动</strong>调用父类的无参构造方法。</li><li>如果父类的构造函数有参数，那么假如想在子类中调用父类的有参构造方法，必须显式地进行调用。</li></ul><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>方法的重载（Overload）指的是<strong>同一个类中，方法名一样，但方法的参数不一样</strong>，方法的返回类型可以相同也可以不同。</p><p>每个被重载的方法都必须有独一无二的参数，最常被使用的地方是构造方法的重载。</p><p>重载的规则：</p><ul><li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul><h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><p>方法的重写（Override）指的是<strong>子类对父类的允许访问的方法进行重新编写</strong>，方法名、参数、返回值都不改变。即外壳不变，子类中对核心重新书写。</p><p>重写的好处是子类可以根据需要重新定义自己的行为。</p><p>方法的重写规则如下：</p><ul><li>重写的方法不能抛出比被重写的方法更宽泛的异常。</li><li>重写的方法，方法名、参数列表必须和被重写的一致。</li><li>父类的成员方法只能被其子类重写。</li><li>重写的方法不能比被重写的方法访问权限更低。</li><li>声明为final的方法不能被重写。</li><li>声明为static的方法不能被重写，但是能被重新声明。</li><li><strong>构造方法不可以被重写，因为子类并不继承父类的构造方法，只是调用</strong>。</li></ul><h3 id="重写与重载之间的区别"><a href="#重写与重载之间的区别" class="headerlink" title="重写与重载之间的区别"></a>重写与重载之间的区别</h3><table><thead><tr><th align="center">区别点</th><th align="center">重载方法</th><th align="center">重写方法</th></tr></thead><tbody><tr><td align="center">参数列表</td><td align="center">必须修改</td><td align="center">一定不能修改</td></tr><tr><td align="center">返回类型</td><td align="center">可以修改</td><td align="center">一定不能修改</td></tr><tr><td align="center">异常</td><td align="center">可以修改</td><td align="center">可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td align="center">访问</td><td align="center">可以修改</td><td align="center">一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table><p>重写与重载都是Java中多态性的表示方式，重写表示的是父类与子类间的多态性，而重载表示的是类内部的多态性。</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包（package）机制的作用是：</p><ul><li>将功能相似或者相关的类或者接口放在同一个包下，无需import关键字引用，可以方便调用。</li><li>不同包下可以拥有同名的类和接口，减少了命名冲突问题。相当于C++中创建了新的namespace命名空间。</li><li>包可以设置访问权限。</li></ul><p>包的声明通常位于Java文件的开头，每个源文件只能有一个包声明。如果某个源文件中没有包声明，那么该文件中的类、接口、枚举、注释等将被放在无名包中（unnamed package）。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/* 文件名: Animal.java */</span><span class="token keyword">package</span> animals<span class="token punctuation">;</span><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">travel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在当前类中需要引用其他包中类的方法（必须是public权限），则需要使用import先将包导入。</p><p>我们可以使用通配符“*”导入某个包中全部的类，如：</p><blockquote><p> import java.util.*; </p></blockquote><p>也可以使用类全名描述导入某个包中特定的类，如：</p><blockquote><p> import java.util.Scanner; </p></blockquote><p>需要注意：当一个类放在某个包下时，包名会成为类全名的一部分。在包外调用这个类，需要使用类全名。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统全部笔记</title>
      <link href="/2020/05/14/cao-zuo-xi-tong-quan-bu-bi-ji/"/>
      <url>/2020/05/14/cao-zuo-xi-tong-quan-bu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统笔记"><a href="#操作系统笔记" class="headerlink" title="操作系统笔记"></a>操作系统笔记</h1><p>本文是我在学习操作系统过程中的总结与笔记。</p><h2 id="操作系统基本知识"><a href="#操作系统基本知识" class="headerlink" title="操作系统基本知识"></a>操作系统基本知识</h2><h3 id="操作系统简介"><a href="#操作系统简介" class="headerlink" title="操作系统简介"></a>操作系统简介</h3><p>操作系统是<strong>管理计算机硬件</strong>的程序，它为<strong>应用程序</strong>提供基础，并且充当<strong>计算机用户和计算机硬件</strong>的中介（可以看做是一种<strong>资源分配器</strong>）</p><p>它的具体定义为：</p><blockquote><p>操作系统是<strong>一直运行在计算机上</strong>的程序（通常称为<strong>内核</strong>，kernel，<strong>常驻于内存</strong>）， 除了内核部分外，还有其他两类程序，分别是<strong>系统程序</strong>（与系统运行有关的程序，如某些驱动程序）和<strong>应用程序</strong>（与系统运行无关的程序，如 QQ 等） </p></blockquote><p>下图为计算机系统组件的抽象层次结构：</p><p><img src="%E6%8A%BD%E8%B1%A1%E5%B1%82%E6%AC%A1.png" alt="计算机系统组件抽象层次结构"></p><p>可以看到，从底层到顶层依次为：</p><p>计算机硬件——&gt;<strong>操作系统-</strong>——&gt;系统程序和应用程序——–&gt;用户</p><p>所以操作系统是计算机硬件和用户的媒介，是应用程序和系统程序的基础。</p><h3 id="操作系统设计目的"><a href="#操作系统设计目的" class="headerlink" title="操作系统设计目的"></a>操作系统设计目的</h3><p>操作系统的设计目的主要分为：</p><ul><li>核心目标：<strong>运行用户程序</strong></li><li>面向用户：<strong>方便性</strong></li><li>面向系统：<strong>高效性</strong></li></ul><p>需要注意的是，不同操作系统具有不同的设计目的，例如：</p><ul><li>PC用户：关注方便性、易用性、高性能，而不关注资源利用率。</li><li>主机用户：关注资源利用率，因为要同时满足所有用户需求。</li><li>工作站用户：性能和资源利用率折中。</li><li>手持设备用户：方便、续航时间。</li><li>……</li></ul><h3 id="现代计算机系统的组成"><a href="#现代计算机系统的组成" class="headerlink" title="现代计算机系统的组成"></a>现代计算机系统的组成</h3><p>现代计算机系统由以下几个主要部分组成：</p><ul><li>一个或多个中央处理器<strong>CPU</strong></li><li>若干个<strong>设备控制器</strong>（如磁盘控制器，图形适配器，USB控制器等）</li><li><strong>总线</strong></li></ul><p>多个设备控制器可以<strong>并行工作</strong>，竞争访问内存，需要<strong>内存控制器</strong>的协调。</p><p>每个设备控制器都有一个<strong>缓冲</strong>（Buffering)，用于：</p><ul><li>解决设备间传输速度的不匹配</li><li>减少中断频率</li><li>提高并行性</li></ul><p>CPU在<strong>内存和本地缓冲</strong>之间传输数据，I/O控制器从<strong>设备和本地缓冲</strong>之间传输数据。I/O控制器可以通过<strong>调用中断</strong>通知CPU完成了操作。</p><p>操作系统是<strong>中断驱动</strong>的。</p><h3 id="现代计算机系统的体系结构"><a href="#现代计算机系统的体系结构" class="headerlink" title="现代计算机系统的体系结构"></a>现代计算机系统的体系结构</h3><ul><li><p><strong>单</strong>处理器系统：只有<strong>一个</strong>通用CPU。</p></li><li><p><strong>多</strong>处理器系统：也叫多核系统或者并行系统，有<strong>两个或多个CPU</strong>紧密通信，共享计算机总线、时间、内设和外存。是<strong>紧耦合</strong>的，只有<strong>一个</strong>独立系统。</p><ul><li>优点：<ul><li>增加<strong>吞吐量</strong>。</li><li><strong>规模经济</strong>。</li><li>增加<strong>可靠性</strong>。（一台电脑多个CPU，肯定比多台单CPU电脑要便宜，且更可靠）</li></ul></li><li>类型：<ul><li><strong>ASMP非对称处理</strong>：CPU具有主从关系，主处理器用户协调各从处理器。</li><li><strong>SMP对称处理</strong>：所有CPU参与操作系统的全部任务</li></ul></li></ul></li><li><p><strong>集群</strong>系统：也是一种类型的多处理器系统，但是它是通过将<strong>多个</strong>独立的计算机系统通过<strong>网络</strong>相连接，进行<strong>并行计算</strong>，从而提高处理性能。它是<strong>松耦合</strong>的。</p><p>（集群系统和多处理器系统的区别）</p></li></ul><h3 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h3><ul><li><p>批处理系统：</p><ul><li><p>单道程序系统：内存中同时只能驻留<strong>一个</strong>外部应用程序，当进程需要进行I/O操作，CPU一直进入等待状态，<strong>CPU利用率低</strong>。</p></li><li><p>多道程序系统：内存中同时存在<strong>多道</strong>作业，通过管理程序控制<strong>穿插运行</strong>（CPU调度），使得 CPU 总有一个执行作业，从而<strong>提高 CPU 利用率</strong>。</p><blockquote><p>操作系统先将作业（进程）保存在磁盘上的<strong>作业池</strong>中，内存中的作业集为磁盘上的作业集的<strong>子集</strong>。操作系统从内存的作业集中选择一个执行。对于单道程序系统，当CPU执行到某个作业的某些任务，例如I/O操作时，需要使CPU进入等待状态，等待该任务的执行完成，从而陷入空闲的状态。而多道程序系统会自动在等待时切换到另一个作业，使CPU始终有作业在执行。</p></blockquote><p>（这里是<strong>并发作业</strong>，而非并行作业！并行指的是多处理器系统）</p><p>（单道程序系统和多道程序系统都属于：批处理系统，缺点是<strong>缺少交互性</strong>）</p></li></ul></li><li><p><strong>分时系统</strong>：分时系统是多道程序设计的自然延伸。采用<strong>时间片轮转（RR）</strong>的方式同时为<strong>多个用户</strong>服务，经常用于<strong>服务器</strong>。一种<strong>联机的多用户交互式的操作系统</strong>。每个用户获得一个时间片并运行，保证用户获得足够小的响应时间，并提供<strong>交互能力</strong>。若某个作业在分配的时间片用完之前计算还未完成，该作业就暂时中断，等待下一轮;此时，处理机让给另一个作业使用。每个用户好象实时独占一台计算机。（由于时间片小，但其实只是用户的错觉，并不是实时独占的）切换频率很高（响应时间小于 1s）。</p><p>​    （Unix就是一种著名的分时系统，所以服务器上经常使用Unix系统。）</p></li></ul><h3 id="并发VS并行"><a href="#并发VS并行" class="headerlink" title="并发VS并行"></a>并发VS并行</h3><p>并发：<strong>多个作业</strong>在<strong>同一时间间隔</strong>内在<strong>同一处理器</strong>上<strong>交替</strong>运行。常见于<strong>多道程序设计</strong>。</p><p>并行：<strong>多个作业</strong>在<strong>同一时刻</strong>在<strong>不同处理器</strong>上<strong>同时</strong>运行，常见于<strong>多处理器系统</strong>。</p><h3 id="操作系统的主要操作和功能"><a href="#操作系统的主要操作和功能" class="headerlink" title="操作系统的主要操作和功能"></a>操作系统的主要操作和功能</h3><p>操作系统的主要操作有：</p><ul><li>双模式</li><li>I/O和内存保护</li><li>定时器</li></ul><p>操作系统的主要功能有：</p><ul><li>进程管理</li><li>内存管理</li><li>文件管理</li><li>I/O系统管理</li></ul><h4 id="双模式"><a href="#双模式" class="headerlink" title="双模式"></a>双模式</h4><p>双模式将操作系统的运行模式分为了两种模式，使用<strong>模式位</strong>来控制：</p><ul><li><strong>用户模式</strong>（用户态）：执行用户代码。</li><li><strong>内核模式</strong>（核心态）：执行系统代码。</li></ul><p>双模式的作用是<strong>确保操作系统正确运行</strong>，区分系统代码和用户代码的执行，防止操作系统受到错误应用程序的损害而崩溃。</p><p>双模式最主要的用处是<strong>将特权指令放在内核模式下运行</strong>，从而保证了内核的安全。</p><p>特权指令是：<strong>可能引起损害的机器指令</strong>，如：I/O操作、定时器管理、中断管理等。</p><p>常用的使用特权指令的方法为：<strong>系统调用（System Call）</strong>。一般视为<strong>软件中断</strong>，是操作系统封装好的方法。从用户模式切换至内核模式（陷阱模式位=0），执行完特权指令后再从内核模式返回至用户模式（返回模式位=1）（2 次切换） </p><p><img src="%E5%8F%8C%E6%A8%A1%E5%BC%8F.png" alt="系统调用"></p><p>系统调用是一种软件中断，提供操作系统服务<strong>编程接口</strong>，只能在<strong>核心态</strong>运行。这些调用通常以 C 或 C++编写， 如果是底层任务通常以汇编语言指令编写。主要包括：进程控制、 文件管理、设备管理、信息维护、通信、保护。（java 系统调用在不同的操作系统中不用改变指令，是因为它采用了 JVM 技术） </p><p>常见的系统调用API有：</p><ul><li>Windows的<strong>Win32 API</strong></li><li>POSIX系统（包括所有版本的Unix、Linux、Mac os）的<strong>POSIX API</strong></li><li>JVM的<strong>Java API</strong></li></ul><h4 id="I-O保护"><a href="#I-O保护" class="headerlink" title="I/O保护"></a>I/O保护</h4><p>目的：防止用户程序执行非法I/O。</p><p>做法：将所有I/O指令设置为特权指令，只能通过系统调用在核心态运行。</p><h4 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h4><p>目的：防止内存非法访问。</p><p>做法：存储保护机制、硬件支持。</p><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>目的：防止用户程序进入死循环，或者不执行系统调用且不将控制权返还给操作系统。</p><p>做法：使用固定速率的时钟或者计数器实现，在指定周期后中断计算机。</p><h3 id="操作系统的主要服务"><a href="#操作系统的主要服务" class="headerlink" title="操作系统的主要服务"></a>操作系统的主要服务</h3><p>操作系统的服务：（两类） ：</p><ul><li><p>用户功能服务（基本服务）： </p><ul><li>用户界面 （第一个GUI系统：<strong>Xerox Alto</strong>)</li><li>I/O 操作 </li><li>文件系统操作 </li><li>通信 </li><li>错误检测 </li></ul></li><li><p>操作系统服务（增值服务）：  </p><ul><li>资源分配 </li><li>记账 </li><li>保护与安全c） </li></ul></li><li><p>服务形式： </p><ul><li>系统调用(System Call) </li><li>用户接口(User Interface) </li><li>系统程序(System Program)</li></ul></li></ul><h3 id="操作系统主要的设计思想"><a href="#操作系统主要的设计思想" class="headerlink" title="操作系统主要的设计思想"></a>操作系统主要的设计思想</h3><ul><li><p>简单结构：</p><ul><li><strong>MS-DOS</strong>是最早的操作系统，采用了简单结构，没有很好的区分接口和层次，导致很容易崩溃。</li><li>单片结构：操作系统由<strong>内核和系统程序</strong>两个独立的部分组成，<strong>系统调用接口和内核通信</strong>开销较小，UNIX、LINUX、Windows操作系统中都有采用。</li></ul></li><li><p>分层结构：</p><ul><li>操作系统划分为<strong>若干层</strong>，每层只使用更底层的功能和服务，最底层为硬件层，最高层为用户层，类似于计算机网络OSI分层体系。</li><li>好处是<strong>简化了系统的设计与实现，便于调试和升级维护</strong>。</li><li>缺点是<strong>效率较差</strong>。</li><li>MAC OS X 中有采用，THE系统有采用。</li></ul></li><li><p>微内核：</p><ul><li>将<strong>不必要的功能</strong>从内核中移除，将其作为系统级和用户级的程序实现。内核只提供<strong>最小的进程、内存管理和通信等功能</strong>。</li><li>好处是便于扩充微内核，便于移植操作系统到新架构系统上，更稳定（更少的代码运行在核心态），更安全。</li><li>缺点是<strong>通信开销增加</strong>，性能受损。（微内核采用<strong>消息传递机制</strong>进行缓解）</li><li>Mac OS X中使用了Mach微内核、QNX采用，WindowsNT及后续版本采用。</li></ul></li><li><p>模块化：</p><ul><li>采用<strong>可加载的模块</strong>，内核只提供核心服务，其他服务采用<strong>模块链接</strong>的方式实现。</li><li>优点：<ul><li>类似于分层系统，其中每个内核部分都有接口。但它更加<strong>灵活</strong>，因为每个内核模块都可以调用其他模块，而非只能上层模块调用下层模块。</li><li>利用<strong>动态链接</strong>服务，优于直接添加服务至内核中，不需要重新编译内核。</li><li>类似于微内核系统，内核只提供核心服务，并知道如何加载模块以及如何让模块进行通信。但更为有效，无需利用消息传递来进行通信，而是<strong>直接动态加载模块。</strong> </li></ul></li><li>Solaris系统、现代Unix和Windows中都采用了模块化思想。</li></ul></li><li><p>混合结构：</p><ul><li>实际上，几乎所有操作系统都使用了混合的设计结构。例如：Linux 和 Solaris 既采用单片结构，也采用模 块化。Windows 采用了单片、模块化、微内核等。</li></ul></li></ul><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>虚拟机是：通过<strong>软件模拟</strong>实现，具有<strong>完整硬件系统功能</strong>，运行在一个<strong>完全隔离的环境</strong>中的完整计算机系统。</p><p>常见的虚拟机有以下几类：</p><ul><li><strong>高级语言虚拟机</strong>：提供高级语言执行的<strong>环境</strong>，用于<strong>跨平台</strong>。常见的有：JVM（java虚拟机）。</li><li><strong>工作站虚拟机</strong>：用于工作站或者PC机上，实现了<strong>一个宿主操作系统上可以运行多个客户操作系统</strong>。也是我们通常所说的“虚拟机”。</li><li><strong>服务器虚拟机</strong>：用在服务器上，实现了多用户、多操作系统并存，将<strong>一个物理服务器虚拟化为多个服务器。</strong></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h3><ul><li><strong>作业</strong>：被组装成一个整体的一组计算步骤，既可以指进程，也可以指线程。</li><li><strong>任务</strong>：Linux中不区分线程和进程，统一称为任务（jobs）。</li><li><strong>进程</strong>：一个程序在一个数据集上的一次运行，是<strong>执行的程序</strong>，是程序的<strong>实例</strong>。它包括：<ul><li>代码</li><li>当前活动：<ul><li><strong>程序计数器</strong>：指向当前要执行的指令地址</li><li><strong>栈</strong>：存放函数参数、临时变量等临时数据</li><li><strong>堆</strong>：动态分配内存</li><li><strong>数据</strong>：全局变量、要处理的文件等</li></ul></li></ul></li><li><strong>程序</strong>：是进程的代码部分。</li></ul><p>进程与程序的区别在于：</p><ul><li>程序是<strong>被动实体</strong>，存放在<strong>外存</strong>上，是<strong>静止</strong>的。</li><li>进程是<strong>活动实体</strong>，存放在<strong>内存</strong>中，是<strong>活动</strong>的，具有程序计数器和一组相关资源。</li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>进程的<strong>五状态图</strong>（非常重要）：</p><p><img src="%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="进程状态"></p><p>进程主要有以下五种状态：</p><ul><li><strong>新建</strong>（new）：进程正在被创建，位于<strong>外存</strong>上。</li><li><strong>就绪</strong>（ready）：进程<strong>等待分配CPU</strong>。主要有三种转移：<ul><li>新建到就绪：操作系统将被创建好的进程调入<strong>内存</strong>中（<strong>长程调度</strong>）（admitted)</li><li>运行到就绪：进程被<strong>中断</strong>（interrupt）</li><li>等待到就绪：进程等待的I/O操作或者事件被完成</li></ul></li><li><strong>运行</strong>（running）：进程正在CPU上执行。主要由就绪态的进程，通过操作系统的进程调度，分配处理器并执行。</li><li><strong>等待</strong>（waiting）：进程等待I/O或事件的完成。</li><li><strong>终止</strong>（terminated）：进程结束执行。</li></ul><h3 id="进程数据结构"><a href="#进程数据结构" class="headerlink" title="进程数据结构"></a>进程数据结构</h3><p><strong>进程控制块</strong>：操作系统中的进程表示方式采用PCB，即进程控制块。进程的所有信息存放在进程控制块中，每个进程都有一个进程控制块。<strong>Linux中，使用进程创建原语创建进程，本质上就是为一个进程创建PCB。</strong>Linux使用<strong>task_struct的双向链表</strong>表示进程控制块。可用于<strong>进程上下文切换的保存现场和恢复现场</strong>。</p><p><img src="PCB" alt="PCB中的信息"></p><p><strong>进程环境块</strong>：PEB，位于<strong>用户空间</strong>中，存放进程的运行环境。</p><h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>进程上下文切换指<strong>切换 CPU 到另一个进程需要保存当前进程状态和恢复另一个进程的状态</strong>。</p><ul><li>中断导致 CPU 从执行当前任务改变到执行内核程序。进程上下文切换采用进程 PCB 表示。先通过执行状态保存，保存 CPU 当前状态（包括内核模式和用户模式）之后，状态恢复重新开始运行。</li><li>速度与硬件支持密切相关。</li><li>单任务操作系统不需要进行进程上下文切换，因为只有一个进程。</li></ul><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>进程在运行过程中可以创建多个进程，创建进程为父进程，被创建的进程为子进程：</p><ul><li>子进程和父进程的进程标识符PID不一样。<strong>每个进程的PID唯一</strong>。</li><li>资源可能：<strong>子进程的资源可以直接获得，也可以是父进程的子集。</strong>限定子进程只分配父进程的资源子集，可以防止创建过多进程而导致系统超载。</li><li>执行可能：子进程可以与父进程<strong>并发执行</strong>，也可以让父进程<strong>等待</strong>子进程执行完毕，再将其资源释放（<strong>wait函数</strong>）。</li><li>地址空间可能：<ul><li>子进程是父进程的复制品。（类UNIX操作系统）</li><li>子进程加载另一个新程序。（Windows）</li></ul></li></ul><p>Linux中与进程创建相关的函数有：</p><ul><li>fork函数：类UNIX系统采用<strong>fork函数</strong>创建子进程，fork函数创建的子进程的地址空间完全是父进程的共享。但类UNIX系统支持<strong>写时拷贝（COW）</strong>，即：起初父子进程除了PID不同，其余大部分资源都是由父进程共享给子进程的。<strong>而当子进程想要修改地址空间时，操作系统会分配新的地址空间给它。</strong><ul><li>fork函数一次调用，两次返回：<ul><li>在父进程中返回的值为子进程的PID</li><li>在子进程中返回的值为0</li><li>创建子进程失败则为-1</li></ul></li></ul></li><li>vfork函数：使用vfork函数创建子进程，子进程的资源完全共享自父进程的资源，<strong>修改子进程的地址空间，会使父进程的地址空间也发生改变。</strong></li><li>wait函数：wait函数一般用在父进程中，用于<strong>等待子进程执行完成</strong>。当子进程执行完毕后，会调用系统调用<strong>exit函数</strong>请求系统删除自身的相关资源。此时父进程的wait函数可以接收到其状态值的返回，并<strong>将子进程在PCB表中的条目完全释放</strong>。</li><li>abort函数：父进程可以使用abort函数<strong>终止</strong>子进程的执行。</li></ul><p>三种资源拷贝方式：</p><ul><li>共享：共享同一资源，如虚存空间、文件等。仅增加有关描述符的用户计数器。类似于Python中的引用。</li><li>直接拷贝：相同的结构，原样复制。类似于Python中的深拷贝。</li><li>写时复制COW：一开始引用，在需要的时候才深拷贝。</li></ul><h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>当进程执行完最后的语句并且通过<strong>系统调用 exit函数</strong>请求操作系统删除自身时， 即为<strong>进程终止</strong>。此时，利用父进程的系统调用 wait函数可以接收到其状态值的返回。</p><ul><li><strong>级联终止</strong>：有些系统中，一旦父进程终止，所有子进程都要被终止。</li><li><strong>僵尸进程</strong>：一个子进程在终止后，会调用exit函数释放自己占用的资源。<strong>但它在PCB表中的条目依然还是存在的，这需要父进程使用wait函数将其释放</strong>。如果一个子进程结束后，其父进程没有及时调用wait函数释放它在PCB表中的条目，在这段时间里，子进程处于僵尸进程状态。子进程需要等待父进程终止后，<strong>被跟进程init收管并释放</strong>。<ul><li><strong>僵尸进程的父进程必然是存在的</strong>，否则它将变为孤儿进程。所以解决僵尸进程的办法是<strong>杀死它的父进程。</strong></li><li>由于僵尸进程在PCB中占用了大量条目，所以如果大量的产生僵尸进程，将因为没有<strong>可用的进程号</strong>而导致系统不能产生新的进程 。</li></ul></li><li><strong>孤儿进程</strong>：如果子进程还在执行时，父进程已经提前终止了，那么此时子进程处于孤儿进程状态。Linux系统会自动将孤儿进程收养为跟进程init的子进程，并由它定时释放孤儿进程。</li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>如果一个进程与其他进程不能相互影响，则它是独立的；反之它是协作的。协作的目的主要有：<strong>信息共享、计算加速、模块化、方便</strong>。协作进程需要有一种进程间通信机制（IPC），以<strong>允许进程相互交换数据与信息</strong>。</p><p>进程通信的主要方式有：</p><ul><li><p><strong>共享内存</strong>：利用<strong>通信进程</strong>创建<strong>共享内存区域</strong>，由其他想要进行通信的进程将其附加到自己的逻辑内存空间。需要进行<strong>访问控制</strong>，通常与<strong>信号量</strong>搭配使用。（一般用于<strong>大数据通信</strong>，<strong>远程通信无法采用共享内存</strong>）</p><ul><li>不需要频繁地进行内核态和用户态的切换，<strong>速度最快</strong>，但共享内存是<strong>临界资源</strong>，需要保持同步控制。</li><li>可实现<strong>双向通信</strong>。</li></ul></li><li><p><strong>消息传递</strong>：操作系统提供机制，在进程之间创建通信链路，从而进行消息传递。可以用于<strong>远程通信</strong>。消息传递分为<strong>直接通信</strong>和<strong>间接通信</strong>两种方式。直接通信不需要中间媒介，直接传输，但会造成<strong>有限模块化</strong>的缺点，因为需要显式地声明接收者和发送者的进程ID。间接通信一般使用共享的<strong>邮箱或者端口</strong>进行信息传递。一般可以使用共享的<strong>消息队列</strong>实现间接通信。</p><ul><li>消息队列可以认为是一个<strong>全局的一个链表</strong>，链表节点钟存放着数据报的类型和内容，有消息队列的标识符进行标记。 </li><li>消息队列允许一个或多个进程<strong>写入或者读取消息</strong>，可以是同步地（阻塞）也可以是异步地（非阻塞）。</li><li>消息队列可实现<strong>双向通信，容量有限</strong>。  </li></ul></li><li><p><strong>管道</strong>（PIPE）：管道可以看作是一种<strong>特殊的文件</strong>，对于它的读写也可以使用read、write等方式，但它本质上只存在于<strong>内存</strong>中，而不是文件系统中。管道主要分为：</p><ul><li><strong>匿名管道</strong>：在内存中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，<strong>没有名称</strong>，只能用于<strong>父子进程</strong>之间通信。</li><li><strong>命名管道</strong>（FIFO）： 在内存中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，但有独特的名称，可以用于<strong>不相关进程</strong>的通信。</li><li><strong>管道面向字节流，自带同步互斥机制，且是单向的。它速度较慢且容量有限</strong></li></ul></li><li><p><strong>套接字</strong>（Socket）：通常用于进程之间的网络通信，可以用在不同机器之间。需要指明IP地址和端口。</p></li><li><p><strong>信号量</strong>（semophore）： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种<strong>锁机制</strong>，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 </p></li><li><p><strong>远程过程调用</strong>（RPC）：也是一种进程网络通信的方式。</p></li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是<strong>CPU调度的基本单位</strong>，在Linux中，它被认为是一种<strong>轻量级的进程</strong>。</p><p>线程（Thread）<strong>由进程</strong>（Process）创建而来，同一进程中的多个线程共享：</p><ul><li>代码</li><li>数据</li><li>其他操作系统资源</li></ul><p>同一进程中的多个线程独占：</p><ul><li><p>线程ID</p></li><li><p>堆栈</p></li><li><p>寄存器组</p></li><li><p>程序计数器</p></li></ul><p><strong>可以看到，那些在程序运行过程中需要频繁改变的资源，往往是各线程独占的，而不变的资源，往往是线程共享的，位于进程之上。</strong></p><p>线程的优点在于<strong>切换开销小</strong>，同一进程的多个线程之间相互切换，不需要切换资源。</p><h4 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h4><p>线程和进程的区别主要在于：</p><ul><li>代码：进程往往包含线程，<strong>线程往往是进程中的一段代码。</strong></li><li>资源：<strong>进程是资源分配的基本单位</strong>；<strong>线程不拥有资源</strong>，而是通过进程向 CPU 申请</li><li>调度：同一进程中的线程切换不会引起进程切换；<strong>线程是 CPU 的基本调度单位</strong></li><li>切换：进程上下文切换<strong>开销大</strong>，线程因为资源共享，所以上下文切换<strong>开销小</strong></li><li>生命周期：进程撤销会导致它的所有线程撤销；线程撤销不会导致进程撤销 </li></ul><h4 id="多线程编程的优点"><a href="#多线程编程的优点" class="headerlink" title="多线程编程的优点"></a>多线程编程的优点</h4><ol><li><strong>响应度高</strong>：因为线程创建和切换的速度快，例如Web浏览器的多个窗口。</li><li><strong>资源共享</strong>：进程中的线程可以共享进程资源。</li><li><strong>经济性</strong>：线程创建、上下文切换比进程快，开销更小。</li><li><strong>可伸缩性</strong>。</li></ol><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p>提供线程支持的方法主要有：</p><ul><li><strong>用户线程</strong>：位于<strong>用户空间</strong>，它的创建和管理无需内核支持，对内核是不可见的。常见的用户线程库有：<strong>Pthreads（类UNIX系统）和Java线程库。</strong></li><li><strong>内核线程</strong>：位于<strong>内核空间</strong>，由操作系统内核直接进行支持和管理，现代操作系统均支持内核线程。常见的内核线程库有：<strong>Win32线程库</strong>。</li></ul><p>常见的操作系统多线程模型有：</p><ul><li><strong>多对一模型</strong>：<ul><li><strong>多个用户线程对应一个内核进程</strong>。进程中的用户线程由进程自己管理。一个进程中的多个线程只能运行在一个处理器上，<strong>并发性较差</strong>。</li><li>进程内线程切换不会导致进程切换。<strong>一个线程的阻塞系统调用会导致整个进程阻塞</strong>。并且，多对一模型不支持多处理核系统，一般用于不支持内核线程的单核操作系统。</li><li>例子：<ul><li>Solaris Green Threads </li><li>GNU Portable Threads</li></ul></li></ul></li><li><strong>一对一模型</strong>：<ul><li><strong>一个用户线程映射到一个内核线程</strong>。</li><li><strong>并发性好</strong>，允许线程并行允许在多处理核系统上。</li><li>是创建一个用户线程就要创建一个内核线程，<strong>开销较大</strong>。</li><li>例子：<ul><li>Windows</li></ul></li></ul></li><li><strong>多对多模型</strong>：<ul><li><strong>多个用户线程映射为相等或更小数目的内核线程</strong>，并发性和效率兼顾， 但<strong>增加了复杂度</strong>。</li></ul></li></ul><h3 id="多进程编程与多线程编程的对比"><a href="#多进程编程与多线程编程的对比" class="headerlink" title="多进程编程与多线程编程的对比"></a>多进程编程与多线程编程的对比</h3><table><thead><tr><th>维度</th><th>多进程</th><th>多线程</th></tr></thead><tbody><tr><td>数据共享、同步</td><td>各进程之间数据独立，共享复杂，需要进行IPC。同步简单。</td><td>各线程之间共享数据，共享简单。同步复杂。</td></tr><tr><td>内存、CPU</td><td>占用内存多、切换开销大，CPU利用率低。</td><td>占用内存少、切换开销小，CPU利用率高。</td></tr><tr><td>创建销毁、切换</td><td>创建销毁、切换开销大，复杂</td><td>创建销毁、切换开销小，简答</td></tr><tr><td>编程调试</td><td>编程简单，调试简单</td><td>编程复杂，调试复杂（难以定位是哪个线程出现问题）</td></tr><tr><td>可靠性</td><td>进程间不会相互影响</td><td>线程间会相互影响，一个线程的崩溃会导致所有线程的崩溃</td></tr><tr><td>分布式</td><td>适用于多核分布，也适用于多机分布的集群系统</td><td>只适用于多核分布</td></tr></tbody></table><h3 id="Java多线程编程的方式"><a href="#Java多线程编程的方式" class="headerlink" title="Java多线程编程的方式"></a>Java多线程编程的方式</h3><h4 id="继承Thread类，实现多线程"><a href="#继承Thread类，实现多线程" class="headerlink" title="继承Thread类，实现多线程"></a>继承Thread类，实现多线程</h4><p> java里面提供了一个<strong>java.lang.Thread</strong>的程序类，那么一个类只要继承了此类就表示这个类为线程的主体类，<br>但是并不是说这个类就可以实现多线程处理了，因为还需要重写Thread类中提供的一个run（）方法（public void run（）），而这个方法就属于线程的主方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//线程主体类</span>    <span class="token keyword">private</span> String title<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MyThread</span><span class="token punctuation">(</span>String title<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//线程的主体方法</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">+</span> <span class="token string">"运行，x = "</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 多线程要执行的功能，都应该在run（）方法中进行定义，但是需要说明的是：在正常情况下，如果要想使用一个类中的方法，那么肯定要产生实例化对象，而后去调用类中提供的方法，但是run()方法不能直接调用的，因为这牵扯到<strong>一个操作系统的资源调度问题</strong>，所以要想启动多线程必须使用<strong>start（）</strong>方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"线程A"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"线程B"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"线程C"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用start（）方法的原因是：它的源代码中定义了异常，<strong>可以防止一个线程被重复启动</strong>。</p><pre class="line-numbers language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>threadStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 判断线程的状态</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 抛出一个异常</span>        group<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> started <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">start0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//  在start（）中调用了start0（）</span>            started <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>started<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    group<span class="token punctuation">.</span><span class="token function">threadStartFailed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">start0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Thread.png" alt="Thread的执行分析"></p><h4 id="基于Runnable接口实现多线程"><a href="#基于Runnable接口实现多线程" class="headerlink" title="基于Runnable接口实现多线程"></a>基于Runnable接口实现多线程</h4><p> 虽然可以通过Thread类的继承来实现多线程的定义，但是在Java程序里面对于继承永远都是存在有<strong>单继承局限</strong>的，所以在Java里面又提供有第二种多线程的主体定义结构形式：实现<strong>java.lang.Runnable接口</strong>，此接口定义如下： </p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span>    <span class="token comment" spellcheck="true">// 从JDK1.8引入了Lambda 表达式之后就变为了函数式接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 通过Runnable 实现多线程的主体类 ：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//线程主体类</span>    <span class="token keyword">private</span> String title<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MyThread</span><span class="token punctuation">(</span>String title<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//线程的主体方法</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">+</span> <span class="token string">"运行，x = "</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个实现了Runnable接口的线程主体类不能直接启动线程，它只能<strong>作为Thread类的构造函数 public Thread(Runnable target)的参数</strong>，实例化一个Thread对象，然后使用start（）方法启动线程。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread threadA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"线程A"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread threadB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"线程B"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread threadC <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"线程C"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadA<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadB<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadC<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基于Runnable接口的多线程，相当于兜了一个圈子<strong>解决了Java语言单继承的局限性</strong>，应该被优先考虑。</p><p>从JDK1.8开始，Runnable接口使用了<strong>函数式接口定义</strong>，所以也可以直接利用<strong>Lambda表达式</strong>进行线程类的实现定义。 </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">3</span> <span class="token punctuation">;</span> x <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String title <span class="token operator">=</span> <span class="token string">"线程对象-"</span> <span class="token operator">+</span> x<span class="token punctuation">;</span>                Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> y <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>title <span class="token operator">+</span> <span class="token string">"运行，y = "</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>                <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Thread-与-Runnable-的关系"><a href="#Thread-与-Runnable-的关系" class="headerlink" title="Thread 与 Runnable 的关系"></a>Thread 与 Runnable 的关系</h4><p><strong>Thread类其实也是Runnable 接口的子类</strong>，那么在之前继承Thread类的时候对run方法的重写实际上<strong>等同于在实现Runnable接口的run方法</strong>。 </p><p>多线程的设计之中，使用了代理设计模式的结构，用户自定义的线程主体只是负责项目核心功能的实现，而所有的辅助实现全部交给Thread类来处理。 </p><p> 多线程开发的本质实质上是在于多个线程可以进行共享资源的抢占，那么<strong>Thread主要描述的是线程，那么资源的描述是通过Runnable完成的</strong>。 </p><p><img src="%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt="代理模式"></p><h3 id="Callable实现多线程"><a href="#Callable实现多线程" class="headerlink" title="Callable实现多线程"></a>Callable实现多线程</h3><p>从最传统的开发来讲如果要进行多线程的实现肯定依靠的就是Runnable，但是Runnable接口有一个缺点：<strong>当线程执行完毕后，我们无法获取一个返回值</strong>，所以从JDK1.5之后就提出了一个新的线程实现接口：<strong>java.util.concurrent.Callable接口</strong>。首先观察这个接口的定义：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token keyword">public</span> V <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现Callbale定义的时候可以设置一个泛型，此泛型的类型就是返回数据的类型，这样的的好处是可以避免向下转行所带来的安全隐患。 </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread2</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> x <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"******线程执行，x = "</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token string">"线程执行完毕！"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">demo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        FutureTask futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程返回值："</span> <span class="token operator">+</span> futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Runable与Callable接口的区别是：</p><ul><li>Runable接口只有Run方法，<strong>且返回值类型为Void类型，没有返回值</strong>。</li><li>Callable接口支持Call方法，<strong>返回值类型可以自己设置，线程执行完毕后我们可以得到一个返回值。</strong></li></ul><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h3><p><strong>周转时间</strong>：进程从<strong>提交</strong>（新建队列到就绪队列）到结束运行的全部时间（提交不等于开始运行，可能还需要等待一段时间）</p><p><strong>等待时间</strong>：进程在<strong>就绪队列</strong>中等待所花时间之和。（可能有多段时间）</p><p><strong>响应时间</strong>：进程从提交到<strong>第一次运行</strong>的时间。</p><p><strong>CPU利用率</strong>：固定时间内CPU运行时间的比例。</p><p><strong>吞吐量</strong>：单位时间内完成进程的数量。</p><p>周转时间 = 等待时间 + 运行时间</p><p>我们进行进程调度的准则是：<strong>最大化吞吐量和CPU利用率，最小化周转时间、等待时间、响应时间。</strong></p><h3 id="调度类型"><a href="#调度类型" class="headerlink" title="调度类型"></a>调度类型</h3><p>进程调度的类型有：</p><ul><li><strong>长程调度</strong>：又叫作业调度、高级调度，发生在进程由“<strong>新建</strong>”状态转移到“<strong>就绪</strong>状态”的过程中。通过调度程序选择，将进程从外存调入内存，<strong>控制多道程序的道数</strong>。开销大，切换频率低。</li><li><strong>中程调度</strong>：又称<strong>交换</strong>（swap），是<strong>内存扩容</strong>的方法之一。中程调度将进程在内存和外存之间换进换出，从而使计算机可以执行大于内存容量的进程。（虚拟内存技术以<strong>页</strong>为单位）</li><li><strong>短程调度</strong>：又叫CPU调度、低级调度，发生在进程由“<strong>就绪</strong>”转移到“<strong>运行</strong>”状态的过程中。通过调度程序选择下一个需要执行的进程。开销小，切换频率高。</li></ul><p>调度程序的作用就是根据某种策略在就绪队列中选择CPU下一个运行的进程。</p><p>我们后文所说的进程调度都是指“<strong>短程调度</strong>”。</p><h3 id="调度的方式"><a href="#调度的方式" class="headerlink" title="调度的方式"></a>调度的方式</h3><p>调度根据是否<strong>发生抢占</strong>，可以分为：</p><ul><li><strong>非抢占式调度</strong>：如果一个进程分配到CPU，那么将一直占用该CPU执行，直到这个进场终止或者切换到等待到等待状态。<ul><li>优点：<strong>易实现，调度开销小，适合批处理系统。</strong></li><li>缺点：<strong>响应时间长，不适合交互式系统。</strong></li></ul></li><li><strong>抢占式调度</strong>：调度程序可以根据某种原则暂停某个正在执行的进程，将它的CPU分配给其他的进程。<ul><li>优点：<strong>相应时间短，适合交互式系统，可防止某一进程长时间独占CPU。</strong></li><li>缺点：<strong>实现困难，调度开销大。</strong></li></ul></li><li>如何区分是否抢占：<strong>进程是否自愿放弃CPU</strong>，比如终止或者进入等待状态。</li><li>只有抢占式调度的算法：时间片轮转调度算法RR</li><li>只有非抢占式调度的算法：先到先服务算法FCFS</li><li>既可以抢占也可以非抢占的算法：短作业优先算法SJF，优先级调度算法PR</li></ul><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="FCFS先到先服务算法"><a href="#FCFS先到先服务算法" class="headerlink" title="FCFS先到先服务算法"></a>FCFS先到先服务算法</h4><p>按<strong>进程请求CPU的先后顺序</strong>为他们分配CPU，较为<strong>公平</strong>，只能是<strong>非抢占式</strong>的。</p><p>适用于<strong>长程调度、后台批处理系统的短程调度</strong>。</p><p>对<strong>CPU密集型进程</strong>有利（执行时间短），对<strong>IO密集型进程</strong>不利（执行时间长）。</p><ul><li>优点：实现简单（FIFO先进先出队列实现），容易理解，公平</li><li>缺点：<strong>平均等待时间长（</strong>比如一个运行时间很长的CPU密集型进程先到了，那么短进程都需要先等待它执行完毕才能执行）</li></ul><h3 id="SJF最短作业优先算法"><a href="#SJF最短作业优先算法" class="headerlink" title="SJF最短作业优先算法"></a>SJF最短作业优先算法</h3><p>按照<strong>进程下次CPU运行时间的长短</strong>进行调度，越短的进程越先被分配CPU并执行。常用于<strong>长程调度</strong>。</p><p>实际过程中难以得知CPU的下次运行时间，需要通过以往运行时长的<strong>指数平均</strong>来计算。</p><ul><li>优点：<strong>平均等待时间最短</strong></li><li>缺点：<strong>存在饥饿问题</strong></li></ul><p>调度模式：</p><ul><li>非抢占式</li><li>抢占式：如果有比当前进程剩余执行时间更短的执行时间的进程到达时，将当前进程中止，并将CPU分配给新进程。也叫<strong>最短剩余时优先间调度算法SRTF。</strong></li></ul><p>什么是<strong>饥饿</strong>：稳定的<strong>更高优先级</strong>的进程流会导致低优先级的进程<strong>始终无法被执行</strong>。</p><p>SJF本质上是PR的一种特例。</p><h3 id="PR优先级算法"><a href="#PR优先级算法" class="headerlink" title="PR优先级算法"></a>PR优先级算法</h3><p>基于进程的紧迫程度，由外部赋予每个进程相应的优先级，CPU 分配给最高优先级的进程。 </p><ul><li>优点：实现<strong>简单</strong>，考虑了进程的紧迫程度；<strong>灵活</strong>，可模拟其它算法。</li></ul><p>调度模式也可以有两种。</p><p>优先级有两种类型：</p><ul><li><strong>静态优先级</strong>：<ul><li>进程创建时确定，在运行期间<strong>不变</strong></li><li>简单易行，<strong>系统开销小</strong></li><li>不够精确，可能会出现<strong>饥饿</strong>问题（稳定的更高优先级的进程流可以阻止低优先级的进程执行）</li></ul></li><li><strong>动态优先级</strong>：<ul><li>进程创建时的优先级随进程推进或等待时间增加而改变，<strong>解决了饥饿</strong>，例如：<strong>老化，即逐渐增加在系统中等待很久的进程的优先级</strong></li><li>现代操作系统常采用<strong>基于动态优先数的抢占式调度算法</strong>，缺点是<strong>每次调度之前，都需要计算优先数，增加系统开销</strong></li></ul></li></ul><h3 id="RR时间片轮转调度算法"><a href="#RR时间片轮转调度算法" class="headerlink" title="RR时间片轮转调度算法"></a>RR时间片轮转调度算法</h3><p>专门为<strong>分时系统</strong>设计，类似于 <strong>FCFS</strong>，但增加了抢占以切换进程。为每个进程分配<strong>不超过一个时间片的 CPU</strong>。时间片用完后， 该进程将被抢占并插入就绪队列末尾，<strong>循环执行</strong>。若进程提前执行完成，则自动释放 CPU。 </p><p>性能很大程度上取决于时间片大小，所以要合理设计时间片大小：</p><ul><li>时间片过大，RR退化为FCFS</li><li>时间片过小，导致上下文切换开销大大增加</li></ul><h3 id="MLQ多级队列调度算法"><a href="#MLQ多级队列调度算法" class="headerlink" title="MLQ多级队列调度算法"></a>MLQ多级队列调度算法</h3><p>系统中存在多个就绪队列，每个队列有自己的调度算法。队列之间也有调度算法，通常采用<strong>固定优先级</strong>（可能会导致<strong>饥饿</strong>，低优先级的队列中的进程始终无法被执行）抢占调度。<strong>不允许进程在多个队列之间流动</strong>。</p><p>例子：操作系统的<strong>前台队列和后台队列</strong></p><h3 id="MFLQ多级反馈队列调度算法"><a href="#MFLQ多级反馈队列调度算法" class="headerlink" title="MFLQ多级反馈队列调度算法"></a>MFLQ多级反馈队列调度算法</h3><p>在 MLQ 的基础上，<strong>进程能在不同队列间移动</strong>。解决了 MLQ的饥饿现象。</p><p><strong>Unix，Solaris，Windows 的调度算法一定程度上都是 MLFQ 的变种</strong> </p><h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><h3 id="多线程-多进程编程可能带来的问题"><a href="#多线程-多进程编程可能带来的问题" class="headerlink" title="多线程/多进程编程可能带来的问题"></a>多线程/多进程编程可能带来的问题</h3><p>共享数据如果同时被多个进程或者线程并发或者并行访问，可能会导致：<strong>数据不一致性，又称不可再现性</strong>。即同一进程在同一批数据上多次运行的结果不一样。 </p><p>为了解决数据不一致性问题，我们要采取：<strong>同步（互斥）机制</strong>。其中，互斥机制是同步机制的一种特殊情况。</p><p>一个数据不一致性的例子：counter</p><blockquote><p>n 个缓冲区的有界缓冲问题，生产者进程和消费者进程同时对共享资源 counter 进行修改，产生了错误的结果。解决方案：counter–与 counter++必须作为原子操作，建立互斥机制，将 counter 变为临界资源。</p></blockquote><p><strong>原子操作</strong>：操作执行的过程中必须是连续的。</p><h3 id="同步与互斥的概念"><a href="#同步与互斥的概念" class="headerlink" title="同步与互斥的概念"></a>同步与互斥的概念</h3><p>同步指的是<strong>协调进程的执行次序</strong>，使并发进程间能有效地共享资源和相互合作，<strong>保证数据一致性</strong>。</p><p><img src="%E5%90%8C%E6%AD%A5.png" alt="同步"></p><p>互斥指的是进程<strong>排他性</strong>地运行某段代码，任何时候只有一个进程能够运行。多个进程<strong>互斥地访问只允许被独占的资源。</strong>但是，互斥无法保证进程的执行次序。</p><p>互斥的特点：</p><ul><li>原子性</li><li>排他性</li><li>唯一性</li></ul><p><img src="%E4%BA%92%E6%96%A5.png" alt="互斥"></p><h3 id="临界的概念"><a href="#临界的概念" class="headerlink" title="临界的概念"></a>临界的概念</h3><p>临界是<strong>互斥控制</strong>中的重要概念。</p><p>临界资源：<strong>一次只允许一个进程使用的资源</strong>，又称互斥资源、独占资源或共享资源。许多物理设备都属于临界资源，如输入机、打印机、磁带机等 </p><p>临界区：<strong>涉及临界资源的代码段</strong>，若保证互斥进入关联的临界区，可实现对临界资源的互斥访问。</p><ul><li>临界区属于代码片段，它的特征是包含临界资源。</li><li>临界区的使用准则：<ul><li><strong>互斥</strong>：有相同临界资源的临界区需要互斥，<strong>同一时刻只能有一个进程的临界区访问临界资源</strong>，其他进程需要在临界区外等待。而无相同临界资源的临界区不需要互斥。</li><li><strong>有空让进（进步）</strong>：临界区内无进程执行时，不能无限期地延长下一个要进临界区进程的等待时间，应及时选择不在剩余区中执行的进程进入临界区 。</li><li><strong>有限等待</strong>：<strong>每个进程进入临界区前的等待时间必须有限</strong>，不能无限等待。其他进程允许进入临界区的次数应有上限。</li></ul></li></ul><p><img src="%E4%B8%B4%E7%95%8C%E5%8C%BA.png" alt="临界区"></p><p>原则：<strong>在进入区实现互斥准则；在退出区实现有空让进准则 ；每个临界区不能过大，从而实现有限等待准则。</strong></p><h3 id="信号量的概念"><a href="#信号量的概念" class="headerlink" title="信号量的概念"></a>信号量的概念</h3><p>同步机制的<strong>软件解决方案</strong>之一。在进入关键代码段前，进程必须获取一个信号量，否则不能运行。执行完该关键代码段，必须释放信号量。</p><h4 id="信号量的基本操作"><a href="#信号量的基本操作" class="headerlink" title="信号量的基本操作"></a>信号量的基本操作</h4><p>信号量S除了定义以外，提供了两个不可分割的<strong>原子操作</strong> <strong>wait（S）</strong>（又称 P（S））和 <strong>signal（S）</strong>（又称 V（S））。</p><ul><li>wait操作申请并占用一个信号量，signal操作释放一个占用的信号量。</li></ul><h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p>整型信号量的取值范围是<strong>非负整数</strong>，主要有两种，分别为：</p><ul><li><p><strong>计数信号量</strong>：</p><ul><li>取值范围：<strong>没有限制的非负整数</strong>，计数信号量的值等于系统中<strong>可用的资源数目</strong>。</li><li>也叫作同步信号量，主要用于<strong>同步控制</strong>。</li></ul><p><img src="%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F.png" alt="计数信号量实现同步控制"></p></li><li><p><strong>二值信号量</strong>：</p><ul><li>取值范围：<strong>0或者1</strong>。</li><li>也叫作互斥信号量，主要用于在没有互斥锁的系统中实现<strong>互斥控制</strong>。</li></ul><p><img src="%E4%BA%92%E6%96%A5%E4%BF%A1%E5%8F%B7%E9%87%8F.png" alt="互斥信号量实现互斥控制"></p></li></ul><p>整型信号量的缺陷主要为：当使用wait操作申请信号量，而信号量值为0时，进程或者线程将处于<strong>忙等待</strong>。</p><p>忙等待：进程或者线程使用While循环或者其他循环操作，<strong>不断阻塞循环查询信号量的值</strong>，直到信号量可用。效率很差，因为进程或者线程一直处于运行状态，占用CPU资源。</p><h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>当一个进程执行 wait（S）时，当系统中没有可用的资源（S&lt;=0），不需要再循环查询信号量值，而是将自己阻塞（调用 block（）），由运行状态切换为<strong>等待状态</strong>，并<strong>将自己放入一个与信号量相关的等待队列</strong>中。当另一个进程执行 signal（S）时，当存在等待进程时，从等待进程队列中唤醒一个进程（wakeup（P））使其继续运行。</p><p><img src="%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F.png" alt="记录型信号量"></p><p>记录型信号量的值：</p><ul><li>大于0：可用资源数目</li><li>等于0：无资源可用</li><li>小于0：等待的进程或者线程数目</li></ul><p>与整型信号量相比：</p><ul><li>解决了<strong>忙等待</strong>问题。当进程或者线程无法获得想要的信号量时，不会循环在运行状态查询，占用CPU资源，而是转至等待状态，提高了CPU利用率。</li><li>信号量的值可以<strong>为负数</strong>，其绝对值等于该信号量上阻塞的进程数目。</li></ul><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>在多任务操作系统中，同时运行的多个任务可能都需要使用同一种资源。这个过程有点类似于，公司部门里，我在使用着打印机打印东西的同时（还没有打印完），别人刚好也在此刻使用打印机打印东西，如果不做任何处理的话，打印出来的东西肯定是错乱的。<br>在线程里也有这么一把锁——<strong>互斥锁（mutex）</strong>，互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态,即<strong>上锁( lock )和解锁( unlock )</strong>。<br>互斥锁的基本作用和<strong>二值型信号量</strong>一致，但当申请互斥锁失败后，进程或者线程会<strong>自动阻塞睡眠，进入等待状态</strong>。这一点与记录型信号量类似。</p><p>特点：</p><ul><li>原子性</li><li>排他性</li><li>唯一性</li><li>非忙等</li></ul><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁与互斥锁功能一样，唯一一点不同的就是<strong>互斥锁阻塞后休眠让出CPU，而自旋锁阻塞后不会让出CPU</strong>，会一直忙等待，直到得到锁。 就像整型信号量和记录型信号量的区别。</p><p>自旋这个名字非常形象，因为申请锁失败后的进程或者线程会忙等，循环查询锁的状态，就像一直在旋转一样。</p><h3 id="自旋锁和互斥锁（整型信号量和记录型信号量）的使用场景"><a href="#自旋锁和互斥锁（整型信号量和记录型信号量）的使用场景" class="headerlink" title="自旋锁和互斥锁（整型信号量和记录型信号量）的使用场景"></a>自旋锁和互斥锁（整型信号量和记录型信号量）的使用场景</h3><ul><li>自旋锁和整型信号量会产生<strong>忙等待</strong>，当<strong>锁的持有时间较长</strong>时，这段时间内进程或者线程将一直占用CPU，降低CPU利用率。但它也并非一无是处。当锁的持有时间很短，特别是<strong>短到小于两次上下文切换时间</strong>（运行-等待，等待-运行）时，适合使用自旋锁和整型信号量。</li><li>互斥锁和记录型信号量当<strong>锁的持有时间较长</strong>时，能够提高CPU利用率，更适合。</li></ul><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁与互斥量类似，不过读写锁允许<strong>更改并行性</strong>，也叫共享互斥锁。互斥量要么是锁住状态，要么就是不加锁状态，而且一次只有一个线程可以对其加锁。读写锁可以有3种状态：<strong>读模式下加锁状态、写模式加锁状态、不加锁状态。</strong></p><p>一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁（允许多个线程读但只允许一个线程写）。因为<strong>多个读者同时读不会产生并发问题</strong>，其余情况都可能导致并发问题。</p><p> 读写锁适合于对数据结构的<strong>读次数比写次数多得多</strong>的情况。 </p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>与互斥锁不同，条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直 到某特殊情况发生为止。通常条件变量<strong>和互斥锁同时使用</strong>。<br>条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作： </p><ul><li>一个线程等待”<strong>条件变量的条件成立</strong>“而挂起；</li><li>另一个线程使 “<strong>条件成立”</strong>（给出条件成立信号）。</li></ul><h3 id="并发控制经典问题"><a href="#并发控制经典问题" class="headerlink" title="并发控制经典问题"></a>并发控制经典问题</h3><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><p><img src="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85.png" alt="生产者消费者问题"></p><p>生产者消费者问题是一个<strong>有界缓冲</strong>问题，是一个经典的并发控制问题。</p><ul><li>生产者（M个）：生产产品，并并放入有界缓冲区。</li><li>消费者（N个）：从有界缓冲区取出产品。</li><li>问题：如何实现生产者与消费者之间的同步与互斥</li></ul><p><strong>互斥</strong>问题：</p><ul><li><p>互斥问题的基本研究方法：</p><p><img src="%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98.png" alt="互斥问题"></p></li><li><p>本问题中的临界资源：</p><ul><li>生产者进程：<ul><li>把产品放入指定缓冲区的代码需要使用 in 指针存放生产者放入的位置（这里我们在缓冲区内使用<strong>队列数据结构</strong>），使用counter指针存放当前资源数目</li><li>in:所有的生产者对 in 指针需要互斥</li><li>counter：所有生产者消费者进程对 counter 互斥 </li></ul></li><li>消费者进程：<ul><li>把从指定缓冲区取出产品的代码需要使用 out 指针存放消费者取出的位置，使用counter指针存放当前资源数目</li><li>out:所有的消费者对 out 指针需要互斥</li><li>counter：所有生产者消费者进程对 counter 互斥 </li></ul></li></ul></li><li><p>对于含有上述临界资源的代码段，我们将其视为临界区，并使用互斥信号量或者互斥锁进行互斥控制。</p></li></ul><p><strong>同步</strong>问题</p><ul><li><p>同步问题的基本研究方法：</p><p><img src="%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98.png" alt="同步问题"></p></li><li><p>需要同步的部分：</p><ul><li>生产者：把产品放入空缓冲区。</li><li>消费者：把产品放入满缓冲区。 </li></ul></li><li><p>不同执行次序：</p><ul><li>当<strong>没有空缓冲区</strong>时，生产者进程阻塞，等待消费者进程先执行。 </li><li>当<strong>没有满缓冲区</strong>时，消费者进程阻塞，等待生产者进程先执行。 </li><li>当空缓冲区和满缓冲区都存在时，<strong>二者可并行</strong>。 </li></ul></li></ul><p>解决方案：使用三个信号量，两个信号量用于同步，值分别为满缓冲区和空缓冲区的可用资源数目。一个信号量进行互斥，控制临界区的访问。</p><p><img src="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.png" alt="生产者消费者问题解决"></p><h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><p>问题描述：两组并发进程读者和写者共享一组数据区进行读写。要求：允<strong>许多个读者同时读，不允许读者、写者同时读写，不允许多个写者同时写。</strong>例子：对文件的读写操作。</p><p>Linux内置<strong>读写锁</strong>进行并发控制。</p><p>如果我们仅仅使用互斥信号量，使得所有读者和写者进程对于数据的访问都是互斥的，那么将不符合多个读者同时读的要求。</p><p>解决方法：额外为读者进程设置<strong>计数变量</strong>，当其为 1 时（第一个进入的读者进程）执行 P 操作占用互斥信号量，当其为 0 时（最后一个离开的读者进程）执行 V 操作释放互斥信号量。换句话说：<strong>只有第一个读者需要申请信号量，只有最后一个读者需要释放信号量</strong></p><p>需要注意的是：<strong>计数变量本身是一个互斥资源，包含它的代码段必须被声明为临界区。</strong></p><p><img src="%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.png" alt="读者写者问题解决"></p><h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p>问题描述：5 个哲学家，5 根筷子。哲学家左右各有一根筷子，哲学家只有<strong>拿起左右两个筷子</strong>才能吃饭。</p><p>存在死锁的解决方法：将筷子视为<strong>临界资源</strong>。但如果当五个哲学家同时想要吃饭，先拿起左边筷子时，他们<strong>会因为在拿起右边筷子时互相等待而陷入死锁</strong>。 （符合死锁条件中的互斥、非抢占、持有并等待、循环等待）</p><p>解决措施：</p><ul><li><p><strong>最多允许四个哲学家同时就坐</strong>。方法：设置 seat 信号量，初始值为 4，每个哲学家就餐前后先对 seat 信号量执行 P、V 操作占用一个座位。</p></li><li><p><strong>非对称策略</strong>。方法：为哲学家编号。奇数哲学家先拿起左侧的筷子，后拿起右侧的筷子。偶数哲学家先拿起右侧的筷子，再拿起左侧的筷子。</p></li><li><p><strong>只有左右两侧筷子均可拿起时，才会拿起筷子。</strong>方法：设置哲学家分为 3 个状 态：int <em>state={Thinking, hungry, eating};设置 5 个信号量，对应 5 个哲学家，初始值为 0。设计 test 函数，当<strong>左右两侧哲学家均不在吃饭（左右两侧筷子均可 拿起），且自己处于 hungry 时</strong>，把自己的状态设置为 eating 并将自己的信号 量加 1，从而拿起筷子吃饭，否则阻塞等待别人吃完。吃完饭后，将自己的状态设置为 thinking，并执 行两次 test 函数，查看左右两侧的哲学家是否因为自己的进食而处于 hungry 并等待，若有，<em>*将他们唤醒</em></em>。</p><p>实现方式：需要注意，test操作涉及临界资源state，需要互斥控制。</p><p><img src="%E5%93%B2%E5%AD%A6%E5%AE%B6%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.png" alt="哲学家问题解决"></p></li></ul><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>信号量机制的问题：</p><ul><li>需要程序员实现，编程困难。</li><li>维护困难。</li><li>容易出错：P、V 操作位置错或者不配对。</li></ul><p>管程<strong>将相应的数据结构和操作封装起来，由编程语言解决同步互斥问题</strong>。 一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。管程类型属于<strong>抽象数据类型 ADT。</strong> </p><p><img src="%E7%AE%A1%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="管程结构"></p><ul><li>互斥机制：管程中的变量只能由管程中的操作访问，<strong>同一时刻只能有一个进程在管程中</strong>，这一思想类似于临界区，由<strong>编译器</strong>实现，从而实现了互斥机制。（<strong>管程中不需要特地进行互斥控制</strong>）</li><li>同步机制：利用<strong>条件变量</strong>，以及每个条件变量的阻塞 wait()和唤醒 signal()操作来实现。（与<strong>信号量相比，不会出错，但无法计数，需要引入计数变量</strong>）每个条件变量都有一个条件队列，被阻塞的进程将在该条件队列上睡眠，直到被唤醒。在管程中可以自由选择当前进程阻塞到哪一个条件变量上。</li></ul><p><img src="%E7%AE%A1%E7%A8%8B%E5%AE%9E%E7%8E%B0.png" alt="哲学家就餐问题的管程实现"></p><h3 id="Linux和Windows的并发控制对比"><a href="#Linux和Windows的并发控制对比" class="headerlink" title="Linux和Windows的并发控制对比"></a>Linux和Windows的并发控制对比</h3><p>Linux 并发控制机制：</p><ul><li>使用禁止中断来实现短的临界区。（原子操作）</li><li>自旋锁：不会引起调用者阻塞。</li><li>条件变量。 </li><li>信号量。</li><li>互斥锁。</li></ul><p>Windows并发控制机制：</p><ul><li>事件：通过通知操作的方式来保持线程的同步。 </li><li>临界区。</li><li>互斥锁。</li><li>自旋锁。</li><li>信号量。</li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p>死锁指的是：一组等待进程，其中每一个进程都<strong>持有</strong>资源，并且<strong>等待</strong>着由这个组中其他进程所持有的资源。所有死锁进程<strong>无法推进</strong>。</p><p>死锁的四个必要条件（同时满足就能发生死锁）：</p><ul><li><strong>互斥</strong>：至少有一个资源处于<strong>非共享模式</strong>，即一次只能有一个进程访问该资源。</li><li><strong>占有并等待</strong>：一个进程应占有至少一个资源，并等待另一个被<strong>其它进程</strong>占有的资源。</li><li><strong>无抢占</strong>：资源不能被抢占，只能被进程完成任务后<strong>自愿释放</strong>。</li><li><strong>循环等待</strong>：等待资源的进程之间存在环 [P0, P1, …, P0]。P0 等待 P1 占有的资源, P1 等待 P2 占有的资源, …, Pn–1 等待 Pn 占有的资源, Pn 等待 P0 占有的资源。 </li></ul><p>处理死锁的四大方法：</p><ul><li><strong>死锁预防</strong></li><li><strong>死锁避免</strong></li><li><strong>死锁检测</strong></li><li><strong>死锁恢复</strong></li></ul><h3 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h3><p>资源分配图：一个顶点的集合V和边的集合E。V被分为两个部分：P = {P1, P2, …, Pn}, 含有系统中全部的进程。R = {R1, R2, …, Rm}, 含有系统中全部的资源。</p><p><strong>请求边</strong>：有向边Pi–&gt;Rj 。进程到资源。</p><p><strong>分配边</strong>：有向边Ri–&gt;P j。资源到进程。</p><ul><li><p>如果资源分配图中<strong>不存在环</strong>：一定没有死锁。</p></li><li><p>如果资源分配图中<strong>存在环</strong>：</p><ul><li>如果每个资源<strong>只有一个实例</strong>，那么死锁发生。</li><li>如果一个资源<strong>有多个实例</strong>，那么死锁可能发生也可能不发生。</li></ul></li></ul><p><img src="%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png" alt="资源分配图"></p><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>死锁预防指的是：使死锁发生的四个必要条件（互斥、占有并等待、非抢占、循环等待）<strong>至少一个不成立</strong>。</p><p>死锁预防的副作用：<strong>设备使用率低和系统吞吐率低</strong>。</p><ul><li>使互斥不成立：通过<strong>虚拟化技术</strong>，<strong>将互斥资源转换为共享资源</strong>。然而，通常不能通过否定互斥条件来预防死锁，因为有的资源本身就是非共享的，例如<strong>互斥锁</strong>。</li><li>使占有并等待不成立：<strong>保证进程申请资源时不占有任何资源</strong>。然而，这种方法的资源利用率较低，也可带来饥饿。<ul><li>每个进程在执行前一次性申请并获得所有资源。</li><li>每个进程在申请资源时先释放掉占用的所有资源。</li></ul></li><li>使非抢占不成立：当一个进程占有资源并申请另一个不能立即被分配（不可用且不是其他等待进程的可抢占资源）的资源时，它占有的所有资源被<strong>隐式释放</strong>，均可被抢占。当它获得了申请的资源和在等待过程中被抢占的资源时，才可重新执行。</li><li>使循环等待不成立：对所有的资源类型排序进行<strong>总排序</strong>，并且要求进程按照<strong>递增顺序</strong>申请资源。</li></ul><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>死锁避免指的是系统理论上存在着死锁的可能，但在每次<strong>分配资源</strong>时，调用死锁避免算法，使死锁不可能成立。</p><p>死锁避免需要系统提供一些<strong>额外信息</strong>，如每一个进程声明它所需要的每种资源的最大数目。死锁避免算法动态检查<strong>资源分配状态</strong>，以确保循环等待不成立。资源分配状态包括：<strong>可用的资源、已分配的资源、资源的最大需求。</strong></p><p><strong>安全状态</strong>：只有存在一个<strong>安全序列</strong>，系统才处于安全状态。<strong>死锁状态是非安全状态的子集</strong>。死锁避免算法确保系统处于安全状态。</p><p><strong>安全序列</strong>：如果每一个进程Pi所申请的可以被满足的资源数加上当前其他进程所持有的该资源数小于系统总数。那么，进程序列&lt;P1, P2, …, Pn&gt;是安全的。也就是说，<strong>使得进程按照某个序列可以流畅地推进，不会产生死锁，那么该序列是安全的。</strong></p><h4 id="单实例：资源分配图法"><a href="#单实例：资源分配图法" class="headerlink" title="单实例：资源分配图法"></a>单实例：资源分配图法</h4><p>当系统中的资源都是单实例的时，我们可以使用资源分配图来进行死锁避免。<strong>因为单实例时，一旦资源分配图中存在环，则必然会产生死锁。</strong>所以，我们只需要判断资源分配是否可能导致资源分配图存在环，即可进行死锁避免。</p><p>判断图中是否存在环可以使用<strong>拓扑排序</strong>，时间复杂度：$O(n^2)$，n为进程数目。</p><ul><li><strong>需求边</strong>：需求边 Pi –&gt;Rj 表示 Pi 可能以后需要申请Rj资源，用虚线表示。</li><li><strong>请求边</strong>：Pi 申请Rj资源，需求边转换为请求边。</li><li><strong>分配边</strong>：请求边在资源分配后转换为分配边。</li><li>资源申请能够被满足的条件：<strong>把请求边转换为分配边后不会导致环存在。</strong></li></ul><h4 id="多实例：银行家算法"><a href="#多实例：银行家算法" class="headerlink" title="多实例：银行家算法"></a>多实例：银行家算法</h4><p>银行家算法，顾名思义，就是先借资源给某个进程，当他执行完毕后，将原先占有的资源，和所借的资源<strong>全部返还</strong>给系统，就像在银行借款一样。</p><ul><li>新进入进程要声明自己所需的各资源最大数目，且不能大于系统资源最大数目。</li><li>当进程请求资源时，可能要等待。</li><li>当一个进程获得所有需要的资源并执行时，必须在有限的时间释放它们。</li><li>数据结构：（<strong>n为进程数目，m为资源数目</strong>）<ul><li><strong>Available</strong>: 长度为 m的向量，表示每种资源的可用数目。如果available[j]=k,那么资源Rj有k个实例可用。</li><li><strong>Max</strong>: n x m 矩阵。 如果Max[i,j]=k,那么进程Pi最多需求k个资源Rj的实例。</li><li><strong>Allocation</strong>: n x m 矩阵。 如果Allocation[i,j]=k,那么进程Pi当前分配了k个资源Rj的实例。</li><li><strong>Need</strong>: n x m 矩阵。如果Need[i,j]=k,那么进程Pi还需要k个资源Rj的实例。Need [i,j] = Max[i,j] – Allocation [i,j]。</li></ul></li><li><strong>安全检测算法（银行家算法）</strong>： （时间复杂度：$O(m*n^2)$）<ol><li>让<strong>Work</strong>和<strong>Finish</strong>作为长度为m和n的向量初始化：Work := Available，Finish [i] = false。（初始化work矩阵用于模拟<strong>执行过程中的available矩阵</strong>，finish矩阵记录<strong>模拟执行过程中进程是否执行完成</strong>）</li><li>循环遍历查找i，使其满足：（查找可被满足需求的进程并执行）<ol><li>Finish [i] = false（<strong>第 i 个进程尚未被执行</strong>）</li><li>Need[i]&lt;=Work（<strong>第 i 个进程可以被执行</strong>）</li><li>如果不存在这样的i，直接跳转步骤4.</li></ol></li><li>Work := Work + Allocation[i]；Finish[i] := true；go to step 2.（<strong>释放进程i的资源，以便其他等待进程执行</strong>）</li><li>如果对于所有进程i，都可以执行，那么系统处于安全状态，其中i的访问次序即为安全序列（<strong>安全序列不唯一</strong>）。否则，系统处于不安全状态。</li></ol></li><li><strong>资源请求算法</strong>：Request[i] =进程 Pi 的资源请求向量. 如果Request[i ,m] = k 则进程Pi想要资源类型为Rj[m]的k个实例。<ol><li>如果 Request[i]&lt;=Need[i]转 step 2. 否则报错, <strong>因为进程请求超出了其声明的最大值</strong>。<ol start="2"><li>如果 Request[i] &lt;=Available, 转 step 3. 否则 Pi 必须等待, <strong>因为资源暂时不可用</strong>.<pre><code>  3. 通过修改下列状态来分配请求的资源给进程Pi :  1. Available[i] := Available[i] - Request[i];     2. Allocation[i]:= Allocation[i] + Request[i];        3. Need[i]:= Need[i] – Request[i]        4. 调用安全检测算法（银行家算法）检测执行请求后的新资源分配状态是否安全，**若安全则通过请求，否则需要回滚**。</code></pre></li></ol></li></ol></li></ul><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>死锁检测指的是<strong>系统允许进入死锁状态</strong>，定时调用死锁检测算法，判断当前系统中是否存在死锁，如果存在则进行死锁恢复。</p><p>调用死锁检测算法的频率取决于：</p><ul><li><strong>死锁可能发生的概率</strong></li><li><strong>死锁发生时可能有多少进程受影响</strong></li></ul><h4 id="单实例：等待图法"><a href="#单实例：等待图法" class="headerlink" title="单实例：等待图法"></a>单实例：等待图法</h4><p>等待图是资源分配图的简化，省略了资源类型结点，合并了边。Pi–&gt;Pj表明Pi在等待Pj的资源。系统维护等待图，并定时调用算法检测是否存在环。</p><h4 id="多实例：银行家算法-1"><a href="#多实例：银行家算法-1" class="headerlink" title="多实例：银行家算法"></a>多实例：银行家算法</h4><p>类似银行家算法。基本思路完全一致，如果无法找到安全序列，则系统死锁。需要注意的是，这里的need矩阵变为了request矩阵，如果进程的request被允许，则可以乐观的释放它的全部资源。</p><h3 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h3><p>死锁恢复指的是系统产生死锁后将死锁状态解除的算法。</p><ul><li><strong>人工恢复</strong>：通知操作员人工处理，代价小，是目前操作系统常用的方法。</li><li><strong>自动恢复</strong>：<ul><li><strong>进程终止</strong>：<ul><li><strong>中止所有死锁进程</strong>：代价大，但肯定可以解决死锁。</li><li><strong>一次中止一个进程</strong>：开销大，每中止一个进程都要调用死锁检测算法。</li></ul></li><li><strong>资源抢占</strong>：抢占一些进程的资源给其他进程使用，直到死循环被打破。<ul><li>选择一个牺牲进程：于进程中止类似，需要选择合适的被抢占进程序列来最小化代价。</li><li><strong>回滚</strong>：使被抢占资源的进程返回到安全的状态，然后重新开始进程。</li><li><strong>饥饿</strong>：同样进程的可能总是被牺牲。需要防止同一个进程总是被选中抢占资源，应在代价因素中加入<strong>回滚次数</strong>。</li></ul></li></ul></li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="基本硬件"><a href="#基本硬件" class="headerlink" title="基本硬件"></a>基本硬件</h3><ul><li>程序必须<strong>装入内存</strong>才可以执行。</li><li>CPU可以直接访问的存储器只有<strong>主存高速缓存</strong>和<strong>寄存器</strong>。</li><li>CPU内置的寄存器通常只需要一个（或少于一个）CPU时钟周期内就可以完成访问。而内存通常需要多个CPU时钟周期来访问。所以CPU在已读入指令但尚未从内存读取完数据时，会暂停。</li><li>为了解决CPU的暂停，提高CPU利用率，在内存和CPU之间引入了<strong>高速缓存Cache</strong>。其主要的功能是<strong>协调CPU和内存的访问速度差异，通常位于CPU芯片上</strong>。高速缓存Cache将频繁需要读取的数据从内存暂存到Cache内，从而加快CPU的访问速度。</li><li>内存保护需要保证正确的操作。</li></ul><h3 id="缓冲-VS-缓存"><a href="#缓冲-VS-缓存" class="headerlink" title="缓冲 VS 缓存"></a>缓冲 VS 缓存</h3><p> <strong>Buffer</strong>（缓冲区）是系统两端处理<strong>速度平衡</strong>（从长时间尺度上看）时使用的。它的引入是为了减小短期内突发I/O的影响，起到<strong>流量整形</strong>的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。例如：观看视频时的缓冲。</p><p>Buffer可以将突发的大数量较小规模的 I/O 整理成平稳的小数量较大规模的 I/O，以<strong>减少响应次数</strong> 。例如：下载电影时，不可能每下载几个字节就存入硬盘，效率会非常低下，通常需要积攒一定量的数据才能够存入硬盘。</p><p><strong>Cache</strong>（缓存）则是系统两端处理<strong>速度不匹配</strong>时的一种<strong>折衷策略</strong>。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的<strong>局部性</strong>（locality）特征，通过使用<strong>存储系统分级</strong>（memory hierarchy）的策略来减小这种差异带来的影响。 </p><p>Cache 是为了弥补<strong>高速设备和低速设备</strong>的鸿沟而引入的中间层，最终起到<strong>加快访问速度</strong>的作用。 可以将常用的数据存在高速缓存中，以提高存取速度，提升性能。</p><p><strong>Buffer和Cache在一般情况下其实可以混用。Buffer一般用于内存与外部设备之间，Cache一般用于CPU和内存之间。Buffer是顺序存取的，而Cache是随机存取的。</strong></p><h3 id="内存管理的目的"><a href="#内存管理的目的" class="headerlink" title="内存管理的目的"></a>内存管理的目的</h3><p>目的：</p><ul><li>提高<strong>内存利用率</strong>。</li><li>提高<strong>指令执行速度</strong>。</li><li>保证指令<strong>安全运行</strong>。</li></ul><p>功能：</p><ul><li>内存<strong>分配</strong></li><li>内存<strong>回收</strong></li><li>地址<strong>转换</strong></li><li>存储<strong>保护</strong></li><li>内存<strong>共享</strong></li></ul><h3 id="逻辑地址与物理地址"><a href="#逻辑地址与物理地址" class="headerlink" title="逻辑地址与物理地址"></a>逻辑地址与物理地址</h3><ul><li>逻辑地址：<ul><li>在CPU内产生</li><li>在进程内的<strong>相对地址</strong></li><li>也称<strong>虚地址、相对地址、程序地址</strong>。</li><li>逻辑地址空间：由程序所生成的所有逻辑地址的集合。</li></ul></li></ul><p><img src="%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80.png" alt="逻辑地址"></p><ul><li>物理地址：<ul><li>内存中的地址</li><li><strong>所有内存统一编址</strong></li><li>也称<strong>实地址、绝对地址</strong>。</li><li>物理地址空间：由逻辑地址所对应的所有物理地址的集合。</li></ul></li></ul><p><img src="%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80.png" alt="物理地址"></p><p>使用逻辑地址，可以方便地通过<strong>重定位机制</strong>修改进程在内存中的位置。</p><p><img src="%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="地址转换"></p><p>用户程序所对应到的是逻辑地址，物理地址对它从来都<strong>不可见</strong>。</p><h3 id="地址绑定"><a href="#地址绑定" class="headerlink" title="地址绑定"></a>地址绑定</h3><p>每个进程<strong>独立拥有</strong>一个内存空间：</p><p><img src="%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.png" alt="内存空间"></p><ul><li><strong>基地址寄存器</strong>：位于CPU上，存储CPU正在运行的进程最小的合法物理内存地址，主要用于<strong>地址转换</strong>。</li><li><strong>界限地址寄存器</strong>：位于CPU上，存储CPU正在运行的进程内存的范围，主要用于<strong>地址合法性检验</strong>。</li><li>CPU在执行指令时，需要进行<strong>地址合法性验证</strong>。</li></ul><p><img src="%E5%9C%B0%E5%9D%80%E5%90%88%E6%B3%95%E6%80%A7.png" alt="地址合法性"></p><p><strong>地址绑定</strong>：编译器将源程序中的指令和数据绑定到<strong>可重定位的地址（逻辑地址）</strong>，链接程序或加载程序再<strong>将逻辑地址绑定到物理地址</strong>。</p><p>一个程序运行的流程：<strong>编译（编译成机器码）–&gt;链接（链接外部模块）–&gt;加载（加载进内存）–&gt;执行</strong>。</p><p><strong>地址绑定的时机</strong>：</p><ul><li><strong>编译时</strong>：若编译时已知进程在内存中驻留的地址，即可生成绝对代码。如果未来地址发送变化，程序需要<strong>重新编译</strong>。例如：MS-DOS的.COM格式程序再编译时完成地址绑定。（<strong>静态重定位，不需要硬件支持</strong>）</li><li><strong>加载时</strong>：如果编译时不知道进程即将驻留的地址，可以编译生成可重定位代码。加载时再进行绑定，此时若内存地址发生变化，只需要<strong>重新加载程序</strong>。（<strong>静态重定位，不需要硬件支持</strong>）</li><li><strong>运行时</strong>：如果一个进程在运行时可从一个内存段移到另一个内存段，那么绑定将延迟到运行时进行。如果要改变内存地址，只需要改变基址寄存器的值即可。（<strong>动态重定位，需要硬件支持，如基址寄存器和界限地址寄存器和MMU，为大多数操作系统采用</strong>）</li></ul><p>动态重定位的地址绑定是在<strong>每次执行指令</strong>时才进行的。每次移动进程时只是改变<strong>重定位寄存器</strong>里的内容，不进行地址变换。</p><p>一般而言，<strong>静态重定位适合于内存地址不发生改变的存储管理方式</strong>，如：<strong>固定分区存储管理。</strong></p><p><strong>动态重定位适合于内存地址常常需要动态改变的存储管理方式</strong>，如：<strong>分段式存储、分页式存储、可变分区存储（紧缩）等。</strong></p><h3 id="内存管理单元MMU"><a href="#内存管理单元MMU" class="headerlink" title="内存管理单元MMU"></a>内存管理单元MMU</h3><ul><li>完成从逻辑地址到物理地址的<strong>运行时映射（动态重定位）</strong>。</li><li>是CPU用来管理内存的<strong>控制线路</strong>。</li><li>在MMU策略中，基址寄存器（重定位寄存器）中的值在其送入内存的时候被加入到由一个用户进程所产生的每个地址中。</li></ul><p><img src="MMU.png" alt="MMU"></p><h3 id="动态加载和动态链接机制"><a href="#动态加载和动态链接机制" class="headerlink" title="动态加载和动态链接机制"></a>动态加载和动态链接机制</h3><p>一个程序运行的流程：<strong>编译（编译成机器码）–&gt;链接（链接外部模块）–&gt;加载（加载进内存）–&gt;执行</strong>。但链接和加载有时也可以在执行时动态进行。</p><ul><li>动态链接（运行时链接）：将链接（多个代码文件合并为一个单一的文件）延迟到运行时执行。需要操作系统的支持。</li><li>动态加载（运行时加载）：将不常用的代码（例如用于异常处理的代码）写入到模块程序中，只有当需要时才会加载进入内存。优点是<strong>提高了内存空间利用率</strong>。它不需要系统提供特别的支持，通常是程序员实现。例子：<strong>Windows操作系统的各种DLL库</strong>。</li></ul><h3 id="存储保护机制"><a href="#存储保护机制" class="headerlink" title="存储保护机制"></a>存储保护机制</h3><p>存储保护机制主要是为了防止程序相互<strong>越界访问</strong>：</p><ul><li>访问<strong>超过限长</strong>的内存。</li><li>访问<strong>不在自己逻辑地址空间内</strong>的内存。</li></ul><h3 id="内存存储管理机制"><a href="#内存存储管理机制" class="headerlink" title="内存存储管理机制"></a>内存存储管理机制</h3><h4 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h4><p>碎片主要指的是<strong>因为某些原因导致的不可用内存空间</strong>，会导致内存利用率下降。</p><ul><li><strong>外部碎片</strong>：虽然整个可用内存空间可以用来满足一个进程的请求，但它<strong>不是连续</strong>的。这些不连续的小孔就是外部碎片，会被浪费。主要出现在：<strong>可变分区内存分配、分段式内存分配</strong>等。</li><li><strong>内部碎片</strong>：分配给进程的内存是固定大小的分区，<strong>有可能大于进程申请的内存</strong>，那么多出来的内存将被浪费。主要出现在：<strong>固定分区内存分配、分页式内存分配等</strong>。</li></ul><h4 id="连续内存分配机制"><a href="#连续内存分配机制" class="headerlink" title="连续内存分配机制"></a>连续内存分配机制</h4><p>连续内存分配：为一个用户程序分配一个<strong>连续的内存空间</strong>。是<strong>早期</strong>的内存分配方式，适用于<strong>内存容量较小</strong>的系统。缺点：<strong>内存利用率低，存在很多碎片。</strong>一个进程的逻辑地址空间必须被分配一块连续的物理内存。</p><h5 id="单一连续内存分配"><a href="#单一连续内存分配" class="headerlink" title="单一连续内存分配"></a>单一连续内存分配</h5><p><strong>单道程序环境</strong>下，仅装有一道用户程序，即只在内存中装入一个程序，整个内存的用户空间由该程序独占。例子：CP/M、MS-DOS、RT11。</p><h5 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h5><ul><li>最早的、也是最简单的一种可运行<strong>多道程序</strong>的存储管理方式</li><li>预先把可分配的主存空间分割成<strong>若干个连续区域</strong>，称为一个<strong>分区</strong></li><li>每个分区的大小<strong>可以相同也可以不同</strong>。但分区大小<strong>固定不变</strong>，每个分区装一个且只能装一个连续的程序<ul><li>分区大小相同：<ul><li>缺乏灵活性，程序太大装不下，程序太小浪费内存。</li><li>某些情况下可用，例如管理多个相同对象。</li></ul></li><li>分区大小不同：<ul><li>许多小分区</li><li>适量中分区</li><li>少量大分区</li></ul></li></ul></li><li><strong>存在内碎片，不存在外碎片。</strong></li></ul><p><img src="%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA.png" alt="固定分区分配"></p><h5 id="可变分区分配"><a href="#可变分区分配" class="headerlink" title="可变分区分配"></a>可变分区分配</h5><p>与固定分区分配的区别在<strong>分区大小是否可以动态改变</strong>。</p><ul><li>分区(孔、Hole)—可用的内存块，不同大小的分区分布在整个内存中</li><li>当一个进程到来的时候，它将从一个足够容纳它分区中分配内存。如果这个分区太大，可以将其分为两块，<strong>一块分配给进程，一块还给空闲分区表</strong>。当进程使用完毕后，将返还分配给它的分区给孔集合。分配策略：<ul><li><strong>首次适应</strong>：分配首个足够大的孔</li><li><strong>最优适应</strong>：分配最小的足够大的孔</li><li><strong>最差适应</strong>：分配最大的足够大的孔</li><li>在速度和存储空间的利用上，首次适应和最佳适应要好于最差适应。首次使用在速度上比最有适应更快。</li></ul></li><li>操作系统包含以下信息：<ul><li>已分配的分区-<strong>已分配分区表</strong></li><li>空的分区-<strong>空闲分区表</strong></li></ul></li><li>内存回收：新孔产生时（被分出来或者被返还），需要进行<strong>内存回收</strong>，当新孔与其他孔相邻，可以将这些孔<strong>合并</strong>为更大的孔。</li><li><strong>存在外碎片，不存在内碎片</strong>。</li><li>解决外部碎片的方法：<strong>紧缩</strong>。移动内存内容，<strong>将外部碎片合并为一整块内存空间</strong>。只有当重定位是动态且在运行时进行，才可以紧缩。紧缩是运行时动态进行的。<strong>开销很大，现在一般使用非连续内存分配解决外碎片</strong>。</li></ul><p><img src="%E7%B4%A7%E7%BC%A9.png" alt="紧缩"></p><h4 id="非连续内存分配机制"><a href="#非连续内存分配机制" class="headerlink" title="非连续内存分配机制"></a>非连续内存分配机制</h4><p>非连续内存分配最大的特点是<strong>允许分配给进程的内存空间是不连续的</strong>，只要有可用的内存就可以分配给进程，大大提高了内存利用率。</p><h5 id="分页式内存分配"><a href="#分页式内存分配" class="headerlink" title="分页式内存分配"></a>分页式内存分配</h5><p><img src="%E5%88%86%E9%A1%B5%E6%A8%A1%E5%9E%8B.png" alt="分页模型"></p><ul><li><p>分页：把<strong>物理内存</strong>分成<strong>等大小</strong>的块，叫做<strong>帧（frame）或页帧（还可以叫页框）</strong>。大小通常由硬件决定，<strong>是2的幂</strong>。把<strong>逻辑内存</strong>分成<strong>大小相同</strong>的块，叫做<strong>页（page）或页面</strong>。把<strong>备份存储</strong>分成<strong>大小相同或整数倍</strong>的<strong>块（block，也叫物理块)</strong>，主要用于<strong>虚拟内存</strong>技术。</p></li><li><p>当需要执行一个进程时，它的页从<strong>文件系统或备份存储</strong>中，加载至内存的<strong>可用帧</strong>。系统通过<strong>帧表</strong>保留所有的空闲帧。逻辑内存到物理内存的映射由<strong>页表</strong>实现。每一个进程都拥有一个自己的页表，<strong>存放着自己的逻辑地址空间（页）与物理地址空间（帧）的映射。</strong></p></li><li><p>分页使逻辑内存完全<strong>独立</strong>于物理内存。它<strong>解决了外部碎片，但仍有内部碎片</strong>。</p></li><li><p>分页与分段相比：</p><ul><li>优点：避免了<strong>外部碎片和紧缩</strong>，也避免了<strong>将不同大小的内存块匹配到交换空间的麻烦问题（虚拟内存，调页机制）</strong>。</li><li>缺点：<strong>不方便共享内存</strong>，因为页在逻辑上没有意义。而段在逻辑上有意义，例如代码段、堆栈段、数据段、附加段等。</li></ul></li><li><p>地址转换机制：</p><ul><li>一个数据的<strong>逻辑地址</strong>表示通常为：<strong>页码+页偏移</strong>。</li><li>页码用来作为<strong>页表的索引</strong>，我们通过页码在页表中找到页对应的帧号。</li><li>页偏移表示<strong>数据在当前页内的偏移值</strong>。通过页偏移和帧号，我们可以最终获取该逻辑地址所在的物理地址。</li></ul><p><img src="%E5%88%86%E9%A1%B5%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80.png" alt="分页逻辑地址"></p></li></ul><p><img src="%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="逻辑地址转换"></p><ul><li>空闲帧的分配：优先选择帧表中<strong>靠前</strong>的空闲帧分配给新进程</li><li>共享页:<ul><li>分页的优点之一是可以<strong>共享公共代码</strong>。</li><li>如果代码是<strong>可重入代码或者纯代码</strong>，那么它可以被共享。可重入代码是不能自我修改（只读）的代码，它在执行期间不会改变。因此多个进程可以执行相同的代码。需要注意的是共享代码在进程的逻辑地址空间内的位置需要一致。</li><li>私有代码和数据不可以被共享，存有私有数据和代码的页能够出现在逻辑地址空间的任意位置。</li></ul></li></ul><h5 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h5><ul><li><p>页表的实现：</p><ul><li>早期实现：把页表作为一组专用的<strong>寄存器</strong>，适用于<strong>页表条目很少</strong>的情况。</li><li>现代：由于页表条目现在非常大，需要将它放在<strong>内存</strong>中，并将<strong>页表基地址寄存器（PTBR）</strong>指向它的基地址。<strong>页表限长寄存器(PRLR)</strong>表明页表的长度。</li></ul></li><li><p>页表的读取：</p><ul><li><p>直接访问内存中的页表，再访问所需数据/指令：需要<strong>两次</strong>内存访问，延迟较高。</p></li><li><p>使用<strong>转换表缓冲区（TLB，也称联想寄存器）</strong>：它是<strong>高速硬件Cache</strong>（实际上，TLB起名时出错了，不应该叫Buffer，按照功能它叫做Cache更为合理），存储<strong>少数频繁访问的页表条目</strong>，它的访问几乎不需要额外的开销，将内存访问次数由两次减少到<strong>一次</strong>。</p><ul><li><p>所需条目在TLB中：直接读取帧号，计算物理地址并访问。</p></li><li><p>所需条目不在TLB中：从内存中的页表读取帧号，并将页码和帧号存入TLB，若TLB已满可采用相应的替换策略。</p><p><img src="TLB.png" alt="TLB"></p></li><li><p><strong>有效访问时间</strong>：假设从在TLB中查找一次平均需要a微秒，从内存中存取一次平均需要b微秒，命中率$\lambda$为在TLB中找到页号的百分比，比率与<strong>TLB的大小</strong>有关。</p></li></ul></li></ul></li><li><p>页表的保护：</p><ul><li>超过页表限长：将页号与页表限长寄存器PTLR比较。</li><li>不在进程指定的逻辑内存空间内：在页表的项中加入一个有效-无效位，有效表示该页合法且在进程的逻辑地址空间内，无效表示不在进程的逻辑地址空间内。</li></ul></li><li><p>页表的结构：</p><ul><li><p>由于原始的单级页表需要<strong>连续存储</strong>，且目前的页表条目都很多，所以需要<strong>大量连续的内存空间</strong>来存储（页表必须加载进内存）。使用合适的页表结构可以减少占用的连续存储空间。</p></li><li><p><strong>层次页表</strong>：将页表再分页。使用时先利用外部页表的页码和外部页表的页偏移获取内部页表中的帧号，再计算物理地址，存取数据。<strong>（向前映射页表）</strong>除了二级页表以外，还支持三级页表甚至四级页表等。</p><p><img src="%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8.png" alt="二级页表"></p></li><li><p><strong>哈希页表</strong>：处理大于32位地址空间，防止存储时稀疏问题，解决了浪费。</p><ul><li>将虚拟页码哈希到哈希表，每个哈希表的条目中存储了一个<strong>链表</strong>（<strong>拉链法解决哈希时的碰撞</strong>），链表每个元素含有三个字段：（1）虚拟页码（2）帧号（3）指向下个元素的指针。</li><li>将虚拟页码与哈希表中第一个元素的第一个字段比较，如果相同，那么取出帧号计算物理地址。否则利用指针访问下个元素，再次比较。</li></ul><p><img src="%E5%93%88%E5%B8%8C%E9%A1%B5%E8%A1%A8.png" alt="哈希页表"></p></li><li><p><strong>倒置页表（反向页表）</strong>：通常，每个进程拥有一个页表，页表按照虚拟地址（页码）排序，操作系统通过页码可以直接访问页表的条目。但是这种方法<strong>对于每个进程创建一个页表，占用了大量物理内存，特别是对于虚拟内存技术</strong>。所以，可以使用倒置页表，<strong>为每个物理内存帧创建一个对应页的条目</strong>，使页表按照物理内存排序，所有进程共享一张页表。（倒排索引的思想）</p><ul><li>倒置页表不再包括<strong>进程逻辑地址空间的完整信息</strong>，每个进程必须将完整信息保存在外存上的<strong>外部页表</strong>中。外部页表按需调入内存。</li><li>优点：减少了物理内存的占用。</li><li>缺点：进程较少时，检索时间较长<strong>（原先直接访问，现在需要遍历搜索）</strong>。实现共享内存困难。</li></ul></li></ul></li></ul><h5 id="分段式内存分配"><a href="#分段式内存分配" class="headerlink" title="分段式内存分配"></a>分段式内存分配</h5><p><img src="%E5%88%86%E6%AE%B5.png" alt="分段"></p><p>分段：不将内存看作是一个线性数组，而将其看成是不同区域组成的。逻辑地址由<strong>段号和段偏移</strong>组成。由逻辑地址到物理地址的映射由<strong>段表</strong>来实现，段表中的每个条目包含<strong>段基址和段界限</strong>。</p><ul><li>分段与分页最大的区别在于：<strong>段的大小不固定，而页的大小固定</strong>。</li><li>分段无法解决外部碎片，<strong>因为碎片大小可能会比所有请求的段大小更小</strong>。而分页可以解决外部碎片，因为进程的内存请求以固定大小的页为单位，孔至少是一个页，能够被分配给进程。</li><li>分段不存在内部碎片问题，因为分配给进程的内存块大小不是固定的。</li><li>分段的好处是易于共享内存，因为段具有实际意义。不同进程共享的段具有同样的段号。</li><li><strong>非连续内存存储才支持共享内存，连续内存存储每个进程的内存区域都是唯一的</strong>。</li></ul><h5 id="段页式内存分配"><a href="#段页式内存分配" class="headerlink" title="段页式内存分配"></a>段页式内存分配</h5><p>段页式：先分段，再分页，<strong>每个段的大小为页大小的整数倍</strong>。<strong>解决了单纯分段的外部碎片问题</strong>。</p><ul><li>逻辑地址：&lt;段号，页号，页内偏移&gt;。</li><li>两级分页中，<strong>外部页表中的内部页表数目固定，而段页式不固定。</strong></li><li>例子：intel 386.</li></ul><p><img src="%E6%AE%B5%E9%A1%B5%E5%BC%8F.png" alt="段页式"></p><h2 id="内存扩容技术"><a href="#内存扩容技术" class="headerlink" title="内存扩容技术"></a>内存扩容技术</h2><p>逻辑地址空间——用户希望看到的内存。物理地址空间——实际的内存。<strong>当逻辑地址空间大于物理地址空间，即在较小的内存中运行较大的进程时，需要进行内存扩容。</strong></p><p>原理：<strong>局部性原理</strong>，即程序往往不需要全部装入也可正常运行。与<strong>动态加载技术思想</strong>类似，运行时动态加载模块程序。</p><p>我们需要采用<strong>以时间换空间</strong>的方法，进行内存扩容。</p><h3 id="紧缩"><a href="#紧缩" class="headerlink" title="紧缩"></a>紧缩</h3><p>属于可变分区连续内存分配的一种<strong>减少外部碎片</strong>的方式，定期移动进程，使进程占用的内存空间集中在一头，从而扩大可用的内存容量。</p><h3 id="覆盖Overlaying"><a href="#覆盖Overlaying" class="headerlink" title="覆盖Overlaying"></a>覆盖Overlaying</h3><ul><li>解决问题：程序总大小超过物理内存大小。</li><li>解决方案：程序执行时，只在内存中常驻那些无论何时都需要的指令和数据。<strong>其余不必要的部分在程序执行时相互替换（覆盖）。</strong></li><li>解决人员：<strong>程序员</strong>设计覆盖方案，覆盖程序往往十分<strong>复杂</strong>，只应用于早期操作系统。</li></ul><h3 id="交换Swapping"><a href="#交换Swapping" class="headerlink" title="交换Swapping"></a>交换Swapping</h3><p><img src="%E4%BA%A4%E6%8D%A2.png" alt="交换"></p><ul><li><p>解决问题：在内存中的某些进程由于某事件尚未发生而被<strong>阻塞运行</strong>，但它却占用了大量的内存空间，导致许多进程在外存上等待，浪费资源、降低系统吞吐量。通过交换，可以使程序总大小超过实际物理内存大小。（其实就是<strong>进程调度中的中程调度</strong>）</p></li><li><p>解决方案：一个进程可以<strong>暂时</strong>被交换（swap）到内存外的一个<strong>备份区</strong>，随后可以被换回内存继续执行。备份区是一个<strong>固定的足够大的可以容纳所有用户内存映像拷贝的快速磁盘</strong>；必须提供对这些内存映像的直接访问。</p></li><li><p>滚入，滚出(Roll out, roll in )：交换由于基于优先级的算法而不同，低优先级的进程被换出，这样高优先级的进程可以被装入和执行。</p></li><li><p>交换时间的主要部分是转移时间，总的转移时间直接同交换的内存的数量成正比。交换较为耗时，通常100MB需要4ms。</p></li><li><p>考虑到性价比，一般只有当空闲内存不够时才可以采用交换。并且一般不会换出正在等待的进程。</p></li><li><p>交换与虚拟内存技术的区别在于：<strong>交换技术以一整个进程为单位，而虚拟内存技术以页为单位。</strong></p></li></ul><h3 id="虚拟内存技术"><a href="#虚拟内存技术" class="headerlink" title="虚拟内存技术"></a>虚拟内存技术</h3><p>虚拟内存技术：当进程运行时，<strong>先将其一部分装入内存，另一部分暂留在磁盘上的备份区</strong>，当要执行的指令或访问的数据不在内存时，由操作系统自动完成将它们从磁盘调入内存执行。</p><ul><li>虚拟地址空间：分配给进程的虚拟内存。</li><li>虚拟地址：在虚拟内存中指令或数据的位置。</li><li>虚拟内存：把内存和磁盘结合起来使用，得到一个容量很大的“内存”，即虚存。其中，物理内存上的数据可以通过页表直接被访问，但<strong>如果访问到磁盘上的数据，即备份数据，需要先将其调入到内存上的空闲帧</strong>，若无空闲帧，则需要先将其利用<strong>置换算法</strong>与内存中的某个帧交换，再更新<strong>页表的项目</strong>，并<strong>重启指令</strong>执行访问。</li></ul><p>虚拟内存的大小决定因素：</p><ul><li><strong>操作系统字长</strong>：决定了逻辑地址的最大长度，自然也决定了虚拟内存的大小。如果操作系统字长不够大，那么内存再大，也无法被正确寻址并使用。例如：32位字长的操作系统最大只支持4GB的内存，现已被逐渐淘汰。</li><li><strong>内存外存容量和</strong></li></ul><p>虚拟内存的实现手段主要有：</p><ul><li><strong>虚拟页式</strong>（虚拟存储技术+页式存储管理）<ul><li><strong>请求调页</strong>（ Demand paging ）：进程运行开始前，只装入<strong>0个或1个页面</strong>，其余页面动态调入</li><li><strong>预调页</strong>（Prepaging）：进程运行开始前，将<strong>所有的页面</strong>一次性装入</li></ul></li><li><strong>虚拟段式</strong>（虚拟存储技术+段式存储管理）</li></ul><p><strong>虚拟页式+请求调页机制</strong>是目前虚拟内存技术最为常用的方法。</p><h4 id="请求调页机制"><a href="#请求调页机制" class="headerlink" title="请求调页机制"></a>请求调页机制</h4><p>进程运行开始时，仅装入<strong>一个或零个页面</strong>，所有的数据和指令大都存放在<strong>备份存储（外存）</strong>而非内存中。当进程执行过程中，根据进程的需求，动态装入页面，即<strong>将外存中固定块的内容装入内存中的某一帧，并更新页表</strong>。当内存已满时，需要利用<strong>页面置换</strong>算法，将<strong>低优先级的页面置换出去</strong>。如果事先只装入零个页面，则叫做<strong>纯请求分页</strong>。</p><p>请求调页机制的优点：</p><ul><li><strong>I/O操作少</strong></li><li><strong>需要很少的内存</strong></li><li><strong>快速响应</strong></li><li><strong>多用户</strong></li></ul><p>请求调页机制使用<strong>惰性（lazy）</strong>的<strong>调页程序（pager）</strong>，即只调入被需要的页面。</p><p><img src="%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5.png" alt="请求调页"></p><p>每一个页表的表项有一个<strong>有效-无效位</strong>相关联：</p><ul><li>1代表有效，即该页面<strong>在内存中并且合法</strong>。</li><li>0代表无效，有两种情况：<ul><li><strong>页面合法但不在内存中</strong>（可以利用调页程序调入），</li><li><strong>页面不合法</strong>（超过限长或不在逻辑地址空间内）。</li></ul></li></ul><p><strong>缺页中断</strong>：对一个页面的首次访问，需要陷入操作系统的<strong>缺页中断</strong>。（中断指的是操作系统中止CPU中正在执行的程序，转向中断服务程序进行执行，完成后再恢复原程序的执行。分为软中断和硬中断。系统调用属于软中断。）</p><p><strong>缺页中断的过程</strong>（6步，非常重要）：</p><ol><li>访问指令或数据，如果对应的页表有效-无效位为1，则直接访问对应的帧。否则，进入第2步。</li><li>查看操作系统中的另一个表来判断：<ol><li>页面合法但不在内存中：进入第3步。</li><li>页面不合法：终止，报错。</li></ol></li><li>找到页在备份存储中的位置。</li><li>查看帧表：<ol><li>如果无空闲帧，那么使用页面置换算法换出一个低优先级的帧，并且：<ol><li>如果这个帧自从调入内存以来没有被修改过，那么直接覆盖。</li><li>如果这个帧被修改过，需要先将其写入到备份区，再覆盖。</li></ol></li><li>如果有空闲帧，直接将当前页调入该帧内。</li></ol></li><li>重新设置页表，将对应页的有效位置1。</li><li>重启指令。</li></ol><p><img src="%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD.png" alt="缺页中断"></p><p>一条指令可能导致多个缺页中断（涉及多个页面）</p><p><img src="%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2.png" alt="需要页面置换的情况"></p><p><strong>硬件支持</strong>：</p><ul><li>带有效无效位的页表。</li><li>交换空间。</li><li>指令重启。</li></ul><p><strong>请求调页时内存的有效访问时间</strong>：</p><ul><li>缺页率（缺页的概率）：0 &lt;=p&lt;= 1.0（纯请求调页机制，进程刚开始时缺页率为100%）</li><li><strong>有效访问时间：EAT=(1-p) <em> 内存访问时间+P </em> 缺页错误处理时间</strong></li><li><strong>缺页错误处理时间=处理缺页中断+ [页交换出去时间 ]+ 读入页时间+ 重启进程开销。</strong>（因为对于在被调入后没有被修改过的页面，将它再次换出没有任何意义，所以可以不换出，从而减少缺页错误时间）</li><li><img src="%E7%BC%BA%E9%A1%B5%E9%94%99%E8%AF%AF.png" alt="缺页错误"></li></ul><p><strong>请求调页的性能优化</strong>：</p><ul><li>页面转换时采用交换空间，而不是文件系统：交换区的块大，比文件系统服务快速。</li><li>在进程装载时，把整个进程拷贝到交换区，基于交换区调页，早期的 BSD Unix。</li><li>利用文件系统进行交换：Solaris和当前的BSD，部分内容仍旧需要交换区（堆栈等）</li></ul><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>页面置换：当<strong>需要调入新的页面而内存中无空闲帧</strong>时，要将内存中不常使用的页面换出（<strong>牺牲</strong>）。同一页面可能被装入内存多次。</p><p>如果发生页置换，则缺页处理时间加倍，使用<strong>修改位modify bit或脏位 (dirty bit)</strong> 来防止页面转移过多：<strong>只有在被读入内存后被修改的页面才写入磁盘。</strong></p><p>页面置换算法的目的：找出一个<strong>最小缺页率</strong>的访问算法，<strong>减少缺页中断次数</strong>。</p><h5 id="先进先出（FIFO）算法"><a href="#先进先出（FIFO）算法" class="headerlink" title="先进先出（FIFO）算法"></a>先进先出（FIFO）算法</h5><ul><li>置换在内存中<strong>停留时间最久</strong>的页面。</li><li>使用FIFO队列完成，<strong>容易理解和实现，但性能不总是很好</strong>。（类似于<strong>FCFS</strong>进程调度算法）</li><li>FIFO算法可能导致<strong>Belady异常，即给进程分配的帧数越多，但缺页次数并没有下降。</strong></li></ul><blockquote><p> 先进先出的置换算法，完全不考虑使用频率，即使增加了帧数，多贮存的部分接下来常访问可能性也不一定大（看运气），也就并不一定能增加命中率。 </p></blockquote><p><img src="FIFO.png" alt="FIFO"></p><h5 id="最优置换选择（OPT）算法"><a href="#最优置换选择（OPT）算法" class="headerlink" title="最优置换选择（OPT）算法"></a>最优置换选择（OPT）算法</h5><ul><li>置换在<strong>最远的将来才需要被使用或未来不需要再使用</strong>的页面。</li><li><strong>缺页错误率最低，不会产生Belady异常，但是难以实现</strong>，因为<strong>需要未来知识</strong>（SJF进程调度算法同理），通常只用于在实验中比较研究。</li></ul><p><img src="OPT.png" alt="OPT"></p><h5 id="最近最少使用（LRU）算法"><a href="#最近最少使用（LRU）算法" class="headerlink" title="最近最少使用（LRU）算法"></a>最近最少使用（LRU）算法</h5><ul><li>置换<strong>最长时间没有被使用</strong>的页面。</li><li>性能近似于OPT，但是需要硬件的支持：<strong>计数器或堆栈</strong>，<strong>开销较大</strong>。</li><li>Leetcode上的算法题使用双向链表加哈希表实现LRU。</li></ul><p><img src="LRU.png" alt="LRU"></p><h5 id="近似LRU算法——二次机会法"><a href="#近似LRU算法——二次机会法" class="headerlink" title="近似LRU算法——二次机会法"></a>近似LRU算法——二次机会法</h5><ul><li><p>当操作系统不提供硬件支持时，可以使用<strong>引用位</strong>实现近似LRU算法。</p></li><li><p>二次机会法：</p><ul><li>初始时，将所有内存中的页面的引用位设为0。</li><li>当页面被引用时，将其引用位设为1。</li><li>当需要置换时，顺时针遍历内存中所有页面。如果找到的页的引用位为0，那么将其置换；为1，则将其改为0，继续遍历。<strong>（频繁被引用的页，其引用位总是会被置为1，所以会被后置换）</strong></li><li>当所有页的引用位都为1时，二次机会法退化为FIFO算法。</li></ul><p><img src="%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E6%B3%95.png" alt="二次机会法"></p></li><li><p>增强二次机会法：</p><ul><li>在二次机会法的基础上增加<strong>修改位</strong>。</li><li>选取优先级最高的先置换，<strong>最近没有被使用且没有被修改的页优先级最高</strong>。减少了IO次数。</li></ul></li></ul><h4 id="页框分配"><a href="#页框分配" class="headerlink" title="页框分配"></a>页框分配</h4><p>每个进程所需要的最小帧数由<strong>计算机架构</strong>决定：</p><ul><li>例子：IBM370的SS-MOV指令：<ul><li>指令是6个字节，并可能跨越2个页面</li><li>存储来源（from）可能需要2个页面</li><li>目的区域（to）可能需要2个页面</li><li>所以这个指令需要的最小帧数为6</li></ul></li></ul><p><strong>固定分配</strong>：</p><ul><li><strong>平均分配</strong>：如果有100个帧，和5个进程，则每个进程分给20个帧。</li><li><strong>比例分配</strong>：按照每个进程的大小分配。</li><li><strong>优先级分配</strong>：根据优先级而不是进程大小来使用比率分配策略</li></ul><h4 id="置换方式"><a href="#置换方式" class="headerlink" title="置换方式"></a>置换方式</h4><p><strong>全局置换</strong>：每个进程可以从<strong>所有帧的集合</strong>中选择一个进行页面置换，而不用管该帧是否已分配给其它进程。<strong>高优先级进程可以选择低优先级进程的帧来置换</strong>。</p><p><strong>局部置换</strong>：每个进程只能在<strong>自己的帧中</strong>进行选择。</p><p>全局置换往往具有<strong>更好的系统吞吐量</strong>，更为常用。</p><h4 id="颠簸"><a href="#颠簸" class="headerlink" title="颠簸"></a>颠簸</h4><p>颠簸（抖动）:一个进程的页面<strong>经常换入换出</strong>。</p><ul><li>原因：<ul><li>进程分配的<strong>帧数不足</strong>，小于局部大小之和。、<ul><li><strong>增大内存</strong>。</li><li><strong>减少多道程序道数</strong>。</li></ul></li><li>页面置换算法<strong>不合理</strong>。<ul><li>更换算法。</li></ul></li></ul></li><li>后果：<ul><li>CPU利用率低，而分页磁盘（即备份存储，用于存储尚未调入内存时逻辑内存中的页面）利用率很高，因为此时系统频繁进行页面置换，CPU需要等待。</li><li>由于此时CPU利用率很低，操作系统认为需要增加多道程序的道数，调入新进程，进而导致更多的缺页错误和更长的调页设备队列。<strong>恶性循环</strong>。</li></ul></li><li>使用<strong>局部置换策略</strong>或者<strong>优先级置换策略</strong>，可以限制系统的抖动，防止一个抖动进程使用其他运行中的进程的帧进行页面置换，从而导致抖动的扩散。</li><li>局部模型：<strong>进程由一个局部转向另一个局部</strong>。</li><li><strong>工作集模型</strong>基于局部模型，认为进程始终只使用到一部分页面。是解决颠簸问题的一个方法。<ul><li>检查最近$\delta$个页面引用，这些页面引用的页面集合就是工作集。</li><li>系统监视每个进程的工作集，并为它分配<strong>大于其工作集帧数的帧</strong>。</li><li>当所有进程的工作集帧数之和大于当前系统可用帧数时，系统将发生抖动，<strong>需要暂停一个进程</strong>。</li><li>困难：<strong>跟踪工作集</strong>。</li></ul></li><li><strong>缺页率（PFF）策略</strong>：设置可接受的缺页率。<ul><li>如果缺页率太低，回收一些进程的页框。</li><li>如果缺页率太高，就分给进程一些页框。</li></ul></li></ul><h3 id="内核内存分配"><a href="#内核内存分配" class="headerlink" title="内核内存分配"></a>内核内存分配</h3><p> 用户态的内存分配和内核态的内存分配不一样：</p><ul><li><p>内核需要为不同大小的数据结构请求内存，其中有的小于一页。因此，内核应<strong>保守</strong>地使用内存，并努力<strong>最小化碎片浪费</strong>。</p></li><li><p>内核内存分配可能需要<strong>连续的物理内存</strong>。</p><p>内核内存分配的特点：</p></li><li><p>内存块<strong>尺寸小</strong>；</p></li><li><p>占用内存块的<strong>时间短</strong>；</p></li><li><p>要求<strong>快速</strong>完成分配和回收；</p></li><li><p><strong>不参与交换</strong>；</p></li><li><p>频繁使用<strong>尺寸相同</strong>的物理块，存放同样大小的数据；</p></li><li><p>要求<strong>动态</strong>分配和回收。</p></li></ul><p>内核内存管理策略：</p><ul><li><p><strong>伙伴系统</strong>：</p><ul><li>主要用于<strong>Linux早期版本</strong>中内核底层内存管理；</li><li>从<strong>物理上连续的大小固定的段</strong>上分配内存；</li><li>主要思想：内存按2的幂的大小进行划分，即4KB、8KB等，组成若干空闲块链表；查找链表找到满足进程需求的最佳匹配块<ul><li>首先将整个可用空间看作一块: 2^n</li><li>假设进程申请的空间大小为s，如果满足2^n-1&lt;s&lt;=2^n，则分配整个块</li><li>否则，将块划分为两个大小相等的伙伴，大小为2^n-1,一直划分下去直到产生大于或等于s的最小块</li></ul></li><li>优点：通过合并的技术，可以将相邻的伙伴<strong>迅速组合</strong>以形成更大的分段；</li><li>缺点：由于圆整到下一个2的幂，所以很可能造成<strong>内部碎片</strong>浪费。</li></ul><p><img src="%E4%BC%99%E4%BC%B4.png" alt="伙伴"></p></li><li><p><strong>slab分配</strong>:</p><ul><li>本质上仍然是分页，但物理页面在内存中是连续的，我认为有些类似于分页的可变分区分配</li><li>Slab 是由一个或多个物理上<strong>连续的页</strong>组成</li><li>Cache 含有一个或多个 slab</li><li>每个内核数据结构都有一个cache，用于存储内核数据结构对象<strong>实例</strong>（<strong>每个数据结构一个Cache，每个Cache一个或多个Slab，每个Slab一个或多个物理连续的页</strong>）</li><li>优点：<ul><li>没有因碎片而引起内存浪费；</li><li>可以快速满足内存请求。</li></ul></li></ul><p><img src="slab.png" alt="slab"></p></li></ul><h3 id="虚拟内存技术拓展"><a href="#虚拟内存技术拓展" class="headerlink" title="虚拟内存技术拓展"></a>虚拟内存技术拓展</h3><h4 id="预调页"><a href="#预调页" class="headerlink" title="预调页"></a>预调页</h4><p>① 纯请求调页时，当进程启动时，会产生大量的缺页中断。</p><p>② 预调页是在进程开始时，调入进程所需的全部或部分页面，减少了开始阶段的<strong>缺页错误</strong>。有的操作系统对于<strong>小文件</strong>采用预调页，如Solaris。</p><p>③ 优点：减少了处理缺页错误的成本。</p><p>④ 缺点：如果预先调入的页面不被使用，则会造成内存浪费。</p><h4 id="页大小"><a href="#页大小" class="headerlink" title="页大小"></a>页大小</h4><p>没有最佳答案，总的来说，趋向<strong>更大的页</strong>。</p><p>① 减少内部碎片 – 需要小的页</p><p>② 减少页表大小 – 需要大的页</p><p>③ 减少读取或写入页面的I/O 开销 – 需要大的页</p><p>④ 每个页面更精确地匹配程序的局部性 – 需要小的页</p><p>⑤ 减少缺页次数 – 需要大的页</p><h4 id="TLB范围"><a href="#TLB范围" class="headerlink" title="TLB范围"></a>TLB范围</h4><p>① TLB 范围 – 通过TLB所访问的内存量</p><p>② TLB 范围 = (TLB 大小) X (页大小)</p><p>③ 理想情况：<strong>一个进程的工作集应存放在TLB中</strong></p><p>④ 增大TLB范围的方法（更快的读取页面）：</p><ul><li><strong>增大页的大小</strong>，但这可能导致内部碎片的增加;</li><li><strong>提供多种大小的页</strong>：这允许需要大页的应用程序有机会使用大页而不增加碎片的大小。</li></ul><h4 id="I-O互锁"><a href="#I-O互锁" class="headerlink" title="I/O互锁"></a>I/O互锁</h4><p>① 允许某些页在内存中被锁住；</p><p>② I/O时，正在进行I/O的页面不允许被置换算法置换出内存。</p><h4 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h4><p>① 程序结构可能影响系统性能</p><p>② 例子：</p><ul><li>array A[1024, 1024] of integer，数组的每行保存在一个页面中，创建一个进程遍历这个数组，为该进程分配一个帧。<ul><li><img src="%E7%A8%8B%E5%BA%8F1.png" alt="程序1"></li><li>程序1：1024 x 1024 缺页（每一次换一行访问，导致每一次遍历都需要产生缺页中断，进行页面置换）</li><li><img src="%E7%A8%8B%E5%BA%8F2.png" alt="程序2"></li><li>程序2：1024 次缺页（每一次访问完一个页面才会访问下一个）</li></ul></li><li>优先访问当前页面内的数据。</li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件概念"><a href="#文件概念" class="headerlink" title="文件概念"></a>文件概念</h3><p>文件：是计算机中<strong>信息存储</strong>的基本组织形式，是存储设备的<strong>逻辑存储单位</strong>，是记录在<strong>外存中</strong>的相关信息的命名组合。<strong>具有文件名</strong>。</p><p>文件名：文件系统的方便性体现在<strong>按名存取</strong>，方便人类用户的使用。通过文件的名称，可以访问文件的存储位置。文件名由一串ASCII码或(和)汉字构成，8.3规则规定文件名8个字符，类型3个字符，之间有“.”分割。长文件名规定可以最多输入255多个字符作为文件名。文件名可能大小写敏感。</p><p>文件结构：</p><ul><li>目的：<strong>便于程序理解文件内容</strong></li><li>文件结构：<ul><li><strong>无结构</strong>：文字流、字节流等</li><li><strong>简单记录结构</strong>：线性、固定长度、可变长度等</li><li><strong>复杂结构</strong>：格式化文档、多媒体文件等</li></ul></li><li>谁决定了文件结构<ul><li><strong>操作系统</strong></li><li><strong>程序</strong></li><li><strong>用户</strong></li></ul></li></ul><p>文件类型：</p><ul><li>文件类型一般由扩展名决定。文件扩展名也称文件后缀名，标识文件类型的一种机制。扩展名跟在主文件名后面，由一个分隔符“.”分隔。</li><li>Linux不严格区分文件类型。Windows严格区分。</li><li>例子：.txt,.exe,.doc…</li></ul><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>文件相关操作主要有：</p><ul><li>创建文件</li><li>写文件</li><li>读文件</li><li>在文件内重定位</li><li>删除文件</li><li>截断文件</li><li>打开文件：需要数据结构——<strong>打开文件表</strong>，存放文件指针、打开文件计数器、文件存储位置、访问权限等。</li><li>关闭文件<ul><li>为什么要进行打开文件、关闭文件：<ul><li>文件存放在外存上，打开文件操作将文件<strong>调入内存</strong>，</li><li><strong>方便文件共享</strong>。</li><li>提高<strong>文件存取效率</strong>，减少了<strong>调入内存的次数</strong>。</li></ul></li><li>打开、关闭是否必须：<strong>不必须</strong>，有的系统在每一次文件的读写操作都会<strong>隐式</strong>地进行打开文件和关闭文件，但这样效率很低，需要反复调入内存。</li></ul></li></ul><p><strong>创建文件、删除文件、打开文件、关闭文件</strong>等操作均不需要获知文件内容，只与目录有关。</p><p>而<strong>写文件、读文件、文件内重定位、截断文件</strong>等需要文件内容。</p><p>文件保护主要通过<strong>设置文件权限</strong>来进行。</p><h3 id="文件控制块FCB"><a href="#文件控制块FCB" class="headerlink" title="文件控制块FCB"></a>文件控制块FCB</h3><p>与线程、进程等类似，文件的管理也依赖于<strong>文件控制块FCB</strong>。文件控制块中，存放了文件相关的如下属性：</p><ul><li>文件名：<strong>人类可读</strong>的来保存的唯一信息。</li><li>文件标识符：<strong>人类不可读</strong>，通常为唯一的数字ID，用于给操作系统进行文件处理。</li><li><strong>文件位置</strong>：设备上文件位置的指针。<strong>（文件所在位置的索引）</strong></li><li>文件类型 ：文件的格式。</li><li>文件大小：文件当前大小。</li><li>保护：读、写、执行等访问控制信息。</li><li>时间、日期和用户标识：保护、安全和使用跟踪的数据。</li><li>……</li><li>文件属性保存在文件目录中的FCB。</li></ul><h3 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统包括：</p><ul><li><strong>文件逻辑结构</strong>（<strong>逻辑文件</strong>）：（每个文件<strong>内部</strong>记录的组织形式）<ul><li>文件内容的组织形式</li><li>面向<strong>用户</strong></li></ul></li><li><strong>目录（文件组织结构）</strong>：（每个文件整体<strong>之间</strong>的组织结构）<ul><li>文件的组织形式</li><li>存放了文件属性</li></ul></li><li><strong>文件物理结构（物理文件）</strong>：（文件在<strong>磁盘</strong>上的存储方式）<ul><li>文件的存储形式</li><li>面向<strong>系统</strong></li></ul></li></ul><h3 id="文件逻辑结构"><a href="#文件逻辑结构" class="headerlink" title="文件逻辑结构"></a>文件逻辑结构</h3><p>逻辑文件：</p><ul><li>文件内容信息<strong>呈现在用户面前</strong>的<strong>组织结构</strong></li><li>逻辑文件决定了文件存储的信息的<strong>访问方法</strong></li><li>是影响<strong>文件访问效率</strong>的重要因素。</li></ul><p>逻辑文件类型：</p><ul><li><p><strong>顺序访问（顺序文件）</strong>：文件信息<strong>按顺序</strong>（即一个接着一个记录）加以处理，依次访问数据，不能直接跳转到文件的指定位置。类似于<strong>磁带</strong>的访问方式。这种访问模式是最常见的，例如，<strong>编译器和编辑器</strong>以这种方式访问文件。还有<strong>日志文件</strong>也是顺序文件。</p><ul><li>优点：<strong>节省存储空间</strong>，不会有空间浪费。</li><li>缺点：<strong>访问效率较差。</strong>需要顺序遍历寻找，<strong>线性时间复杂度</strong>。</li></ul></li><li><p><strong>直接访问（直接文件）</strong>：又称随机访问、相对访问。文件信息以<strong>定长的分区</strong>形式存储，访问时，先计算记录所在的块，再直接读取相应的块。基于磁盘的访问方式，<strong>对于大数据的立即存取</strong>十分有用。例如，<strong>数据库</strong>通常使用这种方式。</p><ul><li>优点：<strong>访问效率较好。</strong>$O(1)$。</li><li>缺点：<strong>浪费存储空间（内部碎片）</strong>。</li></ul></li><li><p>索引文件：<strong>顺序文件存储+直接文件检索</strong></p><ul><li>文件内部的记录按照<strong>顺序访问</strong>进行存储，但是为记录建立<strong>可直接访问的索引表</strong>，存放记录号和记录所在位置的指针。访问时，先访问索引获取位置，再访问实际地址。</li></ul><p><img src="%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6.png" alt="索引文件"></p></li></ul><h3 id="目录（文件组织结构）"><a href="#目录（文件组织结构）" class="headerlink" title="目录（文件组织结构）"></a>目录（文件组织结构）</h3><p>目录项：存放文件的属性信息，在某些操作系统中，目录项中就是FCB，更多地采用<strong>iNode节点</strong>以减少目录项大小，<strong>从而提高检索效率。</strong></p><p>目录：</p><ul><li>包含着所有文件信息的<strong>节点集合</strong></li><li>根据文件名检索文件的<strong>桥梁</strong></li><li>目录项的<strong>有序集合</strong></li></ul><p>目录文件：</p><ul><li>目录的存在形式</li><li>目录以<strong>文件的方式</strong>存放在外存上的文件系统中，因为一个操作系统的文件系统往往包含着数百GB的文件，目录文件会非常大，如果全部调入内存会极大地占用空间。</li></ul><p>目录常见操作：</p><ul><li>搜索文件</li><li>创建文件</li><li>删除文件</li><li>列出目录</li><li>重命名文件</li><li>跟踪文件系统</li></ul><p>检索文件：<strong>遍历目录项</strong>（虽然目录项类似一种索引，但它由于<strong>经常变动</strong>，所以<strong>一般不排序</strong>，因此也无法直接访问，需要进行<strong>按文件名</strong>遍历）</p><p>① 打开目录文件</p><p>② 从磁盘读入该目录文件的1个(物理)块，该块包含若干个目录项</p><p>③ 根据文件名遍历内存中的该块，如找到对应的FCB则结束</p><p>④ 判断该目录文件是否还有物理块没有读入，如果是转2；否则，结束。表示该目录中没有此文件名的文件</p><p>目录性能：</p><ul><li><strong>物理块</strong>：外部存储被划分为和页、帧等大小或者倍数的物理块。<strong>内存和存储设备数据交换基本单位</strong>。一个物理块一般为4KB、8KB和16KB等</li><li>提高目录性能：检索时，读入<strong>尽可能少</strong>的物理块</li><li>如果：<ul><li>目录项大小= ds bytes</li><li>目录中最多文件数 = n</li><li>物理块大小 = b</li></ul></li><li>那么：<ul><li>目录文件大小 = ds*n bytes</li><li>目录文件需要的物理块数目 = ds*n/b</li><li>检索一个文件需要平均读入的块数=(ds*n/b+1)/2</li></ul></li><li>提高目录性能的方法<ul><li>减少目录中的文件数目（<strong>多级目录</strong>）</li><li>减少目录项的大小（<strong>iNode</strong>）</li></ul></li></ul><p>iNode：将目录项由较大的FCB变为较小的iNode，类似于索引，包含<strong>一个文件名和iNode号。</strong></p><ul><li>我们根据iNode号，可以进入一个iNode表（不含文件名）查询对应的FCB指针，通过FCB获取对应的文件。</li></ul><p><img src="iNode.png" alt="iNode"></p><h4 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h4><p>不同目录存在同名文件，为了区分引入了路径名，即<strong>从根目录开始到文件的路径</strong>，称为路径名。如/user4/a，/user1/a。<strong>./表示当前路径，../表示上一级</strong>。</p><p><strong>绝对路径</strong>：从根目录开始的路径。</p><p><strong>相对路径</strong>：从当前目录开始的路径。可以提高检索效率（当前目录和根目录位于内存中，不需要再检索）：</p><p><img src="%E8%B7%AF%E5%BE%84%E5%90%8D.png" alt="路径名"></p><h4 id="目录的逻辑结构"><a href="#目录的逻辑结构" class="headerlink" title="目录的逻辑结构"></a>目录的逻辑结构</h4><p>目录逻辑结构的设计目标：</p><ul><li><strong>效率（性能）</strong>：<ul><li>快速定位文件位置</li><li>提高文件访问效率</li></ul></li><li><strong>命名（方便性）</strong>：<ul><li>方便用户使用</li><li>同名的不同文件</li><li>不同名的相同文件</li></ul></li><li><strong>分组</strong>：<ul><li>文件分组（子目录）</li><li>兼顾效率和方便性</li></ul></li></ul><p><strong>单层目录</strong>：</p><ul><li>所有文件在<strong>同一目录</strong>中，只有一级目录：<strong>根目录</strong></li><li>优点：<strong>结构简单</strong></li><li>缺点：<ul><li><strong>效率差</strong></li><li><strong>不能有同名文件</strong></li><li><strong>不能分组</strong></li></ul></li></ul><p><img src="%E5%8D%95%E5%B1%82%E7%9B%AE%E5%BD%95.png" alt="单层目录"></p><p><strong>两级目录</strong>：</p><ul><li><strong>每个用户</strong>有自己的目录结构，即目录下的目录</li><li>优点：<ul><li><strong>不同用户可有相同文件名的文件</strong>；</li><li>比单层目录<strong>提高检索效率</strong>（文件分布在多个用户目录中）</li></ul></li><li>缺点：<ul><li>相同用户不能有同名文件;</li><li>相同用户无法给文件分组</li></ul></li></ul><p><img src="%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95.png" alt="两级目录"></p><p><strong>树形目录</strong>：</p><ul><li>两级目录的扩展，从两层变为<strong>多层</strong>。</li><li>特点：<ul><li>检索高效（子目录增多导致每个目录下文件减少）</li><li>可以分组</li><li>允许重名</li></ul></li></ul><p><strong>（有向）无环图目录</strong>:</p><ul><li>树形目录的扩展，允许目录中的多个不同的文件索引指向存储设备中的<strong>同一个</strong>物理文件。</li><li>实现了<strong>文件共享</strong>，如Windows中的快捷方式。<ul><li><strong>硬链接</strong>（Unix常用）：<ul><li>目录中的不同文件名的inode指向相同物理文件的FCB，<strong>共享FCB。</strong></li><li>本质上，采用硬链接共享的多个文件都是<strong>同一个文件</strong>。</li><li>只允许指向<strong>相同文件系统</strong>下的文件，不允许指向<strong>不存在</strong>的文件。</li></ul></li><li><strong>软链接</strong>（Windows常用）：<ul><li>目录中的不同文件名的inode指向<strong>不同的FCB</strong>，但快捷方式文件的文件内容是<strong>源文件的路径</strong>。</li><li>更加灵活，允许指向<strong>不存在的文件和不在同一文件系统下的文件</strong>。</li></ul></li></ul></li></ul><p><strong>通用图目录（有环图目录）：</strong></p><ul><li><p>可能会导致死循环。</p></li><li><p>如何保证无环？</p><ul><li>仅允许指向文件的链接，不允许指向子目录的链接</li><li>垃圾回收</li><li>每当加入新链接时，使用环路检测算法判断是否正确</li><li>优化遍历目录算法，避免对环的重复搜索</li></ul></li></ul><h2 id="文件系统实现（物理文件）"><a href="#文件系统实现（物理文件）" class="headerlink" title="文件系统实现（物理文件）"></a>文件系统实现（物理文件）</h2><p>文件系统：提供高效和便捷的<strong>磁盘访问</strong>，以便允许轻松存储、定位、提取数据.</p><ul><li><p>定义：</p><ul><li>在存储设备上组织文件的方法和数据结构。</li><li>操作系统中负责管理和存储文件信息的模块。</li></ul></li><li><p>功能：</p><ul><li>系统角度：<ul><li>对存储设备的空间进行组织和分配</li><li>负责文件<strong>检索、读写</strong>等操作</li><li>目标：<strong>存取速度和存储空间效率</strong></li></ul></li><li>用户角度：<ul><li>提供<strong>按名存取</strong>的文件访问机制</li><li>文件的<strong>组织管理</strong></li><li>目标：<strong>方便的文件存取机制</strong></li></ul></li></ul></li><li><p>结构：</p><p><img src="%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.png" alt="文件系统结构"></p></li><li><p>I/O控制层：</p><ul><li>设备驱动程序（Device Drivers）</li><li>中断处理程序</li></ul></li><li><p>基本文件系统（<strong>偏底层交互</strong>）：</p><ul><li>物理块读写</li><li>向设备驱动程序发送控制命令</li></ul></li><li><p>文件组织模块（<strong>分配空间与地址转换</strong>）：</p><ul><li>管理文件、逻辑块和物理块</li><li>把文件的逻辑地址转换为物理地址</li><li>管理空闲空间</li><li>为文件分配物理块</li></ul></li><li><p>逻辑文件系统（<strong>高层文件操作</strong>）：</p><ul><li>管理文件系统中的<strong>元数据</strong>（除了文件数据外的所有结构数据）</li><li>文件按名存取</li><li>文件目录组织管理</li><li>把文件名转换为文件ID，</li><li>文件句柄</li><li>管理FCB</li><li>存储保护</li></ul></li></ul><h3 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h3><p><strong>物理块（簇）</strong>：一个或多个（2n）<strong>扇区</strong>组成，<strong>基本文件读写单位</strong>。大小通常是<strong>页大小或整数倍</strong>。</p><p><strong>分区（物理）</strong>：可以使一个磁盘分为若干分区，也可以使一个分区由若干磁盘组成。 </p><ul><li><strong>主分区</strong>：可以安装操作系统的<strong>启动</strong>分区。</li><li><strong>扩展分区</strong>：不能安装操作系统，不能直接使用，必须先划分为若干<strong>逻辑分区（卷）</strong>。</li></ul><p><strong>卷（逻辑）</strong>：磁盘上的<strong>逻辑分区</strong>，建立在<strong>物理分区</strong>上。扩展分区必须划分为若干卷才能使用。一般一个卷可以安装一个<strong>文件系统</strong>。</p><p>常用的文件系统：</p><ul><li>Windows： <strong>FAT16、FAT32、NTFS</strong> </li><li>Linux： JFS、 ReiserFS、ext、ext2、<strong>ext3</strong>、ISO9660、XFS、Minx、MSDOS、UMSDOS、VFAT、NTFS、HPFS、NFS、 SMB、SysV、PROC </li></ul><h3 id="文件系统组成"><a href="#文件系统组成" class="headerlink" title="文件系统组成"></a>文件系统组成</h3><p><strong>磁盘文件系统</strong>（<strong>外存上的文件系统</strong>）：</p><ul><li><strong>引导控制块</strong>（Boot control block） ：包含了系统引导操作系统的各种信息，只有安装操作系统的分区才有。</li><li><strong>分区控制块</strong>（Partition control block）：包含分区信息。</li><li><strong>目录文件和FCB文件。</strong></li><li><strong>用户文件</strong>。</li></ul><p><img src="%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.png" alt="磁盘结构"></p><p><strong>内存文件系统</strong>（存放在内存）:</p><ul><li>包含:<ul><li><strong>分区表</strong>：所有安装分区信息</li><li><strong>目录缓存结构</strong>：保存最近访问的目录信息</li><li><strong>系统打开文件表</strong></li><li><strong>进程打开文件表</strong></li></ul></li><li>文件操作需要用到内存文件系统。（外存上的文件需要先读入到内存中才能继续读写操作（打开文件））</li><li>目的：<strong>通过缓存技术提高文件系统性能</strong></li></ul><p><strong>虚拟文件系统VFS</strong>：采用<strong>面向对象</strong>技术，屏蔽各文件系统之间的差异，提供<strong>统一的API</strong>。</p><p>网络文件系统NFS：用于通过<strong>LAN（或WAN）</strong>访问远程文件系统的软件系统的实现或规范。好处：<strong>节省存储空间，实现共享。</strong></p><p><strong>通用Internet文件系统CIFS</strong>：在Windows主机之间进行网络文件共享。</p><h3 id="文件物理结构"><a href="#文件物理结构" class="headerlink" title="文件物理结构"></a>文件物理结构</h3><p>物理块和逻辑块的关系类似于进程的逻辑地址和物理地址。</p><p><strong>物理块</strong>：（位于<strong>磁盘空间</strong>）</p><ul><li>读写存储设备的基本单位：<ul><li>文件读写操作<strong>按块</strong>进行。能够<strong>减少读写次数，提高效率</strong>。</li></ul></li><li>存储设备的基本分配单位：<ul><li>以物理块为单位为文件分配存储空间。</li></ul></li><li>与页面大小相匹配，通常为页面大小或者它的整数倍。</li></ul><p><strong>逻辑块</strong>：（<strong>文件空间</strong>）</p><ul><li>在文件空间中的块。</li><li>大小与物理块一致，<strong>一个逻辑块存放在一个物理块中</strong>。</li><li><strong>直接文件</strong>：一条记录占据一个逻辑块。</li><li>从0编号， 一维空间，可根据物理设备特性转换。</li></ul><p><img src="%E9%80%BB%E8%BE%91%E5%9D%97.png" alt="逻辑块"></p><p><strong>存储空间分配方式</strong>：为文件分配物理块。对应文件物理结构。（还有文件逻辑结构，文件目录结构）</p><ul><li><p><strong>连续分配</strong>（<strong>存储空间连续，顺序表</strong>）：</p><ul><li>每个文件在磁盘上占用一组<strong>连续</strong>的物理块。</li><li>FCB仅需给出文件的：<ul><li><strong>起始块号</strong>。</li><li><strong>长度</strong>。</li></ul></li><li>访问文件的某个字节的方法：<ul><li>利用该字节的逻辑地址LA（文件内相对地址，一维）除以物理块大小S，所得的商为逻辑块号Q，余数为块内偏移D。</li><li>看是否越界。不越界则将该文件的起始块号加上Q，得到所要访问的字节的物理块号B。</li><li>利用所要访问的字节的物理块号B和块内偏移D，即可取出该字节。</li></ul></li><li>优点：<ul><li>可<strong>随机访问</strong>。（可以直接计算出物理位置）</li><li><strong>存取速度快。</strong></li><li>适用<strong>一次性</strong>读写操作。（便于存取，不便于修改和删除）</li></ul></li><li>缺点：<ul><li><strong>浪费空间</strong>（连续分配导致的外部碎片）</li><li>文件不能<strong>动态增长</strong>。（需要移动之后所有的物理块）</li><li>不利于文件的插入和删除（需要移动数据）</li></ul></li><li>改进：<ul><li>基于扩展的文件系统（<strong>局部连续</strong>）</li></ul></li></ul><p><img src="%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8.png" alt="连续存储"></p></li><li><p><strong>链接分配（存储空间离散，单链表）</strong>：</p><ul><li>将文件信息存放在物理上<strong>不连续</strong>的物理块中，通过<strong>指针</strong>指明块之间的逻辑关系。</li><li>具体实现方案：<ul><li><strong>隐式链接</strong>（<strong>指针存放在每个物理块中，纯单链表</strong>）：<ul><li>FCB仅给出文件的<strong>首个</strong>物理块地址。</li><li>每个物理块都有指向<strong>下个</strong>物理块的指针。</li><li>文件终止于<strong>空指针</strong>。</li><li>由于需要存放指针，每个物理块能用于存放数据的空间<strong>变小</strong>。</li><li>访问某个字节的方式：<ul><li>利用该字节的逻辑地址LA（文件内相对地址，一维）除以物理块大小S减去指针占有空间P，所得的商为逻辑块号Q，余数为块内偏移D。</li><li>从物理块链表首部<strong>开始遍历</strong>，第Q块即为所要访问的物理块，利用块内偏移D取出该字节。</li></ul></li><li>优点：<ul><li>可以<strong>离散</strong>存放，提高<strong>磁盘利用率</strong>（<strong>解决了外部碎片</strong>）</li><li>可以<strong>动态扩充</strong>文件大小。</li><li>便于文件<strong>插入和删除</strong>。</li></ul></li><li>缺点：<ul><li>不可以随机访问，<strong>文件存取慢</strong>。（访问第i块，需要将它之前所有的块都访问一遍）</li><li>可靠性差。</li></ul></li><li>优化方法：多块集合成<strong>簇</strong>。（<strong>减少指针占用空间</strong>）</li></ul></li><li><strong>显式链接（所有指针存放于一张外部表中，单链表+索引）：</strong><ul><li>解决了隐式链接指针存放分散的问题，当随机访问某个逻辑块时，<strong>不需要遍历之前的所有物理块。</strong></li><li>设计一张<strong>链接表</strong>，为磁盘内所有物理块分配一个表项，内容为<strong>指向该物理块的next指针</strong>。访问时，先访问链接表得到物理块的地址，再直接访问。</li><li>优点：<strong>大大提高了检索速度。</strong></li><li>缺点：链接表需要在文件系统装载时，装入内存。当使用的是大容量磁盘时，需要的链接表也很大，会<strong>占用大量内存</strong>。（为许多空闲的物理块分配了表项，解决方案：<strong>索引分配</strong>）</li><li>例子：<strong>FAT文件分配表系统</strong>。</li></ul></li></ul></li></ul></li><li><p><strong>索引分配（存储空间离散，单链表+多索引）</strong>：</p><ul><li>与显式链接分配的区别是：显式链接以链表形式存储文件的物理块，为磁盘上所有物理块的指针设计一张链接表，索引分配只为<strong>每个文件内部</strong>的逻辑块设计特有的索引表。（<strong>索引表类似于页表，而链接表类似于倒置页表</strong>）</li><li><strong>索引块（表）</strong>：存放指向文件每个物理块指针的物理块</li><li><strong>索引块（表）中的第i个项</strong>：存放当前文件内部的第i个逻辑块对应的物理块指针</li><li><strong>FCB中的文件位置指向该文件的索引块（表）</strong></li><li>优点：<ul><li>支持<strong>随机访问</strong>（先访问索引块，然后访问具体块）</li><li>离散存放，<strong>没有碎片</strong></li></ul></li><li>缺点：<ul><li>需要<strong>额外空间</strong>存放索引表（虽然相比链接存储已经节省了很多空间）</li><li><strong>磁盘访问时间</strong>增加（物理块分布在磁盘各地）</li></ul></li><li>访问某个字节的方式：<ul><li>利用该字节的逻辑地址LA（文件内相对地址，一维）除以物理块大小S，所得的商为逻辑块号Q，余数为块内偏移D。</li><li>访问索引表的第Q项，获取对应的物理块号，进行访问。</li></ul></li><li><strong>多级索引</strong>：<ul><li>解决问题：单个物理块中存放的索引项是有限的。对于大文件，<strong>单个物理块</strong>是不够用的。</li><li>链接索引：索引表存放在多个物理块中，每个物理块分出一块空间存放指向下一个物理块的指针。    </li><li>二级索引：为多个索引表设计一张<strong>外层索引表</strong>。</li><li>n级索引文件大小=(1K)^n*4KB</li></ul></li></ul></li></ul><h3 id="空闲磁盘空间管理"><a href="#空闲磁盘空间管理" class="headerlink" title="空闲磁盘空间管理"></a><strong>空闲磁盘空间管理</strong></h3><h4 id="空闲表（空闲块连续）"><a href="#空闲表（空闲块连续）" class="headerlink" title="空闲表（空闲块连续）"></a>空闲表（空闲块连续）</h4><p>空闲区：连续的未分配物理块集合。</p><p>空闲表适用<strong>连续分配的空闲区</strong>。</p><p>分配和回收方式：和<strong>内存的连续分配</strong>类似。</p><p>缺点：空闲块<strong>必须连续</strong>，需要<strong>额外空间</strong>存放空闲表。</p><p><img src="%E7%A9%BA%E9%97%B2%E8%A1%A8.png" alt="空闲表"></p><h4 id="空闲链表（空闲块不连续）"><a href="#空闲链表（空闲块不连续）" class="headerlink" title="空闲链表（空闲块不连续）"></a>空闲链表（空闲块不连续）</h4><p>将磁盘上所有空闲块链接在一个链表中。</p><p>优点：不需<strong>专用块</strong>存放管理信息，仅需分出一个指针。</p><p>缺点：<strong>增加I/O操作，得到连续空间难</strong>。</p><h4 id="位示图"><a href="#位示图" class="headerlink" title="位示图"></a>位示图</h4><p> 所有块都有一个二进制位与之对应，<strong>0代表该块不空闲，1代表该块空闲。</strong></p><p>存放在物理块中，比较容易得到连续的物理块，<strong>是Windows和Linux常用的方法。</strong></p><p><strong>一般从每个字节的高位到低位是物理块号低位到高位，符合从左到右的顺序。</strong></p><p>已知，第i个字节的第j位，则该位代表的块号为：i*8+(7-J)</p><p>已知物理块号K，则它在位示图中是[K/8]个字节的[7-K%8]</p><p><img src="%E4%BD%8D%E7%A4%BA%E5%9B%BE.png" alt="位示图"></p><h4 id="成组链接"><a href="#成组链接" class="headerlink" title="成组链接"></a>成组链接</h4><p>结合了空闲表和空闲链表，Unix系统常用。</p><p>将空闲块分成若干组，每100个块为一组。每一组的首块存放了以下信息：<strong>空闲块总数、当前组空闲块位置列表、下一组空闲块组首块地址。</strong></p><p>空闲块回收：新回收的空闲块放在首个空闲块组的首部，当首个空闲块组已满，则新建一个空闲块组，并设置好指针。</p><p><img src="%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5.png" alt="成组链接"></p><h4 id="一致性检查"><a href="#一致性检查" class="headerlink" title="一致性检查"></a>一致性检查</h4><p>将目录结构数据与磁盘空闲块结构相比较，纠正发现的不一致（一致的情况应是1、0或0、1）</p><ul><li>]空闲块在某个文件的物理块中（A） （1、1）</li><li>非空闲块不属于任意一个文件（B）（0、0）</li><li>一个物理块属于多个文件（C）（2、0）</li></ul><h4 id="空闲空间整理"><a href="#空闲空间整理" class="headerlink" title="空闲空间整理"></a>空闲空间整理</h4><p>把不连续的空闲块集合在一起</p><p>利于给文件分配连续的物理块</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux账户管理</title>
      <link href="/2020/05/14/linux-zhang-hu-guan-li/"/>
      <url>/2020/05/14/linux-zhang-hu-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux账户管理"><a href="#Linux账户管理" class="headerlink" title="Linux账户管理"></a>Linux账户管理</h1><h2 id="账户实质"><a href="#账户实质" class="headerlink" title="账户实质"></a>账户实质</h2><p>账户实质上就是<strong>一个用户在系统上的标识</strong>。</p><p>系统依据账户来<strong>区分</strong>每个用户的文件、进程、任务，给每个用户提供<strong>特定的工作环境</strong>（如用户的工作目录、shell版本、以及X-Window环境的配置等），使每个用户的工作都能<strong>独立不受干扰</strong>地进行。</p><p>Linux的账户包括：</p><ul><li><strong>用户账户</strong></li><li><strong>组账户</strong></li></ul><h3 id="用户账户"><a href="#用户账户" class="headerlink" title="用户账户"></a>用户账户</h3><p>Linux系统下的用户账户（简称用户）有两种：</p><ul><li><strong>普通用户账户</strong>：在系统上的任务是进行<strong>普通工作</strong></li><li><strong>超级用户账户</strong>（或管理员账户）：在系统上的任务是<strong>对普通用户和整个系统进行管理</strong>。 </li></ul><p>每个用户都被分配了一个唯一的<strong>用户ID号</strong>（<strong>UID</strong>） （<strong>GID是组ID号</strong>）：</p><ul><li><strong>超级用户</strong>：UID=0，GID=0</li><li><strong>普通用户</strong>：UID&gt;=500</li><li><strong>系统用户</strong>（<strong>伪用户</strong>，不可登录）：0&lt;UID&lt;500</li></ul><p>用户名和 UID 被保存在 <strong>/etc/passwd</strong> 这个文件中 。</p><p>当用户登录时，他们被分配了一个<strong>主目录和一个运行的程序（通常是 shell）</strong> 。若<strong>无适当权限</strong>，用户无法读取、写入或执行彼此的文件</p><h3 id="组账户"><a href="#组账户" class="headerlink" title="组账户"></a>组账户</h3><p><strong>组是用户的集合</strong>。</p><p>每个组都被分配了一个唯一的<strong>组ID号（GID）</strong> </p><p>组和GID 被保存在 <strong>/etc/group</strong> 文件中 </p><p>每个用户都有他们自己的<strong>私有组</strong> </p><p>每个用户都可以被添加到其他组中来获得<strong>额外的存取权限</strong> </p><p>组中的所有用户都可以<strong>共享</strong>属于该组的文件</p><h4 id="标准组和私有组"><a href="#标准组和私有组" class="headerlink" title="标准组和私有组"></a>标准组和私有组</h4><ul><li><strong>标准组</strong>：<ul><li>标准组可以容纳<strong>多个用户</strong></li><li>若使用标准组，在<strong>创建</strong>一个新的用户时就应该<strong>指定</strong>他所属于的组（如果不指定，默认会创建一个私有组）</li></ul></li><li><strong>私有组</strong>：<ul><li>私有组中只有<strong>用户自己</strong></li><li>当在创建一个新用户时， 若<strong>没有指定</strong>他所属于的组，RHEL/CentOS就建立一个和该用户<strong>同名</strong>的私有组，且用户被分配到这个私有组中</li><li>优点：<strong>防止新文件归 “公共” 组所有</strong> </li><li>缺点：<strong>可能会鼓励创建 “任何人都可以访问” 的文件</strong></li></ul></li></ul><h4 id="用户和组的关系"><a href="#用户和组的关系" class="headerlink" title="用户和组的关系"></a>用户和组的关系</h4><p><strong>组是用户的集合。</strong></p><p>一个标准组可以容纳<strong>多个</strong>用户。</p><p>同一个用户可以同属于<strong>多个</strong>组，这些组可以是私有组，也可以是标准组。</p><p>当一个用户同属于多个组时，将这些组分为：</p><ul><li><strong>主组（初始组）</strong>：用户<strong>登录</strong>系统时的组。</li><li><strong>附加组</strong>：<strong>可切换</strong>的其他组。、</li></ul><h4 id="Red-Hat-的账户管理"><a href="#Red-Hat-的账户管理" class="headerlink" title="Red Hat 的账户管理"></a>Red Hat 的账户管理</h4><ul><li>默认启用<strong>shadow passwords</strong>功能。<ul><li><strong>/etc/passwd</strong>文件对任何用户<strong>均可读</strong>， 为了<strong>增加系统的安全性</strong>， 用户的口令通常用<strong>shadow passwords</strong>保护。</li><li>经过shadow passwords保护的账户密码和相关设置信息保存在<strong>/etc/shadow</strong>文件里。 /etc/shadow只对<strong>root用户</strong>可读。</li><li>默认使用<strong>MD5算法</strong>的用户口令。</li></ul></li><li>一般<strong>不设置组口令</strong>。因为绝大多数应用程序不使用组口令。</li><li>建议尽量使用<strong>私有组</strong>来提高系统安全性。</li><li>管理工具由 <strong>shadow-utils</strong> 软件包提供。</li><li>不建议管理员<strong>直接编辑修改</strong>系统账户文件来维护账户。</li></ul><h4 id="账户验证信息文件"><a href="#账户验证信息文件" class="headerlink" title="账户验证信息文件"></a>账户验证信息文件</h4><ul><li>口令文件 <strong>/etc/passwd</strong> ：文件权限 (-rw-r–r–)</li><li>影子口令文件 <strong>/etc/shadow</strong>：文件权限 (-r——–)</li><li>组账号文件 <strong>/etc/group</strong>：文件权限 (-rw-r–r– )</li><li>组口令文件 <strong>/etc/gshadow</strong>：文件权限 (-r——–)</li></ul><h4 id="口令文件-etc-passwd"><a href="#口令文件-etc-passwd" class="headerlink" title="口令文件 /etc/passwd"></a>口令文件 /etc/passwd</h4><ul><li><strong>每一个用户一条记录</strong> </li><li>每条记录由用分号间隔的<strong>七个字段</strong>组成。</li></ul><table><thead><tr><th><strong>字段</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>name</td><td>用户名</td></tr><tr><td>password</td><td>在此文件中的口令是X，这表示用户的口令是被/etc/shadow文件保护的</td></tr><tr><td>uid</td><td>用户的识别号，是一个数字。每个用户的UID都是唯一的</td></tr><tr><td>gid</td><td>用户的组的识别号，也是一个数字。每个用户账户在建立好后都会有一个主组。主组相同的账户其GID相同。</td></tr><tr><td>description</td><td>用户的个人资料，包括地址、电话等信息</td></tr><tr><td>home</td><td>用户的主目录，通常在/home下，目录名和账户名相同</td></tr><tr><td>shell</td><td>用户登录后启动的shell，默认是/bin/bash</td></tr></tbody></table><h4 id="影子口令文件-etc-shadow"><a href="#影子口令文件-etc-shadow" class="headerlink" title="影子口令文件 /etc/shadow"></a>影子口令文件 /etc/shadow</h4><ul><li><strong>每一个用户一条记录</strong> </li><li>每条记录由用分号间隔的<strong>九个字段</strong>组成。 </li></ul><table><thead><tr><th><strong>字段</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>用户名</td><td>用户登录名</td></tr><tr><td>口令</td><td>用户的密码，是加密过的（MD5）</td></tr><tr><td>最后一次修改的时间</td><td>从1970年1月1日起，到用户最后一次更改密码的天数</td></tr><tr><td>最小时间间隔</td><td>从1970年1月1日起，到用户应该更改密码的天数</td></tr><tr><td>最大时间间隔</td><td>从1970年1月1日起，到用户必须更改密码的天数</td></tr><tr><td>警告时间</td><td>在用户密码过期之前多少天提醒用户更新</td></tr><tr><td>不活动时间</td><td>在用户密码过期之后到禁用账户的天数</td></tr><tr><td>失效时间</td><td>从1970年1月1日起，到账户被禁用的天数</td></tr><tr><td>标志</td><td>保留位</td></tr></tbody></table><h4 id="组账号文件-etc-group"><a href="#组账号文件-etc-group" class="headerlink" title="组账号文件 /etc/group"></a>组账号文件 /etc/group</h4><ul><li><strong>每一个组一条记录</strong> </li><li>每条记录由用分号间隔的<strong>四个字段</strong>组成</li></ul><table><thead><tr><th><strong>字段</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>组名</td><td>这是用户登录系统时的默认组名，它在系统中是唯一的</td></tr><tr><td>口令</td><td>组口令，由于安全性原因，已不使用该字段保存口令，用“x”占位</td></tr><tr><td>组ID</td><td>是一个整数，系统内部用它来标识组</td></tr><tr><td>组内用户列表</td><td>属于该组的所有用户名表，列表中多个用户间用“,”分隔</td></tr></tbody></table><h4 id="组口令文件-etc-gshadow"><a href="#组口令文件-etc-gshadow" class="headerlink" title="组口令文件 /etc/gshadow"></a>组口令文件 /etc/gshadow</h4><ul><li><strong>每一个组一条记录</strong> </li><li>每条记录由用分号间隔的<strong>四个字段</strong>组成。</li></ul><table><thead><tr><th><strong>字段</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>组名</td><td>组名称，该字段与group文件中的组名称对应</td></tr><tr><td>加密的组口令</td><td>用于保存已加密的口令</td></tr><tr><td>组的管理员账号</td><td>管理员有权对该组添加删除账号</td></tr><tr><td>组内用户列表</td><td>属于该组的用户成员列表，列表中多个用户间用“,”分隔</td></tr></tbody></table><h3 id="用户默认环境配置及模板"><a href="#用户默认环境配置及模板" class="headerlink" title="用户默认环境配置及模板"></a>用户默认环境配置及模板</h3><p>用户默认配置文件 </p><ul><li><strong>/etc/login.defs</strong> </li><li><strong>/etc/default/useradd</strong> </li></ul><p>新用户基本信息 </p><ul><li><strong>/etc/skel</strong> </li><li>如果手工创建用户，则需复制该目录到用户主目录</li></ul><h2 id="用户和组管理工具"><a href="#用户和组管理工具" class="headerlink" title="用户和组管理工具"></a>用户和组管理工具</h2><p>本质上这些工具是在帮忙修改用户的配置文件。</p><h3 id="添加用户账号（useradd）"><a href="#添加用户账号（useradd）" class="headerlink" title="添加用户账号（useradd）"></a>添加用户账号（useradd）</h3><p>格式：</p><blockquote><p>useradd [ &lt; 选项 &gt; ] &lt; 用户名 &gt;</p></blockquote><p>常用选项:</p><table><thead><tr><th>-g group</th><th>指定新用户的主（私有）组。</th></tr></thead><tbody><tr><td>-G group</td><td>指定新用户的附加组。</td></tr><tr><td>-d directory</td><td>指定新用户的自家目录。</td></tr><tr><td>-s shell</td><td>指定新用户使用的Shell，默认为bash。</td></tr><tr><td>-e expire</td><td>指定用户的登录失效时间，例如：08/10/2001</td></tr><tr><td>-M</td><td>不建立新用户的自家目录。</td></tr></tbody></table><p>流程：</p><ol><li>编辑<strong>账户验证信息文件</strong><ol><li>/etc/passwd, /etc/shadow</li><li>/etc/group, /etc/gshadow </li></ol></li><li>创建<strong>主目录</strong> /home/&lt; username &gt;<ol><li>根据骨架目录（Skeleton Directory） /etc/skel/ 的内容填充用户主目录 </li><li>设置权限和拥有者 </li></ol></li></ol><p>显示 useradd 命令参数的<strong>默认值</strong> ：从文件 <strong>/etc/default/useradd</strong> 中读取 </p><blockquote><p>useradd -D </p></blockquote><p>可以使用 -D 选项修改默认参数：</p><blockquote><p> useradd -D [-g group] [-b base] [-s shell]  [-e expire ] </p></blockquote><h4 id="设置用户口令（passwd）"><a href="#设置用户口令（passwd）" class="headerlink" title="设置用户口令（passwd）"></a>设置用户口令（passwd）</h4><p>格式：</p><blockquote><p>passwd [ &lt; 用户账号名 &gt; ]</p></blockquote><p>使用举例</p><ul><li><p>设置用户自己的口令</p><blockquote><p>$ passwd</p></blockquote></li><li><p>root 用户设置他人的口令（<strong>必须是超级管理员用户</strong>）</p><blockquote><p>passwd user1</p></blockquote></li></ul><p>实例：</p><blockquote><p>useradd -g group1 -e 12/31/2011 user1（添加一个主用户组为group1，登录失效时间为2011年12月31日的user1用户</p><p>passwd user1（修改user1的密码口令）</p><p>useradd -G ftpgrp -d /var/ftp2 -s /sbin/nologin -M ftp1（添加一个附加组为ftpgrp，主目录为 /var/ftp2，主Shell为/sbin/nologin，不新建自家用户的ftp1用户）</p></blockquote><h3 id="修改用户账号（usermod）"><a href="#修改用户账号（usermod）" class="headerlink" title="修改用户账号（usermod）"></a>修改用户账号（usermod）</h3><p>格式：</p><blockquote><p>usermod [ &lt; 选项 &gt; ] &lt; 用户名 &gt;</p></blockquote><p>选项与<strong>useradd命令</strong>基本相同</p><p>举例：</p><blockquote><p>usermod -l user2 user1 </p><p>usermod -G softgroup jjh</p><p>usermod -L user1 </p><p>usermod -U user1 </p></blockquote><h3 id="删除用户账号（userdel）"><a href="#删除用户账号（userdel）" class="headerlink" title="删除用户账号（userdel）"></a>删除用户账号（userdel）</h3><p>格式：</p><blockquote><p>userdel [ &lt; -r &gt; ] &lt; 用户名 &gt;</p></blockquote><p>选项-r用于<strong>删除用户的宿主目录</strong></p><p>举例：</p><blockquote><p>userdel ftp1 </p><p>userdel –r user1</p></blockquote><h3 id="添加组账号（-groupadd-）"><a href="#添加组账号（-groupadd-）" class="headerlink" title="添加组账号（ groupadd ）"></a>添加组账号（ groupadd ）</h3><p>格式：</p><blockquote><p>groupadd [ &lt; 参数 &gt; ] &lt; 组账号名 &gt;</p></blockquote><p>常用参数</p><ul><li>参数-r用于创建<strong>系统组账号</strong>（GID小于500 ）</li><li>参数-g用于指定<strong>GID</strong></li></ul><blockquote><p>groupadd mygroup </p><p>groupadd -r sysgroup</p><p>groupadd -g 888 group2</p></blockquote><h3 id="修改组账号（-groupmod-）"><a href="#修改组账号（-groupmod-）" class="headerlink" title="修改组账号（ groupmod ）"></a>修改组账号（ groupmod ）</h3><p>格式:</p><blockquote><p>groupmod [ &lt; 参数 &gt; ] &lt; 组账号名 &gt;</p></blockquote><p>常用参数：</p><ul><li>参数-g改变组账号的GID ，组账号名保持不变。 </li><li>参数-n改变组账号名 </li></ul><blockquote><p>groupmod -g 503 mygroup </p><p>groupmod –n newgroup mygroup</p></blockquote><h4 id="删除组账号（-groupdel-）"><a href="#删除组账号（-groupdel-）" class="headerlink" title="删除组账号（ groupdel ）"></a>删除组账号（ groupdel ）</h4><p>格式：</p><blockquote><p>groupdel &lt; 组账号名 &gt;</p></blockquote><p>举例：</p><blockquote><p>groupdel  mygroup </p></blockquote><p>注意：</p><blockquote><p>被删除的组账号<strong>必须存在</strong> </p><p>当有用户使用组账号作为<strong>私有组</strong>时不能删除</p><p>与用户名同名的私有组账号在使用<strong>userdel命令</strong>删除用户时被<strong>同时删除</strong>，无需使用<strong>groupdel命令</strong> </p></blockquote><h3 id="组成员管理"><a href="#组成员管理" class="headerlink" title="组成员管理"></a>组成员管理</h3><p>向标准组中添加用户 :</p><blockquote><p>gpasswd -a &lt; 用户账号名&gt; &lt; 组账号名 &gt; </p><p>usermod -G &lt; 组账号名 &gt; &lt; 用户账号名 &gt; </p></blockquote><p>从标准组中删除用户 ：</p><blockquote><p>gpasswd -d &lt; 用户账号名 &gt; &lt; 组账号名 &gt; </p></blockquote><h2 id="批量用户管理"><a href="#批量用户管理" class="headerlink" title="批量用户管理"></a>批量用户管理</h2><h3 id="newusers命令"><a href="#newusers命令" class="headerlink" title="newusers命令"></a>newusers命令</h3><p>格式：</p><blockquote><p>newusers  &lt; filename &gt;</p></blockquote><p>新建一个文件，其内容格式与 <strong>/etc/passwd</strong> 一致，调用newusers指令可以将该文件内容追加到/etc/passwd中。</p><h3 id="chpasswd命令"><a href="#chpasswd命令" class="headerlink" title="chpasswd命令"></a>chpasswd命令</h3><p>格式：</p><blockquote><p>chpasswd  &lt; &lt; filename &gt;</p></blockquote><p>filename每一行的格式：</p><ul><li>username : password，username必须是系统上已存在的用户</li></ul><h3 id="pwgen命令"><a href="#pwgen命令" class="headerlink" title="pwgen命令"></a>pwgen命令</h3><p>格式：</p><blockquote><p>pwgen [选项] [口令长度] [口令个数]</p></blockquote><ul><li>默认的口令长度为 <strong>8</strong></li><li>默认生成的口令个数为 <strong>8*20</strong></li><li>选项：<ul><li>-c：至少包含一个<strong>大写字母</strong></li><li>-n：至少包含一个<strong>数字</strong></li><li>-y：至少包含一个<strong>非字母和数字的特殊字符</strong></li><li>-s：生成<strong>完全随机的安全口令</strong></li><li>-1：每行显示<strong>一个</strong>口令</li></ul></li></ul><p>使用pwgen命令生成chpasswd命令所需的口令文件：</p><pre class="line-numbers language-shell"><code class="language-shell"># cat userfile.txtuser1:x:1001:1001::/home/user1:/bin/bashuser2:x:1002:1002::/home/user2:/bin/bashftpuser1:x:2001:2001::/home/ftpuser1:/sbin/nologinftpuser2:x:2002:2002::/home/ftpuser2:/sbin/nologin# cut -d\: -f 1 userfile.txt> pwdtemp1（只取用户名）# pwgen -cn1 8 $(wc -l < userfile.txt) > pwdtemp2（生成密码）# paste -d \: pwdtemp1 pwdtemp2 > userpwdfile.txt（粘贴，以冒号为分隔符合并）# chmod 600 userpwdfile.txt; rm -f pwdtemp{1,2}（修改权限，删除临时文件）# chpasswd < userpwdfile.txt（执行chpasswd命令）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="口令维护和口令时效"><a href="#口令维护和口令时效" class="headerlink" title="口令维护和口令时效"></a>口令维护和口令时效</h2><h3 id="口令维护"><a href="#口令维护" class="headerlink" title="口令维护"></a>口令维护</h3><p><strong>禁用</strong>用户账户口令 ：</p><blockquote><p>passwd -l &lt; 用户账号名 &gt;</p></blockquote><p><strong>查看</strong>用户账户口令状态 ：</p><blockquote><p>passwd -S &lt; 用户账号名 &gt;</p></blockquote><p><strong>恢复</strong>用户账户口令：</p><blockquote><p>passwd -u &lt; 用户账号名 &gt;</p></blockquote><p><strong>清除</strong>用户账户口令 ：</p><blockquote><p> passwd -d &lt; 用户账号名 &gt;</p></blockquote><h3 id="口令时效"><a href="#口令时效" class="headerlink" title="口令时效"></a>口令时效</h3><p>口令时效是系统管理员用来防止机构内<strong>不良口令</strong>的一种技术。</p><p>防止口令被攻击的方法就是要<strong>经常地改变口令</strong>。</p><p>强制用户在一段时间之后更改口令的机制称为<strong>口令时效。</strong></p><p>在默认状况下，<strong>口令不会过期</strong>。强制口令失效是强大安全策略的一部分。</p><h3 id="设置新添用户的口令时效"><a href="#设置新添用户的口令时效" class="headerlink" title="设置新添用户的口令时效"></a>设置新添用户的口令时效</h3><p>修改 <strong>/etc/login.defs</strong> 的相关配置参数</p><table><thead><tr><th>PASS_MAX_DAYS</th><th>设定在多少天后要求用户修改口令。默认口令时效的天数为99999，即关闭了口令时效。明智的设定一般是60天（2个月）强制更改一次口令。</th></tr></thead><tbody><tr><td>PASS_MIN_DAYS</td><td>设定在本次口令修改后，至少要经过多少天后才允许更改口令。</td></tr><tr><td>PASS_MIN_LEN</td><td>设定口令的最小字符数。</td></tr><tr><td>PASS_WARN_AGE</td><td>设定在口令失效前多少天开始通知用户更改口令（一般在用户刚刚登录系统时就会收到警告通知）。</td></tr></tbody></table><h3 id="设置已存在用户的口令时效"><a href="#设置已存在用户的口令时效" class="headerlink" title="设置已存在用户的口令时效"></a>设置已存在用户的口令时效</h3><p><strong>chage命令</strong></p><p>格式：</p><blockquote><p>chage [选项] [用户登录名]</p></blockquote><p>举例：</p><ul><li><p>查看用户jason当前的口令时效信息：</p><blockquote><p>chage -l jason</p></blockquote></li><li><p>使用户jason下次登录之后修改口令</p><blockquote><p>chage -d 0 jason</p></blockquote></li><li><p>用户 jason 两天内不能更改口令，且口令最长的存活期为 30 天，并在口令过期前 5 天通知用户</p><blockquote><p>chage -m 2 -M 30 -W 5 jason</p></blockquote></li></ul><h3 id="用户切换命令"><a href="#用户切换命令" class="headerlink" title="用户切换命令"></a>用户切换命令</h3><p><strong>su</strong>（系统中单个超级用户）：</p><ul><li>直接切换为<strong>超级用户（super）</strong></li><li>普通用户要切换为超级用户必须<strong>知道超级用户的口令</strong></li><li>适用于系统中只有<strong>单个系统管理员</strong>的情况</li></ul><p><strong>sudo</strong>（系统中多个超级用户）：</p><ul><li>直接使用 <strong>sudo 命令前缀</strong>执行系统管理命令</li><li>执行系统管理命令时<strong>无需知道超级用户的口令</strong>，使用普通用户自己的口令即可</li><li>由于执行系统管理命令时无需知晓超级用户口令，所以适用于<strong>系统中有多个系统管理员的</strong>情况，因为这样不会泄露超级用户口令。当然系统只有单个系统管理员时也可以使用。</li></ul><h3 id="账户相关命令"><a href="#账户相关命令" class="headerlink" title="账户相关命令"></a>账户相关命令</h3><table><thead><tr><th>id</th><th>显示用户当前的uid、gid和用户所属的组列表</th></tr></thead><tbody><tr><td>groups</td><td>显示指定用户所属的组列表</td></tr><tr><td>whoami</td><td>显示当前用户的名称</td></tr><tr><td>w/who</td><td>显示登录用户及相关信息</td></tr><tr><td>newgrp</td><td>用于转换用户的当前组到指定的组账号，用户必须属于该组才可以正确执行该命令</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件系统</title>
      <link href="/2020/05/14/linux-wen-jian-xi-tong/"/>
      <url>/2020/05/14/linux-wen-jian-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux文件系统管理"><a href="#Linux文件系统管理" class="headerlink" title="Linux文件系统管理"></a>Linux文件系统管理</h1><h2 id="Linux文件系统概述"><a href="#Linux文件系统概述" class="headerlink" title="Linux文件系统概述"></a>Linux文件系统概述</h2><p>Linux下的所有文件和目录以一个<strong>树状</strong>的结构组织构成了 Linux 中的文件系统。</p><ul><li>Linux文件系统标准（Linux File System Standard，FSSTND） </li><li>文件系统层次结构标准（File System Hierarchy Standard，FHS） </li></ul><p>Linux常见的文件目录含义为：</p><p><strong>系统启动必须：</strong></p><ul><li><p><strong>/boot：</strong>存放的启动Linux 时使用的<strong>内核</strong>文件，包括连接文件以及镜像文件。</p></li><li><p><strong>/etc：</strong>存放<strong>所有</strong>的系统需要的<strong>配置文件</strong>和<strong>子目录列表，</strong>更改目录下的文件可能会导致系统不能启动。</p></li><li><p><strong>/lib</strong>：存放<strong>基本代码库</strong>（比如c++库），其作用类似于Windows里的<strong>DLL文件</strong>。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p><strong>/sys</strong>： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：<strong>针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统</strong>。该文件系统是<strong>内核设备树</strong>的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中</p></li></ul><p><strong>指令集合：</strong></p><ul><li><p><strong>/bin：</strong>存放着最常用的<strong>程序和指令</strong></p></li><li><p><strong>/sbin：</strong>只有<strong>系统管理员</strong>能使用的程序和指令。</p></li></ul><p><strong>外部文件管理：</strong></p><ul><li><p><strong>/dev ：</strong>Device(设备)的缩写, 存放的是Linux的外部设备。<strong>注意：</strong>在Linux中访问设备和访问文件的方式是相同的。</p></li><li><p><strong>/media</strong>：类windows的<strong>其他设备，</strong>例如U盘、光驱等等，识别后linux会把设备放到这个目录下。</p></li><li><p><strong>/mnt</strong>：<strong>临时挂载</strong>别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p></li></ul><p><strong>临时文件：</strong></p><ul><li><p><strong>/run</strong>：是一个<strong>临时</strong>文件系统，存储<strong>系统启动以来的信息</strong>。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p></li><li><p><strong>/lost+found</strong>：一般情况下为空的，系统<strong>非法关机</strong>后，这里就存放一些文件。</p></li><li><p><strong>/tmp</strong>：这个目录是用来存放一些<strong>临时文件</strong>的。</p></li></ul><p><strong>账户：</strong></p><ul><li><strong>/root</strong>：<strong>系统管理员</strong>的用户主目录。</li><li><strong>/home</strong>：<strong>用户</strong>的主目录，以用户的账号命名的。类似于windows下的<strong>users目录。</strong></li><li><strong>/usr</strong>：用户的很多应用程序和文件都放在这个目录下，类似于windows下的<strong>program files目录</strong>。</li><li><strong>/usr/bin：系统用户</strong>使用的应用程序与指令。</li><li><strong>/usr/sbin：超级用户</strong>使用的比较高级的管理程序和系统守护程序。</li><li><strong>/usr/src：</strong>内核<strong>源代码</strong>默认的放置目录。</li></ul><p>（ /bin和/usr/bin目录的区别：</p><p>1）/bin,/sbin目录是在系统启动后挂载到根文件系统中的，所以/sbin,/bin目录必须和根文件系统在同一分区；</p><p>2）  /usr/bin,usr/sbin可以和根文件系统不在一个分区。）</p><p><strong>运行过程中要用：</strong></p><ul><li><p><strong>/var</strong>：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。（variable）</p></li><li><p><strong>/proc</strong>：管理<strong>内存空间！</strong>虚拟的目录，是<strong>系统内存的映射</strong>，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。（process，进程）</p></li></ul><p><strong>扩展用的：</strong></p><ul><li><p><strong>/opt</strong>：默认是空的，我们安装额外软件可以放在这个里面。</p></li><li><p><strong>/srv</strong>：存放服务启动后需要提取的数据<strong>（不用服务器就是空）</strong></p></li></ul><h2 id="Linux支持的文件系统"><a href="#Linux支持的文件系统" class="headerlink" title="Linux支持的文件系统"></a>Linux支持的文件系统</h2><p>Linux的内核采用了称之为<strong>虚拟文件系统（Virtual File System，VFS）</strong>的技术，因此 Linux 可以支持多种不同的文件系统类型。（类似于虚拟设备）</p><p>Linux可支持的文件系统有：</p><ul><li>Linux目前几乎支持所有的<strong>UNIX类</strong>的文件系统，如 HFS、XFS、JFS、Minix FS 及 UFS 等</li><li>Linux 支持 <strong>NFS 文件系统</strong></li><li>Linux 也支持 <strong>NTFS 和 vfat（FAT32）</strong>（Windows下常用）</li></ul><h3 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h3><p>日志文件系统（journaling file system）是一个具有<strong>故障恢复能力</strong>的文件系统，在这个文件系统中，因为对目录以及位图的更新信息总是在原始的磁盘日志被更新之前写到<strong>磁盘上的一个连续的日志</strong>上，所以它<strong>保证了数据的完整性</strong>。当发生系统错误时，一个全日志文件系统将会保证磁盘上的数据恢复到<strong>发生系统崩溃前的状态</strong>。同时，它还将覆盖未保存的数据，并将其存在如果计算机没有崩溃的话这些数据可能已经遗失的位置，这是对关键业务应用来说的一个很重要的特性。 </p><p>如果不使用日志文件系统，那么一旦系统崩溃，可能导致整个磁盘卷的损坏。</p><p>日志文件系统的优点 ：</p><ul><li>提高了文件的<strong>存储安全性</strong></li><li>降低了文件<strong>被破坏的机率</strong></li><li>缩短了对磁盘的<strong>扫描时间</strong></li><li>减少了磁盘整体<strong>扫描次数</strong></li></ul><p>Linux支持以下的日志文件系统：</p><ul><li>ext3/ext4</li><li>JFS（IBM）</li><li>XFS（ SGI ）</li><li>Reiserfs</li></ul><h3 id="Linux下常见的文件系统"><a href="#Linux下常见的文件系统" class="headerlink" title="Linux下常见的文件系统"></a>Linux下常见的文件系统</h3><ul><li>Linux使用的<strong>标准文件系统</strong>：<ul><li>ext2/ext3/ext4</li></ul></li><li><strong>交换</strong>文件系统：<ul><li>swap</li></ul></li><li><strong>Windows</strong>文件系统：<ul><li>FAT32/vfat</li></ul></li><li><strong>网络</strong>文件系统：<ul><li>NFS</li></ul></li><li><strong>标准光盘</strong>文件系统：<ul><li>iso9660</li></ul></li></ul><h2 id="使用Linux文件系统的一般方法"><a href="#使用Linux文件系统的一般方法" class="headerlink" title="使用Linux文件系统的一般方法"></a>使用Linux文件系统的一般方法</h2><ol><li>在硬盘上<strong>创建分区或逻辑卷</strong>：<ol><li>可以使用fdisk命令创建分区。</li><li>可以使用LVM（logical volume manager）的相关命令创建逻辑卷</li></ol></li><li>在分区/LV上<strong>建立文件系统</strong>：<ol><li>类似于在Windows下进行格式化操作。</li></ol></li><li><strong>挂装</strong>文件系统到系统中：<ol><li>手工挂装：使用mount命令</li><li>启动时自动挂装：编辑“/etc/fstab” 添加相应的配置行。</li></ol></li><li><strong>卸装</strong>文件系统：<ol><li>对于可移动介质（如u盘、光盘）上的文件系统，当使用完毕可以使用umount命令实施卸装操作。</li></ol></li></ol><h2 id="挂装和卸装文件系统"><a href="#挂装和卸装文件系统" class="headerlink" title="挂装和卸装文件系统"></a>挂装和卸装文件系统</h2><p>什么是挂装（挂载，mount）：</p><blockquote><p>Unix操作系统只有一个单一的目录树结构，该目录树的最顶层就是 <code>/</code> ， 所有可访问文件都必须与这个目录树结构关联。这一点和Windows操作系统不同，在Windows中，每一个硬盘都有独立的目录树结构，比如<code>D:\workspace\algorithm</code> ，<code>C:\Users</code> 这样的。</p><p>挂载（mount）这一动作就是把某个设备与目录树中的某个特定位置进行关联，以便于操作系统能够从根目录开始找到这个刚刚加入的设备，从而访问该设备的内的文件数据。（需要注意的是，这里的设备是泛指，既可以指usb、CD-ROM这样真实的设备，也可以是操作系统中的某个目录）。比如，当系统启动的时候，一个特殊的存储设备（通常被称为root 分区）就会与目录树的根进行关联，换句话说，把root分区挂载到了<code>/</code> 上。</p><p>再比如说，现在你想访问存储在U盘上的数据，操作系统究竟发生了什么呢？根据前面说的，为了使操作系统找到它，我们必须把usb挂载到目录树结构的某个位置下（比如说，<code>/media/usb/</code>），假设usb设备是<code>/dev/usb</code> ，那么在把usb插入电脑的时候，对应执行的命令就是：</p><pre><code>mount /dev/usb /media/usb</code></pre><p>经过这行命令，usb中的文件就对操作系统可见了，比如在usb中的某个文件位于/dir/hello.txt，那么操作系统可访问的对应路径就是/media/usb/dir/hello.txt。当拔出usb时，就执行<code>umount /dev/usb</code> 或<code>umount /media/usb</code> （两者都可行）</p><p>Mounting applies to anything that is made accessible as files, not just actual storage devices. 比如Linux系统有一个特殊的文件系统（被称为 proc filesystem）被挂载在<code>/proc</code> 目录下，该文件系统就没有真实的存储设备：<code>/proc</code> 目录下存放的文件保存着正在运行的进程的一些信息。（关于 proc 可以看之前写的那篇文章</p></blockquote><p><strong>任何可以以文件形式访问的设备的文件系统，都可以被挂载到Linux的文件层次结构（目录树）中，以方便从根目录开始对其进行访问。这里的设备包括但不限于可移动设备、硬盘、甚至内存镜像。</strong></p><blockquote><p> 挂载的本质就是针对某一设备, 分析出其文件系统结构, 并根据其文件系统类型调用 linux 中相应的驱动, 处理其元数据, 将这些信息附加到 linux 的目录树上呈现出来。</p><p> 挂载点就是挂载的目录。</p></blockquote><p>实际上，Linux系统除了根目录以外的所有文件目录，都是系统启动后挂载进目录树的。比如最先被挂载的是内核文件目录 \boot。</p><p><img src="mount.png" alt="已挂载的设备"></p><h3 id="挂装文件系统"><a href="#挂装文件系统" class="headerlink" title="挂装文件系统"></a>挂装文件系统</h3><p>挂装文件系统通常使用mount命令，其格式为：</p><blockquote><p>mount  [选项]  [&lt;分区设备名&gt;]  [&lt;挂装点&gt;]</p></blockquote><p>常用选项：</p><ul><li><strong>-t &lt;文件系统类型&gt;：指定文件系统类型</strong></li><li>-r ：使用只读方式来挂载 </li><li>-a：挂装/etc/fstab文件中记录的设备</li><li>-o iocharset=cp936/utf8：使挂装的设备可以显示中文文件名</li><li>-o loop：使用回送设备挂装ISO文件和映像文件</li></ul><pre class="line-numbers language-shell"><code class="language-shell">$ mount $ mount -l$ mount --guess /dev/sda3# mount –t ext3 /dev/sdb1 /opt# mount –t vfat /dev/hda6 /mnt/win# mount –t vfat –o iocharset=cp936  \   /dev/hda8  /mnt/win2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="卸装文件系统"><a href="#卸装文件系统" class="headerlink" title="卸装文件系统"></a>卸装文件系统</h3><p>卸装文件系统通常使用umount命令，格式为：</p><blockquote><p>umount &lt; 分区设备名或挂装点&gt;</p></blockquote><pre class="line-numbers language-shell"><code class="language-shell"># umount /dev/hda6# umount /dev/sdb1# umount /opt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>挂装点目录<strong>必须存在</strong></li><li>应该在挂装目录的<strong>上级目录</strong>下进行挂装操作</li><li>不该在<strong>同一个挂装点目录</strong>下挂装两个文件系统</li><li>当文件系统处于<strong>“busy”状态</strong>时不能进行卸装<ul><li>文件系统何时处于“busy”状态<ul><li>文件系统上面有打开的文件</li><li>某个进程的工作目录在此文件系统上</li><li>文件系统上面的缓存文件正在被使用 </li></ul></li></ul></li></ul><h2 id="可移动介质"><a href="#可移动介质" class="headerlink" title="可移动介质"></a>可移动介质</h2><p>挂装和卸装除了用于自己电脑上的硬盘分区，还可以用于Linux系统访问各种可移动介质——<strong>光盘、DVD、软盘、USB等等</strong>。</p><p>可移动介质的挂载点通常在 <strong>/media</strong> 下。</p><h3 id="CD和DVD"><a href="#CD和DVD" class="headerlink" title="CD和DVD"></a>CD和DVD</h3><p>CD和DVD可移动设备可以在<strong>Gnome/KDE（Unix桌面环境）</strong>中自动挂载 。也可以使用命令行手工挂载：</p><ul><li>CD/DVD（只读） <ul><li>mount /media/cdrom</li></ul></li><li>CD/DVD（刻录） <ul><li>mount /media/cdrecorder</li></ul></li><li>卸载<ul><li>umount /media/cdrom</li><li>umount /media/cdrecorder</li><li>eject —— 卸载并弹出光盘</li></ul></li></ul><h3 id="USB存储设备"><a href="#USB存储设备" class="headerlink" title="USB存储设备"></a>USB存储设备</h3><ul><li>被内核探测为<strong>SCSI</strong>设备 <ul><li>/dev/sdaX、/dev/sdbX、或类似的设备文件 </li></ul></li><li>在<strong>Gnome/KDE</strong>中自动挂载 <ul><li>在[计算机]窗口中创建图标</li><li>挂载在/media/&lt;设备ID&gt;下 </li><li>&lt;设备ID&gt;被厂商内建在设备中</li></ul></li><li>命令行下手动挂载/卸载<ul><li>mount -t <strong>vfat</strong> /dev/sda1 /mnt/usb1 </li><li>umount /mnt/usb1 </li></ul></li></ul><h3 id="软盘"><a href="#软盘" class="headerlink" title="软盘"></a>软盘</h3><ul><li><strong>必须</strong>被手工挂载和卸载 <ul><li>mount /media/floppy</li><li>umount /media/floppy</li></ul></li><li>DOS软盘可以使用<strong>mtools</strong>工具<ul><li>透明地挂载和卸载设备 </li><li>使用DOS命名规则 <ul><li>mdir a:</li><li>mcopy  /home/file.txt  a:</li></ul></li></ul></li></ul><h3 id="直接挂装使用映像文件"><a href="#直接挂装使用映像文件" class="headerlink" title="直接挂装使用映像文件"></a>直接挂装使用映像文件</h3><ul><li>用mount命令加<strong>-o loop</strong>选项挂装<strong>光盘镜像</strong>文件<ul><li>mount -o loop &lt;ISO文件名&gt; &lt;挂装点&gt;</li><li>例如：<ul><li>mount -o loop CentOS-5.5-i386-bin-DVD.iso /mnt/iso </li></ul></li></ul></li><li>卸装ISO文件<ul><li>umount /mnt/iso</li></ul></li></ul><p>IMG文件同理。</p><h2 id="系统启动挂装表"><a href="#系统启动挂装表" class="headerlink" title="系统启动挂装表"></a>系统启动挂装表</h2><p>如果每次开机都手动挂载设备，那么显然会非常麻烦。我们可以使用系统启动挂载表，让系统开机时自动对需要挂载的设备进行挂载。</p><p>系统启动挂装表的目录在：<strong>/etc/fstab</strong></p><p>fstab (file system table，文件系统表) 是一个纯文本文件，开机后，系统会<strong>自动搜索</strong>该文件中的内容，对列于该文件中的文件系统进行<strong>自动挂载</strong>。也可以使用 mount -a 命令手动挂载该文件中的所有设备，这样更新后重新挂载不需要重启。</p><ul><li>系统重启时保留文件系统体系结构</li><li>配置文件系统体系结构</li><li>被 mount、fsck 和其它程序使用</li><li>使用 <strong>mount -a</strong> 命令挂载 /etc/fstab 中的所有文件系统</li><li>可以在设备栏使用文件系统卷标</li></ul><p>/etc/fstab的每一行说明一个文件系统的挂载信息，每一行由 <strong>6</strong> 列信息组成，列与列之间用 TAB 键隔开。</p><ul><li>fs_spec：设备或远程文件系统 </li><li>fs_file：挂装点目录 </li><li>fs_type：文件系统类型 </li><li>fs_options：文件系统挂载选项 </li><li>fs_dump：被”dump”命令使用来检查一个文件系统应该以多快频率进行转储，若不需要转储则该字段为“0” </li><li>fs_pass：被”fsck”命令用来决定在启动时需要被扫描的文件系统的顺序，若无需在启动时扫描则该字段为“0”</li></ul><p><img src="fstab.png" alt="fstab"></p><p>一个fstab的实例如下图所示：</p><p><img src="fstab-1.png" alt="fstab实例"></p><p>挂装选项有：</p><table><thead><tr><th><strong>选项</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>defaults</td><td>使用 rw, suid, dev, exec, auto, nouser 和 async 挂装设备</td></tr><tr><td>acl/noacl</td><td>支持/不支持 POSIX Access Control Lists （ACL）</td></tr><tr><td>async</td><td>以非同步方式（延迟写）执行文件系统的输入输出操作</td></tr><tr><td>atime/noatime</td><td>每次访问文件时都 更新/不更新 文件的访问时间，atime 为默认值，noatime 会提高文件系统的访问速度</td></tr><tr><td>auto/noauto</td><td>使用 mount -a 或开机时 会/不会自动挂装</td></tr><tr><td>dev/nodev</td><td>可以/不可 解读文件系统上的字符或区块设备</td></tr><tr><td>exec/noexec</td><td>可以/不可 执行文件系统上的二进制文件</td></tr><tr><td>suid/nosuid</td><td>开启/禁用 SUID和SGID设置位</td></tr><tr><td>user/nouser</td><td>允许普通用户/仅超级用户 挂装这个文件系统</td></tr><tr><td>users</td><td>使一般用户可以挂装/卸载,用于桌面环境，包含 noexec、nosuid、nodev 选项</td></tr><tr><td>rw/ro</td><td>以 读写/只读 方式挂装文件系统。</td></tr><tr><td>remount</td><td>重新挂装已挂装的文件系统（通常用于mount命令行）</td></tr></tbody></table><h2 id="交换空间"><a href="#交换空间" class="headerlink" title="交换空间"></a>交换空间</h2><p>Linux系统使用交换分区/文件实现<strong>虚拟内存</strong>技术，它是系统RAM的补充。能够实现内存扩容。</p><p>基本设置有：</p><ul><li>创建交换<strong>分区或者文件</strong> </li><li>使用 mkswap 创建<strong>交换文件系统</strong> </li><li>在 /etc/fstab 文件中<strong>添加适当的条目</strong> </li><li>使用 swapon -a <strong>激活</strong>交换空间 </li></ul><p>生成交换文件可以使用<strong>dd命令</strong>：</p><blockquote><p>dd if=/dev/zero of=/swapfile bs=1024 count=X</p></blockquote><h3 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h3><p>从标准输入、文件或设备读取数据，<strong>依照指定的格式</strong>来转换数据， 再输出至文件、设备或标准输出。</p><p>常用选项：</p><ul><li>if=file：输入文件名或设备名，缺省标准输入</li><li>of=file：输出文件名或设备名，缺省标准输出</li><li>bs=n：同时设置输入输出块的大小为n</li><li>count=n：仅仅读取指定的n块数据</li></ul><pre class="line-numbers language-shell"><code class="language-shell">将软盘的内容制作成映像文件备份到硬盘# dd if=/dev/fd0　of=fdtemp.img将硬盘上的软盘映像文件恢复至软盘# dd if=fdtemp.img　of=/dev/fd0将硬盘首扇备份到文件bootsector.bin中# dd if=/dev/sda of=bootsector.bin bs=512 count=1创建一个800MB的交换文件# dd if=/dev/zero of=/swapfile bs=4096 count=200000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ext2-ext3文件系统管理"><a href="#ext2-ext3文件系统管理" class="headerlink" title="ext2/ext3文件系统管理"></a>ext2/ext3文件系统管理</h2><h3 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h3><p>我们可以使用<strong>mkfs（make file system）</strong>命令在指定的设备上创建文件系统。</p><blockquote><p>mkfs -t fstype -c  分区设备名</p></blockquote><pre class="line-numbers language-shell"><code class="language-shell"># mkfs -t ext3 -c /dev/hda2# mkfs -t vfat /dev/hdb2# mke2fs -c /dev/hda2# mkfs.ext3 /dev/sda1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="检查文件系统"><a href="#检查文件系统" class="headerlink" title="检查文件系统"></a>检查文件系统</h3><p><strong>fsck（file system check）</strong>是操作系统<strong>扫描文件系统内容检查内部一致性</strong>的工具。</p><p>主要功能:</p><ul><li>检测并修正链接中断的目录</li><li>检测并修正错误时间标记</li><li>检测并修正指向错误磁盘区域的i-node</li></ul><p>命令格式：</p><blockquote><p>fsck [选项] [-t 文件系统类型] &lt;设备名&gt; [特定文件系统的附加选项]</p></blockquote><p>实例：</p><pre class="line-numbers language-shell"><code class="language-shell">检查文件系统，对所有问题回答“yes”# fsck -t ext3 /dev/sdb2自动检查并修复文件系统#  e2fsck  -p  /dev/sda5 强制进行文件系统检查，标识损坏区块，对所有问题回答“yes”#  fsck.ext3  -f  -y  /dev/hda2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意事项：</p><ul><li>一般情况下，无需用户手动执行fsck命令。</li><li>在系统启动过程中， 一旦系统检测到了不一致就会自动运行fsck命令。</li><li>手动执行fsck命令，应该在单用户模式且文件系统被卸装的情况下进行。</li></ul><h3 id="显示和调整文件系统属性"><a href="#显示和调整文件系统属性" class="headerlink" title="显示和调整文件系统属性"></a>显示和调整文件系统属性</h3><p>显示文件系统属性参数：</p><ul><li>tune2fs -l  device</li><li>dumpe2fs -h device</li></ul><p>可调整的文件系统属性参数 ：</p><ul><li>保留块 </li><li>默认挂载选项 </li><li>fsck 频率</li></ul><h4 id="tune2fs命令"><a href="#tune2fs命令" class="headerlink" title="tune2fs命令"></a>tune2fs命令</h4><blockquote><p>tune2fs [&lt;选项&gt;] &lt;设备名&gt;</p></blockquote><p>常用选项</p><ul><li>-c：表示文件系统在 mount 次数达到设定后，需要运行 fsck 检查文件系统。 </li><li>-i：文件系统的检查间隔时间。系统在达到时间间隔时，自动检查文件系统。 </li><li>-l：显示文件系统的很多参数。 </li><li>-j：为 ext2 文件系统添加文件系统日志，转换为 ext3 文件系统。 </li><li>-m: 设置保留的空间百分比，预设为 5%。 </li><li>-o: 设置默认加载参数。 </li><li>-L: 为指定设备设置卷标，不大于 16 字符。</li></ul><pre class="line-numbers language-shell"><code class="language-shell">设置默认挂载参数# tune2fs -o acl,user_xattr /dev/sda1将ext2文件系统转换成ext3文件系统。#  tune2fs -j /dev/sdb2将每两次完整性检查之间的装载次数调整为10次。#  tune2fs -c 10 /dev/sdb5将每两次完整性检查的时间间隔调整为2个月。#  tune2fs -i 2m /dev/sdb5调整指定文件系统的预留块比例为2%。#  tune2fs -m 2 /dev/sdb5禁用强制文件系统检查#  tune2fs -i0 -c0 /dev/sda1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="维护文件系统的卷标"><a href="#维护文件系统的卷标" class="headerlink" title="维护文件系统的卷标"></a>维护文件系统的卷标</h3><p>e2label </p><ul><li>功能：用于显示或设置指定ext2或ext3分区的卷标。 </li><li>格式：# e2label  &lt;设备&gt; [新的卷标名称]</li><li>举例：# e2label  /dev/sda10  www</li></ul><p>findfs </p><ul><li>功能：在系统中查找指定卷标的文件系统 </li><li>格式：# findfs LABEL=&lt;文件系统卷标&gt;</li><li>举例：# findfs LABEL=www</li></ul><h2 id="磁盘限额"><a href="#磁盘限额" class="headerlink" title="磁盘限额"></a>磁盘限额</h2><h3 id="Linux文件系统的组成"><a href="#Linux文件系统的组成" class="headerlink" title="Linux文件系统的组成"></a>Linux文件系统的组成</h3><ul><li><strong>超级块</strong>(superblock)：包含了该分区上的文件系统的整体信息，如文件系统大小等</li><li><strong>索引结点</strong>(inode)：包含了针对某一个具体文件的几乎全部信息，如存取权限、大小、对应的目录块和数据块等</li><li><strong>数据块</strong>(data block)：真正存储文件内容的位置</li><li><strong>目录块</strong>(directory block)：包含文件名字及此文件的索引节点号。</li></ul><h3 id="什么是磁盘限额"><a href="#什么是磁盘限额" class="headerlink" title="什么是磁盘限额"></a>什么是磁盘限额</h3><p>磁盘限额是系统管理员用来<strong>监控和限制用户或组对磁盘的使用</strong>的工具。 </p><p>磁盘限额可以从两方面限制：</p><ul><li>限制用户或组可以拥有的<strong>inode数</strong>（即文件个数） </li><li>限制分配给用户或组的磁盘块block的数目，即用户可以占用的<strong>磁盘容量</strong></li></ul><p>磁盘限额限定的是<strong>一个用户在一个文件系统上的额度</strong>，如果一个用户使用了多个文件系统，那么需要在多个文件系统上对它进行限制。</p><p>磁盘限额的限制策略主要有：</p><ul><li><strong>软限制</strong>：超过此设定值后仍旧可以<strong>继续存储</strong>新的文件，同时系统发出警告信息, 建议用户清理自己的文件，释放出更多的空间。<ul><li><strong>时限</strong>：超过软限制多长时间之内（默认为7天）可以继续存储新的文件。</li></ul></li><li><strong>硬限制</strong>：超过此设定值后<strong>不能继续存储</strong>新的文件。</li></ul><p>磁盘限额使用<strong>quota</strong>工具。磁盘限额的前提有：</p><ul><li>查看内核是否支持<ul><li>默认安装时，是支持quota的。</li></ul></li><li>查看系统中是否安装了quota的RPM<ul><li>Red Hat/CentOS 默认已经安装。</li></ul></li><li>查看启动脚本是否在系统启动时打开了quota<ul><li>RHEL/CentOS默认已经打开。</li></ul></li></ul><h3 id="磁盘限额的步骤"><a href="#磁盘限额的步骤" class="headerlink" title="磁盘限额的步骤"></a>磁盘限额的步骤</h3><ol><li><p><strong>启用</strong>文件系统的quota功能：编辑/etc/fstab，为需要启用quota功能的文件系统添加挂载选项，然后重新挂载文件系统：</p><blockquote><p>LABEL=/home      /home         ext3     defaults,<strong>grpquota,usrquota</strong>    1  2</p><p>mount <strong>-o remount</strong> /home</p></blockquote></li><li><p>创建<strong>quota数据库</strong>并开启quota</p><blockquote><p>创建quota数据库</p><p>quotacheck -cmvug /home</p><p>开启quota功能</p><p>quotaon -avug</p></blockquote></li><li><p>设置<strong>用户和组</strong>的quota</p><ul><li><p>交互式编辑配额：edquota</p><pre class="line-numbers language-shell"><code class="language-shell">#编辑指定用户的配额(user)edquota [-u]  [ -f filesystem ] <username>#编辑指定组的配额(group)edquota -g    [ -f filesystem ] <groupname>#编辑指定用户的配额时限(time)edquota -t [-u]  [ -f filesystem ] #编辑指定组的配额时限edquota -t -g    [ -f filesystem ] <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>-f filesystem 表示对指定的文件系统设置配额，省略时表示对所有启用了quota的文件系统进行设置。</p></li><li><p>使用edquota编辑配额，会通过vim打开一个文本文件，直接对里面的文本进行修改并保存退出即可</p></li></ul><pre class="line-numbers language-shell"><code class="language-shell">filesystem blocks soft hard inodes soft hard/dev/hda3 752 0 0 163 0 0 (修改前)/dev/hda3 752 5000 8000 163 200 400 (修改后)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><pre><code> ```</code></pre><ul><li><p>命令式设置配额：setquota</p><ul><li>指定用户的设置配额<br>setquota [-u] &lt; username &gt; &lt;块软限制 块硬限制 inode软限制 inode硬限制&gt;  &lt;-a|文件系统&gt;</li><li>为指定组的设置配额<br>setquota  -g &lt; groupname &gt; &lt;块软限制 块硬限制 inode软限制 inode硬限制&gt;  &lt;-a|文件系统&gt;</li><li>为指定用户的设置配额时限<br>setquota -t [-u] &lt;块时限 inode时限&gt;  &lt;-a|文件系统&gt;</li><li>为指定组的设置配额时限<br>setquota -t -g   &lt;块时限 inode时限&gt;  &lt;-a|文件系统&gt;</li><li>若对所有启用了quota的文件系统设置配额，则使用-a；否则，若对指定的文件系统设置配置，则需要指定文件系统。</li></ul></li><li><p>将参考用户/组的配额复制给其他用户/组</p><ul><li>edquota  -p protoname……<ul><li>edquota [-u] -p &lt; protouname &gt; &lt; username &gt;</li></ul></li><li>setquota -p protoname ……<ul><li>setquota [-u] -p &lt; protouname &gt; &lt; username &gt; &lt;-a|filesystem&gt;</li></ul></li></ul></li></ul><ol start="4"><li><p>查看磁盘限额状况：</p><pre class="line-numbers language-shell"><code class="language-shell">查看指定用户或组的quota设置# quota [-vl] [-u <username>] # quota [-vl] [-g <groupname>] # quota -q 显示文件系统的磁盘限额汇总信息显示指定文件系统的磁盘限额汇总信息   # repquota [-ugv] filesystem... 显示所有文件系统的磁盘限额汇总信息   # repquota [-augv] <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的grep、awk和sed命令</title>
      <link href="/2020/05/05/linux-de-grep-awk-he-sed-ming-ling/"/>
      <url>/2020/05/05/linux-de-grep-awk-he-sed-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux的grep、awk和sed命令"><a href="#Linux的grep、awk和sed命令" class="headerlink" title="Linux的grep、awk和sed命令"></a>Linux的grep、awk和sed命令</h1><p>grep、awk和sed命令是Linux下比较常用的三种用于文本相关操作的命令，很有学习的必要。通常情况下，Linux运用在服务器上，而服务器运行的程序经常会产生日志，或者其它很大的文本文件，我们使用cat命令将无法方便地找到想要的文本，所以只能使用这些命令。</p><h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><h3 id="grep简介"><a href="#grep简介" class="headerlink" title="grep简介"></a>grep简介</h3><blockquote><p> grep [范本模式] [文件或目录] </p></blockquote><p>grep命令是一种强大的文本搜索工具，它能使用<strong>正则表达式</strong>搜索文本，并把匹配的行<strong>打印</strong>出来。</p><p>grep的全名叫做：Global Regular Expression Print，表示<strong>全局正则表达式打印</strong>，它的使用权限是<strong>所有用户</strong>。</p><p>grep搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。</p><p>grep命令主要包括：</p><ul><li>grep</li><li>egrep：等同于grep -E，是 grep的扩展，支持更多的正则表达式元字符。</li><li>fgrep：将模式串中的所有字符看作是普通字符，不再具有正则表达式元字符的含义。</li></ul><p>grep也可以不指定文件和目录，直接通过管道符“|”输入文本进行搜索。例如：我们有1000个进程在执行，需要找到名为test的进程，就可以使用如下的式子<code>ps -aux | grep test</code></p><h3 id="grep主要参数"><a href="#grep主要参数" class="headerlink" title="grep主要参数"></a>grep主要参数</h3><p>grep命令的主要参数有：</p><ul><li><strong>-a 或 –text</strong> : 不要忽略二进制的数据。</li><li><strong>-A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt;</strong> : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。</li><li><strong>-b 或 –byte-offset</strong> : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。</li><li><strong>-B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt;</strong> : 除了显示符合样式的那一行之外，并显示该行之前的内容。</li><li><strong>-c 或 –count</strong> : 计算符合样式的列数。</li><li><strong>-C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt;</strong> : 除了显示符合样式的那一行之外，并显示该行之前后的内容。</li><li><strong>-d &lt;动作&gt; 或 –directories=&lt;动作&gt;</strong> : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</li><li><strong>-e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt;</strong> : 指定字符串做为查找文件内容的样式。</li><li><strong>-E 或 –extended-regexp</strong> : 将样式为延伸的正则表达式来使用。</li><li><strong>-f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt;</strong> : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。</li><li><strong>-F 或 –fixed-regexp</strong> : 将样式视为固定字符串的列表。</li><li><strong>-G 或 –basic-regexp</strong> : 将样式视为普通的表示法来使用。</li><li><strong>-h 或 –no-filename</strong> : 在显示符合样式的那一行之前，不标示该行所属的文件名称。</li><li><strong>-H 或 –with-filename</strong> : 在显示符合样式的那一行之前，表示该行所属的文件名称。</li><li><strong>-i 或 –ignore-case</strong> : 忽略字符大小写的差别。</li><li><strong>-l 或 –file-with-matches</strong> : 列出文件内容符合指定的样式的文件名称。</li><li><strong>-L 或 –files-without-match</strong> : 列出文件内容不符合指定的样式的文件名称。</li><li><strong>-n 或 –line-number</strong> : 在显示符合样式的那一行之前，标示出该行的列数编号。</li><li><strong>-o 或 –only-matching</strong> : 只显示匹配PATTERN 部分。</li><li><strong>-q 或 –quiet或–silent</strong> : 不显示任何信息。</li><li><strong>-r 或 –recursive</strong> : 此参数的效果和指定”-d recurse”参数相同。</li><li><strong>-s 或 –no-messages</strong> : 不显示错误信息。</li><li><strong>-v 或 –revert-match</strong> : 显示不包含匹配文本的所有行。</li><li><strong>-V 或 –version</strong> : 显示版本信息。</li><li><strong>-w 或 –word-regexp</strong> : 只显示全字符合的列。</li><li><strong>-x –line-regexp</strong> : 只显示全列符合的列。</li><li><strong>-y</strong> : 此参数的效果和指定”-i”参数相同。</li></ul><h3 id="egrep语法"><a href="#egrep语法" class="headerlink" title="egrep语法"></a>egrep语法</h3><p>egrep命令使用扩展的正则表达式，比grep命令的常规正则表达式更加规范，推荐使用。</p><p>其格式为：</p><blockquote><p>egrep [范本模式] [文件或目录] </p></blockquote><p>需要注意的是，grep命令不仅可以在指定文件下查询匹配正则表达式的字符串，还可以在指定目录下查询，具体的方法为：</p><blockquote><p>egrep [模式串] *（表示当前目录）</p></blockquote><h2 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h2><h3 id="awk简介"><a href="#awk简介" class="headerlink" title="awk简介"></a>awk简介</h3><p>awk命令，本质上是一门专有的语言，主要用来读入标准输入内容，按照特定的规则过滤后写入标准输出。</p><p>它的特点有：</p><ul><li>解释型，是Unix的标准过滤器程序；</li><li>执行速度快，擅长结构化文本数据处理和报表生成；</li><li>与grep、tr、wc、sort、uniq等功能单一的过滤器程序不同，awk程序支持<strong>用户自己编程</strong>实现文本过滤功能，更加强大和灵活。</li></ul><h3 id="awk使用方式"><a href="#awk使用方式" class="headerlink" title="awk使用方式"></a>awk使用方式</h3><p>awk主要有五种使用方式：</p><ul><li><p>管道符传入文本：<code>cat emp.data | awk &#39;$3 &gt; 0 { print $1, $2 * $3 }</code></p></li><li><p>常规方式，指定文本文件：<code>awk &#39;$3 &gt; 0 { print $1, $2 * $3 } &#39; emp.data</code></p></li><li><p>将awk语言脚本写在指定的文件中，使用awk命令执行，并指定文本文件：<code>awk -f programfile emp.data</code></p></li><li><p>将awk语言脚本写在指定的文件中，使用awk命令执行，并使用管道符传入文本：<code>cat emp.data | awk -f programfile</code></p></li><li><p>在awk脚本文件的开头使用<code>#! /usr/bin/awk -f</code>指定执行脚本的程序，然后使用：<code>chmod +x programfile</code></p><p>和<code>cat emp.data | ./programfile</code></p></li></ul><p>比较复杂的awk脚本推荐写在文本文件中，再使用awk命令执行。</p><h3 id="awk程序的结构"><a href="#awk程序的结构" class="headerlink" title="awk程序的结构"></a>awk程序的结构</h3><p>awk程序等于：<strong>模式  \{动作\}</strong>。如：<code>awk &#39;$3 &gt; 0 { print $1, $2 * $3 } &#39; emp.data</code>，<code>$3 &gt; 0</code> 即为模式，而<code>{ print $1, $2 * $3 }</code>是动作。</p><p>awk程序的执行过程就是：按行匹配模式，如果当前行符合指定的模式，那么就在当前行执行指定的动作。</p><h4 id="缺省模式"><a href="#缺省模式" class="headerlink" title="缺省模式"></a>缺省模式</h4><p>awk程序的模式或者动作可以缺省：</p><ul><li>如果模式缺省：表示匹配所有行。</li><li>如果动作缺省：表示输出匹配的行。</li></ul><h4 id="特殊模式BEGIN和END"><a href="#特殊模式BEGIN和END" class="headerlink" title="特殊模式BEGIN和END"></a>特殊模式BEGIN和END</h4><ul><li>BEGIN{ 这里面放的是执行前的语句 }</li><li>END {这里面放的是处理完所有的行后要执行的语句 }</li><li>{这里面放的是处理每一行时要执行的语句}</li></ul><p>实例：</p><ul><li>假设有一张学生成绩表</li></ul><pre class="line-numbers language-shell"><code class="language-shell">$ cat score.txtMarry   2143 78 84 77Jack    2321 66 78 45Tom     2122 48 77 71Mike    2537 87 97 95Bob     2415 40 57 62<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>我们的awk脚本如下：</li></ul><pre class="line-numbers language-shell"><code class="language-shell">$ cat cal.awk#!/bin/awk -f#运行前BEGIN {    math = 0    english = 0    computer = 0    printf "NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n"    printf "---------------------------------------------\n"}#运行中{    math+=$3    english+=$4    computer+=$5    printf "%-6s %-6s %4d %8d %8d %8d\n", $1, $2, $3,$4,$5, $3+$4+$5}#运行后END {    printf "---------------------------------------------\n"    printf "  TOTAL:%10d %8d %8d \n", math, english, computer    printf "AVERAGE:%10.2f %8.2f %8.2f\n", math/NR, english/NR, computer/NR}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用awk -f命令执行脚本，结果为：</li></ul><pre class="line-numbers language-shell"><code class="language-shell">$ awk -f cal.awk score.txtNAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL---------------------------------------------Marry  2143     78       84       77      239Jack   2321     66       78       45      189Tom    2122     48       77       71      196Mike   2537     87       97       95      279Bob    2415     40       57       62      159---------------------------------------------  TOTAL:       319      393      350AVERAGE:     63.80    78.60    70.00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="常用内建变量"><a href="#常用内建变量" class="headerlink" title="常用内建变量"></a>常用内建变量</h4><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">$n</td><td align="left">当前记录的第n个字段，字段间由FS分隔</td></tr><tr><td align="left">$0</td><td align="left">完整的输入记录</td></tr><tr><td align="left">ARGC</td><td align="left">命令行参数的数目</td></tr><tr><td align="left">ARGIND</td><td align="left">命令行中当前文件的位置（从0开始算）</td></tr><tr><td align="left">ARGV</td><td align="left">包含命令行参数的数组</td></tr><tr><td align="left">CONVFMT</td><td align="left">数字转换格式（默认值为%.6g）ENVIRON环境变量关联数组</td></tr><tr><td align="left">ERRNO</td><td align="left">最后一个系统错误的描述</td></tr><tr><td align="left">FIELDWIDTHS</td><td align="left">字段宽度列表（用空格键分隔）</td></tr><tr><td align="left">FILENAME</td><td align="left">当前文件名</td></tr><tr><td align="left">FNR</td><td align="left">各文件分别计数的行号</td></tr><tr><td align="left">FS</td><td align="left">字段分隔符（默认是任何空格）</td></tr><tr><td align="left">IGNORECASE</td><td align="left">如果为真，则进行忽略大小写的匹配</td></tr><tr><td align="left">NF</td><td align="left">一条记录的字段的数目</td></tr><tr><td align="left">NR</td><td align="left">已经读出的记录数，就是行号，从1开始</td></tr><tr><td align="left">OFMT</td><td align="left">数字的输出格式（默认值是%.6g）</td></tr><tr><td align="left">OFS</td><td align="left">输出记录分隔符（输出换行符），输出时用指定的符号代替换行符</td></tr><tr><td align="left">ORS</td><td align="left">输出记录分隔符（默认值是一个换行符）</td></tr><tr><td align="left">RLENGTH</td><td align="left">由match函数所匹配的字符串的长度</td></tr><tr><td align="left">RS</td><td align="left">记录分隔符（默认是一个换行符）</td></tr><tr><td align="left">RSTART</td><td align="left">由match函数所匹配的字符串的第一个位置</td></tr><tr><td align="left">SUBSEP</td><td align="left">数组下标分隔符（默认值是/034）</td></tr></tbody></table><p>一些内建变量可以被我们自己修改，我们可以在BEGIN中写入命令修改它们。例如FS变量，可以修改为任意的字符串。</p><h3 id="awk的控制结构"><a href="#awk的控制结构" class="headerlink" title="awk的控制结构"></a>awk的控制结构</h3><p>与常规的编程语言类似，awk也支持C语言风格的控制语句。</p><p> <a href="https://www.runoob.com/w3cnote/awk-if-loop.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/awk-if-loop.html</a> </p><p>此外，awk也支持函数，包括内建函数和用户自定义函数：</p><p> <a href="https://www.runoob.com/w3cnote/awk-built-in-functions.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/awk-built-in-functions.html</a> </p><h3 id="awk的数组"><a href="#awk的数组" class="headerlink" title="awk的数组"></a>awk的数组</h3><p>awk的数组不需要事先声明，直接使用下标赋值即可。和Shell的数组有一些类似。（感觉有点更像哈希表）</p><p> <a href="https://www.runoob.com/w3cnote/awk-arrays.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/awk-arrays.html</a> </p><h3 id="awk的正则表达式"><a href="#awk的正则表达式" class="headerlink" title="awk的正则表达式"></a>awk的正则表达式</h3><p>awk可以在模式中加入正则表达式匹配，其中 ~ 符号表示正则表达式匹配开始，//中写入正则表达式。例如：</p><pre class="line-numbers language-shell"><code class="language-shell"># 输出第二列包含 "th"，并打印第二列与第四列$ awk '$2 ~ /th/ {print $2,$4}' log.txt---------------------------------------------this a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>~ 符号可以省略，表示在整行中进行正则表达式匹配：</p><pre class="line-numbers language-shell"><code class="language-shell"># 输出包含"re" 的行$ awk '/re/ ' log.txt---------------------------------------------3 Are you like awk10 There are orange,apple,mongo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h2><p>Linux sed 命令是利用脚本来处理文本文件。</p><p>sed 可依照脚本的指令来处理、编辑文本文件。</p><p>Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p><p>sed = stream editor，即<strong>流编辑器</strong>。</p><h3 id="sed参数"><a href="#sed参数" class="headerlink" title="sed参数"></a>sed参数</h3><p>sed命令常用的参数选项如下：</p><ul><li>-e 或–expression 以选项中指定的script来处理输入的文本文件。</li><li>-f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。</li><li>-h或–help 显示帮助。</li><li>-n或–quiet或–silent 仅显示script处理后的结果。</li><li>-V或–version 显示版本信息。</li><li>-r 使用扩展的正则表达式，更加简洁，类似于grep 的-e选项。</li></ul><h3 id="sed动作"><a href="#sed动作" class="headerlink" title="sed动作"></a>sed动作</h3><ul><li>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现（目前的下一行）～</li><li>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li><li>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</li><li>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现（目前的上一行）；</li><li>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</li><li>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</li><li>g：全局替换标志</li></ul><p>需要注意的是：sed的所有动作，包括s、p、d、a、i等，都是<strong>以行为单位</strong>的！</p><h3 id="替换命令s"><a href="#替换命令s" class="headerlink" title="替换命令s"></a>替换命令s</h3><p>sed命令中最基础、最重要的命令就是s：文本替换，其基本格式如下：</p><blockquote><p>sed ‘s/xxx/yyy/[g]’</p></blockquote><p>其中：</p><ul><li>s为替换命令的标志，写在sed语句的最前面</li><li>xxx是要替换的字符串，可以是正则表达式</li><li>yyy是用于替换的字符串</li><li>分隔符号”/“可以替换成其他符号，如：head -5 /etc/passwd | sed ‘s|/bin/sh/|/bin/bash/|’</li><li>&amp;可以表示要替换的正则表达式，即xxx，匹配到的内容</li><li>yyy中，支持正则表达式的\num元字符，用来获取xxx中第num个分组的匹配结果</li><li>默认情况下，sed中使用正则表达式的所有特殊字符都需要进行转义。如果我们加入-r选项，使用增强的正则表达式，会更加规范，且不需要转义</li><li>g 表示全局替换，如果不加g，sed默认只替换当前匹配到的第一个字符串</li><li>除标记 g 外，替换命令还可以使用标记 /n ，用以具体描述替换发生的位置，即在当前匹配到的第几个字符串进行替换</li><li>替换命令仅在原始输入文本上进行操作</li></ul><p>例如：</p><blockquote><p>sed ‘s/one/ONE/‘</p></blockquote><h3 id="删除命令d"><a href="#删除命令d" class="headerlink" title="删除命令d"></a>删除命令d</h3><p>删除命令d可以对指定行号的行进行删除：</p><ul><li>删除第2到5行</li></ul><blockquote><p>nl /etc/passwd | sed ‘2,5d’</p></blockquote><ul><li>删除第3行到最后一行</li></ul><blockquote><p>nl /etc/passwd | sed ‘3,$d’ </p></blockquote><p>也可以对匹配指定表达式的行进行删除：</p><blockquote><p>nl /etc/passwd | sed  ‘/root/d’</p></blockquote><h3 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h3><p>sed重要的内容就这些，更多内容可以参考 <a href="https://www.runoob.com/linux/linux-comm-sed.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-sed.html</a> </p><h2 id="比较grep、sed、awk"><a href="#比较grep、sed、awk" class="headerlink" title="比较grep、sed、awk"></a>比较grep、sed、awk</h2><ul><li>grep 更适合<strong>单纯的查找或匹配文本</strong></li><li>sed 更适合<strong>编辑</strong>匹配到的文本</li><li>awk 更适合<strong>格式化</strong>文本，对文本进行较复杂格式处理，例如生成报表</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式笔记</title>
      <link href="/2020/05/05/zheng-ze-biao-da-shi-bi-ji/"/>
      <url>/2020/05/05/zheng-ze-biao-da-shi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式笔记"><a href="#正则表达式笔记" class="headerlink" title="正则表达式笔记"></a>正则表达式笔记</h1><h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h2><p><strong>正则表达式</strong>，又称规则表达式<strong>。</strong>（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。</p><h2 id="正则表达式的作用"><a href="#正则表达式的作用" class="headerlink" title="正则表达式的作用"></a>正则表达式的作用</h2><p>典型的搜索和替换操作要求提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。</p><p>通过使用正则表达式，可以：</p><ul><li>测试字符串内的模式。<br>例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</li><li>替换文本。<br>可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</li><li>基于模式匹配从字符串中提取子字符串。<br>可以查找文档内或输入域内特定的文本。</li></ul><p>许多编程语言都支持正则表达式，但或多或少会存在着一些区别。</p><h2 id="正则表达式的语法"><a href="#正则表达式的语法" class="headerlink" title="正则表达式的语法"></a>正则表达式的语法</h2><p>正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。 </p><blockquote><p>正则表达式 = 普通字符 + 元字符</p></blockquote><p>一般情况下，普通字符和元字符需要使用转义符号反斜杠“\”互相转义。</p><p>一个简单的正则表达式示例：</p><blockquote><p>^[0-9]+abc$</p></blockquote><p>上述正则表达式的含义为：匹配单独的一个字符串，以1个或多个数字开头，且以字符串abc结尾。</p><h2 id="正则表达式的元字符"><a href="#正则表达式的元字符" class="headerlink" title="正则表达式的元字符"></a>正则表达式的元字符</h2><p>正则表达式的普通字符即为没有特殊指明为元字符的数字、字母、符号等所有字符。</p><p>正则表达式的核心是多样的元字符，正是这些元字符赋予了正则表达式匹配多样字符串的能力。</p><h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><p>非打印字符指的是没有被显式地打印出来的字符，正则表达式提供了以下的元字符去匹配它们。</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\cx</td><td align="left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td align="left">\f</td><td align="left">匹配一个<strong>换页符</strong>。等价于 \x0c 和 \cL。</td></tr><tr><td align="left">\n</td><td align="left">匹配一个<strong>换行符</strong>。等价于 \x0a 和 \cJ。</td></tr><tr><td align="left">\r</td><td align="left">匹配一个<strong>回车符</strong>。等价于 \x0d 和 \cM。</td></tr><tr><td align="left">\s</td><td align="left">匹配任何<strong>空白字符，包括空格、制表符、换页符等等</strong>。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td></tr><tr><td align="left">\S</td><td align="left">匹配任何<strong>非空白字符</strong>。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td align="left">\t</td><td align="left">匹配一个<strong>制表符</strong>。等价于 \x09 和 \cI。</td></tr><tr><td align="left">\v</td><td align="left">匹配一个<strong>垂直制表符</strong>。等价于 \x0b 和 \cK。</td></tr></tbody></table><h3 id="常见特殊字符"><a href="#常见特殊字符" class="headerlink" title="常见特殊字符"></a>常见特殊字符</h3><p>特殊字符指的是在正则表达式中具有特殊含义的字符，如果我们需要匹配它们的原本形态，应该在前面加上转义字符”\”。</p><p>常见的特殊字符有：</p><table><thead><tr><th align="left">特别字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">$</td><td align="left">匹配输入字符串的<strong>结尾位置</strong>。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 <code>\$</code>。</td></tr><tr><td align="left">( )</td><td align="left">标记一个<strong>子表达式的开始和结束位置</strong>。子表达式可以获取供以后使用。要匹配这些字符，请使用 <code>\(</code> 和 <code>\)</code>。</td></tr><tr><td align="left">*</td><td align="left">匹配前面的子表达式<strong>零次或多次</strong>。要匹配 <em> 字符，请使用 `\</em>`。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式<strong>一次或多次</strong>。要匹配 + 字符，请使用 <code>\+</code>。</td></tr><tr><td align="left">.</td><td align="left">匹配<strong>除换行符 \n 之外的任何单字符</strong>。要匹配 . ，请使用 <code>\.</code> 。</td></tr><tr><td align="left">[</td><td align="left">标记一个<strong>中括号表达式</strong>的开始。要匹配 [，请使用 <code>\[</code>。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式<strong>零次或一次</strong>，或<strong>指明一个非贪婪限定符</strong>。要匹配 ? 字符，请使用 <code>\?</code>。</td></tr><tr><td align="left">\\</td><td align="left">将下一个字符标记为<strong>或特殊字符、或原义字符、或向后引用、或八进制转义符</strong>。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\\’ 匹配 “\”，而 ‘(‘ 则匹配 “(“。需要注意，如果要匹配反斜杠，同样需要转义：<code>\\</code>。</td></tr><tr><td align="left">^</td><td align="left">匹配输入字符串的<strong>开始位置</strong>，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，<strong>表示不接受该方括号表达式中的字符集合</strong>。要匹配 ^ 字符本身，请使用 <code>\^</code>。</td></tr><tr><td align="left">\{</td><td align="left">标记<strong>限定符表达式</strong>的开始。要匹配 \{，请使用 <code>\{</code>。</td></tr><tr><td align="left">|</td><td align="left">指明<strong>两项之间的一个选择</strong>。要匹配 |，请使用 <code>|</code>。</td></tr></tbody></table><p>有几点易混淆的：</p><ul><li>*匹配之前的子表达式0次或多次，+匹配1次或多次，?匹配0次或1次。默认情况下，一个字符就是一个子表达式，除非使用括号括起来成为一个整体的子表达式。</li><li>?除了可以做限定符表示匹配前面的子表达式0次或1次，还可以表示非贪婪的匹配，既一旦匹配到符合条件的结果立刻返回。默认的匹配模式是贪婪的，能匹配得越多越好。</li><li>^在中括号表达式中，表示匹配除了中括号表达式中的字符集合以外的字符。如：[^0-9]表示匹配除了数字0到9以外的任意字符。</li></ul><h3 id="常用匹配符"><a href="#常用匹配符" class="headerlink" title="常用匹配符"></a>常用匹配符</h3><p>这些元字符是最常使用的，用于匹配字母、数字等内容。</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>匹配<strong>除换行符以外的任意字符</strong>，如果要匹配包括 ‘\n’ 在内的任何字符，请使用`(.</td></tr><tr><td>\w</td><td>匹配<strong>字母或数字或下划线</strong>，等价于’[A-Za-z0-9_]’。</td></tr><tr><td>\s</td><td>匹配任意的<strong>空白符</strong></td></tr><tr><td>\d</td><td>匹配<strong>数字</strong></td></tr><tr><td>\b</td><td>匹配单词的<strong>开始或结束</strong></td></tr></tbody></table><h3 id="中括号表达式"><a href="#中括号表达式" class="headerlink" title="中括号表达式"></a>中括号表达式</h3><p>中括号表达式通常用来表示字符集合或者字符范围。</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>[xyz]</td><td>匹配xyz中的任意一个字符</td></tr><tr><td>[a-z]</td><td>匹配从a到z这一范围中的任意一个字符</td></tr></tbody></table><h3 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h3><p>反义，有定义的元字符大写，即是反义，同样，在中括号表达式内的字符集或字符范围前加上^也是反义。它的含义是匹配给定的字符或字符集合以外的任意字符。</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\W</td><td>匹配<strong>非字母、数字、下划线</strong>。等价于 <code>[^A-Za-z0-9_]</code>。</td></tr><tr><td>\S</td><td>匹配任意<strong>不是空白符的字符</strong></td></tr><tr><td>\D</td><td>匹配任意<strong>非数字的字符</strong></td></tr><tr><td>\B</td><td>匹配<strong>非单词边界</strong></td></tr><tr><td>[^xyz]</td><td>匹配除了xyz以外的任意字符</td></tr><tr><td>[^a-z]</td><td>负值字符范围。匹配除了a到z以外的任意字符</td></tr></tbody></table><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>限定符用来指明匹配子表达式出现的次数，常用的限定符有一下6种：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">匹配前面的子表达式<strong>零次或多次</strong>。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式<strong>一次或多次</strong>。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式<strong>零次或一次</strong>。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td></tr><tr><td align="left">{n}</td><td align="left">n 是一个非负整数。匹配<strong>确定的 n 次</strong>。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td align="left">{n,}</td><td align="left">n 是一个非负整数。<strong>至少匹配n 次</strong>。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td align="left">{n,m}</td><td align="left">m 和 n 均为非负整数，其中n &lt;= m。<strong>最少匹配 n 次且最多匹配 m 次</strong>。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>定位符有如下几种，一般用于指定正则表达式匹配的字符串出现的特定位置，如行首、单词开头等。</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">^</td><td align="left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td></tr><tr><td align="left">$</td><td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词边界，即字与空格间的位置。</td></tr><tr><td align="left">\B</td><td align="left">非单词边界匹配。</td></tr></tbody></table><h3 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h3><p>默认情况下，正则表达式的匹配是贪婪的，即：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。</p><p>除了<code>{n}</code>限定符指定了确定的n次匹配以外，其余限定符指定的匹配都可以是一个范围。贪婪的匹配就是尽可能在这一范围内多匹配字符。</p><p>例如：存在字符串“aabab”，如果我们使用正则表达式<code>a.*b</code>匹配，默认会匹配到”aabab”。</p><p>有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。这时我们可以在限定符后面加上<code>?</code>，意味着尽可能少地重复。</p><p>常见的懒惰限定符有：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">*?</td><td align="left">重复0次或任意次，但尽可能少重复</td></tr><tr><td align="left">+?</td><td align="left">重复1次或更多次，但尽可能少重复</td></tr><tr><td align="left">??</td><td align="left">重复0次或1次，但尽可能少重复</td></tr><tr><td align="left">{n,m}?</td><td align="left">重复n到m次，但尽可能少重复</td></tr><tr><td align="left">{n,}?</td><td align="left">重复n次以上，但尽可能少重复</td></tr></tbody></table><p>对字符串”aabab”，如果我们使用非贪婪的正则表达式<code>a.*?b</code>匹配将得到结果”aab”。可能你会问：为什么不是ab，不是尽可能少匹配吗？这是因为正则表达式的匹配规则是具有优先级的，匹配的先后优先级高于非贪婪的优先级。</p><h3 id="并列"><a href="#并列" class="headerlink" title="并列"></a>并列</h3><p>我们可以使用竖杠”|“将多个子表达式合并在一起，任意匹配到其中一个子表达式即可。</p><blockquote><p> x|y </p></blockquote><p>例如：</p><p>电话号码可以是3位区号8位号码，或4位区号7位号码</p><ul><li>022-22334455    </li><li>0477-7192112</li></ul><p>我们可以写出正则表达式：<code>\d{3}-\d{8}|\d{4}-\d{7}</code></p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p> 们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定<strong>子表达式</strong>(也叫做<strong>分组</strong>)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作。</p><p>例如，我们想要匹配IP地址，可以对重复的部分进行分组后使用：<code>(\d{1,3}\.){3}\d{1,3}</code></p><h3 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h3><p>当我们使用小括号对表达式进行了分组后，<strong>分组匹配到的结果默认会临时存储起来</strong>，可以在后面利用组号进行二次调用。</p><p>默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。调用时，对组号为1的子表达式，使用<code>\1</code>进行调用。</p><p>如果我们不想通过默认的组号调用分组的匹配结果，<strong>可以为各分组起名</strong>，格式为：<code>(?&lt;name&gt;exp)</code>。</p><p>实例：</p><p>\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, kitty kitty。首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，然后是1个或几个空白符(\s+)，最后还是前面匹配的那个单词(\1)。</p><p>如果我们不想让分组的结果被存储，可以使用<code>(?:pattern)</code>。这是一个<strong>非获取匹配</strong>的分组，匹配到的结果不会存入内存中，也无法进行后向引用。</p><p>此外，还有一些常见的<strong>零宽断言</strong>，一般加入问号的分组都不存储，只是用来判断是否符合条件，不加入结果中：</p><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>(pattern)</td><td>匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。</td></tr><tr><td>(?:pattern)</td><td>匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。</td></tr><tr><td>(?=pattern)</td><td>正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?!pattern)</td><td>正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?&lt;=pattern)</td><td>反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95</td></tr><tr><td>(?&lt;!pattern)</td><td>反向否定预查，与正向否定预查类似，只是方向相反。例如”<code>(?&quot;能匹配&quot;</code>3.1Windows<code>&quot;中的&quot;</code>Windows<code>&quot;，但不能匹配&quot;</code>2000Windows<code>&quot;中的&quot;</code>Windows`”。</td></tr></tbody></table><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>运算符的优先级从高到低如下表所示：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">转义符</td></tr><tr><td align="left">(), (?:), (?=), []</td><td align="left">圆括号和方括号</td></tr><tr><td align="left">*, +, ?, {n}, {n,}, {n,m}</td><td align="left">限定符</td></tr><tr><td align="left">^, $, \任何元字符、任何字符</td><td align="left">定位点和序列（即：位置和顺序）</td></tr><tr><td align="left">|</td><td align="left">替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本编程</title>
      <link href="/2020/05/03/shell-jiao-ben-bian-cheng/"/>
      <url>/2020/05/03/shell-jiao-ben-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><p>本文中由于编译的问题，将所有英文括号换成了中文括号，需要注意！</p><h1 id="Shell脚本编程"><a href="#Shell脚本编程" class="headerlink" title="Shell脚本编程"></a>Shell脚本编程</h1><h2 id="什么是Shell"><a href="#什么是Shell" class="headerlink" title="什么是Shell"></a>什么是Shell</h2><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p><p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p><h2 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h2><p>当命令不在命令行中执行，而是从一个文件中执行时，该文件就称为 Shell 脚本。</p><ul><li>Shell 脚本是纯文本文件。</li><li>Shell 脚本通常以 .sh 作为后缀名，但不是必须。</li><li>Shell 脚本是以行为单位的，在执行脚本的时候会分解成一行一行依次执行。</li><li>Shell 是一种功能强大的解释型编程语言，通常用于完成特定的、较复杂的系统管理任务。</li><li>Shell 脚本语言非常擅长处理文本类型的数据。</li></ul><blockquote><p>脚本其实就是短小的、用来让计算机自动化完成一系列工作的程序，这类程序可以用文本编辑器修改，不需要编译，通常是解释运行的。 </p></blockquote><h2 id="Shell-环境"><a href="#Shell-环境" class="headerlink" title="Shell 环境"></a>Shell 环境</h2><p> Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 </p><p>Linux 的 Shell 种类众多，常见的有：</p><ul><li>Bourne Shell（/usr/bin/sh或/bin/sh）</li><li>Bourne Again Shell（/bin/bash）</li><li>C Shell（/usr/bin/csh）</li><li>K Shell（/usr/bin/ksh）</li><li>Shell for Root（/sbin/sh）</li><li>……</li></ul><p>我们最常使用的通常是Bash。 同时，Bash 也是大多数Linux 系统默认的 Shell。 一般而言，bash和sh不严格区分。</p><h2 id="Shell编程的步骤"><a href="#Shell编程的步骤" class="headerlink" title="Shell编程的步骤"></a>Shell编程的步骤</h2><p>一般来说，编写、执行一个Shell脚本需要如下的步骤：</p><ol><li><p>创建一个文本文件，通常以.sh结尾，但不影响脚本的执行（Linux的特性）</p><blockquote><p>touch test.sh</p></blockquote></li><li><p>使用文本编辑器打开该文件，一般可以使用gedit、vim等</p><blockquote><p>vim test.sh</p></blockquote></li><li><p>输入脚本代码，通常我们还需要在开头声明执行脚本的程序的解释器，即哪一种Shell解释器</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bashThis is the first Bash shell program # Scriptname: greetings.shechoecho -e "Hello $LOGNAME, \c"echo    "it's nice talking to you."echo -n "Your present working directory is: "pwd # Show the name of present directoryechoecho -e "The time is `date +%T`!. \nBye"echo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>保存脚本，并为其添加可执行权限</p><blockquote><p>chmod +x test.sh</p></blockquote></li><li><p>执行脚本，这里必须使用./告诉系统在当前目录下寻找脚本。因为不加./，系统会默认从环境变量<code>$PATH</code>中的路径寻找可执行的脚本，而一般我们的路径都不在<code>$PATH</code>中。</p><blockquote><p>./test.sh</p></blockquote></li><li><p>也可以直接使用解释器执行，将文件名作为解释器的参数：</p><blockquote><p>bash test.sh</p></blockquote></li></ol><h2 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h2><h3 id="Shell变量的类型"><a href="#Shell变量的类型" class="headerlink" title="Shell变量的类型"></a>Shell变量的类型</h3><p>Shell变量主要可以分为4类：</p><ul><li>用户自定义变量<ul><li>由用户自己定义、修改和使用</li></ul></li><li>Shell 环境变量<ul><li>由系统维护，用于设置用户的Shell工作环境</li><li>只有少数的变量用户可以修改其值</li></ul></li><li>位置参数变量（Positional Parameters）<ul><li>通过命令行给程序传递执行参数</li><li>可用 shift 命令实现位置参数的迁移</li></ul></li><li>专用参数变量（Special Parameters）<ul><li>Bash 预定义的特殊变量</li><li>用户不能修改其值</li></ul></li></ul><h3 id="Shell变量的定义和赋值"><a href="#Shell变量的定义和赋值" class="headerlink" title="Shell变量的定义和赋值"></a>Shell变量的定义和赋值</h3><p> 定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如： </p><blockquote><p>a=0</p></blockquote><p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><p>除了显式的为变量赋值，我们还可以使用命令赋值，如：</p><blockquote><p>for file in <code>$（ls /etc）</code></p></blockquote><p>此外，还可以用read语句通过读取输入端口的输入为变量赋值，如：</p><blockquote><p>read -p “please input：” name</p></blockquote><h3 id="Shell变量的使用"><a href="#Shell变量的使用" class="headerlink" title="Shell变量的使用"></a>Shell变量的使用</h3><p> 使用一个定义过的变量，只要在变量名前面加美元符号即可，如： </p><pre class="line-numbers language-shell"><code class="language-shell">your_name="qinjx"echo $your_nameecho ${your_name}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况： </p><pre class="line-numbers language-shell"><code class="language-shell">for skill in Ada Coffe Action Java; do    echo "I am good at ${skill}Script"done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果不给skill变量加花括号，写成echo “I am good at <code>$skillScript&quot;</code>，解释器就会把<code>$skillScript</code>当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。此外，变量还可以参与计算，此时必须加上花括号。</p><p>推荐给所有变量加上花括号，这是个好的编程习惯。</p><p> 已定义的变量，可以被重新定义，如： </p><pre class="line-numbers language-shell"><code class="language-shell">your_name="tom"echo $your_nameyour_name="alibaba"echo $your_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是：定义变量时一律不加<code>$</code>，使用变量时一律加<code>$</code>。</p><h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><p> 使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 </p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/basha=0readonly aa=1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果尝试修改只读变量的值，程序将报错。类似于Java中的final。</p><h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>使用 unset 命令可以删除变量。语法：</p><pre class="line-numbers language-shell"><code class="language-shell">unset variable_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>变量被删除后不能再次使用。unset 命令不能删除只读变量。</p><p>被删除变量的所有资源将被系统回收。</p><h3 id="变量的间接引用"><a href="#变量的间接引用" class="headerlink" title="变量的间接引用"></a>变量的间接引用</h3><p>变量的间接引用在高级语言中十分常见，特别是可变类型的变量。Shell中以下两种方式来进行间接引用：</p><ul><li>使用感叹号：</li></ul><pre class="line-numbers language-shell"><code class="language-shell">＃ bash2.0以上才支持newstr=${!str2}echo $newstrHello World或echo ${!str2}Hello World <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用<code>$</code>：</li></ul><pre class="line-numbers language-shell"><code class="language-shell">eval newstr=`$$str2echo $newstrHello World或eval echo `$$str2Hello World <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="内置命令eval"><a href="#内置命令eval" class="headerlink" title="内置命令eval"></a>内置命令eval</h3><blockquote><p>eval arg1 [arg2] … [argN]</p></blockquote><p>Shell内置命令eval通常用于解释并执行字符串类型的命令，我们可以将命令以字符串的形式进行拼接修改，最后用eval命令进行执行。</p><p>它对参数进行两次扫描和替换：</p><ul><li><p>将所有的参数连接成一个表达式，并计算或执行该表达式</p></li><li><p>参数中的任何变量都将被展开</p></li></ul><pre class="line-numbers language-python"><code class="language-python">listpage<span class="token operator">=</span><span class="token string">"ls -l | more"</span>eval $listpage<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><p>位置参数变量是一组特殊的内置变量，一般用于跟在函数调用之后或者执行脚本时脚本名的后面。</p><p><code>$1</code>代表的是第一个位置参数变量，<code>${11}</code>代表第十一个位置参数变量。</p><p>用处主要是：</p><ul><li>从 shell 命令/脚本 的命令行接受参数</li><li>在调用 shell 函数时为其传递参数</li></ul><h4 id="shift-n"><a href="#shift-n" class="headerlink" title="shift [n]"></a>shift [n]</h4><ul><li>将位置参量列表依次左移n次，缺省为左移一次</li><li>一旦位置参量列表被移动，最左端的那个参数就会从列表中删除</li><li>经常与循环结构语句一起使用，以便遍历每一个位置参数</li></ul><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/sh# ScriptName: pp_shift.sh# To test Positional Parameters & Shift.echo "The script name is :  $0"echo '$1'=$1,'$2'=$2,'$3'=$3,'$4'=$4   --   '$#'="$#" echo '$@': "$@" shift              # 向左移动所有的位置参数1次echo '$1'=$1,'$2'=$2,'$3'=$3,'$4'=$4   --   '$#'="$#"echo '$@': "$@"shift 2            # 向左移动所有的位置参数2次echo '$1'=$1,'$2'=$2,'$3'=$3,'$4'=$4   --   '$#'="$#"echo '$@': "$@"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="专用参数变量"><a href="#专用参数变量" class="headerlink" title="专用参数变量"></a>专用参数变量</h3><p>用户无法修改这些值。</p><h4 id="位置参数相关"><a href="#位置参数相关" class="headerlink" title="位置参数相关"></a>位置参数相关</h4><ul><li><code>$*</code>        将所有位置参量看成一个字符串（以空格间隔） 。</li><li><code>$@</code>      将每个位置参量看成单独的字符串（以空格间隔）。</li><li>“<code>$*</code>”   将所有位置参量看成一个字符串（以$IFS间隔）。</li><li>“<code>$@</code>” 将每个位置参量看成单独的字符串（以$IFS间隔） 。</li><li><code>$0</code>       命令行上输入的Shell程序名。</li><li><code>$#</code>    表示命令行上参数的个数。</li></ul><h4 id="进程状态相关"><a href="#进程状态相关" class="headerlink" title="进程状态相关"></a>进程状态相关</h4><ul><li><code>$?</code>  表示上一条命令执行后的返回值<ul><li>0：成功</li><li>1－255：不成功<ul><li>1：通用错误</li><li>126：命令或脚本没有执行权限</li><li>127：命令没找到</li></ul></li><li>通常与exit命令配合使用，用于退出脚本或当前Shell </li></ul></li><li><code>$$</code>  当前进程的进程号</li><li><code>$!</code>   显示运行在后台的最后一个作业的 PID </li><li><code>$_</code>  在此之前执行的命令或脚本的最后一个参数</li></ul><h2 id="Shell字符串"><a href="#Shell字符串" class="headerlink" title="Shell字符串"></a>Shell字符串</h2><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。 </p><h4 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h4><pre class="line-numbers language-shell"><code class="language-shell">str='this is a string'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li><li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li></ul><h4 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h4><pre class="line-numbers language-shell"><code class="language-shell">your_name='runoob'str="Hello, I know you are \"$your_name\"! \n"echo -e $str<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出结果为：</p><pre class="line-numbers language-shell"><code class="language-shell">Hello, I know you are "runoob"! <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>双引号的优点：</p><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符（但必须在使用echo语句时，加上-e选项，解释转义字符）</li></ul><p>单双引号最显著的区别在于：<strong>单引号不解释变量，双引号解释变量且支持转义。</strong></p><h4 id="反撇号"><a href="#反撇号" class="headerlink" title="反撇号"></a>反撇号</h4><p>反撇号 ` `：展开变量并执行表达式，将命令执行的结果输出给变量。</p><pre class="line-numbers language-shell"><code class="language-shell">string="runoob is a great site"count=`expr index "$string" io`  # 输出 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>类似的，$（expression）也有类似的作用，可以用来获取执行命令的结果：</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bashecho $（expr 3 + 4）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><p>拼接时可以使用双引号，也可以使用单引号。嵌套的单引号将解释变量，但不嵌套的单引号不解释内层的变量。</p><pre class="line-numbers language-shell"><code class="language-shell">your_name="runoob"# 使用双引号拼接greeting="hello, "$your_name" !"greeting_1="hello, ${your_name} !"echo $greeting  $greeting_1# 使用单引号拼接greeting_2='hello, '$your_name' !'greeting_3='hello, ${your_name} !'echo $greeting_2  $greeting_3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为：</p><pre class="line-numbers language-shell"><code class="language-shell">hello, runoob ! hello, runoob !hello, runoob ! hello, ${your_name} !<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="字符串计数"><a href="#字符串计数" class="headerlink" title="字符串计数"></a>字符串计数</h3><p>使用#符号，加在字符串变量之前进行计数。</p><pre class="line-numbers language-shell"><code class="language-shell">string="abcd"echo ${#string} #输出 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p><code>${var:m}</code>将截取变量<code>${var}</code>从第m个字符到最后一个字符的子串，`${var:\m:len}截取从第m个字符开始，长度为len的部分。默认情况下，变量的字符编号从0开始。</p><pre class="line-numbers language-shell"><code class="language-shell">string="runoob is a great site"echo ${string:1:4} # 输出 unoo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="字符串删除"><a href="#字符串删除" class="headerlink" title="字符串删除"></a>字符串删除</h3><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>${var#pattern}</td><td>删除${var}中开头部分与pattern匹配的最小部分</td></tr><tr><td>${var##pattern}</td><td>删除${var}中开头部分与pattern匹配的最大部分（贪心）</td></tr><tr><td>${var%pattern}</td><td>删除${var}中结尾部分与pattern匹配的最小部分</td></tr><tr><td>${var%%pattern}</td><td>删除${var}中结尾部分与pattern匹配的最大部分（贪心）</td></tr></tbody></table><p>需要注意的是，这里的模式串pattern可以是正则表达式，</p><pre class="line-numbers language-shell"><code class="language-shell">str='I love linux. I love UNIX too.’echo ${str#I love}linux. I love UNIX too.echo ${str#I*.}I love UNIX too.echo ${str##I*}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>${var//old/new}</td><td>用new替换${var}中所有的old(全局替换)</td></tr><tr><td>${var/#old/new}</td><td>用new替换${var}中开头部分与old匹配的部分</td></tr><tr><td>${var/old/new}</td><td>用new替换${var}中第一次出现的old</td></tr><tr><td>${var/%old/new}</td><td>用new替换${var}中结尾部分与old匹配的部分</td></tr></tbody></table><ul><li>old 中可以使用 通配符。</li><li>var 可以是 @ 或 *，表示对每个位置参数进行替换</li></ul><pre class="line-numbers language-shell"><code class="language-shell">str='I love linux. I love UNIX too.’echo ${str/love/like}I like linux. I love UNIX too.echo ${str//love/like}I like linux. I like UNIX too.echo ${str/I*linux/I like FreeBSD}I like FreeBSD. I love UNIX too.echo ${str/#I love/"J'aime"}J'aime linux. I love UNIX too.echo ${str//I love/"J'aime"}J'aime linux. J'aime UNIX too. echo ${str/%too./also.}I love linux. I love UNIX also.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Shell输入输出"><a href="#Shell输入输出" class="headerlink" title="Shell输入输出"></a>Shell输入输出</h2><h3 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h3><blockquote><p> read  [-p  “提示信息”]  [var1 var2 …]</p></blockquote><p>read命令从键盘输入内容为变量赋值。若省略变量名，则将输入的内容存入系统变量$REPLY变量。</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash# This script is to test the usage of read# Scriptname: ex4read.shecho "=== examples for testing read ==="echo -e "What is your name? \c"read nameecho "Hello $name"echoecho -n "Where do you work? "readecho "I guess $REPLY keeps you busy!"echoread -p "Enter your job title: "echo "I thought you might be an $REPLY."echoecho "=== End of the script ==="<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h3><blockquote><p>echo 字符串</p></blockquote><p> Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。</p><p>字符串的类型依然分为三类，分别是单引号、双引号、反撇号，具体功能见上一章。</p><p>这里需要注意的是：<strong>echo命令输出时，双引号可以省略，但如果字符串内有空格，必须加上双引号</strong>。</p><p>如果在字符串内使用了转义字符，我们在使用echo进行输出时还需要开启转义，具体做法是采用-e选项。</p><pre class="line-numbers language-shell"><code class="language-shell">echo -e "OK! \n" # -e 开启转义echo "It is a test"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>echo命令可以使用重定向符号进行标准输出端口的重定向（默认是终端的屏幕）。</p><h3 id="printf-命令"><a href="#printf-命令" class="headerlink" title="printf 命令"></a>printf 命令</h3><blockquote><p>printf format 输出参数列表</p></blockquote><p>printf命令与C++等高级语言中类似，都是用来输出格式化字符串的。</p><p>格式字符串format的规格如下：</p><p>![printf]（printf.png）</p><p>常用的格式替代符有：</p><ul><li>%s：字符串string</li><li>%c：字符char</li><li>%d：整型数</li><li>%f ：浮点数</li></ul><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bashprintf "%-10s %-8s %-4s\n" 姓名 性别 体重kg  printf "%-10s %-8s %-4.2f\n" 郭靖 男 66.1234 printf "%-10s %-8s %-4.2f\n" 杨过 男 48.6543 printf "%-10s %-8s %-4.2f\n" 郭芙 女 47.9876 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>printf命令支持如下的转义序列：</p><table><thead><tr><th align="left">序列</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">\a</td><td align="left">警告字符，通常为ASCII的BEL字符</td></tr><tr><td align="left">\b</td><td align="left">后退</td></tr><tr><td align="left">\c</td><td align="left">抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td></tr><tr><td align="left">\f</td><td align="left">换页（formfeed）</td></tr><tr><td align="left">\n</td><td align="left">换行</td></tr><tr><td align="left">\r</td><td align="left">回车（Carriage return）</td></tr><tr><td align="left">\t</td><td align="left">水平制表符</td></tr><tr><td align="left">\v</td><td align="left">垂直制表符</td></tr><tr><td align="left">\\</td><td align="left">一个字面上的反斜杠字符</td></tr><tr><td align="left">\ddd</td><td align="left">表示1到3位数八进制值的字符。仅在格式字符串中有效</td></tr><tr><td align="left">\0ddd</td><td align="left">表示1到3位的八进制值字符</td></tr></tbody></table><pre class="line-numbers language-shell"><code class="language-shell">printf "%6d\t%6o\"%6x\"\n" 20 20 20<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Shell整数运算"><a href="#Shell整数运算" class="headerlink" title="Shell整数运算"></a>Shell整数运算</h2><p>Bash 变量没有严格的类型定义</p><ul><li>本质上 Bash 变量都是字符串</li><li>若一个字面常量或变量的值是纯数字的，不包含字母或其他字符， Bash可以将其视为长整型值，并可做算数运算和比较运算。</li></ul><p>Bash 也允许显式地声明整型变量</p><ul><li>declare -i 变量名</li></ul><h3 id="declare命令"><a href="#declare命令" class="headerlink" title="declare命令"></a>declare命令</h3><blockquote><p>declare [选项] variable[=value]</p></blockquote><p>Shell内置命令 declare 可用来显式地声明变量，因为Shell默认是弱类型语言，使用declare命令可以强制规定变量的类型，无需等到执行到具体的命令时才知道变量的类型。</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>将变量设为只读 ( <em>readonly</em> )</td></tr><tr><td>-x</td><td>将变量输出到子 shell 中（<em>export</em> 为全局变量）</td></tr><tr><td>-i</td><td>将变量设为整型 ( <em>integer</em> )</td></tr><tr><td>-a</td><td>将变量设置为一个数组 ( <em>array</em> )</td></tr><tr><td>-f</td><td>列出函数的名字和定义 ( <em>function</em> )</td></tr><tr><td>-F</td><td>只列出函数名</td></tr></tbody></table><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table><thead><tr><th>算术运算符</th></tr></thead><tbody><tr><td>+、 -、 *、 / （四则运算）</td></tr><tr><td>**、 %    （幂运算 和 模运算，取余数）</td></tr><tr><td>&lt;&lt;、 &gt;&gt;   （按位左移 和 按位右移）</td></tr><tr><td>&amp;、 ^、 |  （按位与 、按位异或 和 按位 或）</td></tr><tr><td>=、 +=、 -= 、 *=、 /= 、 %= 、&lt;&lt;= 、 &gt;&gt;= 、 &amp;=、 ^=、 |=  （赋值运算）</td></tr><tr><td>&lt;、 &gt;、 &lt;=、 &gt;=、 ==、 !=   （比较操作符）</td></tr><tr><td>&amp;&amp;、 ||   （逻辑与 和 逻辑 或）</td></tr></tbody></table><p>Shell自带的算术运算符基本与Java类似，含义也类似。</p><h3 id="expr命令"><a href="#expr命令" class="headerlink" title="expr命令"></a>expr命令</h3><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p><p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bashval=`expr 2 + 2`echo "两数之和为 : $val"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>两点注意：</p><ul><li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</li><li>完整的表达式要被``包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li><li>表达式中的运算可以是算术运算，比较运算，字符串运算和逻辑运算。</li></ul><h3 id="expression-、-（（expression））"><a href="#expression-、-（（expression））" class="headerlink" title="$[expression]  、$（（expression））"></a><code>$[expression]</code>  、<code>$（（expression））</code></h3><p>同时，随着Bash的升级，我们也可以使用符号来声明和进行整数运算。</p><pre class="line-numbers language-shell"><code class="language-shell">num1=$[4+1]; echo $num1num1=$（（$num1*2-3））; echo $num1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>需要注意的是，用 <code>$[···]</code>，<code>$（（···））</code>进行整数运算时，括号内变量前的美元符号  $ 可以省略。</p><p>这样运算的话，不需要在表达式和运算符之间打空格（不过推荐都打上，养成良好习惯，看的也清楚，赋值时不能打）</p><h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><p>Shell还内置了let命令用于算术运算。</p><pre class="line-numbers language-shell"><code class="language-shell">num2=1; echo $num2let num2=4+1; echo $num2let num2=$num2+1; echo $num2let "num2=4 + 1" # 用引号忽略空格的特殊含义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意以下几点：</p><ul><li><p>赋值符号和运算符两边不能留空格！除非用引号将算式括起来。</p></li><li><p>如果将字符串赋值给一个整型变量时，则变量的值为 0。</p></li><li><p>如果变量的值是字符串，则进行算术运算时设为 0。</p></li></ul><h2 id="Shell浮点数运算"><a href="#Shell浮点数运算" class="headerlink" title="Shell浮点数运算"></a>Shell浮点数运算</h2><p>bash 只支持整数运算。</p><p>但我们可以使用一些工具，例如：可以通过使用 bc 或 awk 工具来处理浮点数运算。</p><pre class="line-numbers language-shell"><code class="language-shell">n=$（echo "scale=3; 13/2" | bc ）echo $nm=`awk 'BEGIN{x=2.45;y=3.123; \    printf "%.3f\n", x*y}'`echo $m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Shell数组"><a href="#Shell数组" class="headerlink" title="Shell数组"></a>Shell数组</h2><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><p>数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。</p><p>与大部分编程语言类似，数组元素的下标由0开始。</p><p>Shell 数组用括号来表示，元素用”空格”符号分割开，语法格式如下：</p><blockquote><p>array_name=（value1 … valuen）</p></blockquote><p>与python等弱类型脚本语言类似，Shell数组可以存放任意类型的值，这一点和C++、Java等编译型语言不同：</p><pre class="line-numbers language-shell"><code class="language-shell">my_array=（A B "C" D）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们也可以使用declare命令声明数组，直接使用下标定义元素，并使用`${array_name[index]}去访问元素，这里的下标可以为变量：</p><pre class="line-numbers language-shell"><code class="language-shell">declare -a array_namearray_name[0]=value0array_name[1]=value1array_name[2]=value2echo "第一个元素为: ${my_array[0]}"echo "第二个元素为: ${my_array[1]}"echo "第三个元素为: ${my_array[2]}"echo "第四个元素为: ${my_array[3]}"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 使用@ 或 * 可以获取数组中的所有元素，获取所有元素后我们可以使用#符号获取数组的长度，和字符串类似，例如： </p><pre class="line-numbers language-shell"><code class="language-shell">my_array[0]=Amy_array[1]=Bmy_array[2]=Cmy_array[3]=Decho "数组的元素为: ${my_array[*]}"echo "数组的元素为: ${my_array[@]}"echo "数组元素个数为: ${#my_array[*]}"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组与数组元素的删除"><a href="#数组与数组元素的删除" class="headerlink" title="数组与数组元素的删除"></a>数组与数组元素的删除</h3><p>使用unset命令：</p><pre class="line-numbers language-shell"><code class="language-shell">unset stu[1]   # 删除stu的第二个元素unset stu      # 删除整个数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Shell条件测试"><a href="#Shell条件测试" class="headerlink" title="Shell条件测试"></a>Shell条件测试</h2><p>条件测试可以判断某个特定条件是否满足，通常是命令是否成功或者是表达式的真假。</p><p>条件测试的值：</p><ul><li>Bash中没有布尔类型变量<ul><li>退出状态为 0 表示命令成功或表达式为真</li><li>非0 则表示命令失败或表达式为假</li></ul></li><li>状态变量 <code>$?</code> 中保存了退出状态的值Bash中没有布尔类型变量</li></ul><h3 id="条件测试的格式"><a href="#条件测试的格式" class="headerlink" title="条件测试的格式"></a>条件测试的格式</h3><p>Shell支持三种格式的条件测试语句，分别为：</p><ul><li>格式1： test &lt;测试表达式&gt; </li><li>格式2： [ &lt;测试表达式&gt; ] </li><li>格式3： [[ &lt;测试表达式&gt; ]] （bash 2.x 版本以上）</li><li>格式4： （（&lt;测试表达式&gt;）） （整数关系运算）</li></ul><p>说明：</p><ul><li>格式1 和 格式2 是等价的，格式3是扩展的 test 命令</li><li>在 [[ ]] 中可以使用通配符进行模式匹配</li><li>&amp;&amp;, ||, &lt;, 和&gt;能够正常存在于[[ ]]中，但不能在 [] 中出现</li><li>[和[[之后的字符必须为空格，]和]]之前的字符必须为空格</li><li>要对整数进行关系运算也可以使用 （（）） 进行测试</li></ul><h3 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h3><p>文件测试用于检测文件是否存在，文件属性，访问权限等。</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>[ -f fname ]</td><td>fname 存在且是普通文件时，返回真 ( 即返回 0 )</td></tr><tr><td>[ -L fname ]</td><td>fname 存在且是链接文件时，返回真</td></tr><tr><td>[ -d fname ]</td><td>fname 存在且是一个目录时，返回真</td></tr><tr><td>[ -e fname ]</td><td>fname（文件或目录）存在时，返回真</td></tr><tr><td>[ -s fname ]</td><td>fname 存在且大小大于 0 时，返回真</td></tr><tr><td>[ -r fname ]</td><td>fname（文件或目录）存在且可读时，返回真</td></tr><tr><td>[ -w fname ]</td><td>fname（文件或目录）存在且可写时，返回真</td></tr><tr><td>[ -x fname ]</td><td>fname（文件或目录）存在且可执行时，返回真</td></tr></tbody></table><h3 id="字符串测试"><a href="#字符串测试" class="headerlink" title="字符串测试"></a>字符串测试</h3><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>[ -z string ]</td><td>如果字符串string长度为0，返回真</td></tr><tr><td>[ -n string ]</td><td>如果字符串string长度不为0，返回真</td></tr><tr><td>[ str1 = str2 ]</td><td>两字符串相等（也可使用 == ）返回真</td></tr><tr><td>[ str1 != str2 ]</td><td>两字符串不等返回真</td></tr><tr><td>[[ str1 == str2 ]]</td><td>两字符串相同返回真</td></tr><tr><td>[[ str1 != str2 ]]</td><td>两字符串不相同返回真</td></tr><tr><td>[[ str1 =~ str2 ]]</td><td>str2是str1的子串返回真</td></tr><tr><td>[[ str1 &gt; str2 ]]</td><td>str1大于str2返回真（按照Ascii码进行比较）</td></tr><tr><td>[[ str1 &lt; str2 ]]</td><td>str1小于str2返回真</td></tr></tbody></table><h3 id="整数测试"><a href="#整数测试" class="headerlink" title="整数测试"></a>整数测试</h3><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>[ int1 -eq int2 ]</td><td>int1 等于 int2 返回真</td></tr><tr><td>[ int1 -ne int2 ]</td><td>int1 不等于 int2 返回真</td></tr><tr><td>[ int1 -gt int2 ]</td><td>int1 大于 int2 返回真</td></tr><tr><td>[ int1 -ge int2 ]</td><td>int1 大于或等于 int2 返回真</td></tr><tr><td>[ int1 -lt int2 ]</td><td>int1 小于 int2 返回真</td></tr><tr><td>[ int1 -le int2 ]</td><td>int1 小于或等于 int2 返回真</td></tr></tbody></table><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>[[ int1 == int2 ]]</td><td>int1 等于 int2 返回真</td></tr><tr><td>[[ int1 != int2 ]]</td><td>int1 不等于 int2 返回真</td></tr><tr><td>[[ int1 &gt; int2 ]]</td><td>int1 大于 int2 返回真</td></tr><tr><td>[[ int1 &gt;= int2 ]]</td><td>int1 大于或等于 int2 返回真</td></tr><tr><td>[[ int1 &lt;int2 ]]</td><td>int1 小于 int2 返回真</td></tr><tr><td>[[ int1 &lt;= int2 ]]</td><td>int1 小于或等于 int2 返回真</td></tr></tbody></table><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>（（int1 == int2））</td><td>int1 等于 int2 返回真</td></tr><tr><td>（（int1 != int2））</td><td>int1 不等于 int2 返回真</td></tr><tr><td>（（int1 &gt; int2））</td><td>int1 大于 int2 返回真</td></tr><tr><td>（（int1 &gt;= int2））</td><td>int1 大于或等于 int2 返回真</td></tr><tr><td>（（int1 &lt; int2））</td><td>int1 小于 int2 返回真</td></tr><tr><td>（（int1 &lt;= int2））</td><td>int1 小于或等于 int2 返回真</td></tr></tbody></table><p>观察上述表格，我们可以发现：</p><ul><li><p>[]和[[]]两侧必须加空格</p></li><li><p>[[]]可以加入诸如&gt;、&lt;等符号的逻辑运算符，而[]只能使用字母来表示</p></li><li><p>（（））两侧不一定需要加入空格，可省略</p></li><li><p>[]不能加入通识匹配符，如&gt;、&lt;</p></li></ul><h3 id="逻辑测试"><a href="#逻辑测试" class="headerlink" title="逻辑测试"></a>逻辑测试</h3><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>[ expr1 -a expr2 ]</td><td>逻辑与，都为真时，结果为真</td></tr><tr><td>[ expr1 -o expr2 ]</td><td>逻辑或，有一个为真时，结果为真</td></tr><tr><td>[ ! expr ]</td><td>逻辑非</td></tr></tbody></table><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>[[ pattern1 &amp;&amp; pattern2 ]]</td><td>逻辑与</td></tr><tr><td>[[ pattern1 || pattern2 ]]</td><td>逻辑或</td></tr><tr><td>[[ ! pattern ]]</td><td>逻辑非</td></tr></tbody></table><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>（（ expr1 &amp;&amp; expr2 ）\）</td><td>逻辑与</td></tr><tr><td>（\（ expr1 || expr2 ））</td><td>逻辑或</td></tr><tr><td>（（ ! expr ））</td><td>逻辑非</td></tr></tbody></table><p>需要注意的点有：</p><ul><li>不能随便添加括号</li><li>不能在 （（）） 中做字符串比较，只能进行整数运算</li></ul><h2 id="Shell流程控制"><a href="#Shell流程控制" class="headerlink" title="Shell流程控制"></a>Shell流程控制</h2><h3 id="分支语句if"><a href="#分支语句if" class="headerlink" title="分支语句if"></a>分支语句if</h3><p>分支语句if通常和条件测试语句配合使用。</p><pre class="line-numbers language-shell"><code class="language-shell">if expr1      # 如果 expr1 为真（返回值为0）then          # 那么   commands1  # 执行语句块 commands1elif expr2    # 若 expr1 不真，而 expr2 为真then          # 那么   commands2  # 执行语句块 commands2 ... ...      # 可以有多个 elif 语句 else          # else 最多只能有一个   commands4  # 执行语句块 commands4fi            # if 语句必须以单词 fi 终止<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意点：</p><ul><li>elif 可以有任意多个（0 个或多个）</li><li>else 最多只能有一个（0 个或 1 个）</li><li>if 语句必须以 fi 表示结束</li><li>exprX 通常为条件测试表达式；也可以是多个命令，以最后一个命令的退出状态为条件值。</li><li>commands 为可执行语句块，如果为空，需使用 shell 提供的空命令 “ : ”，即冒号。该命令不做任何事情，只返回一个退出状态 0</li><li>if 语句可以嵌套使用</li></ul><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename: ask-age.shread  -p "How old are you?  "  age # 使用 Shell算术运算符（（））进行条件测试if （（age<0||age>120））; then    echo "Out of range !"    exit 1fi # 使用多分支if语句if   （（age>=0&&age<13）） ; then   echo "Child !"elif （（age>=13&&age<20））; then   echo "Callan !"elif （（age>=20&&age<30））; then   echo "P III !"elif （（age>=30&&age<40））; then   echo "P IV !"else   echo "Sorry I asked."fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分支语句Case"><a href="#分支语句Case" class="headerlink" title="分支语句Case"></a>分支语句Case</h3><p>与高级语言类似，Shell中也存在着Case语句，用来进行多分支的判断。</p><pre class="line-numbers language-shell"><code class="language-shell">case expr in # expr 为表达式，关键词 in 不要忘！  pattern1）  # 若 expr 与 pattern1 匹配，注意括号   commands1 # 执行语句块 commands1   ;;        # 跳出 case 结构  pattern2）  # 若 expr 与 pattern2 匹配   commands2 # 执行语句块 commands2   ;;        # 跳出 case 结构  ... ...    # 可以有任意多个模式匹配  *）         # 若 expr 与上面的模式都不匹配   commands  # 执行语句块 commands   ;;        # 跳出 case 结构esac         # case 语句必须以 esac 终止<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的点有：</p><ul><li>表达式 expr 按顺序匹配每个模式，一旦有一个模式匹配成功，则执行该模式后面的所有命令，然后退出 case。</li><li>如果 expr 没有找到匹配的模式，则执行缺省值 “ <em>） ” 后面的命令块（ 类似于 if  中的 else ）；“ </em>） ” 可以不出现。</li><li>所给的匹配模式 pattern 中可以含有通配符和“ | ”。</li><li>每个命令块的最后必须有一个双分号;;，可以独占一行，或放在最后一个命令的后面。</li><li>case语句必须以esac终止。</li></ul><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename: all_in_one_backup.sh# A shell script to backup mysql, webserver and files.# opt=$1case $1 in   sql） echo "Running mysql backup using mysqldump tool..." ;;  sync） echo "Running backup using rsync tool..."           ;;   git） echo "Running backup using gistore tool..."         ;;   tar） echo "Running tape backup using tar tool..."        ;;     *）         echo "Backup shell script utility"        echo "Usage: $0 {sql|sync|git|tar}"        echo "    sql  : Run mySQL backup utility."        echo "    sync : Run web server backup utility."            echo "    git  : Run gistore backup utility."            echo "    tar  : Run tape backup utility."         ;;esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="循环语句For"><a href="#循环语句For" class="headerlink" title="循环语句For"></a>循环语句For</h3><p>与高级语言类似，Shell支持两种类型的循环，分别是foreach型和c语言型</p><h4 id="for循环（foreach型）"><a href="#for循环（foreach型）" class="headerlink" title="for循环（foreach型）"></a>for循环（foreach型）</h4><pre class="line-numbers language-shell"><code class="language-shell">for variable in list # 每一次循环，依次把列表 list 中的一个值赋给循环变量do          # 循环体开始的标志  commands  # 循环变量每取一次值，循环体就执行一遍done        # 循环结束的标志，返回循环顶部<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li>列表 list 可以是命令替换、变量名替换、字符串和文件名列表 （ 可包含通配符 ），每个列表项以空格间隔</li><li>for 循环执行的次数取决于列表 list 中单词的个数</li><li>可以省略  in list ， 如果不用它，for循环使用命令行的位置参数，相当于  in “$@”。</li></ul><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename: for1--constant_as_list.sh# 使用字面字符串列表作为 WordListfor x in centos ubuntu gentoo opensusedo   echo "$x" ; done# 若列表项中包含空格必需使用引号括起来for x in Linux "Gnu Hurd" FreeBSD "Mac OS X"do  echo "$x" ; donefor x in ls "df -h" "du -sh"do    echo "==$x==" ; eval $xdone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意，如果同一行出现了两条命令，需要在他们之间加分号；</p><p>下面的情况特别需要注意，用于分割的空格不能被包含进双引号内：</p><ul><li>for x in “centos” “ubuntu” “gentoo” “opensuse”，输出的是四个单词</li><li>for x in “centos ubuntu gentoo opensuse”，输出的是一整个句子</li></ul><p>更多实例：</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename: for3--pp_as_list.sh# 使用位置参数变量 $@ 作为 WordList， in $@ 可以省略i=1for day ; do  echo -n "Positional parameter $（（i++））: $day "  case $day in    [Mm]on|[Tt]ue|[Ww]ed|[Tt]hu|[Ff]ri）       echo " （weekday）" ;;    [Ss]at|[Ss]un）       echo " （WEEKEND）" ;;    *） echo " （Invalid weekday）" ;;  esacdone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename: for4--filenames_as_list.sh# 使用文件名或目录名列表作为 WordList# 将当前目录下的所有的大写文件名改为小写文件名for filename in * ; do  # 使用命令替换生成小写的文件名，赋予新的变量 fn  fn=$（echo $fname | tr A-Z a-z）  # 若新生成的小写文件名与原文件名不同，改为小写的文件名  if [[ $fname != $fn ]] ; then mv $fname $fn ; fi  # 上面的 if 语句与下面的命令聚合均等效  # [[ $fname != $fn ]] && mv $fname $fn  # [[ $fname == $fn ]] || mv $fname $fndonefor fn in /etc/[abcd]*.conf ; do echo $fn ; donefor fn in /etc/cron.{*ly,d}/* ; do echo $fn ; donefor i in *.zip; do   j="${i%.zip}"; mkdir "$j" && unzip -d "$j" "$i"done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename: for5--command_output_as_list.sh# 使用命令的执行结果作为 WordListi=1for username in `awk -F: '{print $1}' /etc/passwd` do    echo "Username $（（i++）） : $username"donefor line in $（cat files.txt|egrep -v "^$|^#"） ; do    echo "$line"; done for suffix in $（seq 254）do echo "192.168.0.${suffix}"; donefor f in $（ ls /var/ ）; do echo $f; done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="for循环（C语言型）"><a href="#for循环（C语言型）" class="headerlink" title="for循环（C语言型）"></a>for循环（C语言型）</h4><p>C 语言风格的 for 语句通常用于实现计数型循环。该循环方式和C语言、Java等非常类似：</p><pre class="line-numbers language-shell"><code class="language-shell">for （（expr1;expr2;expr3）） # 执行 expr1do # 若 expr2的值为真时进入循环，否则退出 for循环  commands  # 执行循环体，之后执行 expr3done        # 循环结束的标志，返回循环顶部<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>expr1：初始赋值</li><li>expr2：结束条件</li><li>expr3：每轮变化</li></ul><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename: addusers_for_C-style.sh# 成批添加50个用户for （（ n=1; n<=50; n++ ））do    if （（num<10））    then  st="st0${n}"     else  st="st${n}"    fi    useradd $st    echo "centos"|passwd --stdin $st    chage -d 0 $stdone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h4><blockquote><p>break [n]</p></blockquote><p>用于强行退出当前循环。</p><p>如果是嵌套循环，则 break 命令后面可以跟一数字 n，表示退出第 n 重循环（最里面的为第一重循环）。</p><blockquote><p>continue [n]</p></blockquote><p>用于忽略本次循环的剩余部分，回到循环的顶部，继续下一次循环。</p><p>如果是嵌套循环，continue 命令后面也可跟一数字 n，表示回到第 n 重循环的顶部。</p><h4 id="While循环语句"><a href="#While循环语句" class="headerlink" title="While循环语句"></a>While循环语句</h4><p>格式：</p><pre class="line-numbers language-shell"><code class="language-shell">while expr  # 执行 exprdo # 若expr的退出状态为0，进入循环，否则退出while  commands  # 循环体done        # 循环结束标志，返回循环顶部<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>While语句当expr为真时（状态不为0），循环执行。</p><p>实例：</p><ul><li>使用重定向符号为while的条件表达式中的read进行输入重定向。</li></ul><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename: while--read_file.shfile=/etc/resolv.confwhile IFS= read -r linedo    # echo line is stored in $line    echo $linedone < "$file"while IFS=: read -r user enpass uid gid desc home shelldo    # only display if UID >= 500     [ $uid -ge 500 ] && echo "User $user （$uid） assigned \"$home\" home directory with $shell shell."done < /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用管道符为while传入输入</li></ul><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename: while-rename_filename.sh# 找出当前目录下包含空格的文件名，将空格替换为下划线DIR="."find $DIR -type f | while read file; do  # using POSIX class [:space:] to find space in the filename  if [[ "$file" = *[[:space:]]* ]]; then     # substitute space with "_" character （rename the filename）     mv "$file" $（echo $file | tr ' ' '_'）  fidone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="until循环语句"><a href="#until循环语句" class="headerlink" title="until循环语句"></a>until循环语句</h4><p>格式：</p><pre class="line-numbers language-shell"><code class="language-shell">until expr  # 执行 exprdo # 若expr的退出状态非0，进入循环，否则退出until  commands  # 循环体done        # 循环结束标志，返回循环顶部<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>While语句当expr为假时（状态不为0），循环执行。</p><p>实例：</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename: until-user_online_to_write.shusername=$1if [ $# -lt 1 ] ; then  echo "Usage: `basename $0`  <username>  [<message>]"  exit 1fiif grep "^$username:" /etc/passwd > /dev/null ; then   :else  echo "$username is not a user on this system."  exit 2fiuntil who|grep "$username" > /dev/null ; do    echo "$username is not logged on."    sleep 600doneshift ; msg=$*[[ X"$msg" == "X" ]] && msg="Hello, $username"echo "$msg" | write $username<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename: while-until-for_sum.sh# 使用当型循环求 sum（1..100）（（i=0,s=0））        # i=0 ; s=0while （（i<100）） ; do （（i++,s+=i）） ; doneecho sum（1..100）=$s# 使用直到型循环求 sum（1..100）（（i=0,s=0））until （（i==100）） ; do （（i++,s+=i）） ; doneecho sum（1..100）=$s# 使用C风格的 for 循环求 sum（1..100）for （（s=0,i=1;i<=100;s+=i,i++）） ; do : ; doneecho sum（1..100）=$s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="循环语句的使用技巧"><a href="#循环语句的使用技巧" class="headerlink" title="循环语句的使用技巧"></a>循环语句的使用技巧</h4><p>循环语句可以在末尾done之后加入管道符和重定向符，用来重定向当前循环体内的输入、输出端口，以及将循环体内的命令执行结果传入其他命令处理。</p><ul><li>管道：</li></ul><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename: loop--to_pipe.shfor i in 7 8 9 2 3 4 5 11; do    echo $idone | sort -nawk -F':' '$3 >= 500 {print $1}' /etc/passwd | while IFS= read -r person do    echo $person done | sort <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以在done后加入&amp;，来将循环体放在后台运行：</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename: loop--in_background.shfor person in Brown Jiff John Stonedo     mail -s "Test" $person < "Hello $person ."done &awk -F':' '$3 >= 500 {print $1}' /etc/passwd | while IFS= read -r persondo    mail -s "Test" $person <<-END    Hello $person,        This message is from $（hostname -f）.                     $USER   $（date +%F）    ENDdone &<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Select语句实现菜单"><a href="#Select语句实现菜单" class="headerlink" title="Select语句实现菜单"></a>Select语句实现菜单</h2><p>select 循环主要用于创建菜单，通常与case语句配合使用，根据用户输入的不同进入不同的菜单分支。<br>select 是个无限循环，退出方式为：</p><ul><li>按  ctrl+c  退出循环</li><li>在循环体内用 break 命令退出循环</li><li>或用 exit 命令终止脚本</li></ul><p>格式：</p><pre class="line-numbers language-shell"><code class="language-shell">select variable in list do          # 循环开始的标志  commands  # 循环变量每取一次值，循环体就执行一遍done        # 循环结束的标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的点有：</p><ul><li>按数值顺序排列的菜单项（list item）会显示到标准错误</li><li>菜单项的间隔符由环境变量 IFS 决定</li><li>用于引导用户输入的提示信息存放在环境变量 PS3 中</li><li>用户输入的值会被存储在内置变量 RELAY 中</li><li>用户直接输入回车将重新显示菜单</li><li>与 for 循环类似，省略 in list 时等价于 in “<code>$*</code>”</li></ul><p>实例：</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename: what-os-do-you-like_select.shclearPS3="What is your preferred OS? "IFS='|'os="Linux|Gnu Hurd|FreeBSD|Mac OS X"select s in $osdo  case $REPLY in    1|2|3|4） echo "You selected $s"  ;;          *） exit ;;  esacdone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="位置参数处理"><a href="#位置参数处理" class="headerlink" title="位置参数处理"></a>位置参数处理</h2><p>在脚本中经常使用流程控制处理位置参数：</p><ul><li>循环结构：while、for</li><li>多分支结构：case</li></ul><p>在脚本中经常使用如下命令配合位置参数处理：</p><ul><li>shift</li><li>getopts</li></ul><h3 id="shift命令"><a href="#shift命令" class="headerlink" title="shift命令"></a>shift命令</h3><p>shift命令没有参数，它的作用是将所有位置向左循环移动一位。</p><p>以下是一个while循环+shift命令，循环遍历命令行位置参数的例子：</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename: pp_traverse_shift_while.sh# Usage: pp_traverse_shift_while.sh [arguments]#echo "using while loop to traverse positional parameter"#while [[ "$1" ]] ; do#    echo "$1"#    shift#donenum=1while [[ "$1" ]] ; do    echo "The ${num}th argument is: $1"    let num=num+1    shiftdone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="getops命令"><a href="#getops命令" class="headerlink" title="getops命令"></a>getops命令</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><blockquote><p>getopts OPTSTRING VARNAME [ARGS…]</p></blockquote><p>OPTSTRING ：</p><ul><li>是由若干有效的选项标识符组成的选项字符串</li><li>若某选项标识符后有冒号，则表示此选项有附加参数</li><li>若整个字符串前有冒号，将使用“安静”的错误模式</li></ul><p>VARNAME ：</p><ul><li>每次匹配成功的选项保存在变量中</li></ul><p>ARGS ：:</p><ul><li>参数列表，省略时为 ”$@”</li></ul><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><ul><li>通常需要以循环的方式执行多次 getopts 来解析位置参数中的选项以及可能存在的选项附加参数</li><li>每次调用 getopts，将会处理参数列表中的“下一个”选项</li><li>将选项存储在VARNAME变量中</li><li>将此选项对应的附加参数存储在环境变量OPTARG中</li><li>对环境变量OPTIND进行自增操作，使 OPTIND 总是指向原始参数列表中“下一个”要处理的元素位置</li><li>若VARNAME与OPTSTRING的所有选项均不匹配，则做“invalid option”的错误设置</li><li>若某选项的参数不存在，则做“required argument not found”的错误设置</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>getopts 不能解析 GNU-style 长参数 （–myoption） </li><li>getopts从不改变原始位置参数</li><li>若希望移动位置参数，需手工执行 shift</li><li>getopts会自动对变量 OPTIND 做自增处理</li><li>OPTIDX的初始值为 1</li><li>若要重新解析命令行参数，需将OPTIDX的值置为 1</li><li>getopts 遭遇到第一个非选项参数时终止解析</li><li>终止解析后执行命令<pre><code>shift （（OPTIND-1））</code></pre></li><li>可以使 ”<code>$@</code>” 只包含“操作 对象/数”（operands）</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename : mybackup_getopts2.shwhile getopts :zc:x:rv optdo  case $opt in    c） if [[ $OPTARG = -* ]]; then  （（OPTIND--）） ;  continue ;  fi       ConfFile=$OPTARG       ;;    x） ExcludeFile=$OPTARG    ;;    z） Compress=true          ;;    r） Recursive=true         ;;    v） Verbose=true           ;;    :）      echo "$0: Must supply an argument to -$OPTARG." >&2      exit 1      ;;    \?） echo "Invalid option -$OPTARG ignored." >&2   ;;  esacdoneshift （（OPTIND-1）） ; echo $0 ; echo "$@"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>环境变量说明：</p><ul><li>OPTIND：存放当前遍历的选项的下标</li><li>OPTARG：存放当前选项的附加参数</li><li>VARNAME：存放当前选项</li></ul><h2 id="Shell函数"><a href="#Shell函数" class="headerlink" title="Shell函数"></a>Shell函数</h2><p>使用函数式编程有如下的优点：</p><ul><li>简化程序代码，实现代码重用<ul><li>实现一次定义多次调用。如：is_root_user（）函数可以由不同的shell脚本重复使用。</li></ul></li><li>实现结构化编程<ul><li>使脚本内容更加简洁，增强程序的易读性</li></ul></li><li>提高执行效率<ul><li>将常用的功能定义为多个函数并将其保存在一个文件中</li><li>类似其他语言的“模块”文件<ul><li>在 ~/bashrc 或命令行上使用 source 命令调用这个文件</li></ul></li><li>此文件中定义的多个函数一次性地调入内存，从而加快运行速度</li></ul></li></ul><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>Shell函数的定义可以带function fun（） 定义，也可以直接fun（） 定义,不带任何参数。 如：</p><pre class="line-numbers language-shell"><code class="language-shell">function 函数名 （） {   commands }函数名 （） {   commands}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例：</p><pre class="line-numbers language-shell"><code class="language-shell">demoFun（）{    echo "这是我的第一个 shell 函数!"}echo "-----函数开始执行-----"demoFunecho "-----函数执行完毕-----"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数调用和传参"><a href="#函数调用和传参" class="headerlink" title="函数调用和传参"></a>函数调用和传参</h3><p>Shell函数的调用和执行命令是一样的，只需输入函数名即可调用函数，函数必须在调用之前定义。</p><p>函数的参数利用位置参数进行获取与使用：</p><ul><li>调用函数时，使用位置参数的形式为函数传递参数</li><li>函数内的<code>$1</code>-<code>${n}</code> 、<code>$*</code> 和 <code>$@</code> 表示其接收的参数</li><li>函数调用结束后位置参数 <code>$1</code>-<code>${n}</code> 、<code>$*</code> 和 <code>$@</code> 将被重置为调用函数之前的值</li><li>在主程序和函数中，<code>$0</code>始终代表脚本名</li></ul><pre class="line-numbers language-shell"><code class="language-shell">funWithParam（）{    echo "第一个参数为 $1 !"    echo "第二个参数为 $2 !"    echo "第十个参数为 $10 !"    echo "第十个参数为 ${10} !"    echo "第十一个参数为 ${11} !"    echo "参数总数有 $# 个!"    echo "作为一个字符串输出所有参数 $* !"}funWithParam 1 2 3 4 5 6 7 8 9 34 73<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数内变量的作用域"><a href="#函数内变量的作用域" class="headerlink" title="函数内变量的作用域"></a>函数内变量的作用域</h3><ul><li>函数内使用 local 声明的变量是局部（Local）变量，局部变量的作用域是当前函数以及其调用的所有函数。</li><li>函数内未使用 local 声明的变量是全局（Global）变量，即主程序和函数中的同名变量是一个变量（地址一致）。</li><li>这一点与python不同，python在函数内默认的变量作用域是函数作用域，也就是说默认是局部变量，需要用globa在函数内将其声明为全局变量。</li></ul><p>我觉得Shell的变量作用域比较容易混乱。</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename: function_max.sh# User define Function （UDF）usage （） {  echo "List the MAX of the positive integers in command line. "  echo "Usage: `basename $0` <num1> <num2> [ <num3> ... ]"  exit}max （） {  [[ -z $1 || -z $2 ]] && usage    #发现挺多这样写的，因为Shell的与运算默认是短路与，相当于if的效果  largest=0  for i ; do  （（i>largest）） && largest=$i ; done}### Main script starts here ###max "$@"echo "The largest of the numbers is $largest."#由于largest变量在函数max内没有使用local声明，所以它是全局的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="source命令"><a href="#source命令" class="headerlink" title="source命令"></a>source命令</h4><ul><li>如果函数和调用它的主程序保存在同一个文件中，那么函数的定义必须出现在调用之前，这是所有脚本语言共同的特点，python也是这样的。</li><li>如果函数和调用它的主程序保存在不同的文件中，保存函数的文件必须先使用 source 命令执行，之后才能调用其中的函数。<ul><li>source命令类似于python中的import，引入对应的代码文件内容。</li></ul></li></ul><p>文件1：</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename: /root/bin/my_backup_functions.sh### User define Function （UDF） ###sql_bak  （） { echo "Running mysqldump tool..."; }sync_bak （） { echo "Running rsync tool..."; }git_bak  （） { echo "Running gistore tool..."; }tar_bak  （） { echo "Running tar tool..."; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件2：</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash## filename: all_in_one_backup_select.sourcefunc.shsource /root/bin/my_backup_functions.sh    #在这里进行了引入### Main script starts here ###PS3="Please choose a backup tools : "select s in  mysqldump rsync gistore tar quit ; do  case $REPLY in       1|[mM]ysqldump） sql_bak  ;;       2|[rR]sync）     sync_bak ;;       3|[gG]istore）   git_bak  ;;       4|[tT]ar）       tar_bak  ;;       5） exit     ;;  esacdone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数的结束和返回值"><a href="#函数的结束和返回值" class="headerlink" title="函数的结束和返回值"></a>函数的结束和返回值</h3><p>隐式结束：</p><ul><li>当函数的最后一条命令执行完毕，将自动结束</li><li>函数的返回值就是最后一条命令的退出码</li><li>其返回值被保存在系统变量<code>$?</code>中</li></ul><p>显式结束：</p><ul><li><p>return [N]</p><ul><li>return 将结束函数的执行</li><li>可以使用 N 指定函数返回值</li></ul></li><li><p>exit  [N]</p><ul><li>exit 将中断当前函数及当前Shell的执行</li><li>可以使用 N 指定返回值</li></ul></li><li><p>return只结束函数，而exit直接退出脚本</p></li><li><p>使用 return 或 exit 只能返回整数值</p><ul><li>我们也可以使用echo命令输出我们想要返回的结果至标准输出，然后在调用函数时，利用<code>$（func）</code>或者`func`执行函数，并获取结果。这样既可以返回整数，也可以返回字符串。</li></ul><pre class="line-numbers language-shell"><code class="language-shell">RES=$（functionName）echo $RES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统启动及常用命令</title>
      <link href="/2020/05/02/linux-xi-tong-qi-dong-ji-chang-yong-ming-ling/"/>
      <url>/2020/05/02/linux-xi-tong-qi-dong-ji-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux系统启动及常用命令"><a href="#Linux系统启动及常用命令" class="headerlink" title="Linux系统启动及常用命令"></a>Linux系统启动及常用命令</h1><h2 id="Linux系统启动过程"><a href="#Linux系统启动过程" class="headerlink" title="Linux系统启动过程"></a>Linux系统启动过程</h2><h3 id="RHEL-CentOS启动过程总览"><a href="#RHEL-CentOS启动过程总览" class="headerlink" title="RHEL/CentOS启动过程总览"></a>RHEL/CentOS启动过程总览</h3><ol><li>BIOS初始化<ol><li>检测所有外围设备</li><li>按配置顺序寻找启动介质</li><li>从MBR寻找引导程序</li></ol></li><li>启动加载器<ol><li>GRUB（stage1）</li><li>GRUB（stage1.5）</li><li>GRUB（stage2）</li></ol></li><li>内核初始化<ol><li>设备检测</li><li>设备驱动初始化</li><li>以只读方式挂载根文件系统</li><li>加载初始化进程</li></ol></li><li>执行init进程（初始化进程）<ol><li>rc.sysinit</li><li>rc</li><li>rc.local</li><li>mingetty</li></ol></li></ol><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p>BIOS即（basic input/output system，基本输入输出系统），是指首次开机时由计算机上运行的软件代码。</p><p>BIOS 的主要功能是将识别和控制各种设备的程序代码嵌入在一个芯片上。包含机器的配置信息，如：IDE controller, NIC等。</p><p>BIOS允许用户设置介质启动顺序。</p><p>BIOS初始化的过程：</p><ol><li>启动</li><li>CPU跳到BIOS的地址</li><li>BIOS启动POST（Power-On Self Test），检测所有外围设备</li><li>按配置顺序寻找启动介质</li><li>读取和执行引导设备首扇（主引导扇区），读取引导介质上的MBR以寻找引导程序（MBR的前446字节，即MBR的引导加载器，也就是GRUB的stage1），找到之后就执行它</li></ol><h3 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h3><p>MBR即（master boot recorder)，主引导记录，是一个512字节的硬盘首扇区。</p><p>MBR的组成为：</p><ul><li>引导加载器（446字节）：包含可执行代码和错误信息文本</li><li>硬盘分区表（64字节）：包含4个分区的记录</li><li>结束标志（2字节）：用于MBR的验证检查 (0xAA55)</li></ul><p>MBR被加载到RAM后，启动过程由其接管。</p><p><img src="1.png" alt="MBR"></p><h3 id="启动加载器"><a href="#启动加载器" class="headerlink" title="启动加载器"></a>启动加载器</h3><p>启动加载器即Boot Loader，也称作内核加载器，任务是加载Linux内核，是一种可选的、初始的RAM磁盘。目前流行的LINUX引导加载程序有：</p><ul><li>GRUB或LILO</li><li>Syslinux</li></ul><h3 id="GRUB"><a href="#GRUB" class="headerlink" title="GRUB"></a>GRUB</h3><p>GRUB即GRand Unified Bootloader，是一种与操作系统无关的启动加载器，位于/boot/grub目录下，需需要自己下载安装，不过一般Linux系统内置。</p><p>它提供了交互操作界面和命令行界面，支持文件系统的访问，在启动过程中可读取GRUB的配置文件，支持多种内核的可执行文件格式，支持无盘系统，支持MD5口令保护。</p><p>GRUB的启动过程为：</p><ul><li>GRUB stage1：<ul><li>即MBR的前446字节，任务就是加载stage1.5</li></ul></li><li>GRUB stage1.5：<ul><li>位于主引导扇区上的MBR后的30KB</li><li>是stage1和stage2的中间层</li><li>任务是加载文件系统驱动，以识别stage2存放的文件系统，并且加载stage2</li></ul></li><li>PS：GRUB stage1和stage1.5是系统安装时写入硬盘的，其副本位于/boot/grub目录下。</li><li>GRUB stage2：<ul><li>是GRUB的核心程序，位于/boot/grub/stage2</li><li>其主要作用为：<ul><li>读取配置文件 /boot/grub/grub.conf </li><li>显示操作系统启动选择界面</li><li>将用户选择的内核加载到内存，并将控制权移交给该内核</li></ul></li><li>GRUB支持两种加载方式：<ul><li>直接加载：加载用户选择的内核</li><li>链式加载：加载另一个引导程序从而加载其它操作系统</li></ul></li></ul></li></ul><h3 id="内核初始化"><a href="#内核初始化" class="headerlink" title="内核初始化"></a>内核初始化</h3><p>当启动加载器执行完毕，即可装载用户选择的内核，并进行内核初始化。</p><p>内核初始化的过程主要为：</p><ol><li>设备检测：内核向BIOS查询所有的硬件信息，并接管这些设备</li><li>设备驱动程序初始化：驱动系统中的硬件设备</li><li>以只读方式加载根文件系统：装载所需的内核模块（在启动内核中不存在）</li><li>载入初始化进程init</li></ol><p><img src="2.png" alt="内核初始化流程"></p><h3 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h3><p>init进程是Linux内核引导运行的第一个进程，其进程号PID永远为1。</p><p>通过配置，可以初始化不同的init进程，详情参考老师的PPT。</p><h3 id="Linux的运行级别："><a href="#Linux的运行级别：" class="headerlink" title="Linux的运行级别："></a>Linux的运行级别：</h3><p>Linux的运行级别即运行Linux系统的不同模式，每种模式对应不同的服务程序组合。</p><p>默认的7种运行级别为：</p><ul><li>0：关机状态</li><li>1：单用户模式</li><li>2：字符界面的多用户模式（不支持网络）</li><li>3：字符界面的完整多用户模式（服务器上一般采用这种）</li><li>4：未分配使用</li><li>5：图形界面的多用户模式</li><li>6：重新启动</li></ul><h3 id="修复运行级别"><a href="#修复运行级别" class="headerlink" title="修复运行级别"></a>修复运行级别</h3><p>三种用于系统修复的运行级别：</p><ul><li>运行级别1</li><li>运行级别S</li><li>运行级别emergency</li></ul><p>进入方法</p><ul><li>init [1/s/-b]</li><li>在GRUB的菜单中为内核传递参数</li></ul><h3 id="系统救援环境"><a href="#系统救援环境" class="headerlink" title="系统救援环境"></a>系统救援环境</h3><p>在RHEL/CentOS的安装程序Anaconda中提供了一种援救环境（rescue environment），主要解决在执行init守护进程之前发生的故障，也可以修复运行级别1/S/emergency能解决的故障。进入援救环境之后便可以使用其提供的各种工具对系统进行修复。</p><h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><h3 id="Linux的字符工作方式"><a href="#Linux的字符工作方式" class="headerlink" title="Linux的字符工作方式"></a>Linux的字符工作方式</h3><p>Linux的工作方式有：</p><ul><li>图形工作方式</li><li>字符工作方式</li></ul><p>使用字符工作方式的原因是：</p><ul><li>字符工作方式可以高效地完成所有任务，特别是完成系统管理任务</li><li>系统管理通常远程进行，远程登录后只能进入字符工作方式</li><li>由于不启动图形工作环境，大大节约了系统资源</li></ul><p>进入字符工作方式的方法：</p><ul><li>图形界面下开启终端</li><li>系统启动后直接进入字符工作方式</li><li>远程登录（SSH/Telnet）</li></ul><p>系统提供多个（默认6个）虚拟控制台，可以独立使用，互不影响。</p><p>登录和注销字符工作方式：</p><ul><li>登录：输入用户名和密码</li><li>注销：<ul><li>输入logout</li><li>使用ctrl+D</li></ul></li><li>提示符：<ul><li>超级用户（root）：#</li><li>普通用户：$</li></ul></li></ul><h3 id="Linux命令格式"><a href="#Linux命令格式" class="headerlink" title="Linux命令格式"></a>Linux命令格式</h3><p>进入Linux的字符界面后，即可输入命令执行各种操作。Linux的命令基本格式为：</p><blockquote><p>命令名  [选项]  [参数1]  [参数2] …</p><p>如: cp  –i  file1.c  myfile.c</p></blockquote><p>输入命令时，需要注意：</p><ul><li>Linux对于命令名大小写敏感，都是小写</li><li>方括号内容都是可选的</li><li>选项可以有多个，用“-”相连</li><li>命令行的参数提供命令运行的信息或者命令执行过程中所使用的文件名</li><li>如果命令行中没有提供参数，则命令使用标准文件进行输入/输出</li><li>命令在正常执行后返回一个0值，表示执行成功</li><li>Linux操作系统的联机帮助对每个命令的准确语法都做了说明   </li><li>命令与选项和参数之间要用空格或制表符隔开</li></ul><h3 id="关机和重新启动"><a href="#关机和重新启动" class="headerlink" title="关机和重新启动"></a>关机和重新启动</h3><p>Linux中，关机和重启本质是：切换运行级别。</p><p>可以使用的关机命令有：</p><ul><li>init 0（切换Linux运行级别至0，参考上一章的运行级别）</li><li>halt</li><li>shutdown -h +5</li></ul><p>重启命令有：</p><ul><li>init 6</li><li>reboot</li><li>shutdown -r +5</li></ul><p>shutdown命令的参数含义为：</p><ul><li>－k 只是警告，不实际关机</li><li>－r 关机后重新启动</li><li>－h 关闭系统</li></ul><h3 id="常用的简单命令"><a href="#常用的简单命令" class="headerlink" title="常用的简单命令"></a>常用的简单命令</h3><p>这些命令一般较为简单，参数也比较少。</p><h4 id="who命令"><a href="#who命令" class="headerlink" title="who命令"></a>who命令</h4><p>列出所有正在使用系统的用户、所用终端名和注册到系统的时间。</p><p><img src="who.png" alt="who"></p><h4 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h4><p>将命令行中的参数显示到标准输出（即屏幕）上 。</p><p><img src="echo.png" alt="echo"></p><h4 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h4><p>在屏幕上显示或设置系统的日期和时间。</p><p><img src="date.png" alt="date"></p><h4 id="cal命令"><a href="#cal命令" class="headerlink" title="cal命令"></a>cal命令</h4><p>显示公元1～9999年中任意一年或者任意一个月的日历 （默认当前月份）。</p><p><img src="cal.png" alt="cal"></p><h4 id="clear命令"><a href="#clear命令" class="headerlink" title="clear命令"></a>clear命令</h4><p>清屏。</p><h4 id="passwd命令"><a href="#passwd命令" class="headerlink" title="passwd命令"></a>passwd命令</h4><p>修改用户密码。</p><p><img src="passwd.png" alt="passwd"></p><h3 id="常用的信息显示命令"><a href="#常用的信息显示命令" class="headerlink" title="常用的信息显示命令"></a>常用的信息显示命令</h3><h4 id="whoami命令"><a href="#whoami命令" class="headerlink" title="whoami命令"></a>whoami命令</h4><p>显示用户自己的身份。</p><p><img src="whoami.png" alt="whoami"></p><h4 id="hostname命令"><a href="#hostname命令" class="headerlink" title="hostname命令"></a>hostname命令</h4><p>显示主机名称。</p><p><img src="hostname.png" alt="hostname"></p><h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><p>显示当前系统中耗费资源最多的进程。</p><p><img src="top.png" alt="top"></p><h4 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h4><p>显示指定文件已使用的磁盘空间的总量。</p><p><img src="du.png" alt="du"></p><h4 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h4><p>显示文件系统磁盘空间的使用情况。</p><p><img src="df.png" alt="df"></p><h4 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h4><p>显示当前内存和交换空间的使用情况。</p><p><img src="free.png" alt="free"></p><h4 id="du、df、free命令的区别"><a href="#du、df、free命令的区别" class="headerlink" title="du、df、free命令的区别"></a>du、df、free命令的区别</h4><ul><li>du命令通常搜索文件，对搜索到的文件大小进行累加。它只能计算到可见文件大小之和。</li><li>df命令利用文件系统来获取文件大小。有的文件被删除后，虽然不可见了，但是在文件系统中只是暂时消失。当所有程序都不用时，才会根据OS的规则释放掉已经删除的文件， df记录的是通过文件系统获取到的文件的大小，他比du强的地方就是<strong>能够看到已经删除的文件</strong>，而且计算大小的时候，把这一部分的空间也加上了，更精确了。 </li><li>free命令与du、df不同，他是查看内存和交换空间（虚拟内存）的使用情况的，而du和df查看的是硬盘（disk）使用情况。</li></ul><h4 id="id命令"><a href="#id命令" class="headerlink" title="id命令"></a>id命令</h4><p>显示当前用户的id信息。</p><p><img src="id.png" alt="id"></p><h4 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h4><p>显示网络接口信息。</p><p><img src="ifconfig.png" alt="ifconfig"></p><h4 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h4><p>测试网络的连通性。</p><p><img src="ping.png" alt="ping"></p><h2 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h2><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>Linux对于文件命名主要需要注意以下几点：</p><ul><li>尽量简洁有效</li><li>不能使用斜线和空字符，允许使用下划线和句点，但不允许使用特殊字符</li><li>同类文件应该使用相同的后缀</li><li>Linux系统对于大小写敏感</li><li>如果一个目录或文件名以一个点 . 开始，表示这个目录或文件是一个隐藏目录或文件(如：.bashrc)。即以默认方式查找时，不显示该目录或文件。 </li></ul><h3 id="文件显示命令"><a href="#文件显示命令" class="headerlink" title="文件显示命令"></a>文件显示命令</h3><h4 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h4><blockquote><p>cat  [选项]  文件</p></blockquote><p>有两项功能：在标准输出上显示文件的内容；连接两个或多个文件，如：cat  f1  f2&gt;f3  ，这里是使用了一个重定向符号。</p><p>常用选项：</p><ul><li>-b，–number-noblank  从1开始对所有非空输出行进行编号。</li><li>-n，–number  从1开始对所有输出行编号。</li><li>-s，–squeeze-blank  将多个相邻的空行合并成一个空行。</li><li>–help  打印该命令用法，并退出，其返回码表示成功。 </li></ul><h4 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h4><blockquote><p>more   [选项]   文件</p></blockquote><p>说明：该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今已显示的该文件的百分比：–More–（XX%）。（一般很大的文件都是用more显示一页，然后用空格一页一页看的，cat的话会很快占满屏幕）</p><p>常用选项：</p><ul><li>-num，这个选项指定一个整数，表示一屏显示多少行。</li><li>-d，在每屏的底部显示以下更友好的提示信息：</li><li>-c或-p，不滚屏，在显示下一屏之前先清屏。</li><li>-s，将文件中连续的空白行压缩成一个空白行显示。</li><li>+/，该选项后的模式（Pattern）指定显示每个文件之前进行搜索的字符串。</li><li>+num，从行号num开始。  </li></ul><h4 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h4><blockquote><p>less  [选项]   文件</p></blockquote><p>与more命令的区别在于：允许用户从后向前浏览文件。</p><h4 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h4><blockquote><p>head   [选项]   file</p></blockquote><p>head命令在屏幕上显示指定文件的开头若干行，行数由参数值来确定。显示行数的默认值是10。</p><p>常用选项：</p><ul><li>-c，–bytes=[-]N     显示每个文件前面N个字节。如果数字N前面带有“-”，则分别显示每个文件除最后N个字节以外的所有内容。如： head -c 5 log2014.log </li><li>-n，–lines=[-]N      显示指定文件的前面N行，而不是默认的10行。如果数字N前面带有“-”，则分别显示每个文件除最后N行以外的所有内容。如： head -n 5 log2014.log </li><li>-q，-quiet，–silent  不显示给定文件的标题。</li><li>-v，–verbose  始终显示给定文件的标题。</li></ul><h4 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h4><blockquote><p>touch   [选项]   文件名</p></blockquote><p>touch命令将会修改指定文件的时间标签，把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来。如果该文件尚未存在，则建立一个空的新文件。 </p><p>主要用来创建文件。</p><p>常用选项：</p><ul><li>-a  仅改变指定文件的存取时间。</li><li>-c，–no-create  不创建任何文件。</li><li>-m  仅改变指定文件的修改时间。</li><li>-t  STAMP    使用STAMP指定的时间标签，而不是系统当前的时间 。</li></ul><h3 id="文件匹配、排序、显示指定内容的命令"><a href="#文件匹配、排序、显示指定内容的命令" class="headerlink" title="文件匹配、排序、显示指定内容的命令"></a>文件匹配、排序、显示指定内容的命令</h3><h4 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h4><blockquote><p>  grep  [选项] 查找模式 [文件名1，文件名2，…]<br>  grep  [选项] [-e 查找模式| -f  文件] [文件名1，文件名2，…]</p></blockquote><p>grep命令一般用于在文件中查找指定模式的词或短语，并在标准输出上显示包括给定字符串模式的所有行。通常与正则表达式搭配使用。</p><p>例如：grep “nasa” nasa.txt</p><p>常用选项：</p><ul><li>-E  将查找模式解释成扩展的正则表达式。</li><li>-F  将查找模式解释成单纯的字符串。</li><li>-b，–byte-offset  在输出的每一行前面显示包含匹配字符串的行在文件中的位置，用字节偏移量来表示。</li><li>-c，–count  只显示文件中包含匹配字符串的行的总数。</li><li>-f FILE  从文件FILE中获取模式，每行一个。空文件不含模式，因此，不做匹配。</li><li>-i，–ignore-case  匹配比较时不区分字母的大小写。</li><li>-R，-r，–recursive   以递归方式查询目录下的所有子目录中的文件。</li><li>-n  在输出包含匹配模式的行之前，加上该行的行号（文件首行的行号为1）</li><li>-v  只显示不包含匹配字符串的文本行。</li><li>-x  只显示整个行都严格匹配的行。 </li></ul><p>后面会和awk还有sed一起详细讲解一下。</p><h4 id="sort命令"><a href="#sort命令" class="headerlink" title="sort命令"></a>sort命令</h4><blockquote><p>sort   [选项]  文件列表</p></blockquote><p>用来对文本文件的各行进行排序，排序比较是依据从输入文件的每一行中提取的一个或多个排序关键字进行的。默认按照字典序进行排序，但也可以根据不同的选项执行不同的排序依据，例如使用-n按照数值进行排序。  </p><p>常用选项：</p><ul><li>-m，–merge  对已经排好序的文件统一进行合并，但不做排序。</li><li>-c，–check  检查给定的文件是否已排好序，若没有，则显示出错消息，不做 排序。</li><li>-u，–unique   与-c选项一起用，严格地按顺序检查；否则，对排序后的重复行只输出第一行。</li><li>-o，–output=FILE  将排序输出放到该文件名所指定的文件中。如果该文件不存在，则创建一个新文件。（Shell中默认可以将命令行输出使用重定向符&gt;或&gt;&gt;输入到文件里，但sort命令的输出不可以通过重定向符来输出）</li><li>-n  按字符串数值排序，与-g区别为不转为浮点数 。</li><li>-g   按通用数值排序，支持科学计数法 。</li><li>-r   降序排序，默认为升序 。</li><li>-h   使用易读性数字(例如： 2K 1G) </li></ul><h4 id="uniq命令"><a href="#uniq命令" class="headerlink" title="uniq命令"></a>uniq命令</h4><blockquote><p>uniq  [选项] [输入文件[输出文件]]</p></blockquote><p>读取输入文件，比较相邻的行，去掉重复的行，只留下其中的一行。</p><p>常用选项：</p><ul><li>-c，–count   显示输出时，在每行的行首加上该行在文件中出现的次数。</li><li>-d，–repeated   只显示重复行。</li><li>-f, –skip-fields=N   忽略比较前N个字段。</li><li>-s, –skip-chars=N   忽略比较前N个字符。</li><li>-u，–unique   只显示文件中不重复的行。</li></ul><p>需要注意的是，uniq命令只对相邻的重复行起作用，所以可以与sort命令搭配使用，先sort，再去重。</p><h3 id="比较文件内容的命令"><a href="#比较文件内容的命令" class="headerlink" title="比较文件内容的命令"></a>比较文件内容的命令</h3><h4 id="comm命令"><a href="#comm命令" class="headerlink" title="comm命令"></a>comm命令</h4><blockquote><p>comm  [-123]  file1  file2</p></blockquote><p>用来求两个文件的差集，需要注意的是两个文件必须都是排序好的。</p><p>常用选项：</p><ul><li>-1 不显示只在第1个文件里出现过的列。</li><li>-2 不显示只在第2个文件里出现过的列。</li><li>-3 不显示只在第1和第2个文件里出现过的列。</li><li>–help 在线帮助。</li><li>–version 显示版本信息。</li></ul><h4 id="diff命令"><a href="#diff命令" class="headerlink" title="diff命令"></a>diff命令</h4><blockquote><p>diff  [选项]  文件1  文件2</p></blockquote><p>比较两个文本文件，并找出它们的不同。  diff的输出结果表明需要对一个文件做怎样的操作之后才能与第二个文件相匹配。或者这么理解：与第一个文件相比，第二个文件发生了那些变化。 diff并不会改变文件的内容，但是diff可以输出一个ed脚本来应用这些改变。 </p><blockquote><p>//file1.txt<br>I need to buy apples.<br>I need to run the laundry.<br>I need to wash the dog.<br>I need to get the car detailed.</p><p>//file2.txt<br>I need to buy apples.<br>I need to do the laundry.<br>I need to wash the car.<br>I need to get the dog detailed.</p><p>我们使用diff比较他们的不同：<br>diff file1.txt file2.txt</p><p>输出如下结果：<br>2,4c2,4<br>&lt; I need to run the laundry.<br>&lt; I need to wash the dog.<br>&lt; I need to get the car detailed.<br>-–<br>&gt; I need to do the laundry.<br>&gt; I need to wash the car.<br>&gt; I need to get the dog detailed</p></blockquote><p>//file2.txt<br>I need to buy apples.<br>I need to do the laundry.<br>I need to wash the car.<br>I need to get the dog detailed.</p><p>2,4c2,4 的含义是：第一个文件中的第[2,4]行(注意这是一个闭合区间，包括第2行和第4行)需要做出修改才能与第二个文件中的[2,4]行相匹配。 </p><p>常用选项：</p><ul><li>-b  忽略空格造成的差别。</li><li>-c  输出格式是带上下文的三行格式。</li><li>-C n  输出格式是有上下文的n行格式。</li><li>-e  输出一个合法的ed脚本。</li><li>-i  忽略字母大小写的区别。</li><li>-r  当文件1 和文件2都是目录时，递归比较找到的各子目录。</li></ul><h3 id="复制、删除和移动文件的命令"><a href="#复制、删除和移动文件的命令" class="headerlink" title="复制、删除和移动文件的命令"></a>复制、删除和移动文件的命令</h3><h4 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h4><blockquote><p>cp  [选项]  源文件或目录  目标文件或目录</p></blockquote><p>将源文件或目录复制到目标文件或目录中。</p><p>常用选项：</p><ul><li>-a    递归地将源目录下的所有子目录及其文件都复制到目标目录中，并且保留文件链接和文件属性不变。它等效于-dpR。</li><li>-d  复制时保留文件链接。</li><li>-f，–force   如果现存的目标文件不能打开，则删除它并且重试一次。也就是直接覆盖。 </li><li>-i，–interactive   与-f选项不同，在覆盖目标文件之前先给出提示，要求用户予以确认。回答y，将覆盖目标文件。这是交互式复制。</li><li>-p  除复制源文件的内容外，还将其修改时间和存取权限也复制到新文件中。</li><li>-R，-r  递归复制目录，即将源目录下的所有文件及其各级子目录都复制到目标位置。</li><li>-l  不复制，而是创建指向源文件的链接文件，链接文件名由目标文件给出。</li></ul><p>通常上述所说的文件链接都是指软链接，也就是符号链接（操作系统Blog里会讲一下）。</p><p>如果需要复制目录，必须使用-r，也就是递归复制，其他的文件操作命令也是同样的道理，除非是专门的目录操作命令。</p><p>一般来说，交互式操作更安全一些，防止误操作。</p><h4 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h4><blockquote><p>rm  [选项]  文件列表</p></blockquote><p>删除文件和目录 。目录需要使用-r选项。</p><p>常用选项：</p><ul><li>-d  删除目录，不管它是否为空（仅超级用户才可使用）。</li><li>-f，–force   忽略不存在的文件，并且不给出提示信息。</li><li>-r，-R，–recursive   递归地删除指定目录及其下属的各级子目录和相应的文件。</li><li>-i  交互式地删除文件。</li></ul><h4 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h4><blockquote><p> mv  [选项]  source  target</p></blockquote><p>对文件或目录重新命名，或者将文件从一个目录移到另一个目录中 。同样，目录需要递归操作。</p><p>常用选项：</p><ul><li>-i，–interactive   交互式操作。如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入“y”，表示将覆盖目标文件；输入“n”，表示取消对源文件的移动。这样可以避免误将文件覆盖。</li><li>-f    与“-i”相反，它禁止交互式操作。在覆盖已有的目标文件时，不给任何提示。</li></ul><h4 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h4><blockquote><p> wc  [选项]  [文件]…</p></blockquote><p>统计指定文件的字节数、字数、行数，并将统计结果显示出来 .</p><p>常用选项：</p><ul><li>-c，–bytes   统计字节数。</li><li>-l，–lines   统计行数。</li><li>-w，–words   统计字数。</li></ul><h2 id="目录命令"><a href="#目录命令" class="headerlink" title="目录命令"></a>目录命令</h2><h3 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h3><p>在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构。</p><p>文件系统的最顶层是由根目录开始的，系统使用 <strong>/</strong> 来表示根目录。在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含子目录文件。如此反复就可以构成一个庞大的文件系统。</p><p>在Linux文件系统中有两个特殊的目录，一个用户所在的工作目录，也叫当前目录，可以使用一个点 <strong>.</strong> 来表示；另一个是当前目录的上一级目录，也叫父目录，可以使用两个点 <strong>..</strong> 来表示。</p><p>用户可以通过相对路径和绝对路径访问文件或者目录，绝对路径默认从根目录/开始，相对路径默认从当前目录开始，开头可以加./也可以不加。</p><p><img src="dic.png" alt="目录结构"></p><p><strong>系统启动必须：</strong></p><ul><li><p><strong>/boot：</strong>存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。</p></li><li><p><strong>/etc：</strong>存放<strong>所有</strong>的系统需要的<strong>配置文件</strong>和<strong>子目录列表，</strong>更改目录下的文件可能会导致系统不能启动。</p></li><li><p><strong>/lib</strong>：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p><strong>/sys</strong>： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中</p></li></ul><p><strong>指令集合：</strong></p><ul><li><p><strong>/bin：</strong>存放着最常用的程序和指令</p></li><li><p><strong>/sbin：</strong>只有系统管理员能使用的程序和指令。</p></li></ul><p><strong>外部文件管理：</strong></p><ul><li><p><strong>/dev ：</strong>Device(设备)的缩写, 存放的是Linux的外部设备。<strong>注意：</strong>在Linux中访问设备和访问文件的方式是相同的。</p></li><li><p><strong>/media</strong>：类windows的<strong>其他设备，</strong>例如U盘、光驱等等，识别后linux会把设备放到这个目录下。</p></li><li><p><strong>/mnt</strong>：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p></li></ul><p><strong>临时文件：</strong></p><ul><li><p><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p></li><li><p><strong>/lost+found</strong>：一般情况下为空的，系统非法关机后，这里就存放一些文件。</p></li><li><p><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。</p></li></ul><p><strong>账户：</strong></p><ul><li><p><strong>/root</strong>：系统管理员的用户主目录。</p></li><li><p><strong>/home</strong>：用户的主目录，以用户的账号命名的。类似于windows下的users目录。</p></li><li><p><strong>/usr</strong>：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p></li><li><p><strong>/usr/bin：</strong>系统用户使用的应用程序与指令。</p></li><li><p><strong>/usr/sbin：</strong>超级用户使用的比较高级的管理程序和系统守护程序。</p></li><li><p><strong>/usr/src：</strong>内核源代码默认的放置目录。</p></li></ul><p><strong>运行过程中要用：</strong></p><ul><li><p><strong>/var</strong>：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。</p></li><li><p><strong>/proc</strong>：管理<strong>内存空间！</strong>虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。</p></li></ul><p><strong>扩展用的：</strong></p><ul><li><p><strong>/opt</strong>：默认是空的，我们安装额外软件可以放在这个里面。</p></li><li><p><strong>/srv</strong>：存放服务启动后需要提取的数据<strong>（不用服务器就是空）</strong></p></li></ul><h3 id="创建和删除目录的命令"><a href="#创建和删除目录的命令" class="headerlink" title="创建和删除目录的命令"></a>创建和删除目录的命令</h3><h4 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h4><blockquote><p>mkdir  [选项]  dirname</p></blockquote><p>命令创建由dirname命名的目录。</p><p>常用选项：</p><ul><li>-m，–mode=MODE     对新建目录的存取权限设置为MODE，存取权限用给定的八进制数字表示，与chmod类似。</li><li>-p，–parents     可一次建立多个目录，即如果为新建目录所指定的路径中有些父目录尚不存在，此选项可以自动建立它们。</li></ul><h4 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h4><blockquote><p>rmdir  [选项]  dirname</p></blockquote><p>该命令从一个目录中删除一个或多个子目录 ，需要注意的是，该命令删除的目录必须为空，否则无法删除！此时可以使用rm -r 递归删除文件。</p><p><img src="rmdir.png" alt="rmdir"></p><p>常用选项：</p><ul><li>-p，–parents     递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果有非空的目录，则该目录保留下来。</li></ul><h3 id="改变工作目录和显示目录内容的命令"><a href="#改变工作目录和显示目录内容的命令" class="headerlink" title="改变工作目录和显示目录内容的命令"></a>改变工作目录和显示目录内容的命令</h3><h4 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h4><blockquote><p>cd  [dirname]</p></blockquote><p>改变当前工作目录，特别常用。没有选项。</p><p>例如：</p><ul><li>cd ~    切换到用户的私有目录</li><li>cd /bin    切换进入/bin目录</li><li>cd ..        返回当前目录的上一级目录</li></ul><h4 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h4><p>没有参数，返回当前目录。</p><p><img src="pwd.png" alt="pwd"></p><h4 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h4><blockquote><p>ls  [选项]  [目录或文件]</p></blockquote><p>如果给出的参数是目录，该命令将列出其中所有子目录与文件的信息；如果给出的参数是文件，将列出有关该文件属性的一些信息。默认给出的参数是当前目录。</p><p>常用选项：</p><ul><li>-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)</li><li>-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出<ul><li>依次为：文件类型与权限 链接数 文件主 文件组 文件大小 建立或最近修改的时间 文件名</li></ul></li><li>-r 将文件以相反次序显示(原定依英文字母次序)</li><li>-t 将文件依建立时间之先后次序列出</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“</li><li>-R 若目录下有文件，则以下之文件亦皆依序列出（递归显示）</li></ul><p><img src="ls.png" alt="ls -AF"></p><h3 id="链接文件的命令"><a href="#链接文件的命令" class="headerlink" title="链接文件的命令"></a>链接文件的命令</h3><p>Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的<strong>别名</strong>，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。</p><p>不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。</p><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>在另外的目录或本目录中增加目标文件的一个目录项，直接指向目标文件，有些类似于高级语言中的“引用”的概念。实际上，硬链接并没有创建新的文件，所产生的文件与源文件拥有相同的iNode号。</p><p>特点：</p><ul><li>硬链接，以文件副本的形式存在。但不占用实际空间。</li><li>不允许给目录创建硬链接。</li><li>硬链接只有在同一个文件系统中才能创建。</li><li>不能给不存在的文件名创建硬链接。</li></ul><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>软链接也叫作符号链接，也就是Windows中的快捷方式。创建软链接本质上就是新建了一个文本文件，其中存储了目标文件的路径信息，当打开该文本文件时，将指引系统找到目标文件并执行。</p><p>特点：</p><ul><li>符号链接确实是一个新文件，它有不同的I节点号；而硬链接并没有建立新文件。 </li><li>符号链接没有硬链接的限制，可以对目录文件做符号链接，也可以在不同文件系统之间做符号链接。</li><li>符号链接也可以给不存在的文件名创建。</li></ul><h4 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a>ln命令</h4><blockquote><p>ln  [选项]  源文件  [目标文件]</p></blockquote><p>主要作用就是用来创建链接。</p><p>常用选项：</p><ul><li><p>-b 删除，覆盖以前建立的链接</p></li><li><p>-d 允许超级用户制作目录的硬链接</p></li><li><p>-f 强制执行</p></li><li><p>-i 交互模式，文件存在则提示用户是否覆盖</p></li><li><p>-n 把符号链接视为一般目录</p></li><li><p>-s 软链接(符号链接)</p></li><li><p>-v 显示详细的处理过程</p><p><img src="ln.png" alt="ln"></p></li></ul><h3 id="文件目录查找命令"><a href="#文件目录查找命令" class="headerlink" title="文件目录查找命令"></a>文件目录查找命令</h3><h4 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h4><blockquote><p>find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \;</p></blockquote><p> Linux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。 </p><p>通常最常用的参数就是-name，用来查找文件名称符合 name 的文件。iname 会忽略大小写。如：</p><p>find . -name ‘my*’，当前目录下查找以my开头的文件。</p><h4 id="whereis命令"><a href="#whereis命令" class="headerlink" title="whereis命令"></a>whereis命令</h4><p>Linux whereis命令用于查找文件。</p><p>该指令会在特定目录中查找符合条件的文件。这些文件应属于原始代码、二进制文件，或是帮助文件。</p><p>该指令只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用locate命令。</p><p><img src="whereis.png" alt="whereis"></p><h2 id="权限命令"><a href="#权限命令" class="headerlink" title="权限命令"></a>权限命令</h2><h3 id="用户和权限"><a href="#用户和权限" class="headerlink" title="用户和权限"></a>用户和权限</h3><p>Linux系统中规定了4种不同类型的用户：</p><ul><li>u：文件主（owner）；</li><li>g：同组用户（group）；</li><li>o：可以访问系统的其他用户（others）；</li><li>超级用户（root），具有管理系统的特权。</li></ul><p>规定了三种主要的权限：</p><ul><li>读（r）</li><li>写（w）</li><li>可执行或查找（x）</li></ul><h3 id="改变文件或目录存取权限命令"><a href="#改变文件或目录存取权限命令" class="headerlink" title="改变文件或目录存取权限命令"></a>改变文件或目录存取权限命令</h3><h4 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h4><blockquote><p> chmod  key  文件名    </p></blockquote><p>chmod命令负责为文件设置权限。key字符串主要为<code>[who]  [操作符号]  [mode]</code>，用来为指定的用户组设置制定的权限。</p><p>用户组可以是以下四个：</p><ul><li>u 表示该文件的拥有者</li><li>g 表示与该文件的拥有者属于同一个群体(group)者</li><li>o 表示其他以外的人</li><li>a 表示这三者皆是</li></ul><p>操作符主要有：</p><ul><li>+ 表示增加权限</li><li>- 表示取消权限</li><li>= 表示唯一设定权限</li></ul><p>权限主要有：</p><ul><li><p>r 表示可读取</p></li><li><p>w 表示可写入</p></li><li><p>x 表示可执行</p></li><li><p>X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行</p></li></ul><p>例如，以下的命令为： 将文件 file1.txt 设为所有人皆可读取 。</p><blockquote><p>chmod a+r file1.txt</p></blockquote><p>默认情况下，是为所有人设置权限，例如我们在运行shell脚本前，通常需要为.sh文件设置可执行权限：</p><blockquote><p>chmod +x test.sh</p></blockquote><p>这样操作比较复杂，我们也可以使用绝对方式来添加权限。</p><blockquote><p>chmod  mode  文件名</p></blockquote><p>mode是以3位八进制数字出现的，第一位表示文件主（user）权限，第二位表示组用户（group）权限，第三位表示其他用户（others）权限。</p><p>每一位八进制数又是由3位二进制数组成，r=4（100），w=2（010），x=1（001）。 </p><h4 id="umask命令"><a href="#umask命令" class="headerlink" title="umask命令"></a>umask命令</h4><blockquote><p> umask   mode</p></blockquote><p>用来设置系统默认的新建文件权限掩码。 比如我要把umask值改为027，则使用命令 umask 027 即可。 </p><p><img src="umask-S.png" alt="umask-S"></p><h3 id="改变用户组和文件主的命令"><a href="#改变用户组和文件主的命令" class="headerlink" title="改变用户组和文件主的命令"></a>改变用户组和文件主的命令</h3><h4 id="chgrp命令"><a href="#chgrp命令" class="headerlink" title="chgrp命令"></a>chgrp命令</h4><blockquote><p>chgrp  [选项]  组名  文件名</p></blockquote><p>该命令用来改变指定文件所属的用户组，也就是group。</p><p>常用选项：</p><ul><li>-R，–recursive   递归式地改变指定目录及其下面的所有子目录和文件的用户组。</li></ul><h4 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h4><blockquote><p>chown  [选项]  用户或组  文件名</p></blockquote><p>改变某个文件或目录的所有者和所属的组 ，也就是owner。</p><h2 id="进程管理命令"><a href="#进程管理命令" class="headerlink" title="进程管理命令"></a>进程管理命令</h2><h3 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h3><blockquote><p>ps  [选项]</p></blockquote><p>ps命令是查看进程状态的最常用的命令，它可以提供关于进程的许多信息。 </p><p>常用选项：</p><ul><li><p>-a  显示系统中与tty相关的（除会话组长之外）所有进程的信息。</p></li><li><p>a   BSD风格。显示系统中与终端tty相关的所有进程的信息；当与选项x一起使用时，显示所有进程的信息。 </p></li><li><p>-e  显示所有进程的信息。</p></li><li><p>-f  显示进程的所有信息。</p></li><li><p>-l  以长格式显示进程信息。</p></li><li><p>r   只显示正在运行的进程。</p></li><li><p>u   显示面向用户的格式（包括用户名、CPU及内存使用情况等信息）。</p></li><li><p>x   BSD风格。显示所有非控制终端上的进程信息 ；当与选项a一起使用时，显示所有进程的信息。 </p></li></ul><p>我经常使用的一个命令：ps -aux | grep xxx.py ，使用管道符，将ps命令的输出传入grep命令，用来查看服务器上后台运行的某个脚本的进程。因为在服务器上跑代码经常要用nohup放在服务器的后台。但那样在重新登录后无法在当前控制台的后台查看PID，所以要使用grep命令在所有进程中进行查找。</p><p><img src="ps.png" alt="ps"></p><h3 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h3><blockquote><p>kill  [-s  信号|-p ] [-a] 进程号…<br>kill  -l [信号]</p></blockquote><p>Linux kill命令用于删除执行中的程序或工作。</p><p>kill可将指定的信息送至程序。预设的信息为SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或jobs指令查看。</p><p>强制终止进程：</p><ul><li>kill -9 xxx</li></ul><h3 id="sleep命令"><a href="#sleep命令" class="headerlink" title="sleep命令"></a>sleep命令</h3><blockquote><p>sleep  时间值</p></blockquote><p>“时间值”参数以秒为单位，即让进程暂停由时间值所指定的秒数。 </p><h3 id="amp-符号"><a href="#amp-符号" class="headerlink" title="&amp;符号"></a>&amp;符号</h3><blockquote><p>cmd &amp;</p></blockquote><p>符号&amp;可以让指定的命令cmd在后台运行。因为前台一次只能运行一个进程。后台进程的输出可以用重定向符号&gt;或者&gt;&gt;指定。</p><h3 id="进程有关的快捷键"><a href="#进程有关的快捷键" class="headerlink" title="进程有关的快捷键"></a>进程有关的快捷键</h3><ul><li>&lt;Ctrl+D&gt; 正常终止正在前台运行的一个进程</li><li>&lt;Ctrl+C&gt; 强行终止正在前台运行的一个进程</li><li>&lt;Ctrl+Z&gt; 挂起一个正在前台运行的进程</li></ul><h3 id="jobs命令"><a href="#jobs命令" class="headerlink" title="jobs命令"></a>jobs命令</h3><p>显示后台作业和被挂起的进程。</p><p><img src="jobs.png" alt="jobs"></p><h3 id="bg命令"><a href="#bg命令" class="headerlink" title="bg命令"></a>bg命令</h3><blockquote><p>bg 进程ID</p></blockquote><p>bg命令在后台恢复运行一个被挂起的进程，这里一般使用jobs命令显示的进程ID。</p><h3 id="fg命令"><a href="#fg命令" class="headerlink" title="fg命令"></a>fg命令</h3><blockquote><p>fg 进程ID</p></blockquote><p>fg命令在前台恢复运行一个被挂起的进程，这里一般使用jobs命令显示的进程ID。</p><h3 id="进程控制举例"><a href="#进程控制举例" class="headerlink" title="进程控制举例"></a>进程控制举例</h3><blockquote><p>假设当前以root用户登录字符界面，Shell为bash。首先，请显示当前运行的进程。接下来，创建一个后台睡眠进程，让它睡眠1000秒，并在它运行结束前将它挂起。然后，再使用cat命令创建一个进程，使它接受从终端输入的字符并保存至文件example中。输入“This is a example”后， 挂起该进程。现在，请显示被挂起的进程，并将名为cat的进程调度到前台并完成输入，将名为sleep的进程杀死。</p></blockquote><pre class="line-numbers language-shell"><code class="language-shell">pssleep 1000s按下Ctrl+Z，挂起sleep进程cat > example    在终端输入“This is a example”,然后按下 Ctrl+Z, 挂起cat进程    jobs    fg cat按下Ctrl+D，正常结束cat命令运行ps，得到sleep进程的pid，假设为8172kill -9 8172<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文件压缩和解压缩命令"><a href="#文件压缩和解压缩命令" class="headerlink" title="文件压缩和解压缩命令"></a>文件压缩和解压缩命令</h2><p>这里就不详讲了，和操作系统底层关系不大，用到的时候用man看就好了，纯熟练。</p><ul><li>tar 文件,目录打/解包</li><li>gzip 压缩或解压文件目录,后缀为gz</li><li>compress 压缩或解压文件目录,后缀为Z</li><li>bzip2 压缩或解压文件目录,后缀为bz2</li><li>zcat 显示压缩的文本文件的内容</li></ul><blockquote><p>tar -zcvf myusr.tar.gz mydoc 将mydoc目录打包后压缩,调用gzip压缩工具<br>tar -zxvf myusr.tar.gz 解压<br>tar -Zcvf myusr.tar.Z mydoc 将mydoc目录打包后压缩,调用compress压缩工具<br>tar -Zxvf myusr.tar.Z<br>tar -jcvf myusr.tar.bz2 mydoc<br>tar -jxvf myusr.tar.bz2</p></blockquote><h2 id="文件系统挂载和解挂命令"><a href="#文件系统挂载和解挂命令" class="headerlink" title="文件系统挂载和解挂命令"></a>文件系统挂载和解挂命令</h2><p>会专门分一章文件系统的博客来详讲。</p><h2 id="命令使用技巧"><a href="#命令使用技巧" class="headerlink" title="命令使用技巧"></a>命令使用技巧</h2><h3 id="自动补全命令行tab"><a href="#自动补全命令行tab" class="headerlink" title="自动补全命令行tab"></a>自动补全命令行tab</h3><p>通常在bash下不必要把命令输入完全,bash能够判断出用户要输入的命令<br>方法: 输入部分命令,然后按下Tab键<br>如果用户给出的信息并不唯一,bash将发出一声蜂鸣提醒用户<br>如再按一次Tab键,bash将符合条件的目录或文件显示出来</p><h3 id="命令历史history"><a href="#命令历史history" class="headerlink" title="命令历史history"></a>命令历史history</h3><p>bash可以记录一定数目的以前在Shell中输入的命令(历史命令)<br>有关历史命令的环境变量:</p><ul><li>记录历史命令的数目:HISTSIZE</li><li>记录历史命令的文本文件:HISTFILE</li><li>默认的记录文件:.bash_history,隐含文件,位于用户自己的目录中</li></ul><p>使用历史命令的方法:</p><ul><li>上下键,PgUp,PaDn</li><li>用键盘上的编辑功能键对显示在命令行上的命令进行编辑</li><li>用history命令来显示和编辑历史命令</li></ul><p><img src="history.png" alt="history"></p><ul><li>!的使用(!his)</li></ul><h3 id="命令别名alias"><a href="#命令别名alias" class="headerlink" title="命令别名alias"></a>命令别名alias</h3><p>alias命令可以给命令另外取一个名字，如：</p><blockquote><p>alias cp=’cp -i’</p></blockquote><p>在定义别名时,等号两边不允许有空格存在,否则bash不能确定用户的意图.若命令中包含空格或其他特殊字符串则必须使用引号。</p><p>如果用户需要别名的定义在每次登录时均有效,可将其写入用户私有目录下的.bashrc文件中。</p><p>如果别名与系统命令同名,则别名优先于系统命令,如想使用原系统命令,则在命令前添加 \ 字符。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>Linux标准的输入/输出设备端口:</p><ul><li>stdin 标准输入设备端口</li><li>stdout 标准输出设备端口</li><li>stderr 标准错位设备端口</li></ul><p>默认的标准输出端口和标准错位端口为<strong>控制台的屏幕</strong>，默认的标准输入端口是<strong>控制台的键盘</strong>。</p><p>使用重定向符号，可以修改系统默认的输入、输出和错位端口。</p><blockquote><p>&lt;  输入重定向<br>&lt;&lt;!…!   输入重定向特例, 即here文件<br>/&gt;或&gt;&gt;    输出重定向，其中，&gt;为不追加写，&gt;&gt;为追加写<br>2&gt;   错误重定向<br>&amp;&gt;   同时实现输出重定向和错误重定向</p></blockquote><p><img src="%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="重定向"></p><p>重定向符通常用于将命令结果输出至文件中，或者从文件中读取命令的输入。</p><blockquote><p>ls -l /tmp &gt;dir 将ls命令输出的结果存到当前目录中的dir文件中<br>ls -l /etc &gt;&gt;dir 将ls命令输出的结果追加到dir文件中<br>rpm -ql apache &gt;apache.list 获得apache软件包的安装文件清单并存到指定文件中<br>echo “Hello world!”&gt;message 用echo命令和输出重定向建立简单的文本文件<br>myprogram 2&gt;err_file  将命令myprogram的错误信息保存到文件中<br>myprogram &amp;&gt;output_file 将命令myprogram的错误信息和输出信息都保存到文件中</p><p>wc &lt;&lt;!<br>/&gt;This text forms the content of heredocument<br>/&gt;which continues until the end of delimiter<br>/&gt;!  将命令随后输入的文本作为wc命令的输入</p><p>cat &lt;&lt;! &gt;mytext<br>/&gt;This text forms the content of heredocument<br>/&gt;which continues until the end of delimiter<br>/&gt;!<br>利用cat命令,here文档和输出重定向建立简单的文本文件</p></blockquote><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><blockquote><p>命令1|命令2|……|命令n</p></blockquote><p>Shell提供管道命令”|”, 将一些命令前后 衔接在一起,形成一个管道线。每个命令的输出作为下一条命令的输入,管道线中的命令总是从左到右顺序执行的,管道线是单向的。</p><p>管道与重定向的区别：</p><ul><li>重定向是修改程序或命令的输入、输出、错位端口</li><li>管道是直接将一个程序或命令的标准输出作为另一个程序或命令的标准输入,不需要经过任何中间文件</li></ul><h2 id="联机帮助命令"><a href="#联机帮助命令" class="headerlink" title="联机帮助命令"></a>联机帮助命令</h2><h3 id="man-命令-info-命令"><a href="#man-命令-info-命令" class="headerlink" title="man 命令/info 命令"></a>man 命令/info 命令</h3><blockquote><p>man/info  [选项]  命令名 </p></blockquote><p>格式化并显示某一命令的联机帮助手册页 ，非常有用。</p><p>man命令主要是显示选项。</p><p><img src="man.png" alt="man"></p><p>info命令讲解的很详细。</p><p><img src="info.png" alt="info"></p><h4 id="help命令"><a href="#help命令" class="headerlink" title="help命令"></a>help命令</h4><blockquote><p>help  命令</p></blockquote><p>有些命令构造在shell内部，从而在shell环境内部执行。这种命令称为shell内置命令（也称为内部命令）。用来查看所有shell内置命令的帮助信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是主要的常用命令，更多命令可以参考菜鸟教程： <a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-command-manual.html</a> </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节跳动2019笔试题题解</title>
      <link href="/2020/04/30/zi-jie-tiao-dong-2019-bi-shi-ti-ti-jie/"/>
      <url>/2020/04/30/zi-jie-tiao-dong-2019-bi-shi-ti-ti-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="第一题-万万没想到之聪明的编辑"><a href="#第一题-万万没想到之聪明的编辑" class="headerlink" title="第一题  万万没想到之聪明的编辑"></a>第一题  万万没想到之聪明的编辑</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="1.png" alt="1"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目给出的两个条件非常清晰，我们有两个选择：一是原地修改字符串，二是新建一个字符串。这里我们选择第二种方法，因为原地修改涉及到字符数组下标的移动，需要考虑的内容比较多，比如，我们通常会采用遍历的方式去除不符合要求的字符，但在这道题里删除字符后，字符串长度发生了改变，不太好进行遍历。</p><p>我们使用一个新的字符串，每次遍历原字符串中的一个字符，判断是否可以加到新字符串的末尾：</p><ul><li>如果加入后，会有三个同样的字母相连，不加；</li><li>如果加入后，会有两对同样的字母相连，不加。</li></ul><p>此外，这样做还可以满足题目提到的”从左到右”规则。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            s <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> <span class="token string">""</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">2</span> <span class="token operator">and</span> res<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>res<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">continue</span>                <span class="token keyword">if</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">3</span> <span class="token operator">and</span> res<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">==</span>res<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">and</span> res<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">continue</span>                res<span class="token operator">+=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第二题-万万没想到之抓捕孔连顺"><a href="#第二题-万万没想到之抓捕孔连顺" class="headerlink" title="第二题  万万没想到之抓捕孔连顺"></a>第二题  万万没想到之抓捕孔连顺</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="2.png" alt="2"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题其实不难想到暴力的做法，我们只需要进行两层循环遍历所有建筑物区间，如果两个建筑物距离小于等于d，并且之间至少相隔一栋楼，即可在他们之间的所有楼中任选一栋楼，组成一个埋伏选择，加在结果中。</p><pre class="line-numbers language-python"><code class="language-python">n<span class="token punctuation">,</span>d <span class="token operator">=</span> map<span class="token punctuation">(</span>int<span class="token punctuation">,</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>pos <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>res <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> pos<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span>pos<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> d<span class="token punctuation">:</span>            <span class="token keyword">break</span>        res <span class="token operator">+=</span> j<span class="token operator">-</span>i<span class="token number">-1</span><span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token operator">%</span><span class="token number">99997867</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这么做显然是超时的，实际上只能通过20%的数据，为了进一步优化，我们有几种思路：</p><ul><li>首先，我们不必每次固定区间的左右边界，再在中间任选一栋楼。这样做的话，每次移动 j，都需要修改 res的值。这显然是不好的。我们只需要向右搜索j，找到 pos[j]-pos[i] &lt;=d的最后一个位置。该区间内的所有可能的选择是这样计算的：我们只固定 i ，在 i+1 到 j 间任意选择两栋楼，并且组合不能重复。所以，可能的选择数为 ：（j-i）*（j-i-1）//2（概率论的知识，组合数C）</li><li>其次，我们不应当每次线性搜索 j ，这样会很慢。我们有两种办法进行优化:<ul><li>二分查找搜索，因为pos数组是有序的。</li><li>每轮 j 循环跳出后，下一轮 j 循环从上一次跳出之前最后一个有效的位置 right 开始。因为 pos[right] - pos[i] &lt;=d ，那么 pos[right] - pos[i+1] &lt;=d 也是必然的，因为数组升序。</li></ul></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python">n<span class="token punctuation">,</span>d <span class="token operator">=</span> map<span class="token punctuation">(</span>int<span class="token punctuation">,</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>pos <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>res <span class="token operator">=</span> <span class="token number">0</span>right <span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    tmp <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>right<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> pos<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span>pos<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> d<span class="token punctuation">:</span>            <span class="token keyword">break</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            tmp <span class="token operator">=</span> j <span class="token operator">-</span> i    right <span class="token operator">=</span> j <span class="token operator">-</span><span class="token number">1</span> <span class="token comment" spellcheck="true">#下一次j从本轮最后一个有效位置继续</span>    <span class="token keyword">if</span> tmp<span class="token operator">>=</span><span class="token number">2</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 固定i后有效的组合数</span>        res <span class="token operator">+=</span> <span class="token punctuation">(</span>tmp<span class="token operator">*</span><span class="token punctuation">(</span>tmp<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">99997867</span><span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token operator">%</span><span class="token number">99997867</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第三题-雀魂启动！"><a href="#第三题-雀魂启动！" class="headerlink" title="第三题   雀魂启动！"></a>第三题   雀魂启动！</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="3.png" alt="3"></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这道题主要考察的是回溯的知识，我们需要通过回溯来判断当前手上的14张牌是否可以和牌。</p><ul><li><p>首先，我们要判断一下手上是否还有剩余的牌，如果没有，说明可以和牌，否则还需要继续判断。</p></li><li><p>第一点，我们要判断一下是否选取过雀头，我们可以通过目前的牌数是否为3的整数倍来判断。如果没有选过雀头，且第一个数字出现次数大于等于2，我们就尝试将它选为雀头，并从手牌中拿出去，接着继续递归判断剩余的牌是否符合和牌的条件。</p></li><li><p>第二点，如果第一点的尝试没有进行或者失败了（比如已经选过了雀头或者第一个数无法选为雀头或者第一个数选为雀头后无法和牌），我们尝试用第一个数组成刻子，并将第一个数组成的刻子从手牌中移除，接着继续判断剩余的牌是否符合和牌的条件。</p></li><li><p>第三点，如果第二点的尝试也失败了（比如第一个数字无法组成刻子或者组成刻子后无法和牌），我们就尝试将第一个数字组成顺子，将组成的顺子从手牌中移除，接着继续判断剩余的牌是否符合和牌的条件。</p></li><li><p>最后，如果上述三点都不行，则必然不能和牌。</p></li></ul><p>我们在主函数中，尝试1-9的10个数字，看有哪些可以和牌即可。</p><p>因为这里我们传入递归函数的是列表的切片引用，等同于新建了一个列表，实际上并不会改变当前函数内的列表，所以并不需要显式的回溯，但其实是使用了回溯的思想，这一点要清楚。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isHu</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    判断是否可以胡牌    :param nums:    :return:    """</span>    <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    count0 <span class="token operator">=</span> nums<span class="token punctuation">.</span>count<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 没出现过雀头，且第一个数字出现的次数 >= 2,去掉雀头剩下的能不能和牌</span>    <span class="token keyword">if</span> n <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">and</span> count0 <span class="token operator">>=</span> <span class="token number">2</span> <span class="token operator">and</span> isHu<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token comment" spellcheck="true"># 如果第一个数字出现次数 >= 3，去掉这个刻子后看剩下的能和牌</span>    <span class="token keyword">if</span> count0 <span class="token operator">>=</span> <span class="token number">3</span> <span class="token operator">and</span> isHu<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token comment" spellcheck="true"># 如果存在顺子，移除顺子后剩下的能和牌</span>    <span class="token keyword">if</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">in</span> nums <span class="token operator">and</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token keyword">in</span> nums<span class="token punctuation">:</span>        last_nums <span class="token operator">=</span> nums<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>        last_nums<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        last_nums<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        last_nums<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> isHu<span class="token punctuation">(</span>last_nums<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token comment" spellcheck="true"># 以上条件都不满足，则不能和牌</span>    <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    遍历所有可以抓到的牌看能不能胡牌    :return:    """</span>    d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>        d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">.</span>get<span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>    card_list <span class="token operator">=</span> set<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">{</span>i <span class="token keyword">for</span> i<span class="token punctuation">,</span>v <span class="token keyword">in</span> d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> v<span class="token operator">==</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#去除掉在手牌中已经出现四次的数字</span>    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> card_list<span class="token punctuation">:</span>        <span class="token keyword">if</span> isHu<span class="token punctuation">(</span>sorted<span class="token punctuation">(</span>nums <span class="token operator">+</span> <span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 如果这种抽牌方式可以和牌</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 加入和牌类型列表</span>    res <span class="token operator">=</span> <span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>str<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> sorted<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> res <span class="token keyword">else</span> <span class="token string">'0'</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>s <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span>nums <span class="token operator">=</span> <span class="token punctuation">[</span>int<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> s<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>main<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第四题-特征提取"><a href="#第四题-特征提取" class="headerlink" title="第四题  特征提取"></a>第四题  特征提取</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p><img src="4.png" alt="4"></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>这道题看上去比较复杂，但其实不难，我们只需要用一个哈希表，即字典，存储每一个时间的帧上特征其持续的时间（运动长度）。每一时刻，我们遍历当前帧上的所有特征，将哈希表上对应特征的运动长度加1（这里我们使用defaultdict，方便初始化），同时尝试更新最大特征运动长度。如果之前的某些特征在当前帧上没有出现，我们需要将其从字典中移除。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdictn <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    m <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    longest <span class="token operator">=</span> <span class="token number">0</span>    dic <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>        li <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        li<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        hs <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dic<span class="token punctuation">[</span><span class="token punctuation">(</span>li<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>li<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>            longest <span class="token operator">=</span> max<span class="token punctuation">(</span>longest<span class="token punctuation">,</span> dic<span class="token punctuation">[</span><span class="token punctuation">(</span>li<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>li<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            hs<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token punctuation">(</span>li<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>li<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        tmp <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        <span class="token keyword">for</span> tup <span class="token keyword">in</span> hs<span class="token punctuation">:</span>            tmp<span class="token punctuation">[</span>tup<span class="token punctuation">]</span> <span class="token operator">=</span> dic<span class="token punctuation">[</span>tup<span class="token punctuation">]</span>        dic <span class="token operator">=</span> tmp    <span class="token keyword">print</span><span class="token punctuation">(</span>longest<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第五题-毕业旅行问题"><a href="#第五题-毕业旅行问题" class="headerlink" title="第五题  毕业旅行问题"></a>第五题  毕业旅行问题</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p><img src="5.png" alt="5"></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>这道题我只会用DFS来做，只能通过50%的测试用例，实际上存在着很多重复子问题，应该是DP更好，但是我看了答案没弄明白，希望后面能填坑吧！</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python">min_price <span class="token operator">=</span> <span class="token number">1000000000</span><span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span>path<span class="token punctuation">,</span>price_sum<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> min_price    <span class="token keyword">if</span> len<span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token operator">==</span> n<span class="token punctuation">:</span>        min_price <span class="token operator">=</span> min<span class="token punctuation">(</span>price_sum <span class="token operator">+</span> price<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> min_price<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> path<span class="token punctuation">:</span>                dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span>path<span class="token operator">+</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>price_sum<span class="token operator">+</span>price<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>n <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>price<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    price<span class="token punctuation">.</span>append<span class="token punctuation">(</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>dfs<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>min_price<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第六题-找零"><a href="#第六题-找零" class="headerlink" title="第六题  找零"></a>第六题  找零</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p><img src="6.png" alt="6"></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>这道题比较简单，本质上是一个贪心问题。找零钱问题还可以使用BFS来做，通常需要求不同组合的时候用BFS。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python">n <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">-</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>coins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>res <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> coin <span class="token keyword">in</span> coins<span class="token punctuation">:</span>    res <span class="token operator">+=</span> n<span class="token operator">//</span>coin    n <span class="token operator">=</span> n<span class="token operator">%</span>coin<span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第七题-机器人跳跃问题"><a href="#第七题-机器人跳跃问题" class="headerlink" title="第七题  机器人跳跃问题"></a>第七题  机器人跳跃问题</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p><img src="7.png" alt="7"></p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>由题目可知，能量为e的机器人想要越过高度为h的建筑，如果h大于e，那么e=e-（h-e）=2e-h；如果h小于e，那么e=e+（e-h）=2e-h，也就是其实无论怎么样，跳跃一次后，能量都为2e-h。</p><ul><li>第一次跳跃成功，需要：2e-h1&gt;=0，即e&gt;=h1/2</li><li>第二次跳跃成功，需要：2（2e-h1）-h2&gt;=0，即e&gt;=h1/2+h2/4</li><li>……</li><li>第n次跳跃成功，需要：e&gt;=h1/2+h2/4+…hn/2^n，我们只需要保证这个式子成立即可，由于e是整数，我们还需要向上取整。</li></ul><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python">n <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>height <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>int<span class="token punctuation">,</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>e <span class="token operator">=</span> <span class="token number">0</span>t <span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">for</span> h <span class="token keyword">in</span> height<span class="token punctuation">:</span>    e <span class="token operator">+=</span> h<span class="token operator">/</span>t    t <span class="token operator">*=</span> <span class="token number">2</span><span class="token keyword">print</span><span class="token punctuation">(</span>int<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为研发工程师笔试题解</title>
      <link href="/2020/04/29/hua-wei-yan-fa-gong-cheng-shi-bi-shi-ti-jie/"/>
      <url>/2020/04/29/hua-wei-yan-fa-gong-cheng-shi-bi-shi-ti-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="第一题-汽水瓶"><a href="#第一题-汽水瓶" class="headerlink" title="第一题  汽水瓶"></a>第一题  汽水瓶</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="1.png" alt="1"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题我们可以使用的最简单的思路是：直接进行模拟，每次对当前的空瓶数目整除3，即可得到当前可以换得的满饮料数目，剩余的空瓶数目为原先的空瓶数目取余3再加上换得的满饮料数目（被喝了）。循环进行模拟，记录下喝的饮料数目，直到剩下的空瓶数不足以继续兑换（小于3）。特别注意，当只剩两个空瓶时，直接找老板借一瓶，还可再喝一瓶。</p><p>经过数学推导，我们可以直接计算出喝的饮料数等于初始的空瓶数目整除2，这样可以将时间复杂度降到$O(1)$！</p><p>本题还有一个巨坑的地方，题目中说以‘0‘结束，但是实际上测试用例中存在直接以EOF结束的文件。由于我在LeetCode上面刷题不存在这个问题，所以浪费了很多时间。Python对于文件的EOF判断有两种方法：</p><ul><li>使用try…except break</li><li>使用sys.stdin</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">solve</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> n<span class="token operator">>=</span><span class="token number">3</span><span class="token punctuation">:</span>        tmp <span class="token operator">=</span> n<span class="token operator">//</span><span class="token number">3</span>        count<span class="token operator">+=</span>tmp        n <span class="token operator">=</span> n<span class="token operator">%</span><span class="token number">3</span><span class="token operator">+</span>tmp    <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">:</span>        count<span class="token operator">+=</span><span class="token number">1</span>    <span class="token keyword">return</span> count<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>solve<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第二题-明明的随机数"><a href="#第二题-明明的随机数" class="headerlink" title="第二题  明明的随机数"></a>第二题  明明的随机数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="2.png" alt="2"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题很常规，本质上就是一个计数排序，由于随机数的范围在1-1000，所以直接开一个1-1000的数组就可以了。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        li <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            li<span class="token punctuation">[</span>int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> li<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第三题-字符串最后一个单词的长度"><a href="#第三题-字符串最后一个单词的长度" class="headerlink" title="第三题   字符串最后一个单词的长度"></a>第三题   字符串最后一个单词的长度</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="3.png" alt="3"></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>简单题，倒序遍历记录非空格字符数目，直到遇到首个空格即可。需要注意，字符串可能末尾存在空格，需要先rstrip一下。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python">s <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">' '</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        count<span class="token operator">+=</span><span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第四题-计算字符个数"><a href="#第四题-计算字符个数" class="headerlink" title="第四题  计算字符个数"></a>第四题  计算字符个数</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p><img src="4.png" alt="4"></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>直接用python的字符串的lower函数将模式串和目标串中的字母全部转为小写，再调用count方法计算计算一下即可。</p><p>如果不使用库，也可以使用Ascii码的运算来转换为小写字母。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python">s <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span>target <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>count<span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="第五题-字符串分隔"><a href="#第五题-字符串分隔" class="headerlink" title="第五题  字符串分隔"></a>第五题  字符串分隔</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p><img src="5.png" alt="5"></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>基本的下标运算即可。按照8的长度划分下标区间并输出，如果还剩余不足8的区间，那么补齐0并输出。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        s <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> s<span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">:</span>i<span class="token operator">*</span><span class="token number">8</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">8</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#我一开始没有注意到判断剩余区间是否为0，导致只过了90分，一定要细心！</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">8</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">"0"</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token operator">-</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第六题-进制转换"><a href="#第六题-进制转换" class="headerlink" title="第六题  进制转换"></a>第六题  进制转换</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p><img src="6.png" alt="6"></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>依然是字符串题目，按照16进制转10进制的公式，从低位到高位逐位计算即可。</p><p>需要注意的是’A’-‘F’如何转化为数字10-15，我使用了一个简单的Ascii码运算。</p><p>也可以直接使用python类型转换函数进行求解，int（n，16），直接将16进制转为10进制数。</p><p>如果是超大数据的话，需要改成大数运算。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        s <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span>        s <span class="token operator">=</span> s<span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token string">'0x'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#全部转为大写字母，方便运算时转化</span>        res <span class="token operator">=</span> <span class="token number">0</span>         count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> ord<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span>ord<span class="token punctuation">(</span><span class="token string">'F'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token operator">+=</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token operator">**</span>count<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">+</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>ord<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res<span class="token operator">+=</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token operator">**</span>count<span class="token punctuation">)</span><span class="token operator">*</span>int<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            count<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第七题-质数因子"><a href="#第七题-质数因子" class="headerlink" title="第七题   质数因子"></a>第七题   质数因子</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p><img src="7.png" alt="7"></p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>方法1：</p><p>这道题需要对目标数字进行因式分解，且所有的因子都是质数。</p><p>我们只需要对n每次从2开始进行累除因式分解，记录下每个因子即可。如果因子非质数，那么必然在此之前已经被该因子的某个质数因子分解过了，所以最终结果并不会出现非质数因子。</p><p>因式分解结束的条件是：当前数已经被分解成为质数，无法再继续分解。此时我们将该质数加到记录数组的某位，并且使用空格拼接该数组即可。</p><ul><li>时间复杂度：$O(sqrt(n))$</li></ul><p>方法2：</p><p>使用从2到sqrt（n）的所有因子，对n进行因式分解。每个因子可使用多次。由于可以多次使用因子，所以分解后的因子必然都是质数，因为非质数因子可以被多个质数因子所表示。最后，如果分解完的n并不等于0，那么将此时的n加入到结果数组中，最后拼接。</p><ul><li>时间复杂度：$O(sqrt(n))$</li></ul><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> mathn <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>flag <span class="token operator">=</span> <span class="token boolean">True</span><span class="token keyword">while</span> flag<span class="token punctuation">:</span>    flag <span class="token operator">=</span> <span class="token boolean">False</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> n<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>            n<span class="token operator">//=</span>i            flag <span class="token operator">=</span> <span class="token boolean">True</span>            <span class="token keyword">break</span>res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">' '</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> mathn <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> n<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>        n<span class="token operator">//=</span>i        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> n<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">' '</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第八题-取近似值"><a href="#第八题-取近似值" class="headerlink" title="第八题  取近似值"></a>第八题  取近似值</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p><img src="8.png" alt="8"></p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>可以直接调用round（）函数进行运算。但是python中的四舍五入，其实是四舍六入五取偶，所以不太符合题目要求。</p><p>我们可以直接使用四舍五入的原理，为输入的浮点数加上0.5后，直接使用强制类型转换int截取整数部分。这样，4.4+0.5=4.9，还是4，4.5+0.5=5，是5。</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>int<span class="token punctuation">(</span>float<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第九题-合并表记录"><a href="#第九题-合并表记录" class="headerlink" title="第九题   合并表记录"></a>第九题   合并表记录</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><p><img src="9.png" alt="9"></p><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>这题可以用哈希表来做，但是我写的有些臃肿，后来参考了别人的代码才知道自己哈希表使用的不是很好，排序居然还要使用辅助的列表，还是要多学习啊，目前用的最熟的语言都写得这么差，怎么找工作！!</p><p>还有就是defaultdict要熟练，能够减少判断操作，很常用！</p><p>defaultdict的构造函数可以传入各种类型，从而指定哈希表的默认值。如果是普通字典，访问一个不存在的key，将报错，而defaultdict将返回默认值。比如指定了int，就默认值为0；指定了list，就默认返回[]。</p><p>哈希表本身是无序的，但是可以通过排序哈希表的键，从而有序遍历建值对并输出。</p><p>这里简单提一下sorted（）和list.sort（）的区别：</p><ul><li>sort 是应用在 list 上的方法，属于列表的成员方法，sorted 可以对所有可迭代的对象进行排序操作。</li><li>list 的 sort 方法是原地修改，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</li></ul><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><p>我写的垃圾代码：</p><pre class="line-numbers language-python"><code class="language-python">n <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>dic <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">while</span> n<span class="token punctuation">:</span>    tmp <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>    key<span class="token punctuation">,</span>val <span class="token operator">=</span> int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> key <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val    <span class="token keyword">else</span><span class="token punctuation">:</span>        dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+=</span> val    n<span class="token operator">-=</span><span class="token number">1</span>li <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> key <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    li<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>key<span class="token punctuation">,</span> dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>li<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> li<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">(</span>i<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">' '</span><span class="token operator">+</span>str<span class="token punctuation">(</span>i<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好的写法：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdictn <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>dic <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token keyword">while</span> n<span class="token punctuation">:</span>    key<span class="token punctuation">,</span> val <span class="token operator">=</span> map<span class="token punctuation">(</span>int<span class="token punctuation">,</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+=</span> val    n<span class="token operator">-=</span><span class="token number">1</span><span class="token keyword">for</span> key <span class="token keyword">in</span> sorted<span class="token punctuation">(</span>dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"{} {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>key<span class="token punctuation">,</span> dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第十题-提取不重复的整数"><a href="#第十题-提取不重复的整数" class="headerlink" title="第十题    提取不重复的整数"></a>第十题    提取不重复的整数</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><p><img src="10.png" alt="10"></p><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>使用哈希集合记录重复出现的元素，可以将判断的时间复杂度降到$O(1)$</p><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span>        hs <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token string">""</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> n<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> num <span class="token operator">not</span> <span class="token keyword">in</span> hs<span class="token punctuation">:</span>                res<span class="token operator">+=</span>num                hs<span class="token punctuation">.</span>add<span class="token punctuation">(</span>num<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第十一题-字符个数统计"><a href="#第十一题-字符个数统计" class="headerlink" title="第十一题  字符个数统计"></a>第十一题  字符个数统计</h2><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><p><img src="11.png" alt="11"></p><h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>哈希集合存放出现过的有效字符，利用集合的唯一性（不处理哈希碰撞）来记录不重复的字符个数。</p><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        hs <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        s <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>ord<span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">127</span><span class="token punctuation">:</span>                hs<span class="token punctuation">.</span>add<span class="token punctuation">(</span>ch<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>hs<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第十二题-数字颠倒"><a href="#第十二题-数字颠倒" class="headerlink" title="第十二题  数字颠倒"></a>第十二题  数字颠倒</h2><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><p><img src="12.png" alt="12"></p><h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>直接用切片即可，python做很简单。</p><h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="第十三题-字符串反转"><a href="#第十三题-字符串反转" class="headerlink" title="第十三题   字符串反转"></a>第十三题   字符串反转</h2><h3 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h3><p><img src="13.png" alt="13"></p><h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>直接用切片即可，python做很简单。</p><h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="第十四题-句子逆序"><a href="#第十四题-句子逆序" class="headerlink" title="第十四题 句子逆序"></a>第十四题 句子逆序</h2><h3 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h3><p><img src="14.png" alt="14"></p><h3 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h3><p>这类题目python做都很方便，这也是为什么python很受欢迎。</p><h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="第十五题-字串的连接最长路径查找"><a href="#第十五题-字串的连接最长路径查找" class="headerlink" title="第十五题  字串的连接最长路径查找"></a>第十五题  字串的连接最长路径查找</h2><h3 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h3><p><img src="15.png" alt="15"></p><h3 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h3><p>python对字符串列表的排序默认按照字典序升序，正好符合题目要求。</p><h3 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python">n <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>li <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    li<span class="token punctuation">.</span>append<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> word <span class="token keyword">in</span> sorted<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《程序员面试金典》题解</title>
      <link href="/2020/04/22/cheng-xu-yuan-mian-shi-jin-dian-ti-jie/"/>
      <url>/2020/04/22/cheng-xu-yuan-mian-shi-jin-dian-ti-jie/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上的题库《程序员面试金典》的刷题总结。</p><h2 id="数组与字符串"><a href="#数组与字符串" class="headerlink" title="数组与字符串"></a>数组与字符串</h2><h3 id="面试题-01-01-判定字符是否唯一"><a href="#面试题-01-01-判定字符是否唯一" class="headerlink" title="面试题 01.01. 判定字符是否唯一"></a><a href="https://leetcode-cn.com/problems/is-unique-lcci/" target="_blank" rel="noopener">面试题 01.01. 判定字符是否唯一</a></h3><p>简单做法：暴力法，两次循环。时间复杂度：$O(n^2)$，空间复杂度：$O(1)$。</p><p>使用额外数据结构的方法：哈希集合法，将出现过的字符放入一个set中。时间复杂度：$O(n)$，空间复杂度：$O(n)$。</p><p>不使用额外数据结构的方法：</p><ul><li>排序法。根据字符的ASCII码进行排序，然后判断两两字符是否有相等。时间复杂度：$O(nlogn)$，空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isUnique</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> astr<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        s<span class="token operator">=</span>sorted<span class="token punctuation">(</span>astr<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>位运算法。我们使用26个比特位来存放所有字符的访问情况。每次访问到一个字符，获取它的ASCII并减去97，就可以得知它是第几个字母。然后通过左移操作，获取该字符的位数，即x。n用于存放已访问过的字符情况，如果x和n与运算的结果不等于0，说明该字符所在比特位出现了重复，即可返回False。否则，更新n，继续遍历。时间复杂度：$O(n)$，空间复杂度：$O(1)$。（类似于OS中的<strong>位示图</strong>）</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isUnique</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> astr<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        n<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> astr<span class="token punctuation">:</span>            x<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>ord<span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">97</span>            <span class="token keyword">if</span> n<span class="token operator">&amp;</span>x<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            n<span class="token operator">|</span><span class="token operator">=</span>x        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-01-02-判定是否互为字符重排"><a href="#面试题-01-02-判定是否互为字符重排" class="headerlink" title="面试题 01.02. 判定是否互为字符重排"></a><a href="https://leetcode-cn.com/problems/check-permutation-lcci/" target="_blank" rel="noopener">面试题 01.02. 判定是否互为字符重排</a></h3><p>简单方法：ASCII码排序，将两个字符串进行sorted操作，再看是否相等即可。时间复杂度：$O(nlogn)$，空间复杂度：$O(1)$。</p><p>还可以使用哈希表，存放字符串内的字符和出现字符串，进行比较。时间复杂度：$O(n)$，空间复杂度：$O(n)$。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">CheckPermutation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s1<span class="token punctuation">:</span> str<span class="token punctuation">,</span> s2<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dic1<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        dic2<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> s1<span class="token punctuation">:</span>            dic1<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">=</span> dic1<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">if</span> ch <span class="token keyword">in</span> dic1<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">1</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> s2<span class="token punctuation">:</span>            dic2<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">=</span> dic2<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">if</span> ch <span class="token keyword">in</span> dic2<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">1</span>        <span class="token keyword">return</span> dic1<span class="token operator">==</span>dic2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-01-03-URL化"><a href="#面试题-01-03-URL化" class="headerlink" title="面试题 01.03. URL化"></a><a href="https://leetcode-cn.com/problems/string-to-url-lcci/" target="_blank" rel="noopener">面试题 01.03. URL化</a></h3><p>简单方法：可以调用python的库，但很明显不是题目想要我们做的。</p><p>我们可以倒序遍历，对S进行替换。使用双指针i和j，i用于遍历原字符串的真实长度，j用于控制新字符串的生成。具体代码如下所示：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">replaceSpaces</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> S<span class="token punctuation">:</span> str<span class="token punctuation">,</span> length<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        i<span class="token operator">=</span>length<span class="token number">-1</span>        j<span class="token operator">=</span>len<span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        S<span class="token operator">=</span>list<span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#Python要先替换为字符列表，才能按位修改</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">" "</span><span class="token punctuation">:</span>                S<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>S<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>S<span class="token punctuation">[</span>j<span class="token number">-2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"0"</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"%"</span>                j<span class="token operator">-=</span><span class="token number">3</span>                i<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                S<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>S<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                j<span class="token operator">-=</span><span class="token number">1</span>                i<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>S<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么要倒序？防止正序遍历替换空格时可能将尚未遍历的字符替换掉。</p><p>这题貌似有点问题，不知道为什么替换后的字符串无法正好填满字符数组，所以要用j指针的最后位置来返回。</p><ul><li>时间复杂度：$O(n)$</li></ul><h3 id="面试题-01-04-回文排列"><a href="#面试题-01-04-回文排列" class="headerlink" title="面试题 01.04. 回文排列"></a><a href="https://leetcode-cn.com/problems/palindrome-permutation-lcci/" target="_blank" rel="noopener">面试题 01.04. 回文排列</a></h3><p>回文排列的条件是：仅有1个或0个字符出现的次数为奇数次，其余都是偶数次，这样才能实现两两匹配。</p><p>所以，我们可以使用哈希表统计一下字符串内字符出现的次数，看是否符合上述条件即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canPermutePalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>            dic<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">=</span>dic<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">if</span> ch <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">1</span>        count<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> key <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                count<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> count<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-01-05-一次编辑"><a href="#面试题-01-05-一次编辑" class="headerlink" title="面试题 01.05. 一次编辑"></a><a href="https://leetcode-cn.com/problems/one-away-lcci/" target="_blank" rel="noopener">面试题 01.05. 一次编辑</a></h3><p>这道题是一道经典的动态规划题目，叫做编辑距离，在我的LeetCode笔记中有详细的介绍。我们可以通过动态规划转移的方法，计算出从first到second最少需要转移的次数，看其是否小于等于1即可。</p><ul><li>时间复杂度：$O(MN)$。</li><li>空间复杂度：$O(MN)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">oneEditAway</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> first<span class="token punctuation">:</span> str<span class="token punctuation">,</span> second<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>j                <span class="token keyword">elif</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> first<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span>second<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，这道题不需要求解具体的最小编辑次数，所以我们可以使用更为简单的解法。</p><p>我们保证first字符串的长度大于等于second字符串。然后将二者的字符两两比较，如果在位置 i 处出现了不相等的字符，那么：</p><ul><li>如果二者长度相等，就比较first[i+1:]和second[i+1:]（假设当前为替换操作，如果二者后面的字符串相等，则可以仅编辑一次），如 leetcode 与 leetkode。 </li><li>如果二者长度不等，就比较first[i+1:]和second[i:]（假设当前为删除操作），如 leetcode 与 leetode。 </li></ul><p>如果上述比较没有返回结果，说明second是first的子串，此时我们只需要比较二者的长度差是否小于等于1，即可知道编辑距离是否小于等于1。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">oneEditAway</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> first<span class="token punctuation">:</span> str<span class="token punctuation">,</span> second<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">:</span>            first<span class="token punctuation">,</span>second<span class="token operator">=</span>second<span class="token punctuation">,</span>first        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> first<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>second<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> len<span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token operator">==</span>len<span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> first<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">==</span>second<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> first<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">==</span>second<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token operator">-</span>len<span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-01-06-字符串压缩"><a href="#面试题-01-06-字符串压缩" class="headerlink" title="面试题 01.06. 字符串压缩"></a><a href="https://leetcode-cn.com/problems/compress-string-lcci/" target="_blank" rel="noopener">面试题 01.06. 字符串压缩</a></h3><p>我的做法是采用双指针法，r指针用于遍历原字符串，l用于确定重复字符区间的开头。每次遍历到不在当前重复字符区间内的字符，就将当前重复区间进行压缩，并移动 l 指针至当前字符。</p><ul><li>时间复杂度：$O(n)$.</li><li>空间复杂度：$O(n)$.</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">compressString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> S<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">if</span> S<span class="token operator">==</span><span class="token string">""</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> S        l<span class="token operator">=</span><span class="token number">0</span>        r<span class="token operator">=</span><span class="token number">0</span>        res<span class="token operator">=</span><span class="token string">""</span>        <span class="token keyword">while</span> r<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> S<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">!=</span>S<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">:</span>                res<span class="token operator">+=</span>S<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+</span>str<span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span>                l<span class="token operator">=</span>r            <span class="token keyword">else</span><span class="token punctuation">:</span>                r<span class="token operator">+=</span><span class="token number">1</span>        res<span class="token operator">+=</span>S<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+</span>str<span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span>        <span class="token keyword">return</span> res <span class="token keyword">if</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token keyword">else</span> S<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-01-07-旋转矩阵"><a href="#面试题-01-07-旋转矩阵" class="headerlink" title="面试题 01.07. 旋转矩阵"></a><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/" target="_blank" rel="noopener">面试题 01.07. 旋转矩阵</a></h3><p>这题是矩阵操作的经典题目，主站也有。需要一定的数学知识。基本思路是：先对当前矩阵求转置，接着求左右翻转即可。</p><ul><li>时间复杂度：$O(n^2)$.</li><li>空间复杂度：$O(1)$.</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify matrix in-place instead.        """</span>        rowLen<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span>        colLen<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>rowLen<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>colLen<span class="token punctuation">)</span><span class="token punctuation">:</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>rowLen<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>colLen<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>colLen<span class="token operator">-</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">=</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>colLen<span class="token operator">-</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-01-08-零矩阵"><a href="#面试题-01-08-零矩阵" class="headerlink" title="面试题 01.08. 零矩阵"></a><a href="https://leetcode-cn.com/problems/zero-matrix-lcci/" target="_blank" rel="noopener">面试题 01.08. 零矩阵</a></h3><p>这道题我们可以使用两个集合标记一下需要被清零的行和列，进行两次遍历即可。</p><ul><li>时间复杂度：$O(n^2)$.</li><li>空间复杂度：$O(n)$.</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">setZeroes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify matrix in-place instead.        """</span>        row<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        col<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    row<span class="token punctuation">.</span>add<span class="token punctuation">(</span>i<span class="token punctuation">)</span>                    col<span class="token punctuation">.</span>add<span class="token punctuation">(</span>j<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i <span class="token keyword">in</span> row <span class="token operator">or</span> j <span class="token keyword">in</span> col<span class="token punctuation">:</span>                    matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-01-09-字符串轮转"><a href="#面试题-01-09-字符串轮转" class="headerlink" title="面试题 01.09. 字符串轮转"></a><a href="https://leetcode-cn.com/problems/string-rotation-lcci/" target="_blank" rel="noopener">面试题 01.09. 字符串轮转</a></h3><p>这道题的思路，我们可以借鉴主站中的字符串轮转题目。我们可以采用数组实现队列的方式，当需要进行轮转时，将指针重新转移到字符串的开头即可。</p><p>所以，我们对s1进行重复地拼接，如果s2在拼接后的s1中，且s2与s1的原长相等，则说明s2可以由s1轮转而来。</p><p>例如：</p><p>s1“waterbottle”重复拼接后得到“wat<strong>erbottlewat</strong>erbottle”，而s2“erbottlewat”在其中，且二者原长相等。则可以返回True。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isFlipedString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s1<span class="token punctuation">:</span> str<span class="token punctuation">,</span> s2<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> s1<span class="token operator">==</span><span class="token string">""</span> <span class="token operator">and</span> s2<span class="token operator">==</span><span class="token string">""</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">if</span> s1<span class="token operator">==</span><span class="token string">""</span> <span class="token operator">or</span> s2<span class="token operator">==</span><span class="token string">""</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        tmp<span class="token operator">=</span>len<span class="token punctuation">(</span>s1<span class="token punctuation">)</span>        s1<span class="token operator">+=</span>s1        <span class="token keyword">return</span> s2 <span class="token keyword">in</span> s1 <span class="token operator">and</span> len<span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token operator">==</span>tmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="面试题-02-01-移除重复节点"><a href="#面试题-02-01-移除重复节点" class="headerlink" title="面试题 02.01. 移除重复节点"></a><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/" target="_blank" rel="noopener">面试题 02.01. 移除重复节点</a></h3><p>我的做法是采用哈希集合来存放已出现过的节点值，然后使用指针遍历链表。对值已经出现过的链表进行删除处理。</p><p>因为链表中删除节点需要使用的是前一个节点，所以我们通过判断当前节点的下一节点是否重复，来进行删除。如果重复，那么就删除，并且再次判断新的next节点；如果不重复，那么就移动指针继续向后遍历。</p><ul><li>时间复杂度：$O(n)$.</li><li>空间复杂度：$O(n)$.</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeDuplicateNodes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head<span class="token operator">!=</span>None<span class="token punctuation">:</span>            hs<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>            hs<span class="token punctuation">.</span>add<span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            p<span class="token operator">=</span>head            <span class="token keyword">while</span> p<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span>                <span class="token keyword">if</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">not</span> <span class="token keyword">in</span> hs<span class="token punctuation">:</span>                    hs<span class="token punctuation">.</span>add<span class="token punctuation">(</span>p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                    p<span class="token operator">=</span>p<span class="token punctuation">.</span>next                <span class="token keyword">else</span><span class="token punctuation">:</span>                    p<span class="token punctuation">.</span>next<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-02-02-返回倒数第-k-个节点"><a href="#面试题-02-02-返回倒数第-k-个节点" class="headerlink" title="面试题 02.02. 返回倒数第 k 个节点"></a><a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/" target="_blank" rel="noopener">面试题 02.02. 返回倒数第 k 个节点</a></h3><p>双指针法。通过一个间隔为k的快慢指针进行返回。当快指针遍历到链表尾部时，返回此时慢指针的节点值即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">kthToLast</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        slow<span class="token operator">=</span>head        fast<span class="token operator">=</span>head        count<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> fast<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">if</span> count<span class="token operator">==</span>k<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当快指针走出k步后，慢指针开始行动</span>                slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next                fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next            <span class="token keyword">elif</span> count<span class="token operator">&lt;</span>k<span class="token punctuation">:</span>                fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next                count<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> slow<span class="token punctuation">.</span>val<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-02-03-删除中间节点"><a href="#面试题-02-03-删除中间节点" class="headerlink" title="面试题 02.03. 删除中间节点"></a><a href="https://leetcode-cn.com/problems/delete-middle-node-lcci/" target="_blank" rel="noopener">面试题 02.03. 删除中间节点</a></h3><p>主站原题，这道题比较有意思，无法通过修改前一个节点的next指针来删除当前节点。所以我们需要将当前节点与下一个节点进行交换，将删除当前节点转变为删除下一个节点。即可通过修改当前节点的next指针进行删除。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type node: ListNode        :rtype: void Do not return anything, modify node in-place instead.        """</span>        node<span class="token punctuation">.</span>val<span class="token operator">=</span>node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val        node<span class="token punctuation">.</span>next<span class="token operator">=</span>node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但其实我觉得题目出得不好，这样并没有真正删除节点，只是删除了值。</p><h3 id="面试题-02-04-分割链表"><a href="#面试题-02-04-分割链表" class="headerlink" title="面试题 02.04. 分割链表"></a><a href="https://leetcode-cn.com/problems/partition-list-lcci/" target="_blank" rel="noopener">面试题 02.04. 分割链表</a></h3><p>这道题出题人的语文没学好，讲的很混乱。但是基本意思就是给定一个值，让链表中小于这个值的数字都位于大于等于这个值的数字之前。</p><p>我们使用头插法进行操作，当遍历到的值小于x时，将其插入到链表头部即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        p<span class="token operator">=</span>head        <span class="token keyword">while</span> p<span class="token operator">!=</span>None <span class="token operator">and</span> p<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>x<span class="token punctuation">:</span>                tmp<span class="token operator">=</span>p<span class="token punctuation">.</span>next                p<span class="token punctuation">.</span>next<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next                tmp<span class="token punctuation">.</span>next<span class="token operator">=</span>head                head<span class="token operator">=</span>tmp            <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#与之前2.1的删除节点方法类似，删除节点后不能移动指针p，因为无法保证删除后的下一节点没问题。</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-02-05-链表求和"><a href="#面试题-02-05-链表求和" class="headerlink" title="面试题 02.05. 链表求和"></a><a href="https://leetcode-cn.com/problems/sum-lists-lcci/" target="_blank" rel="noopener">面试题 02.05. 链表求和</a></h3><p>大数加法的链表形式。一次遍历用于相加，一次遍历用于进位。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> l2<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        n<span class="token operator">=</span><span class="token number">0</span>        p<span class="token operator">=</span>l1        q<span class="token operator">=</span>l2        dummyhead<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        r<span class="token operator">=</span>dummyhead        <span class="token keyword">while</span> p<span class="token operator">!=</span>None <span class="token operator">and</span> q<span class="token operator">!=</span>None<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#按位相加</span>            now<span class="token operator">=</span>p<span class="token punctuation">.</span>val<span class="token operator">+</span>q<span class="token punctuation">.</span>val<span class="token operator">+</span>n            node<span class="token operator">=</span>ListNode<span class="token punctuation">(</span>now<span class="token punctuation">)</span>            r<span class="token punctuation">.</span>next<span class="token operator">=</span>node            p<span class="token punctuation">,</span>q<span class="token punctuation">,</span>r<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">,</span>q<span class="token punctuation">.</span>next<span class="token punctuation">,</span>r<span class="token punctuation">.</span>next        <span class="token keyword">if</span> p<span class="token operator">==</span>None <span class="token operator">and</span> q<span class="token operator">!=</span>None<span class="token punctuation">:</span>            r<span class="token punctuation">.</span>next<span class="token operator">=</span>q        <span class="token keyword">if</span> q<span class="token operator">==</span>None <span class="token operator">and</span> p<span class="token operator">!=</span>None<span class="token punctuation">:</span>            r<span class="token punctuation">.</span>next<span class="token operator">=</span>p        r<span class="token operator">=</span>dummyhead        <span class="token keyword">while</span> r<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#进位</span>            now<span class="token operator">=</span>r<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token operator">+</span>n            n<span class="token operator">=</span>now<span class="token operator">//</span><span class="token number">10</span>            r<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token operator">=</span>now<span class="token operator">%</span><span class="token number">10</span>            r<span class="token operator">=</span>r<span class="token punctuation">.</span>next        <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>           r<span class="token punctuation">.</span>next<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-02-06-回文链表"><a href="#面试题-02-06-回文链表" class="headerlink" title="面试题 02.06. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/" target="_blank" rel="noopener">面试题 02.06. 回文链表</a></h3><p>主站原题。最简单的方法是遍历一次后将链表中的数据存入数组中，再判断是否为回文数组，但那样需要使用额外的空间。</p><p>如果不想使用额外空间，可以用如下的方法：</p><ol><li>快慢指针法找到链表的中间点。</li><li>翻转后一半链表。</li><li>双指针法，从两头开始向内遍历，比较是否完全相等。</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> head<span class="token operator">==</span>None <span class="token operator">or</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        p<span class="token operator">=</span>head        q<span class="token operator">=</span>head<span class="token punctuation">.</span>next        <span class="token keyword">while</span> q<span class="token operator">!=</span>None <span class="token operator">and</span> q<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#寻找链表中点</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next            q<span class="token operator">=</span>q<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        q<span class="token operator">=</span>p<span class="token punctuation">.</span>next        p<span class="token operator">=</span>None        <span class="token keyword">while</span> q<span class="token operator">!=</span>None<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#翻转后半链表</span>            tmp<span class="token operator">=</span>q<span class="token punctuation">.</span>next            q<span class="token punctuation">.</span>next<span class="token operator">=</span>p            p<span class="token punctuation">,</span>q<span class="token operator">=</span>q<span class="token punctuation">,</span>tmp        q<span class="token operator">=</span>head        <span class="token keyword">while</span> p<span class="token operator">!=</span>None<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#双指针比较</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>val<span class="token operator">!=</span>q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            p<span class="token punctuation">,</span>q<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">,</span>q<span class="token punctuation">.</span>next        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/" target="_blank" rel="noopener">面试题 02.07. 链表相交</a></h3><p>剑指Offer的原题，如下图所示：我们只需要让两个指针p、q各自从A、B出发，走到C点后，p转移至B，q转移至A，这样，两个指针在o点处走的路程分别为：AO+OC+BO和BO+OC+AO。所以，假设存在交点，二者必然在O点相交。如果不存在交点，二者将同时走到尽头。</p><p><img src="2-7.png" alt> </p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> headA<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> headB<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> headA<span class="token operator">==</span>None <span class="token operator">or</span> headB<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        p<span class="token operator">=</span>headA        q<span class="token operator">=</span>headB        <span class="token keyword">while</span> p<span class="token operator">!=</span>q<span class="token punctuation">:</span>            p<span class="token punctuation">,</span>q<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">,</span>q<span class="token punctuation">.</span>next            <span class="token keyword">if</span> p<span class="token operator">==</span>None <span class="token operator">and</span> q<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> None            <span class="token keyword">if</span> p<span class="token operator">==</span>None<span class="token punctuation">:</span>                p<span class="token operator">=</span>headB            <span class="token keyword">if</span> q<span class="token operator">==</span>None<span class="token punctuation">:</span>                q<span class="token operator">=</span>headA        <span class="token keyword">return</span> p<span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-02-08-环路检测"><a href="#面试题-02-08-环路检测" class="headerlink" title="面试题 02.08. 环路检测"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-lcci/" target="_blank" rel="noopener">面试题 02.08. 环路检测</a></h3><p>剑指Offer原题，之前已经细致地推导过了。我们只需要让一对快慢指针同时出发，快指针每次走两步，慢指针每次走一步。二者最终必然在环路中相遇。此时，慢指针走过的路程为s，快指针的路程为f，则f=2s且f=s+nb，b为环路的长度，nb表示快指针比慢指针多走了n圈环路。所以，s=nb。</p><p>此时，我们将快指针移回链表头部，和慢指针同步移动。最终，二者必然在环路入口处相遇。因为a+nb与a必然相遇。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        p<span class="token operator">=</span>head        q<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> q<span class="token operator">==</span>None <span class="token operator">or</span> q<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> None            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next            q<span class="token operator">=</span>q<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            <span class="token keyword">if</span> p<span class="token operator">==</span>q<span class="token punctuation">:</span>                <span class="token keyword">break</span>        q<span class="token operator">=</span>head        <span class="token keyword">while</span> p<span class="token operator">!=</span>q<span class="token punctuation">:</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next            q<span class="token operator">=</span>q<span class="token punctuation">.</span>next        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-03-01-三合一"><a href="#面试题-03-01-三合一" class="headerlink" title="面试题 03.01. 三合一"></a><a href="https://leetcode-cn.com/problems/three-in-one-lcci/" target="_blank" rel="noopener">面试题 03.01. 三合一</a></h3><p>简单的数据结构类题目，使用数组模拟栈，并用一个列表存放三个栈各自的curlen指针。</p><p>使用下标运算的方式存取元素。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TripleInOne</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stackSize<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stack<span class="token operator">=</span><span class="token punctuation">[</span>None <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>stackSize<span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>curlen<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>stackSize<span class="token operator">=</span>stackSize    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stackNum<span class="token punctuation">:</span> int<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>curlen<span class="token punctuation">[</span>stackNum<span class="token punctuation">]</span><span class="token operator">&lt;</span>self<span class="token punctuation">.</span>stackSize<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stack<span class="token punctuation">[</span>stackNum<span class="token operator">*</span>self<span class="token punctuation">.</span>stackSize<span class="token operator">+</span>self<span class="token punctuation">.</span>curlen<span class="token punctuation">[</span>stackNum<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>value            self<span class="token punctuation">.</span>curlen<span class="token punctuation">[</span>stackNum<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stackNum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>curlen<span class="token punctuation">[</span>stackNum<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>curlen<span class="token punctuation">[</span>stackNum<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack<span class="token punctuation">[</span>stackNum<span class="token operator">*</span>self<span class="token punctuation">.</span>stackSize<span class="token operator">+</span>self<span class="token punctuation">.</span>curlen<span class="token punctuation">[</span>stackNum<span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">peek</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stackNum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>curlen<span class="token punctuation">[</span>stackNum<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>           <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack<span class="token punctuation">[</span>stackNum<span class="token operator">*</span>self<span class="token punctuation">.</span>stackSize<span class="token operator">+</span>self<span class="token punctuation">.</span>curlen<span class="token punctuation">[</span>stackNum<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stackNum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>curlen<span class="token punctuation">[</span>stackNum<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token comment" spellcheck="true"># Your TripleInOne object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = TripleInOne(stackSize)</span><span class="token comment" spellcheck="true"># obj.push(stackNum,value)</span><span class="token comment" spellcheck="true"># param_2 = obj.pop(stackNum)</span><span class="token comment" spellcheck="true"># param_3 = obj.peek(stackNum)</span><span class="token comment" spellcheck="true"># param_4 = obj.isEmpty(stackNum)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-03-02-栈的最小值"><a href="#面试题-03-02-栈的最小值" class="headerlink" title="面试题 03.02. 栈的最小值"></a><a href="https://leetcode-cn.com/problems/min-stack-lcci/" target="_blank" rel="noopener">面试题 03.02. 栈的最小值</a></h3><p>剑指Offer原题，时间换空间，用一个辅助栈存放当前栈内某个数及其之前所有数对应的最小值。每次有元素入栈、出栈时，都需要更新最小栈。这样就实现了常数级别的时间复杂度。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MinStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>mini<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>mini<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>mini<span class="token punctuation">.</span>append<span class="token punctuation">(</span>min<span class="token punctuation">(</span>x<span class="token punctuation">,</span>self<span class="token punctuation">.</span>mini<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>mini<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">getMin</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>mini<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your MinStack object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MinStack()</span><span class="token comment" spellcheck="true"># obj.push(x)</span><span class="token comment" spellcheck="true"># obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.top()</span><span class="token comment" spellcheck="true"># param_4 = obj.getMin()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-03-03-堆盘子"><a href="#面试题-03-03-堆盘子" class="headerlink" title="面试题 03.03. 堆盘子"></a><a href="https://leetcode-cn.com/problems/stack-of-plates-lcci/" target="_blank" rel="noopener">面试题 03.03. 堆盘子</a></h3><p>这题不是很难，但要考虑的情况较多。python中可以直接使用二维列表来模拟题目中所说的栈，按照题目要求进行操作即可，当pop后某一堆盘子为空时，需要将其栈进行删除操作。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">StackOfPlates</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> cap<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stackLi<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>cap<span class="token operator">=</span>cap    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>cap<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>         <span class="token keyword">if</span> self<span class="token punctuation">.</span>stackLi<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">or</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stackLi<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span>self<span class="token punctuation">.</span>cap<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stackLi<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>             self<span class="token punctuation">.</span>stackLi<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stackLi<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        res<span class="token operator">=</span>self<span class="token punctuation">.</span>stackLi<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stackLi<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stackLi<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">popAt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> index<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stackLi<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token operator">=</span>self<span class="token punctuation">.</span>stackLi<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>stackLi<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>stackLi<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>index<span class="token punctuation">)</span>            <span class="token keyword">return</span> res        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token comment" spellcheck="true"># Your StackOfPlates object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = StackOfPlates(cap)</span><span class="token comment" spellcheck="true"># obj.push(val)</span><span class="token comment" spellcheck="true"># param_2 = obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.popAt(index)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-03-04-化栈为队"><a href="#面试题-03-04-化栈为队" class="headerlink" title="面试题 03.04. 化栈为队"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/" target="_blank" rel="noopener">面试题 03.04. 化栈为队</a></h3><p>主站经典原题。我们使用两个栈来模拟队列。由于栈和队列都是从尾部加入元素，所以我们只需要通过一个辅助栈来模拟出队操作。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>stack1<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>stack2<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Push element x to the back of queue.        """</span>        self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Removes the element from in front of queue and returns that element.        """</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>empty<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack2<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> self<span class="token punctuation">.</span>stack1<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">peek</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Get the front element.        """</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>empty<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack2<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> self<span class="token punctuation">.</span>stack1<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Returns whether the queue is empty.        """</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>stack1<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your MyQueue object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MyQueue()</span><span class="token comment" spellcheck="true"># obj.push(x)</span><span class="token comment" spellcheck="true"># param_2 = obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.peek()</span><span class="token comment" spellcheck="true"># param_4 = obj.empty()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-03-05-栈排序"><a href="#面试题-03-05-栈排序" class="headerlink" title="面试题 03.05. 栈排序"></a><a href="https://leetcode-cn.com/problems/sort-of-stacks-lcci/" target="_blank" rel="noopener">面试题 03.05. 栈排序</a></h3><p>使用一个辅助栈进行插入排序即可。维护主栈单调递减，每次新push一个元素时，将栈顶大于该元素的值入辅助栈保存，插入新元素，再从辅助栈中将元素重新入主栈即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">SortedStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stack1<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>stack2<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack1<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> self<span class="token punctuation">.</span>stack1<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> val<span class="token operator">></span>self<span class="token punctuation">.</span>stack1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>            <span class="token keyword">while</span> self<span class="token punctuation">.</span>stack2<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack1<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">peek</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack1<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack1<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your SortedStack object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = SortedStack()</span><span class="token comment" spellcheck="true"># obj.push(val)</span><span class="token comment" spellcheck="true"># obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.peek()</span><span class="token comment" spellcheck="true"># param_4 = obj.isEmpty()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-03-06-动物收容所"><a href="#面试题-03-06-动物收容所" class="headerlink" title="面试题 03.06. 动物收容所"></a><a href="https://leetcode-cn.com/problems/animal-shelter-lcci/" target="_blank" rel="noopener">面试题 03.06. 动物收容所</a></h3><p>使用三个队列进行模拟即可，没有什么难度。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">AnimalShelf</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>queueDog<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>queueCat<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>queueAny<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> animal<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> animal<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>queueCat<span class="token punctuation">.</span>append<span class="token punctuation">(</span>animal<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> animal<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>queueDog<span class="token punctuation">.</span>append<span class="token punctuation">(</span>animal<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>queueAny<span class="token punctuation">.</span>append<span class="token punctuation">(</span>animal<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">dequeueAny</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>queueAny<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>queueAny<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>queueCat<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>queueDog<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queueAny<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">dequeueDog</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>queueDog<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>queueAny<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>queueDog<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>queueDog<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">dequeueCat</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>queueCat<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>queueAny<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>queueCat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>queueCat<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your AnimalShelf object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = AnimalShelf()</span><span class="token comment" spellcheck="true"># obj.enqueue(animal)</span><span class="token comment" spellcheck="true"># param_2 = obj.dequeueAny()</span><span class="token comment" spellcheck="true"># param_3 = obj.dequeueDog()</span><span class="token comment" spellcheck="true"># param_4 = obj.dequeueCat()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="树、图"><a href="#树、图" class="headerlink" title="树、图"></a>树、图</h2><h3 id="面试题-04-01-节点间通路"><a href="#面试题-04-01-节点间通路" class="headerlink" title="面试题 04.01. 节点间通路"></a><a href="https://leetcode-cn.com/problems/route-between-nodes-lcci/" target="_blank" rel="noopener">面试题 04.01. 节点间通路</a></h3><p>这道题使用临接表存储图，然后进行基本的DFS即可，不需要回溯，因为只需要访问每个节点一次就行了。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findWhetherExistsPath</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> graph<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> start<span class="token punctuation">:</span> int<span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>v<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>set<span class="token punctuation">)</span>        <span class="token keyword">for</span> e <span class="token keyword">in</span> graph<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>v<span class="token punctuation">[</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>e<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        visited<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> nextV <span class="token keyword">in</span> self<span class="token punctuation">.</span>v<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nextV <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>                    <span class="token keyword">if</span> nextV<span class="token operator">==</span>target<span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">True</span>                    visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>nextV<span class="token punctuation">)</span>                    <span class="token keyword">if</span> dfs<span class="token punctuation">(</span>nextV<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>start<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-04-02-最小高度树"><a href="#面试题-04-02-最小高度树" class="headerlink" title="面试题 04.02. 最小高度树"></a><a href="https://leetcode-cn.com/problems/minimum-height-tree-lcci/" target="_blank" rel="noopener">面试题 04.02. 最小高度树</a></h3><p>我们使用递归的方式创建最小高度的二叉搜索树。由于列表有序，我们可以每次选取列表中间的节点作为根节点，然后分别利用左半列表和右半列表生成左右子树。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> li<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> None            mid<span class="token operator">=</span>len<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>li<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>left<span class="token operator">=</span>build<span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token punctuation">:</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>build<span class="token punctuation">(</span>li<span class="token punctuation">[</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token keyword">return</span> build<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-04-03-特定深度节点链表"><a href="#面试题-04-03-特定深度节点链表" class="headerlink" title="面试题 04.03. 特定深度节点链表"></a><a href="https://leetcode-cn.com/problems/list-of-depth-lcci/" target="_blank" rel="noopener">面试题 04.03. 特定深度节点链表</a></h3><p>简单的层次遍历，用队列可以模拟。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">listOfDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tree<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">:</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span>tree<span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            dummyhead<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            p<span class="token operator">=</span>dummyhead            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                now<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                p<span class="token punctuation">.</span>next<span class="token operator">=</span>ListNode<span class="token punctuation">(</span>now<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>next                <span class="token keyword">if</span> now<span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>now<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> now<span class="token punctuation">.</span>right<span class="token operator">!=</span>None<span class="token punctuation">:</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>now<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>dummyhead<span class="token punctuation">.</span>next<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-04-04-检查平衡性"><a href="#面试题-04-04-检查平衡性" class="headerlink" title="面试题 04.04. 检查平衡性"></a><a href="https://leetcode-cn.com/problems/check-balance-lcci/" target="_blank" rel="noopener">面试题 04.04. 检查平衡性</a></h3><p>剑指Offer原题，我们不是直接返回True或者False，而是当当前子树平衡时直接返回高度，这样就可以减少递归时为了求高度而进行的重复遍历了。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            leftHeight<span class="token operator">=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> leftHeight<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            rightHeight<span class="token operator">=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> rightHeight<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">if</span> abs<span class="token punctuation">(</span>leftHeight<span class="token operator">-</span>rightHeight<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> max<span class="token punctuation">(</span>leftHeight<span class="token punctuation">,</span>rightHeight<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token boolean">False</span> <span class="token keyword">if</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">else</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-04-05-合法二叉搜索树"><a href="#面试题-04-05-合法二叉搜索树" class="headerlink" title="面试题 04.05. 合法二叉搜索树"></a><a href="https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/" target="_blank" rel="noopener">面试题 04.05. 合法二叉搜索树</a></h3><p>递归中序遍历二叉搜索树，要求所得的序列递增即可。这里我们不需要存储整个序列，只需要存储最后一次遍历得到的值，当前值只要大于该值，即说明序列递增。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>tail<span class="token operator">=</span>None        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            left<span class="token operator">=</span>inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>tail<span class="token operator">==</span>None<span class="token punctuation">:</span>                now<span class="token operator">=</span><span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                now<span class="token operator">=</span>root<span class="token punctuation">.</span>val<span class="token operator">></span>self<span class="token punctuation">.</span>tail            self<span class="token punctuation">.</span>tail<span class="token operator">=</span>root<span class="token punctuation">.</span>val            right<span class="token operator">=</span>inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">return</span> left <span class="token operator">and</span> now <span class="token operator">and</span> right        <span class="token keyword">return</span> inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-04-06-后继者"><a href="#面试题-04-06-后继者" class="headerlink" title="面试题 04.06. 后继者"></a><a href="https://leetcode-cn.com/problems/successor-lcci/" target="_blank" rel="noopener">面试题 04.06. 后继者</a></h3><p>依然是中序遍历，每次用一个成员变量self.tail记录下当前节点前遍历到的最后一个节点，如果当前的tail指针指向p，则说明当前节点即为目标结果。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inorderSuccessor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>tail<span class="token operator">=</span>None        self<span class="token punctuation">.</span>res<span class="token operator">=</span>None        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>res<span class="token operator">!=</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>tail<span class="token operator">==</span>p<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>res<span class="token operator">=</span>root                <span class="token keyword">return</span>            self<span class="token punctuation">.</span>tail<span class="token operator">=</span>root            inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-04-08-首个共同祖先"><a href="#面试题-04-08-首个共同祖先" class="headerlink" title="面试题 04.08. 首个共同祖先"></a><a href="https://leetcode-cn.com/problems/first-common-ancestor-lcci/" target="_blank" rel="noopener">面试题 04.08. 首个共同祖先</a></h3><p>剑指Offer经典题目，题解可参考我的剑指Offer博客。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> q<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        <span class="token keyword">if</span> root<span class="token operator">==</span>p <span class="token operator">or</span> root<span class="token operator">==</span>q<span class="token punctuation">:</span>            <span class="token keyword">return</span> root        left<span class="token operator">=</span>self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>        right<span class="token operator">=</span>self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>        <span class="token keyword">if</span> left<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> right        <span class="token keyword">if</span> right<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> left        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-04-09-二叉搜索树序列"><a href="#面试题-04-09-二叉搜索树序列" class="headerlink" title="面试题 04.09. 二叉搜索树序列"></a><a href="https://leetcode-cn.com/problems/bst-sequences-lcci/" target="_blank" rel="noopener">面试题 04.09. 二叉搜索树序列</a></h3><p>这个题库里的第一道难题，还是比较有价值的。我们需要得出给定的BST的所有可能的生成序列。</p><p>我们只需要递归访问二叉搜索树即可。但是，这里的递归并不是传统的先序、中序或者后序，而是每次在候选的可访问节点中选取任意的一个进行访问，访问完某个节点后将其非空左右节点放入候选中。根据观察，我们还发现一定是从根节点开始递归。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">BSTSequences</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>candidate<span class="token punctuation">,</span>path<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                candidate<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                candidate<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> candidate<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">)</span>            <span class="token keyword">for</span> i<span class="token punctuation">,</span>node <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>candidate<span class="token punctuation">)</span><span class="token punctuation">:</span>                recur<span class="token punctuation">(</span>candidate<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token operator">+</span>candidate<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>path<span class="token operator">+</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#本质上进行了回溯</span>        <span class="token keyword">if</span> root<span class="token punctuation">:</span>            recur<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">,</span>root<span class="token punctuation">)</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>res        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意，由于这里递归访问候选节点时需要进行回溯，如果我们直接原地修改candidate列表的话，时间复杂度会比较高。这里，我们可以直接新建一个列表candidate[:i]+candidate[i+1:]作为递归的候选节点，这样无需再对当前列表进行修改和回溯，以空间节省时间。</p><h3 id="面试题-04-10-检查子树"><a href="#面试题-04-10-检查子树" class="headerlink" title="面试题 04.10. 检查子树"></a><a href="https://leetcode-cn.com/problems/check-subtree-lcci/" target="_blank" rel="noopener">面试题 04.10. 检查子树</a></h3><p>双层DFS即可。测试用例太弱！</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">checkSubTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> t1<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> t2<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">:</span>                <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>target<span class="token punctuation">.</span>val <span class="token operator">and</span> preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>target<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>target<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>                <span class="token keyword">if</span> preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>                <span class="token keyword">if</span> preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">return</span> <span class="token boolean">False</span> <span class="token keyword">if</span> target<span class="token operator">!=</span>None <span class="token keyword">else</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> preorder<span class="token punctuation">(</span>t1<span class="token punctuation">,</span>t2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-04-12-求和路径"><a href="#面试题-04-12-求和路径" class="headerlink" title="面试题 04.12. 求和路径"></a><a href="https://leetcode-cn.com/problems/paths-with-sum-lcci/" target="_blank" rel="noopener">面试题 04.12. 求和路径</a></h3><p>剑指Offer原题。双重DFS时间复杂度太高，我们可以使用前缀和求解二叉树中的任意一段路径和。进行回溯的DFS即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        prefixSum<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">:</span>                now_prefixSum<span class="token operator">=</span>prefixSum<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>root<span class="token punctuation">.</span>val                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>prefixSum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> now_prefixSum<span class="token operator">-</span>prefixSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>sum<span class="token punctuation">:</span>                        self<span class="token punctuation">.</span>res<span class="token operator">+=</span><span class="token number">1</span>                prefixSum<span class="token punctuation">.</span>append<span class="token punctuation">(</span>now_prefixSum<span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                prefixSum<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        preorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="面试题-05-01-插入"><a href="#面试题-05-01-插入" class="headerlink" title="面试题 05.01. 插入"></a><a href="https://leetcode-cn.com/problems/insert-into-bits-lcci/" target="_blank" rel="noopener">面试题 05.01. 插入</a></h3><p>题意表述不清，当j-i超过M的位数后，应该以0填充。</p><p>我们可以通过位运算，先将N的i到j位全部置为0，接着再与上M左移i位的结果即可。</p><p>需要重点说明的是将N的i到j位全部置为0的过程：</p><ul><li>我们以j=6，i=2为例，先将1左移j-i+1即5位，得到100000</li><li>再将100000减1，得到011111</li><li>将011111左移i位，得到01111100</li><li>再将01111100取反，得到10000011</li><li>将其与N进行与运算，即可将想要置0的区间置0.</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">insertBits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> N<span class="token punctuation">:</span> int<span class="token punctuation">,</span> M<span class="token punctuation">:</span> int<span class="token punctuation">,</span> i<span class="token punctuation">:</span> int<span class="token punctuation">,</span> j<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        N<span class="token operator">&amp;</span><span class="token operator">=</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>j<span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> N<span class="token operator">|</span><span class="token punctuation">(</span>M<span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-05-02-二进制数转字符串"><a href="#面试题-05-02-二进制数转字符串" class="headerlink" title="面试题 05.02. 二进制数转字符串"></a><a href="https://leetcode-cn.com/problems/bianry-number-to-string-lcci/" target="_blank" rel="noopener">面试题 05.02. 二进制数转字符串</a></h3><p>经典的十进制小数转二进制小数，采用累乘法，并正序输出结果。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">printBin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> float<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">if</span> num<span class="token operator">&lt;=</span><span class="token number">0</span> <span class="token operator">or</span> num<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"ERROR"</span>        res<span class="token operator">=</span><span class="token string">""</span>        <span class="token keyword">while</span> num<span class="token operator">!=</span><span class="token number">0.0</span> <span class="token punctuation">:</span>            num<span class="token operator">*=</span><span class="token number">2</span>            res<span class="token operator">+=</span>str<span class="token punctuation">(</span>int<span class="token punctuation">(</span>num<span class="token operator">//</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            num<span class="token operator">=</span>num<span class="token operator">%</span><span class="token number">1</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">32</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token string">"ERROR"</span>        <span class="token keyword">return</span> <span class="token string">"0."</span><span class="token operator">+</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-05-03-翻转数位"><a href="#面试题-05-03-翻转数位" class="headerlink" title="面试题 05.03. 翻转数位"></a><a href="https://leetcode-cn.com/problems/reverse-bits-lcci/" target="_blank" rel="noopener">面试题 05.03. 翻转数位</a></h3><p>这题虽然看上去是简单题，但个人认为思路还是挺难想的。</p><p>我们需要用一个数组来存放二进制数中连续的1的个数。 如果遇见一段连续的 1，那么会在数组中同一个位置进行累加。 如果遇见了 0，数组下标指针加 1。 稍微思考一下，不难明白此时本题就转换为数组中最大的相邻元素之和。 </p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseBits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        li<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        index<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> num<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> num<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                li<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                index<span class="token operator">+=</span><span class="token number">1</span>            num<span class="token operator">//=</span><span class="token number">2</span>        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token operator">=</span>max<span class="token punctuation">(</span>res<span class="token punctuation">,</span>li<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>li<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 程序员面试金典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上下位关系获取：论文阅读笔记</title>
      <link href="/2020/04/15/shang-xia-wei-guan-xi-huo-qu-lun-wen-yue-du-bi-ji/"/>
      <url>/2020/04/15/shang-xia-wei-guan-xi-huo-qu-lun-wen-yue-du-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>上下位关系</strong>在自然语言知识体系中占有非常重要的地位，它是描述事物层次关系的基础，可以作为词语关系网络的核心骨架。根据 WordNet的定义，<strong>给定两个词语x和y，如果句子“x是一种|类|个|…|y”可接受，则称y是x的上位词(hypernym)，x是y的下位词 (hyponym)，上下位关系记为hyponymy(x,y)</strong>。例如，句子“苹果是一种水果”是可以接受的，因此“苹果”和“水果”具有上下位关系hyponymy(苹果，水果)。很显然，上下位关系是非对称的，如果x是y的上位词，则y一定不是x的上位词。</p><p>本文是我阅读国内外对于上下位关系获取的相关论文的笔记，目前学术界主要采用的获取方法是<strong>基于模板的方法和基于词嵌入投影的方法</strong>。我将对上下位相关经典论文进行解读，并分析它们各自方法存在的优缺点。</p><h2 id="Automatic-acquisition-of-hyponyms-from-large-text-corpora（Hearst-M-A，ACL）"><a href="#Automatic-acquisition-of-hyponyms-from-large-text-corpora（Hearst-M-A，ACL）" class="headerlink" title="Automatic acquisition of hyponyms from large text corpora（Hearst M A，ACL）"></a>Automatic acquisition of hyponyms from large text corpora（Hearst M A，ACL）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>上下位关系获取的开山之作，提出了基于模式匹配的方式获取上下位关系的方法。</p><p>在这篇文章中，作者定义了能够揭示上下位关系的一些常用英文模板（pattern），这里的模板指的都是<strong>语法规则（grammar rule）</strong>，例如：</p><ul><li>NP such as NP。</li><li>NP，especially NP。</li><li>…….</li></ul><p>根据上述词法-句法模板，就可以使用最简单的<strong>正则表达式</strong>对上下位关系进行自动获取。例如：</p><ul><li>…more European countries，especially England，France…</li></ul><p>从上述句子中可以得到上下位关系（England，Country）和（France，Country）。</p><p>Hearst设计了一套简单的模式匹配抽取算法，在百科全书文本中进行了上下位关系抽取，并与人工构建的知识库WordNet内包含的上下位关系进行对比，所得结果的准确率为61/106（57.55%）。</p><p>此外，在这篇文章中，Hearst也提出了手工定义模板困难的缺陷，她通过观察已有的上下位关系，认为可以将已有的上下位关系作为种子集迭代抽取模板。这一思想后来被称作是<strong>BootSrapping的半监督抽取方法</strong>。</p><h3 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h3><p>最早进行上下位关系研究的工作之一，提出的方法非常简单易行，是后续基于模板的上下位关系获取方法的基础。但是，在这篇文章里Hearst没有给出抽取的具体方法，同时，基于模板的方法还存在着以下的缺陷：</p><ul><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 综述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 自然语言处理 </tag>
            
            <tag> 上下位关系 </tag>
            
            <tag> 综述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：Attention、Transformer和BERT</title>
      <link href="/2020/04/11/nlp-zi-xue-bi-ji-attention-transformer-he-bert/"/>
      <url>/2020/04/11/nlp-zi-xue-bi-ji-attention-transformer-he-bert/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由谷歌团队提出的<strong>预训练语言模型BERT</strong>近年来正在各大自然语言处理任务中屠榜（话说学者们也挺有意思的，模型名都强行凑个芝麻街的人物名，哈哈哈）。 BERT算法的最重要的部分便是<strong>Transformer</strong>的概念，它本质上是Transformer的编码器部分。 而Transformer中使用了<strong>Self-Attention</strong>机制，所以本文会从<strong>Attention机制</strong>说起。</p><p>本文是我对Attention、Transformer和BERT的学习总结。同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己的理解，如有错误欢迎在评论区指出，非常感谢！ </p><h2 id="Attention机制"><a href="#Attention机制" class="headerlink" title="Attention机制"></a>Attention机制</h2><p> <strong>注意力模型（Attention Model）</strong> 是深度学习领域最有影响力的思想之一。 它模仿了人类观察文本或图像时的注意力，解决了<strong>长序列问题</strong>，尤其在<strong>机器翻译</strong>等领域应用广泛。</p><h3 id="RNN模型如何解决机器翻译问题"><a href="#RNN模型如何解决机器翻译问题" class="headerlink" title="RNN模型如何解决机器翻译问题"></a>RNN模型如何解决机器翻译问题</h3><p>我们以机器翻译问题作为基础，逐步讲解注意力机制及它的优缺点。首先，我们来看RNN模型是如何解决机器翻译问题的。事实上，这在我之前的RNN博客中已经提到过了，这是<strong>一个Many to Many（$T_x!=T_y$）的Seq2Seq序列标注问题。</strong></p><p><img src="2.png" alt="机器翻译问题"></p><p>下图为RNN解决这一类输入序列和输出序列长度不等的序列标注问题的常用模型结构：</p><p><img src="1.png" alt="RNN模型"></p><p>可以看到，RNN模型此时被分为了两个部分：<strong>编码器部分（Encoder）和解码器部分（Decoder）。</strong></p><p>编码器部分没有Softmax层预测输出，它的作用仅仅是<strong>将源语言文本传入到一个RNN网络（具体可以是GRU、LSTM等），然后在网络的出口处提取最后一个时间步的激活值输出，并且传入解码器。</strong>编码器最后一个时间步的激活值输出因为走过了整个源文本序列，所以可以认为<strong>它蕴含了需要翻译的整个句子的信息</strong>。它的维度与RNN单元的隐藏层神经元数目一致。当然了，这里的RNN可以是深层的，但我们只以单隐藏层的RNN进行讲解。</p><p>解码器部分可以看作是一个条件语言模型（Language Model，例如我们常见的AI写诗模型）。它的作用是<strong>通过编码器输入的激活值，生成当前条件下最大概率的目标语言句子</strong>。它与常规的语言模型有两点不同：</p><ol><li>语言模型零时刻的激活值为<strong>零向量</strong>，而机器翻译模型解码器的零时刻的激活值为<strong>编码器结尾的时间步激活输出。</strong></li><li>语言模型为了保证生成句子的多样性，所以每个时间步的输出都是<strong>按照概率分布随机生成</strong>的。而机器翻译模型很明显需要翻译出最准确的结果，所以输出的序列应是<strong>全局最大概率的序列。</strong></li></ol><p>这个语言模型中，每个RNN单元的输出来自两个方面：</p><ul><li>前一个时间步RNN单元的激活值输出。</li><li>前一个时间步Softmax层预测的输出$\hat y_{t-1}$。</li></ul><p>顺便提一下，机器翻译问题中的全局最优解问题和CRF、HMM等常规机器学习的序列标注模型中类似，可以使用<strong>维特比算法</strong>来解，在对应的博客中都可以找到相应的说明。如果我们使用贪心算法，将可能陷入局部最优解中。</p><p>特别地，我们发现，当词汇表规模很大时，即使是动态规划的维特比算法，其时空复杂度也会很高（时间复杂度：$O(MN^2)$，$Ｍ$为时序数，$N$为词汇表大小）。为了降低计算量，科学家们提出了<strong>集束搜索（Beam Search）</strong>的方法，即第一次输出时选取概率最高的$B$个单词，并将它们作为输入投入第二个时间步，第二次输出时仍然只选概率最高的$B$个单词……以此类推，到最后只会产生$B$条预测序列，我们选取概率最大的的作为最终的结果。<strong>这样做，其实就是在贪心搜索和维特比算法之间进行平衡，当$B=1$时，集束搜索退化成贪心算法，当$B=N$时，集束搜索演变成维特比算法。</strong></p><h3 id="RNN-Attention解决机器翻译问题"><a href="#RNN-Attention解决机器翻译问题" class="headerlink" title="RNN+Attention解决机器翻译问题"></a>RNN+Attention解决机器翻译问题</h3><p>上述RNN架构存在着一些问题，例如：<em><em>我们用编码器的最后一个时序的激活值输出作为解码器的初始激活值，也就是说编码器的最后一个激活值向量需要承载源句子的所有信息，这在输入的句子长度变长时，容易成为整个模型的“信息”瓶颈。 </em></em></p><p>如下图所示，一个最基本的RNN机器翻译模型，当句子长度变长时，翻译的效果（Bleu得分）将逐渐降低：</p><p><img src="3.png" alt="朴素RNN机器翻译模型的缺陷"></p><p>为了解决这个问题，科学家们提出了Attention模型，<strong>它将编码器的每个时序隐藏层直接与解码器每个时序的隐藏层相连接，相等于提供了捷径，解码器的预测可以直接利用编码器在每个源文本单词处的编码结果，从而解决了“信息”瓶颈问题。</strong></p><p>首先，我们使用一个BRNN来做编码器，每个时序的输出都是该处源文本单词丰富的特征。BRNN可以充分的利用上下文全部的信息。如下图所示，$\hat y_t’$为$t’$时刻RNN单元前向后向激活的向量拼接。</p><p><img src="4.png" alt="RNN+Attention的编码器"></p><p>接着，我们使用一个RNN来做解码器。RNN的输入除了上一时刻的激活输出向量、上一时刻的预测结果向量，还要加入<strong>注意力输出（Attention Output）</strong>。为了计算解码器在第$t$时刻需要输入的Attention Output，<strong>我们通过给编码器各时序的输出$\hat y_{t’}$一个注意力权重（Attention Weight）$\alpha_{t,t’}$，来对它们进行加权求和。</strong>如下图所示：</p><p><img src="5.png" alt="Attention机制"></p><p>我们可以将解码器的每个时刻单独拎出来：</p><p><img src="6.png" alt="Attention的每个时刻"></p><p>那么，如何计算注意力权重呢？一种比较常用的方法是利用解码器RNN上一时刻的激活向量$s_{t-1}$和编码器此时刻的输出向量$a_{t’}$做<strong>点积（dot product）操作</strong>，所得结果记为注意力得分（Attention Score）$e_{t,t’}$。<br>$$<br>e_{t,t’}=s_{t-1}^Ta_{t’}<br>$$<br>显然，注意力权重$\alpha_{t,t’}$需要满足值域在[0,1]，且各时刻$t’$的注意力权重之和为1。所以，我们需要使用Softmax非线性函数进行转化：<br>$$<br>\alpha_{t,t’}=Softmax(e_{t,t’})<br>$$<br>具体流程可以参考cs224n上的这页ppt：</p><p><img src="7.png" alt="Attention机制的运算过程"></p><p>上面讲解的只是最基本的点积注意力，还有其他几种Attention，本质都是一样的：</p><p><img src="8.png" alt="Attention变种"></p><p>Attention机制的优点如下：</p><ul><li>解决了传统RNN架构的<strong>“信息“瓶颈问题</strong>。</li><li>让解码器<strong>有选择性地注意</strong>与当前翻译相关的源句子中的词。</li><li>通过使编码器的各时序隐藏层和解码器各时序隐藏层<strong>直接相连</strong>，使梯度可以更加直接地进行反向传播，<strong>缓解了梯度消失问题</strong>。</li><li>增加了机器翻译模型的<strong>可解释性</strong>。</li></ul><h2 id="Transformer模型"><a href="#Transformer模型" class="headerlink" title="Transformer模型"></a>Transformer模型</h2><p>尽管RNN+Attention的模型非常有效，但它同时也存在着一些缺陷。RNN最主要的缺陷在于：<strong>它的计算是有时序依赖的，需要用到前一个时间步或者后一个时间步的信息，这导致它难以并行计算，只能串行计算。</strong>而当今时代，GPU的并行化能够大大加速计算过程，如果不能够并行计算，会导致运算速度很低。</p><p>为了解决这个问题，科学家们首先提出了使用CNN代替RNN做特征抽取器。通过多层卷积运算，CNN的上层将能够完整地考虑整个时序的信息：</p><p><img src="9.png" alt="CNN特征提取"></p><p>CNN的优势在于可以并行计算，没有时序依赖。但同时它也有一个缺陷：<strong>CNN需要经过多层计算才能获取长序列的资讯，下层CNN只能看到较小的范围。</strong></p><p>为了能够进行并行计算，又不需要多层迭代，科学家们提出了Transformer模型。它的论文题目很霸气《Attention is All You Need》。正如题目所说，<strong>Transformer模型通过采用Self-Attention自注意力机制，完全抛弃了传统RNN在水平方向的传播，只在垂直方向上传播，只需要不断叠加Self-Attention层即可。</strong>这样，每一层的计算都可以并行进行，可以使用GPU进行加速。</p><p>你可以使用Self-Attention层来完成任何RNN层可以做到的事情：</p><p><img src="10.png" alt="Self-Attention层"></p><h3 id="Self-Attention机制"><a href="#Self-Attention机制" class="headerlink" title="Self-Attention机制"></a>Self-Attention机制</h3><p>Self-Attention层的基本结构如下图所示：</p><p><img src="11.png" alt="Self-Attention层基本结构"></p><p>我们以Self-Attention层的第一个输出$b_1$的计算为例。Self-Attention层计算的流程如下：</p><ol><li>首先，我们以第一个单词的Word2Vec等词向量作为输入$x_1$。通过与一个参数矩阵$W_a$相乘，我们对$x_1$又进行了一次嵌入，得到了$a_1$向量（这里相当于是一个全连接层）。</li><li>接着，我们需要给定三个参数矩阵，分别为$W_q$、$W_k$、和$W_v$，通过三次矩阵乘法，我们从$a_1$计算得到$q_1$、$k_1$、$v_1$三个向量。（相当于三个分开的全连接层）。（需要注意，所有时序的计算共享上述四个参数矩阵）其中，$q$向量称为query向量，用于匹配其它时序的$k$向量；$k$向量称为match向量，用于被其他时序的$q$向量匹配；$v$向量即为当前时序的要被抽取的信息。</li><li>然后，与上一节所说的Attention权重计算方式类似。我们先计算输出时序 1 对各输入时序 i 注意力得分$\alpha_{1,i}$，它是由时序1处的query向量$q$和各处的key向量$k$做点积操作后得到：</li></ol><p>$$<br>\alpha_{1,i}=q_1^Tk_i<br>$$</p><p>​     为了保持梯度稳定，我们还要除以向量$q$和向量$k$共同的维度$d$的平方根，这一步叫做Score归一化。<br>$$<br>\alpha_{1,i}=\frac{q_1^Tk_i}{\sqrt{d}}<br>$$</p><ol start="4"><li><p>接着，我们需要使用非线性函数Softmax对注意力分数进行概率转化，得到注意力权重$\hat \alpha_{1,i}$。<br>$$<br>\hat \alpha_{1,i}=\frac{e^{\alpha_{1,i}}}{\sum_{j=1}^{n}e^{\alpha_{1,j}}}<br>$$</p></li><li><p>最后，我们使用计算得到的注意力权重对各时序的信息向量$v_i$进行加权求和运算，即可得到输出$b_1$。</p></li></ol><p>$$<br>b_1=\sum_{i=1}^n\hat \alpha_{1,i}v_i<br>$$</p><p>以上就是Self-Attention层计算的全过程。可以看到，Self-Attention层在水平方向上不会进行任何计算，也就可以使用矩阵进行并行化：<br>$$<br>B=\hat A V=Softmax(\frac{Q^TK}{\sqrt{d}})V<br>$$<br>Self-Attention的优点：</p><ul><li>因为每个词都和周围所有词做attention，所以任意两个位置都相当于有直连线路，<strong>可捕获长距离依赖。</strong></li><li>而且Attention的<strong>可解释性更好</strong>，根据Attention score可以知道一个词和哪些词的关系比较大。</li><li><strong>易于并行化</strong>，当前层的Attention计算只和前一层的值有关，所以一层的所有节点可并行执行self-attention操作。</li><li>计算效率高，一次Self-Attention只需要<strong>两次矩阵运算，速度很快</strong>。 </li></ul><p>特别地，如果我们每次产生多组$q$、$k$、$v$向量，这样的Self-Attention层叫做Multi-Head Self-Attention，即多头自注意力机制：</p><p><img src="12.png" alt="Multi-Head Self-Attention"></p><p>Multi-Head Self-Attention的优点：<strong>不同的head可以关注不同的重点，通过多个head可以关注到更多的信息。</strong>这有些相当于CNN中的不同filter。</p><p>此时，Self-Attention层还存在着一个问题：虽然此时通过注意力机制，可以有针对性地捕捉整个句子的信息，但是<strong>没有位置信息</strong>。 也就是说无论句子的结构怎么打乱，Transformer都会得到类似的结果。换句话说，<strong>Transformer只是一个功能更强大的词袋模型而已</strong>。 </p><p>为了解决这个问题，研究人员中在编码词向量时引入了<strong>位置编码（Position Embedding）的特征</strong>。具体地说，位置编码会在词向量中加入了单词的位置信息，这样Transformer就能区分不同位置的单词了。 </p><p><img src="13.png" alt="Position Embedding"></p><p>上述$e_i$即为第 i 时刻输入的位置信息。它可以是学习而来的，也可以手工设置。</p><h3 id="Transformer的架构"><a href="#Transformer的架构" class="headerlink" title="Transformer的架构"></a>Transformer的架构</h3><p>介绍完了Self-Attention机制，我们就可以来看Transformer模型的基本架构了。其结构如下图所示：</p><p><img src="14.png" alt="Transformer模型结构"></p><p>与传统RNN类似，它由编码器和解码器两部分组成。上面的结构有几点需要解释：</p><ul><li>Transformer中使用了ResNet中的 residual connection ，即<strong>残差连接</strong>，方便梯度的反向传播。</li><li>Add&amp;Norm指的是将残差路径上传来的向量和Self-Attention计算得到的向量相加后进行<strong>Layer-Normalization</strong>，即层标准化。Layer Norm对同一个样本同一层的所有神经元进行标准化，使它们满足标准正态分布，而Batch Norm则是对Batch内不同样本的同一个神经元所有值进行标准化。</li><li>编码器输出的两个箭头分别是<strong>输入给解码器第二个Multi-Head Self-Attention层的$k$和$v$，且$k=v$</strong>。相当于提供给解码器源文本信息。</li><li>解码器的Masked Multi-Head Self-Attention层之所以叫Masked，是因为由于语言模型的性质，<strong>生成当前词总是需要利用已生成的序列结果，相当于把后面的结果Masked掉了。</strong>所以Transformer解码时，仍然需要按照时序逐个递推计算，只不过大多数内部的计算可以并行化了。</li><li>Feed-Forward层就是一个基本的<strong>全连接前馈层</strong>，一般使用<strong>ReLu激活函数</strong>。</li></ul><p>通过上述架构，我们便可以构建Transformer模型，并且用于各种序列问题。Transformer模型中的注意力机制为翻译模型带来了可解释性，可视化如下：</p><p><img src="15.png" alt="Attention可视化"></p><h3 id="Transformer的优劣"><a href="#Transformer的优劣" class="headerlink" title="Transformer的优劣"></a>Transformer的优劣</h3><p><strong>优点</strong>：</p><ol><li>虽然Transformer最终也没有逃脱传统学习的套路，Transformer也只是一个全连接（或者是一维卷积）加Attention的结合体。但是其设计已经足够有创新，因为其抛弃了在NLP中最根本的RNN或者CNN并且取得了非常不错的效果，算法的设计非常精彩，值得每个深度学习的相关人员仔细研究和品位。</li><li>Transformer的设计最大的带来性能提升的关键是将任意两个单词的距离是1，这对解决NLP中棘手的长期依赖问题是非常有效的。</li><li>Transformer不仅仅可以应用在NLP的机器翻译领域，甚至可以不局限于NLP领域，是非常有科研潜力的一个方向。</li><li>算法的并行性非常好，符合目前的硬件（主要指GPU）环境。</li></ol><p><strong>缺点</strong>：</p><ol><li>粗暴的抛弃RNN和CNN虽然非常炫技，但是它也使模型丧失了捕捉局部特征的能力，RNN + CNN + Transformer的结合可能会带来更好的效果。</li><li>Transformer失去的位置信息其实在NLP中非常重要，而论文中在特征向量中加入Position Embedding也只是一个权宜之计，并没有改变Transformer结构上的固有缺陷。</li></ol><h2 id="BERT模型"><a href="#BERT模型" class="headerlink" title="BERT模型"></a>BERT模型</h2><h3 id="BERT模型介绍"><a href="#BERT模型介绍" class="headerlink" title="BERT模型介绍"></a>BERT模型介绍</h3><p>BERT模型的全名叫做<strong>Bidirectional Encoder Representation from Transformers</strong>。从名称上就可以看出，BERT模型和Transformer模型联系紧密，事实上，它就是Transformer模型的编码器部分。</p><p><img src="16.png" alt="BERT模型的结构"></p><p>BERT模型本质上是一个<strong>自编码语言模型（Autoencoder LM）</strong>，并且其设计了两个任务来预训练该模型：</p><ul><li><strong>Masked Language Model</strong>：这个方式的灵感很大程度上来自于Word2Vec模型中的<strong>连续词袋模型CBOW</strong>。与完型填空类似，该方法<strong>在句子中随机遮盖住15%的单词（ 80%的概率替换成[MASK] 、 10%的概率替换成随机的一个词 、10%的概率替换成它本身 ），并且用剩下的单词去预测它们</strong>。如下图所示，我们将需要预测的单词的BERT词向量输出传入一个线性分类器（如Softmax BPNN），即可用交叉熵损失函数训练模型。</li></ul><p><img src="17.png" alt="Masked LM"></p><ul><li><strong>Next Sentence Prediction</strong>：该方法的描述是：<strong>给定一篇文章中的两句话，判断第二句话在文本中是否紧跟在第一句话之后，如下图所示</strong>。我们插入[SEP]标志表示句子的分隔符，插入[CLS]表示开始预测的位置。通过预测两个句子正确的连接，即可训练模型。</li></ul><p><img src="18.png" alt="Next Sentence Prediction"></p><p>BERT模型的主要输入是<strong>文本中各个字/词(或者称为token)的原始词向量，该向量既可以随机初始化，也可以利用Word2Vec等算法进行预训练以作为初始值</strong>；输出是<strong>文本中各个字/词融合了全文语义信息后的向量表示 。</strong></p><p>此外，BERT模型的输入还有以下两个向量：</p><ol><li>Transformer模型要求的<strong>位置编码向量（ Position Embeddings ）</strong>：刻画词在句子中的位置信息。</li><li><strong>文本向量（Segment Embeddings）</strong>： 该向量的取值在模型训练过程中自动学习，用于刻画文本的全局语义信息，并与单字/词的语义信息相融合 </li></ol><h3 id="BERT模型的使用"><a href="#BERT模型的使用" class="headerlink" title="BERT模型的使用"></a>BERT模型的使用</h3><p>Word2Vec、GloVe、ELMo等模型是通过语言模型任务得到句子中单词的embedding表示，以此作为补充的新特征给下游任务使用。因为给下游提供的是<strong>每个单词的特征形式</strong>，所以这一类预训练的方法被称为<strong>“Feature-based Pre-Training”</strong>。而BERT模型是“基于<strong>Fine-tuning</strong>的模式”，这种做法和图像领域基于Fine-tuning（微调）的方式基本一致，下游任务需要将模型<strong>改造成BERT模型，才可利用BERT模型预训练好的参数</strong>。 </p><p>尽管我们可以从网上下载别人训练好的BERT模型，但是在实际应用在下游任务时，BERT模型的参数依然会不断进行自动微调。不过好处是不需要从头训练了，需要从头开始训练的只有我们下游任务自己的网络参数。</p><p>这里，李宏毅老师给出了BERT模型应用在常见的四种下游任务中的模型结构：</p><p><img src="19.png" alt="输入是句子，输出是类别"></p><p><img src="20.png" alt="输入是句子，输出是句子中每个词的标签"></p><p><img src="21.png" alt="输入是两个句子，输出是类别"></p><p><img src="22.png" alt="基于抽取的QA"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我对Attention、Transformer和BERT模型的一些学习笔记，目前学的还是比较浅显，日后看到论文或者需要使用的时候再进一步加深理解。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 预训练模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：Word2Vec、Glove和ELMO</title>
      <link href="/2020/04/08/nlp-zi-xue-bi-ji-word2vec-glove-he-elmo/"/>
      <url>/2020/04/08/nlp-zi-xue-bi-ji-word2vec-glove-he-elmo/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>词汇表示（Word Representation）一直是自然语言处理中最基础也是最重要的任务之一。 深度学习已经给这一领域带来了革命性的变革。其中一个很关键的概念就是词嵌入（<strong>word embeddings</strong>），这是语言表示的一种方式，可以让算法自动的理解一些类似的词，比如男人对女人，比如国王对王后，还有其他很多的例子。 </p><p>本文是我在学习吴恩达深度学习课程中的词汇表示一章的总结与思考，同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己的理解，如有错误欢迎在评论区指出，非常感谢！</p><h2 id="one-hot表示法"><a href="#one-hot表示法" class="headerlink" title="one-hot表示法"></a>one-hot表示法</h2><p>one-hot表示法是机器学习中表示<strong>离散化特征</strong>的一种重要方法，在NLP任务中，我们同样可以使用它来表示词。在神经网络序列模型的博客中，我已经介绍了使用one-hot向量表示单词的步骤，这里我再简单说明一下：</p><ul><li>建立一个向量，包含常用的词汇，形成一个<strong>词汇表（vocabulary）</strong> 。词汇表的大小是人为设定的，这里，我们使用10,000个单词来构建我们的词汇表。 对于一般规模的商业应用来说30,000到50,000词大小的词典比较常见，但是100,000词的也不是没有，而且有些大型互联网公司会用百万词，甚至更大的词典。</li><li>接下来，我们为单词建立one-hot向量，假如一个词在词汇表中的序号为1234，那么它的one-hot向量就是在1234行为1，其余行均为0的10000维列向量。</li><li>特别地，我们需要考虑<strong>未登录词、开始标记、结尾标记</strong>等情况。未登录词指的是不在词汇表中的单词，我们需要在词汇表添加标记\UNK来表示它们。此外，在构建语言模型、进行机器翻译等过程中，我们还需要使用到开始标记、结尾标记，它们表示的是句子的开始、结尾位置。例如，一旦语言模型生成了结尾标记，我们就可以认为句子生成完毕。我们在词汇表中添加\BOS和\EOS来表示他们。</li></ul><p><img src="1.png" alt="one-hot表示法"></p><p> 这种表示方法的一大缺点就是它把每个词孤立起来，这样使得算法对相关词的泛化能力不强。  <strong>每个one-hot只是为了表示单词自己而已，无法让算法很容易的跨单词泛化，即它无法表示任何两个单词之间的关系</strong>，因为任何两个单词one-hot向量的内积为都是0。 </p><p>例如，我们需要建立一个语言模型来生成句子，假设我们已经学习了下面这个句子：</p><blockquote><p>I want a glass of orange juice.  </p></blockquote><p>在另一个任务中，我们已经预测了如下的句子：</p><blockquote><p>I want a glass of apple <em>__</em>. </p></blockquote><p><strong>由于在one-hot表示法中，单词orange和单词apple间没有任何关联，所以即使模型知道了orange juice是比较常见的搭配，也无法学习到apple juice也是一种常见的情况。所以，空格处无法正确填入单词juice。</strong></p><p>此外，<strong>one-hot向量通常维度很高（与词汇表的大小一致），同时它又是非常稀疏的（只在一个位置为1），所以使用one-hot向量表示词将会使模型的参数变多，难以训练。</strong></p><h2 id="词嵌入表示法"><a href="#词嵌入表示法" class="headerlink" title="词嵌入表示法"></a>词嵌入表示法</h2><p>有没有方法可以更好的表示词，能够捕捉词义以及词间的关联呢？答案是有的，我们可以使用<strong>特征化</strong>的方法来表示一个单词。</p><p>比如下图所示，一共有4个属性（实际应用会更多）：性别、是否为皇室、年龄、是否为食品。每个单词分别从这4个属性给出与这些属性的相关度。<strong>那么任何一个单词就可以用一个4维的特征向量表示</strong>，比如Man表示为(-1, 0.01, 0.03, 0.09)。 </p><p><img src="2.png" alt="词嵌入表示法"></p><p>此时，可以清晰的看到Apple和Orange极为相似，上面的例子就很容易使得算法在第二句话也填入单词juice。 </p><p>当我们将单词使用这种高维特征表示时，就叫做<strong>词嵌入（word embedding）</strong>。之所以叫做embedding，可以想象成每个单词被嵌入（embed）到了一个高维空间内。词嵌入是NLP最重要的思想之一。 </p><p>需要说明的是，上面的特征只是直观的举例，实际上的特征并不是手工设计的，而是算法（即word embedding）学习而来；而且这些学习的特征，<strong>可能并不具有良好的解释性</strong>，但不管怎样，算法都可以快速哪些单词是相似的。 </p><p>此外，词嵌入向量的维度通常情况下远远小于词汇表中单词的数目，所以一定程度上<strong>减少了参数数量，减轻了训练的负担。</strong></p><p>我们可以使用<strong>t-SNE</strong>算法进行高维词向量的可视化，可以看到，词义相近的单词在经过词嵌入后被聚在了一起：</p><p><img src="3.png" alt="词嵌入可视化"></p><h2 id="词嵌入的作用"><a href="#词嵌入的作用" class="headerlink" title="词嵌入的作用"></a>词嵌入的作用</h2><h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><p>我们以一个命名实体识别（NER）的任务为例，假设训练集中存在着这么一句话：</p><blockquote><p> Sally Johnson is an orange farmer. </p></blockquote><p>我们在这里使用一个BRNN模型，并使用词嵌入向量来表示单词，作为BRNN的输入。BRNN可以根据orange farmer判断出Sally Johnson是一个人名。</p><p>当我们遇到了新的输入，如：</p><blockquote><p> Robert Lin is an apple farmer. </p></blockquote><p>由于apple的词嵌入和orange的词嵌入是相似的，所以模型也可以容易的识别Robert Lin是一个人名 。 </p><p>假如我们的输入中含有冷僻词，如：</p><blockquote><p> Robert Lin is a durian cultivator. </p></blockquote><p>durian（榴莲）和cultivator（培育家）是较为少见的单词，很可能在我们的训练集中没有出现过。使用我们传统的one-hot向量表示，将难以预测出 Robert Lin是一个人名。而如果我们使用词嵌入表示法，那么durian和orange将拥有相似的向量，cultivator和farmer将拥有相似的向量，模型能够依据orange farmer和人名的关系，推断出durian cultivator和人名的关系，进而预测出 Robert Lin是一个人名。</p><p>为什么词嵌入能够学习到没有在当前训练集文本中出现过的词的关联呢？这是因为：<strong>词嵌入向量的训练通常是在海量无标签文本上进行的，后面我们会介绍它的训练方法。</strong></p><p><strong>当训练集数量较小时，词嵌入效果往往会很明显</strong>，因为它能够大大丰富输入模型的信息量，提供了词义信息。 在其他的迁移学习情形中也一样，如果你从某一任务<strong>A</strong>迁移到某个任务<strong>B</strong>，只有<strong>A</strong>中有大量数据，而<strong>B</strong>中数据少时，迁移的过程才有用。所以对于很多<strong>NLP</strong>任务词嵌入效果明显，而对于一些语言模型和机器翻译则不然，因为他们本身数据量就很庞大。</p><h3 id="类比推理"><a href="#类比推理" class="headerlink" title="类比推理"></a>类比推理</h3><p> 词嵌入还可以帮助实现<strong>类比推理（analogy reasoning）</strong>。还是以之前的数据为例： </p><p><img src="4.png" alt="词嵌入"></p><p>使用词嵌入，我们可以发现一个有趣的性质：已知 <strong>man</strong>如果对应<strong>woman</strong>，我们可以使用<strong>词嵌入投影</strong>自动得到 <strong>king</strong>对应<strong>queen</strong> 。</p><p>我们使用man的词嵌入向量$e_{man}$减去woman的词嵌入向量$e_{woman}$，可以得到：</p><p><img src="5.png" alt="man减去woman"></p><p>我们使用king的词嵌入向量$e_{king}$减去queen的词嵌入向量$e_{queen}$，可以得到：</p><p><img src="6.png" alt="king减去queen"></p><p>可以发现，二者的差值是非常接近的。这是因为： <strong>man</strong>和<strong>woman</strong>主要的差异是<strong>gender</strong>（<strong>性别</strong>）上的差异，而<strong>king</strong>和<strong>queen</strong>之间的主要差异，根据向量的表示，也是<strong>gender</strong>（<strong>性别</strong>）上的差异 ，所以两个差值会很相近。</p><p>通过这一性质，<strong>我们可以通过某个已知词对的关系，推导出与另一个词最符合该关系的词是什么。</strong>例如，已知man和woman的关系，想要知道哪个词和king也符合该关系，只需要找到能够最大化$e_{king}-e_w$与$e_{man}-e_{woman}$的相似度的单词$w$即可。<br>$$<br>Find\ word\ w:argmax\ Sim(e_w,e_{king}-e_{man}+e_{woman})<br>$$<br>通常来说，我们在这里选用<strong>余弦相似度</strong>，即计算两个向量的余弦值，来度量两个向量$u$和$v$的相似程度：<br>$$<br>Sim(u,v)=\frac{u·v}{||u||_2||v||_2}<br>$$<br><img src="7.png" alt="余弦相似度"></p><h2 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h2><p>为了训练出词嵌入向量，我们可以使用Word2Vec模型。 Word2Vec是一种简单并且计算高效的学习词嵌入的算法。 </p><p>Word2Vec的核心思想是<strong>学习一个神经网络语言模型来训练词向量。</strong>它基于这样的一个假设：<strong>上下文相似的词，其词嵌入向量也是相似的。</strong>例如，存在以下两个句子：</p><blockquote><ol><li><p>我喜欢吃苹果。</p></li><li><p>我喜欢吃梨子。</p></li></ol></blockquote><p>我们知道，苹果和梨子的语义是非常接近的，在上述例子中，苹果和梨子的上下文也非常相似，所以我们的模型将训练得到苹果和梨子相似的词嵌入向量。</p><p>Word2Vec采用了<strong>分布式语义</strong>的方法来表示一个词的含义。本质上，一个词的含义就是这个词所处的上下文语境。回想一下我们高中做英语完形填空时，一篇短文，挖了好多空，让我们根据空缺词的上下文语境选择合适的词。也就是说上下文语境已经能够确定这个词的含义了，如果选词正确，也就意味着我们理解了这个空缺词的含义。 </p><p>Word2Vec使用的语言模型分为两类，也就是说有两种学习词嵌入的方式，分别为：</p><ul><li>如果是用一个词语作为输入，来预测它周围的上下文，那这个模型叫做<strong>『Skip-gram 模型』</strong>。</li><li>而如果是拿一个词语的上下文作为输入，来预测这个词语本身，则是 <strong>『CBOW 模型』</strong>。（就是上面完形填空的例子）</li></ul><h3 id="Skip-gram模型"><a href="#Skip-gram模型" class="headerlink" title="Skip-gram模型"></a>Skip-gram模型</h3><p>首先，我们介绍Word2Vec中的Skip-gram模型。它<strong>是用一个词语作为输入，来预测它周围的上下文。</strong></p><p>假设在训练集中给定了一个这样的句子： </p><blockquote><p><strong>I want a glass of orange juice to go along with my cereal.</strong> </p></blockquote><p>在<strong>Skip-Gram</strong>模型中，我们要做的是抽取上下文和目标词配对，来构造一个监督学习问题。我们要的做的是随机选一个词作为上下文词，比如选<strong>orange</strong>这个词，然后我们要做的是随机在一定词距（即窗口，window）内选另一个词，比如在上下文词前后5个词内或者前后10个词内，我们就在这个范围内选择目标词。<strong>于是我们将构造一个监督学习问题，它给定上下文词，要求你预测在这个词正负10个词距或者正负5个词距内随机选择的某个目标词，构造这个监督学习问题的目标并不是想要解决这个监督学习问题本身，而是想要使用这个学习问题来构造出一个好的词嵌入模型 。</strong></p><p>Skip-gram的字面含义是跳跃掉某些元，也就是在上下文窗口内随机选择某个词作为目标词，而不用考虑是否连续。</p><p>当然，我们也可以不使用随机选取目标词的做法，而是选择窗口内的<strong>每一个词</strong>作为目标词，和当前上下文词组成样本投入模型进行训练，如下图所示。这种做法的代价相应地也较高。为了解决这个问题，可以使用<em><em>subsampling </em></em>的方法，通过计算每个样本的一个保留概率，以这个概率决定是否删掉对应的样本。（实际上和随机选取窗口内的某个单词本质是一样的）</p><p><img src="8.png" alt="训练样本"></p><p>接着，我们使用一个简单的<strong>单隐藏层基本神经网络</strong>来训练出我们想要的词嵌入向量。网络的结构如下图所示：</p><p><img src="9.png" alt="Skip-gram的网络结构"></p><p>可以看到网络有以下几个细节：</p><ul><li>输入层是我们之前选择的上下文词的<strong>one-hot向量</strong>，即单词的原始表示。</li><li>隐藏层维度是<strong>自定义</strong>的，我们想要得到多少维的词嵌入向量，就可以把隐藏层设置为多少层。<strong>并且，隐藏层是线性的，没有使用非线性的激活函数，可以做到简化语言模型的目的，这也是Word2Vec的优势。</strong></li><li>输出层的维度与词汇表维度一致，使用<strong>Softmax激活函数</strong>作为分类器，输出词汇表中每一个词作为目标词的概率。</li><li>输入层、输出层、隐藏层全连接。</li></ul><p>神经网络的训练方式我已经在之前的博客中有所介绍。这里，考虑到是一个有监督的多分类问题，我们可以<strong>使用交叉熵损失函数作为模型的优化目标，并通过梯度下降法拟合模型的参数。</strong></p><p>经过训练，我们得到了模型的权重矩阵$V$和$U$。其中，从输入层到隐藏层的权重矩阵$V$中，由于输入的是one-hot向量，所以<strong>只有对应上下文词所在位置$x$的权重向量$V_x$被激活</strong>，它的维度与隐藏层单元个数是相等的，我们称其为<strong>输入向量</strong>，因为每个单词在one-hot向量中的位置不相同，使用$V_x$可以唯一地表示$x$。</p><p>从隐藏层到输出层的权重矩阵$U$中，我们也可以<strong>使用输出层中上下文词所在位置$x$的权重向量$U_x$表示$x$。</strong>同样，它的维度和隐藏层单元个数相等，我们称之为<strong>输出向量</strong>，他也可以唯一的表示$x$。</p><p>一般情况下，我们更常使用<strong>输入向量</strong>作为单词$x$的词嵌入表示。</p><p>此外，Skip-gram还可以选择多个单词作为当前上下文词的目标词，网络结构仅需微调即可，依然可以选择相同的输入向量和输出向量作为上下文词的词嵌入表示。</p><p><img src="10.png" alt="多目标词的Skip-gram的网络结构"></p><h3 id="CBOW模型"><a href="#CBOW模型" class="headerlink" title="CBOW模型"></a>CBOW模型</h3><p>CBOW模型，即<strong>连续词袋模型</strong> （Continuous Bag-Of-Words Model） ，它的预测方式和Skip-gram模型正好相反，<strong>使用一个词语的上下文作为输入，来预测这个词语本身。</strong></p><p><img src="11.png" alt="CBOW模型的网络结构"></p><p>可以看到，CBOW模型和Skip-gram模型的网络结构几乎一致，我们只需要将上述多目标词的Skip-gram的网络结构的计算反过来即可。我们依然可以<strong>使用交叉熵损失函数作为模型的优化目标，并通过梯度下降法拟合模型的参数。</strong></p><p>顺便说一下，CBOW模型的原理有些类似于Bert中的Mask，不过Bert中的Mask是在一个句子中随机遮住一些单词，用剩下的单词去预测它们，从而训练词嵌入。而CBOW模型需要预测句子中的每个词。</p><h3 id="Word2Vec的优化"><a href="#Word2Vec的优化" class="headerlink" title="Word2Vec的优化"></a>Word2Vec的优化</h3><h4 id="分级softmax分类器"><a href="#分级softmax分类器" class="headerlink" title="分级softmax分类器"></a>分级softmax分类器</h4><p>Word2Vec模型中有一个比较大的缺陷就是<strong>Softmax层的计算量太大</strong>，尤其当词汇表中的单词很多的时候。我们需要对Softmax层的所有单元计算得到的分数求指数并且求和，事实上当词汇数量达到百万、千万级别，这是很缓慢的。</p><p>针对这个问题，学者们提出了一种优化方法，叫做分级（<strong>hierarchical</strong>）softmax分类器。</p><p>分级softmax分类器的基本思想和<strong>二叉查找树</strong>有一些相近，它将原先的softmax层更换成以下的结构：</p><p><img src="12.png" alt="分级softmax分类器"></p><p>上述结构很像一个二叉查找树，树上的每一个节点都是一个sigmoid二分类器。假设我们有10000个词，即输出层有10000个单元。根节点的第一个二分类器会告诉我们结果是否在前5000个，是则进入左子树，否则进入右子树。依次类推，最终我们将定位到叶子节点，即结果是第几个单词。</p><p>根据上述方法，我们将线性时间复杂度$O(n)$降成对数时间复杂度$O(logn)$，从而加速输出层的运算。</p><p>特别地， 在实践中分级<strong>softmax</strong>分类器不会使用一棵完美平衡的分类树或者说一棵左边和右边分支的词数相同的对称树（上图编号1所示的分类树）。<strong>实际上，分级的softmax分类器会被构造成常用词在顶部，然而不常用的词像durian会在树的更深处（上图编号2所示的分类树）。</strong>具体实现通常采用数据结构中的常用结构<strong>哈夫曼树</strong>。</p><h4 id="负采样"><a href="#负采样" class="headerlink" title="负采样"></a>负采样</h4><p>Word2Vec模型的训练样本很多，如果对于每一个训练样本，都更新所有参数，那么训练速度将会很慢。为此，学者们提出了<strong>负采样（Negative Sampling）</strong>的方法，来减少每次训练所更新的样本个数。</p><p>我们将定义新的监督学习问题：<strong>给定一个单词对（比如orange和juice），预测这两个单词是否是context-target对。</strong>也就是<strong>将原先的softmax多分类转化为了逻辑回归的sigmoid多分类（one vs all）。假设词汇表中有10000个单词，相当于我们构造了10000个独立的逻辑回归模型。</strong></p><ul><li>首先我们产生一个正样本（Positive Example），正样本的生成方法和skip-gram中类似，选择一个context单词，在一个windows大小附近随机选择一个target单词。比如上例语句中的orange和juice，我们把正样本标记为1。</li><li>然后使用相同的context，生成负样本（Negative Example），负样本的对应的单词从词汇表里随机选取，比如生成一个负样本orange-king，并将负样本标记为0。同样的方法，生成更多更多的负样本，可能是：orange-book, orange-the, orange-or。由于是随机选择的，我们总认为是负样本，<strong>因此即便上面的orange-of的例子，of其实是Orange的target，我们依然标记为0</strong>。最终形成如下记录： </li></ul><p><img src="13.png" alt="负采样"></p><p> 一个正样本，会选择多个负样本，其个数记为k，<strong>在较小数据集下k通常推荐取5-20，如果数据集较大，则k取值较小，比如2-5</strong>。 </p><p>我们为10000个词分别构建独立的逻辑回归模型（也就是one vs all的多分类方法），然后每次训练时更新正负样本的模型参数。<strong>这样，我们每次迭代并不需要训练原先10000维softmax层那么多的参数（300万个参数），而是只需要训练5个逻辑回归模型的参数（1500个参数），训练的计算量大大降低。</strong></p><p>怎样选择负样本？ 这个算法有个重要细节是如何选择负样本，一种办法是根据每个单词在语料库中的经验概率进行采样，但会导致常用词被采样的频率很高；还有一种是均匀分布的采样，完全不考虑单词的实际频率。负采样中，<strong>负样本被选中的概率和词频成正比</strong>，词频越大的词被选中的概率越大。概率公式如下:<br>$$<br>p(w_i)=\frac{f(w_i)^{3/4}}{\sum_{j=1}^{10000}f(w_j)^{3/4}}<br>$$<br>其中$f(w_i)$是一个单词在语料库中的观测频率。通过取3/4次方，使得既考虑到单词的语料库频率，又能增加低频单词被选取的概率。 </p><h2 id="GloVe"><a href="#GloVe" class="headerlink" title="GloVe"></a>GloVe</h2><p>之前已介绍了几个词嵌入的算法，NLP领域还有一个有一定势头的算法<strong>GloVe（global vectors for word representation）</strong>，虽然并不如Word2Vec或skip-gram常用，但足够简单。</p><h4 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h4><p><strong>我们使用$X_{ij}$代表单词i出现在单词j的上下文的次数</strong>。因此$X_{ij}$，就表示单词i和j一起出现的<strong>频繁程度。</strong>使用窗口将整个训练文本遍历一遍，即可得到共现矩阵$X$。</p><p>如果定义上下文的含义是在10个单词前后范围内，显然可以得出$X_{ij}=X_{ji}$，即<strong>对称性</strong>。如果定义上下文是紧挨着的前一个单词，则没有对称性。但对于GloVe，我们一般选择前者的定义。</p><p>我们定义模型的优化目标为（具体推导参见<a href="https://blog.csdn.net/coderTC/article/details/73864097" target="_blank" rel="noopener"> https://blog.csdn.net/coderTC/article/details/73864097 </a>）：<br>$$<br>J=\sum_i^n\sum_j^nf(X_{ij})(θ^t_ie_j+b_i+b_j−log(X_{ij}))^2<br>$$<br>通过最小化上式，可以学习到一些向量，能够对两个单词同时出现的频率进行预测。另外，式中的$f(X_{ij})$有两个作用：</p><ul><li>当$X_{ij}=0$时，$log(X_{ij})$为无穷大，无法计算。此时定义$f(X_{ij})=0$，即对这样的情况不纳入计算。换句话说，<strong>至少要求两个词同时出现过一次。</strong></li><li>另外，<strong>作为权重，调节常用和非常用单词的计算权重</strong>。既不给常用词过大的权重，也不给非常用词过小的权重。这一块详细参考GloVe的论文。</li></ul><p>另外，由于GloVe的对称性，所以$\theta$和$e$是对称的，或者说在优化目标中起的作用是一样的，因此最终我们通常将它们的均值作为最终的词向量，即：<br>$$<br>e_w^{final}=\frac{e_w+\theta_w}{2}<br>$$<br>虽然GloVe算法的优化函数非常简单（仅是一个二次代价函数），但结果确实奏效，可以学习到良好的词嵌入。</p><h2 id="ELMO"><a href="#ELMO" class="headerlink" title="ELMO"></a>ELMO</h2><p>Word2Vec和GloVe虽然是最常用的几种词嵌入模型之一，但他们也存在着一个严重的缺陷，<strong>即假设每个单词只有一个词义。</strong>换句话说，Word2Vec<strong>无法针对每个单词的不同词义分类讨论。</strong>而多义词往往是非常常见的，我们仅以一个词嵌入向量来描述它不够合理。例如，我们有一个单词“包袱”，存在着以下的句子：</p><blockquote><p>他背起包袱向远方走去。</p></blockquote><p>以及另一个句子：</p><blockquote><p>他的相声说的很好，经常都抖出有趣的包袱。</p></blockquote><p>可以看到，同一个词“包袱”在不同的语境下，含义迥然不同。上述例子中，我们称不同句子中的“包袱”为同一个Type，却是不同的Token。</p><p><strong>为了解决上述缺陷，学者们提出了ELMO模型（Embedding from Language Model），从而实现了上下文化的词嵌入（Contextual Word Embedding），也就是针对Token进行词嵌入。这样，即使是同一个单词，所在的上下文语境不同，其词嵌入向量也不同，解决了Word2Vec对多义词处理的不足。</strong></p><p>ELMO模型的训练方法是采用基于RNN（循环神经网络）的语言模型。更详细一些，<strong>是使用双向LSTM语言模型，并采用Word2Vec词嵌入向量作为模型的输入，训练得到ELMO词嵌入。</strong></p><p>ELMO模型的架构如下图所示：</p><p><img src="14.png" alt="ELMO模型"></p><p>BRNN和LSTM的知识在我的神经网络序列模型的博客中已经有所介绍。<strong>这个Bi-LSTM语言模型就是通过已知的前面所有的单词和后面所有的单词，预测出当前位置正确的单词，即最大化当前位置正确单词的条件概率。这个最优化问题可以使用softmax的交叉熵损失函数求解。</strong></p><p>需要注意的是，这里使用的Bi-LSTM-LM是多层的，即为Deep-Bi-LSTM-LM。<strong>我们选取第k个时间步每一层的LSTM单元输出，加权求和，最后乘以当前句子的权重，即为当前句子第k个词的ELMO词嵌入向量，其维度与LSTM单元隐藏层的维度的两倍一致（每层LSTM单元激活值输出是对前向和后向传播来的激活值的拼接，所以是两倍）。</strong>示意图可以参考李宏毅老师的PPT：</p><p><img src="15.png" alt="ELMO词嵌入计算"></p><p>具体计算公式如下图所示：<br>$$<br>ELMO^{task}_k=\alpha^{task}\sum_{j=0}^LS_j^{task}h^{LM}_{k,j}<br>$$<br>对于第task句子的第k个词，其ELMO向量表达为：每个句子独特的权重$\alpha^{task}$乘以从0到$L$层每层的权重$S_j^{task}$乘以该层的激活值输出$h^{LM}_{k,j}$的总和。</p><p>这里，$h^{LM}_{k,j}$在第0层即为模型输入的Word2Vec词嵌入向量。第1到$L$层的$h^{LM}_{k,j}$为该位置前向和后向传播而来的激活值的拼接。</p><p>为什么需要对不同层的输出乘以不同的权重呢？因为研究人员发现：<strong>不同层的Embedding适用于不同的任务。 总体而言，ELMO模型每层学到的东西是不一样的，所以将他们叠加起来，对任务有较好的的提升</strong>。 试验结果表明：<strong>上层Embedding对语义理解更好，而下层对词性、词法理解更好</strong>。$S_j^{task}$可以根据不同的任务自己设定。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是常规的预训练语言模型Word2Vec、GloVe和ELMO的基本知识了，我在这里粗略的对他们进行了总结。事实上，目前最好的预训练模型是谷歌的BERT模型，我即将在下一篇博客介绍它的原理。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 预训练模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：神经网络序列模型</title>
      <link href="/2020/04/05/nlp-zi-xue-bi-ji-shen-jing-wang-luo-xu-lie-mo-xing/"/>
      <url>/2020/04/05/nlp-zi-xue-bi-ji-shen-jing-wang-luo-xu-lie-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>序列模型（Sequence Model）是深度学习最令人激动的领域之一。循环神经网络（Recurrent Neural Network, RNN）也已变革了语音识别（Speech Recognition）、自然语言处理（Natural Language Process, NLP）等领域。</p><p>本文是我在学习吴恩达深度学习课程中的序列模型一章的总结与思考，同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己对于该模型的理解，如有错误欢迎在评论区指出，非常感谢！</p><h2 id="从问题出发"><a href="#从问题出发" class="headerlink" title="从问题出发"></a>从问题出发</h2><p>与之前的讲解类似，我们在这里依旧围绕自然语言处理中的经典问题<strong>词性标注问题</strong>进行讨论和解释。</p><ul><li>给定一个句子X，输出句子中每一个单词对应的词性。</li></ul><p><img src="1.png" alt="词性标注任务"></p><h2 id="什么是序列模型"><a href="#什么是序列模型" class="headerlink" title="什么是序列模型"></a>什么是序列模型</h2><p>序列模型（Sequence Model）的相关知识我已经在之前的博客中有所介绍，常规机器学习方法中的隐马尔可夫模型和条件随机场模型都可以用来解决序列标注问题，它们其实就是一类序列模型。<strong>深度学习的序列模型近年来已经成为自然语言处理的最重要模型之一，主要包括循环神经网络（RNN）以及它的一些变体（LSTM、GRU等）。</strong></p><p>序列模型指的是<strong>模型的输入X或者输出Y是一个序列</strong>，例如：词性标注任务中，输入可以是连续的单词组成的句子，而输出可以是句子各单词的词性序列。</p><p>下面是一些序列模型适用的例子，可以看到，它不仅适用于自然语言处理的相关任务，还在计算机视觉、语音识别等领域应用广泛。</p><p><img src="1.jpg" alt="常用序列模型"></p><p>这些问题都可以通过有监督的学习（Supervised Learning），通过给定样本的特征向量X和标签Y进行训练。<strong>这几个例子的区别是，有些是X和Y都是序列数据，有些只有X或Y是序列数据，另外有些X和Y虽然都是序列数据，但序列的长度并不相等</strong>。 </p><p><img src="2.jpg" alt="序列模型的分类"></p><p>可以看到：</p><ul><li>语音识别、DNA序列分析和命名实体识别任务的输入X和输出Y都是序列数据，且序列长度相等。</li><li>机器翻译的输入X和输出Y都是序列数据，但序列长度不一定相等。因为一句英文文本经过翻译后，所得到的中文文本所含单词数不一定是一样的。</li><li>情感分析和视频行为识别的输入X是序列数据，而输出Y只有一个维度，即情感的类别或者行为的类别。</li><li>音乐生成任务的输出Y是序列数据（一段音乐），而输入X 可以是空集，也可以是个单一的整数，这个数可能指代你想要生成的音乐风格，也可能是你想要生成的那首曲子的头几个音符。 </li></ul><p>后面我们将知道，<strong>这些不同类别的序列模型都可以使用同一个深度学习模型来解决，那就是循环神经网络模型（RNN），我们只需要对它进行一些结构上的调整即可。</strong></p><h2 id="什么是循环神经网络"><a href="#什么是循环神经网络" class="headerlink" title="什么是循环神经网络"></a>什么是循环神经网络</h2><h3 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h3><p>首先，我们定义一些接下来的讲解中需要使用到的符号：</p><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">$x^{(i)\langle t \rangle}$</td><td align="center">第$i$个输入序列的第$t$个序列元素，即第$i$个输入句子的第$t$个单词</td></tr><tr><td align="center">$y^{(i)\langle t \rangle}$</td><td align="center">第$i$个输出序列的第$t$个序列元素，即第$i$个句子的词性标注结果的第$t$个词性</td></tr><tr><td align="center">$T_x^{(i)}$</td><td align="center">第$i$个输入序列的长度 ，即第$i$个句子的单词数目（每条数据的序列长度可以不一样）</td></tr><tr><td align="center">$T_y^{(i)}$</td><td align="center">第$i$个输出序列的长度 ，即第$i$个句子的词性数目（词性标注任务中：$T_x^{(i)}=T_y^{(i)}$）</td></tr></tbody></table><p>以词性标注任务为例，上述符号的含义如下图所示：</p><p><img src="2.png" alt="符号示意"></p><h3 id="如何表示词"><a href="#如何表示词" class="headerlink" title="如何表示词"></a>如何表示词</h3><p>接下来，我们需要考虑的问题是<strong>怎么表示输入序列（也就是句子）中的词</strong>。在这里，我们先使用一种最为简单的方法，也就是<strong>one-hot表示法</strong>，来表示句子中的词。这个方法无法捕捉词语本身丰富的语义信息。日后，我将介绍一些预训练的语言模型，如<strong>Word2Vec和Bert</strong>等，<strong>它们通过词嵌入（Word Embedding）的方法使用词嵌入向量表示词，捕捉了词语的含义和词间的关系，替换one-hot向量作为深度学习模型的输入，刷新了NLP中许多任务的最佳表现。</strong></p><p>one-hot表示法在我的对数线性模型博客中有所介绍，它是表示离散特征的一种方法。使用它来表示单词，我们需要进行以下几步：</p><ol><li>建立一个向量，包含常用的词汇，形成一个<strong>词汇表（vocabulary）</strong> 。词汇表的大小是人为设定的，这里，我们使用10,000个单词来构建我们的词汇表。 对于一般规模的商业应用来说30,000到50,000词大小的词典比较常见，但是100,000词的也不是没有，而且有些大型互联网公司会用百万词，甚至更大的词典。 </li><li>接下来，我们为单词建立one-hot向量，假如一个词在词汇表中的序号为1234，那么它的one-hot向量就是在1234行为1，其余行均为0的10000维列向量。</li><li>特别地，我们需要考虑<strong>未登录词、开始标记、结尾标记</strong>等情况。未登录词指的是不在词汇表中的单词，我们需要在词汇表添加标记\UNK来表示它们。此外，在构建语言模型、进行机器翻译等过程中，我们还需要使用到开始标记、结尾标记，它们表示的是句子的开始、结尾位置。例如，一旦语言模型生成了结尾标记，我们就可以认为句子生成完毕。我们在词汇表中添加\Start和\End来表示他们。</li></ol><p>下图是吴恩达老师课件中的例子：</p><p><img src="3.png" alt="词的one-hot表示"></p><h3 id="循环神经网络模型的基本结构"><a href="#循环神经网络模型的基本结构" class="headerlink" title="循环神经网络模型的基本结构"></a>循环神经网络模型的基本结构</h3><p>在介绍循环神经网络之前，我们尝试利用最简单的标准神经网络——反向传播神经网络（BPNN）来进行序列标注。我们可以将句子中的所有词的one-hot向量拼接作为标准神经网络的输入，经过若干隐藏层后输出词性标注结果，如下图所示：</p><p><img src="4.png" alt="标准神经网络"></p><p>但这个神经网络只适用于单个词的词性标注（分类问题），而不适用于整个句子的词性标注（序列标注，结构化分类问题），主要原因有以下几种：</p><ul><li>不同的句子的长度不一样，意味着<strong>BPNN的输入层和输出层维度需要不断地改变。</strong></li><li>更重要的是，<strong>BPNN无法共享从文本的不同位置上学到的特征。</strong> 比如网络学习到Harry在第一个位置可能是名词，但在其他位置却无法识别了。我们希望模型能够像卷积神经网络一样，在图像上某一个位置检测到的边缘特征能够应用到其他位置上。 </li><li>还有一点是<strong>模型的参数过于庞大，计算量太大</strong>。因为每个单词都是10000维的one-hot向量，输入层和输出层的单元太多。</li></ul><p><strong>为了解决BPNN在序列化标注问题中的缺陷，科学家们提出了一种神经网络的序列模型：循环神经网络模型（Recurrent Neural Network Model）</strong>。</p><p><img src="5.png" alt="循环神经网络"></p><p>其中，每个时间步（time step，也就是序列的每个状态）的RNN单元如下图所示：</p><p><img src="6.png" alt="基本的RNN单元"></p><p>可以看到：<strong>每个时间步的RNN单元，其实都是一个简单的单隐藏层BPNN。为了增强模型的表示能力，隐藏层使用tanh激活函数（Activation Function）增加非线性（这里有个疑问：为什么RNN中tanh比ReLU更常用呢）；为了计算当前时间步各词性的概率进行分类预测，输出层使用softmax激活函数进行概率归一化。</strong>上图右侧的公式即为RNN的前向传播公式（ Forward Propagation）。 </p><p>RNN的特别之处在于：当$x^{\langle t \rangle}$输入到当前时间步对应的RNN单元时，同时会将上一个时间步RNN单元的隐藏层的激活值$a^{\langle t-1 \rangle}$加入计算。特别的，第一层的激活值输入$a^{\langle 0 \rangle}$一般是定义为0向量。 也就是说，<strong>对于每一个时间步的预测，其输入信息不仅来自于当前序列元素$x^{\langle t \rangle}$，还间接来自于之前的所有序列元素（因为输入了$a^{\langle t-1 \rangle}$）</strong>。</p><p>上述RNN解决了BPNN用于序列标注的缺陷：</p><ul><li><strong>每个时间步的RNN单元，其输入、输出的维度都是一致的。</strong>例如我们使用单隐藏层RNN单元，隐藏层的神经元数目设为100，则$a^{\langle t-1 \rangle}$为100维列向量，$x^{\langle t \rangle}$为10000维的one-hot向量，每个RNN单元的输入固定为10100维，输出的维度与训练集中的词性数目相等。对于不同长度的输入序列，我们只需要修改RNN单元的个数即可。</li><li><strong>每一个时间步的RNN单元共享参数，即可以共享从文本的不同位置上学到的特征</strong>，也就是上面循环神经网络示意图中的三个参数矩阵$W_{aa}$,$W_{ax}$,$W_{ya}$和对应的偏差项（bias）。</li><li><strong>模型的参数量减少了。</strong>RNN中我们只有三组固定大小的参数，而原先的BPNN光是输入层和第一个隐藏层之间的全连接都需要大量参数，因为BPNN输入的每个词的one-hot向量之间不共享参数矩阵。</li></ul><p>需要注意的是，这里只是画了一个最基本的RNN，只有一个隐藏层，实际上，我们可以加大隐藏层数量，形成深度RNN（Deep RNN）。 对于标准CNN来说，可以有很多层，比如100个隐藏层，<strong>但对RNN来说3层就已经很深了</strong>，因为RNN还有很长的时间维度（temporal dimension），即便3层RNN的训练难度也很大。  </p><p><img src="7.png" alt="深度RNN"></p><h3 id="循环神经网络模型的反向传播"><a href="#循环神经网络模型的反向传播" class="headerlink" title="循环神经网络模型的反向传播"></a>循环神经网络模型的反向传播</h3><p>在上一节，我们已经介绍了RNN前向传播的基本流程。<strong>每一个时间步的RNN单元使用上一个时间步传来的激活值和当前序列元素的输入进行一次或多次全连接层运算，最后所得的激活值，一方面继续传给下一个时间步，另一方面输入softmax层计算当前序列元素的标注输出。</strong>具体过程如下图所示：</p><p><img src="8.png" alt="RNN前向传播示意图"></p><p>接下来，我们需要定义模型的损失函数，以便进行梯度下降优化，拟合出特征权重参数。</p><p>与常规的Softmax输出层的BPNN类似，我们在这里定义第$t$个时间步的损失函数为<strong>交叉熵损失函数</strong>（Cross Entropy Loss）：<br>$$<br>Loss^{\langle t \rangle}(\hat y^{(i)\langle t \rangle},y^{(i)\langle t \rangle})=- y^{(i)\langle t \rangle}log (\hat y^{(i)\langle t \rangle})<br>$$<br>整个序列的损失函数定义为<strong>各时间步损失函数之和</strong>：<br>$$<br>Loss(\hat y^{(i)},y^{(i)})=\sum_{t=1}^{T_x^{(i)}}Loss^{\langle t \rangle}(\hat y^{(i)\langle t \rangle},y^{(i)\langle t \rangle})<br>$$<br>接下来，便可以使用各种凸优化方法进行迭代计算，求解最优参数。假设我们使用梯度下降算法进行参数拟合，那么各参数的梯度反向传播计算如下所示：</p><p><img src="9.png" alt="RNN反向传播示意图"></p><p>上述反向传播可以自己推导一遍，加深印象。<strong>反向传播的推导并不复杂，它其实就是一种动态规划算法，状态转移方程中使用了求导的链式法则而已。</strong></p><p>具体的梯度计算公式<strong>（我推的不是最简形式，最简形式可以参考前向传播公式自己化简）</strong>如下：<br>$$<br>\frac{dLoss^{(i)}}{dW_{ya}}=\sum_{t=1}^{T_x^{(i)}}\frac{dLoss^{(i)\langle t \rangle}}{d \hat y^{(i)\langle t \rangle}}\frac{d \hat y^{(i)\langle t \rangle}}{dW_{ya}}……(1)<br>$$</p><p>$$<br>\frac{dLoss^{(i)}}{dW_{aa}}=\sum_{t=1}^{T_x^{(i)}}\sum_{k=1}^{t}\frac{dLoss^{(i)\langle t \rangle}}{d \hat y^{(i)\langle t \rangle}}\frac{d \hat y^{(i)\langle t \rangle}}{da^{\langle t \rangle}}(\prod_{j=k+1}^t\frac{da^{\langle j \rangle}}{da^{\langle j-1 \rangle}})\frac{da^{\langle k \rangle}}{dW_{aa}}……(2)<br>$$</p><p>$$<br>\frac{dLoss^{(i)}}{dW_{ax}}=\sum_{t=1}^{T_x^{(i)}}\sum_{k=1}^{t}\frac{dLoss^{(i)\langle t \rangle}}{d \hat y^{(i)\langle t \rangle}}\frac{d \hat y^{(i)\langle t \rangle}}{da^{\langle t \rangle}}(\prod_{j=k+1}^t\frac{da^{\langle j \rangle}}{da^{\langle j-1 \rangle}})\frac{da^{\langle k \rangle}}{dW_{aa}}……(2)<br>$$</p><h2 id="循环神经网络的不同架构"><a href="#循环神经网络的不同架构" class="headerlink" title="循环神经网络的不同架构"></a>循环神经网络的不同架构</h2><p>我们在之前提到了许多不同的序列任务都可以使用RNN来完成，我们只需要调整RNN的结构。自然语言处理中，主要的序列任务可以分为以下几类：</p><ol><li>One to many：一对多，如语言模型（Language Model），主要用于文本生成，如AI写诗等，我们通常只给出一个开头的字或词，让语言模型帮我们生成完整的句子序列。</li><li>Many to one：多对一，如文本分类，我们通常给出一个句子序列，让语言模型输出其类别。</li><li>Many to Many（$T_x=T_y$）：输入输出序列长度相等的多对多，如词性标注任务。</li><li>Many to Many（$T_x!=T_y$）：输入输出序列长度不相等的多对多，如机器翻译。</li></ol><p>在前面的几节，我们以词性标注为例，给出了输入输出序列长度相等的多对多RNN模型的基本结构，更多的结构如下图所示：</p><p><img src="10.png" alt="不同类型的RNN"></p><ul><li>左下角就是之前接触的最基本的RNN，Many to many并且$T_x=T_y$。</li><li>Many to one结构，与标准结构相比，<strong>将每个时间步的输出都去除，只保留最后一步的输出。</strong></li><li>One to one结构，就是标准神经网络。</li><li>One to many结构，<strong>仅在第一个时间步输入唯一的序列数据，接下来每一个时间步的输入都来自上一步的输出（Ngram语言模型）。</strong></li><li>Many to many并且$T_x!=T_y$。则将输入时间步和输出时间步完全拆分。前半部分称之为<strong>编码器（encoder）</strong>，后半部分称之为<strong>解码器（decoder）</strong>。例如，机器翻译任务中，前半部分将源文本进行编码，并将编码所得结果输入后半部分的解码器。后半部分的解码器其实就是一个语言模型，采用集束搜索（Beam Search）等方式选择出生成的最大概率序列作为翻译的结果。</li></ul><h2 id="双向循环神经网络"><a href="#双向循环神经网络" class="headerlink" title="双向循环神经网络"></a>双向循环神经网络</h2><p>在实际预测中，我们可能<strong>不仅需要当前时间步之前的信息，也需要当前时间步之后的信息。</strong>例如，一个单词被预测为名词，可能不仅与前一个单词是什么有关，也与后一个单词是什么有关。我们在之前提出的RNN架构，只能使用到之前时间步的信息，为了解决这个缺陷，我们可以使用双向循环神经网络（BRNN）。</p><p>我在这里借用吴恩达的PPT：</p><p><img src="11.png" alt="BRNN"></p><p>如上图所示，BRNN首先包含了前向RNN的基本架构，接着为每个时间步添加反向循环单元。最后，每个时间步的预测输出，需要同时考虑前向激活函数和反向激活函数。</p><p>BRNN中，每个时间步的预测输出要等所有序列扫描结束后才能输出。但这也造成了一个弱点，比如语音识别，需要等用户说完一整句才开始识别，所以真正的实时语音识别，会使用更为复杂的模块，而不是仅使用BRNN。 </p><h2 id="循环神经网络中的梯度消失和梯度爆炸"><a href="#循环神经网络中的梯度消失和梯度爆炸" class="headerlink" title="循环神经网络中的梯度消失和梯度爆炸"></a>循环神经网络中的梯度消失和梯度爆炸</h2><p>我们在之前已经介绍了RNN中的梯度反向传播计算，与其他深度学习的神经网络一样， <strong>RNN也面临梯度消失（vanishing gradients）和梯度爆炸（exploding gradients）</strong> 的问题，尤其是梯度消失的问题，更难解决。 </p><p>首先，我们来看RNN单元隐藏层中最为常用的激活函数tanh的函数曲线以及它的导数曲线：</p><p><img src="12.png" alt="tanh函数曲线和导数曲线"></p><p>可以看到，<strong>tanh的导数值取值范围位于闭区间[0,1]上</strong>。</p><p>在一个最基本的BPNN中，反向传播计算各参数的梯度时，需要使用到权重值、激活函数的导数以及预测值和真实值的误差。 如果我们使用正态分布初始化权重w，那么w都是0-1之间的小数，而tanh激活函数的导数也是0-1之间的数，<strong>经过反向传播的连乘后，随着相距的层数增加，连乘的次数也将被多，结果会变的很小，导致梯度消失</strong>。若我们初始化的w是很大的数，大到乘以激活函数的导数都大于1，那么经过多次连乘后，可能会导致求偏导的结果很大，形成<strong>梯度爆炸</strong>。 </p><p>事实上，tanh激活函数已经算比较好了，如果你使用sigmoid激活函数，那么它的导数值取值范围为[0,0.25]，更容易造成<strong>梯度消失问题</strong>。事实上，比较好的一种激活函数为ReLu激活函数（修正线性单元），它的导数值永远只有0或者1，所以可以很好地解决梯度消失问题。（疑问： RNN 中一个经典的问题是如何避免梯度消失。造成这个问题的一个很重要原因是采用了 tanh 作为激活函数，很容易造成梯度消失问题。所以为什么不换成ReLU呢？）</p><p>我们再回头看一看RNN的反向传播公式：</p><p><img src="9.png" alt="RNN反向传播示意图"></p><p>RNN 中的梯度消失/梯度爆炸和普通的 MLP 或者深层 CNN 中梯度消失/梯度爆炸的含义不一样。MLP/CNN 中不同的层有不同的参数，各是各的梯度；而 RNN 中同样的权重在各个时间步共享，最终的梯度为各个时间步的梯度的和。 所以，<strong>RNN 中总的梯度是不会消失的。即便因为连乘的原因梯度越传越弱，那也只是远距离的梯度消失，由于近距离的梯度不会消失，所有梯度之和便不会消失。RNN 所谓梯度消失的真正含义是，梯度被近距离梯度主导，导致模型难以学到远距离的依赖关系。（可以参考反向传播那一节的式（2）和式（3）理解，当k和t距离越远时，连乘的次数将越多）</strong> </p><p>梯度爆炸比较容易解决，我们可以使<strong>用梯度剪切（gradient clipping）</strong>，即梯度如果超过一定阈值，则缩放梯度。 </p><p><img src="13.png" alt="梯度剪切"></p><p><strong>相对而言，梯度消失问题很难解决，这导致后面的时间步的输出很难通过反向传播影响到前面的参数计算，从而使RNN难以捕捉长距离的依赖。而在自然语言处理任务中，长距离依赖通常是比较重要的，能够很大地影响模型的性能。</strong></p><p>为了解决梯度消失问题，科学家们在基本RNN的基础上提出了改进，<strong>将基本的RNN单元修改为使用了门（Gate)来控制记忆的长短期记忆单元（LSTM）和门控循环单元（GRU）</strong>。</p><h2 id="门控循环单元"><a href="#门控循环单元" class="headerlink" title="门控循环单元"></a>门控循环单元</h2><p>门控循环单元（Gated Recurrent Unit，GRU），<strong>是在基本RNN单元的基础上改进，帮助RNN缓解（无法解决）梯度消失问题，从而更好的捕捉长距离依赖</strong>。 它其实是长短期记忆单元的简化版，这里我们先介绍简单的版本。</p><p>我们以一个语言模型为例，假设我们需要构建一个语言模型根据训练文本自动生成句子，有如下两个句子：</p><blockquote><p>The ==cat==, which already ate …., ==was== full. The ==cats==, which already ate …., ==were== full. </p></blockquote><p> 中间是一个很长的从句，结尾处谓语（be）的形式要根据最开始的主语（cat）的单复数决定。这说明语言中经常会有<strong>长距离的依赖</strong>。但基本的RNN对这种问题的处理效果并不好，它无法捕捉到这种长距离依赖。 </p><p>首先，我们给出吴恩达老师画出的基本RNN单元（这里的$W_a$和$b_a$由原先的$W_{ax}$、$W_{aa}$和$b_{ax}$、$b_{aa}$堆叠而成，方便表述）： </p><p><img src="14.png" alt="基本RNN单元"></p><p>GRU经引入一个新的变量$c$，作为<strong>记忆细胞（Memory Cell）</strong>，其作用是提供一定比特的记忆，比如上例中记忆cat是单数还是负数。在时间$t$，记忆细胞的值记为$c^{\langle t \rangle}$。在GRU中，虽然输出的激活函数$a^{\langle t \rangle}$总是和$c^{\langle t \rangle}$相等，但我们还是提供两个标记区别，主要是为了和后面LSTM保持标记的统一性。 </p><p>接下来是GRU的公式：</p><p>首先是$\widetilde{c}$，代表将用于替换$c^{\langle t \rangle}$的候选（candidate）值：<br>$$<br>\widetilde{c}^{\langle t \rangle}=tanh(W_c[c^{\langle t-1 \rangle},x^{\langle t \rangle}]+b_c)<br>$$<br>接着，我们引入GRU的重要思想——门（Gate），我们用$Γ_u$表示 ：<br>$$<br>Γ_u=\sigma(W_u[c^{\langle t-1 \rangle},x^{\langle t \rangle}]+b_u)<br>$$<br>这里的$Γ_u$代表的是<strong>更新门（update Gate），激活函数$\sigma$使用sigmoid函数，从而使更新门的取值缩放到[0,1]，它表示的是当前时间步更新记忆细胞$c^{\langle t \rangle}$的程度</strong>，越接近1，表示更新的程度越大，具体公式如下：<br>$$<br>c^{\langle t \rangle}=Γ_u \times \widetilde{c}+(1-Γ_u) \times c^{\langle t-1 \rangle}<br>$$<br>上述公式究竟有什么用呢？ 前面说$\widetilde{c}$只是候选，是因为决定权在于$Γ_u$，$Γ_u$决定了什么时候去更新$c^{\langle t \rangle}$。对应上面的例子，<em><em>这个机制可能就是，从读取到cat开始，就一直在$c^{\langle t \rangle}$记录着主语是单数，直到遇到谓语was，$c^{\langle t \rangle}$认为就没必要再记录下去了，即开始更新$c^{\langle t \rangle}$。 </em></em></p><p><img src="15.png" alt="更新门的作用"></p><p> 把上述GRU单元的公式，它的结构用图表示如下： </p><p><img src="16.png" alt="基本GRU"></p><p>可以看到，<strong>GRU仅仅使用了一个门就实现了更新记忆细胞和遗忘记忆细胞，也就是让$(1-Γ_u)$控制遗忘的程度。而LSTM中使用了独立的遗忘门（forget gate）来控制遗忘，所以参数更多一些，训练起来也更慢。</strong></p><p>通过使用更新门，我们可以<strong>选择性的更新记忆细胞</strong>（在GRU中就是上一个时间步的隐藏层激活值输出，包含了前面所有时间步内的信息）。<em><em>当更新门$Γ_u$的值总为0时，相当于保持了记忆，在我们的例子中，就是在谓语was的时间步和主语cat的时间步之间开辟了一条直达的远距离路径。 梯度在这条路径上可以无损地传递，从而不会消失。这有些类似于CNN的 ResNet 中的跳跃连接（short cut）。 </em></em></p><p>此外，完整的GRU单元还设置了一个相关门 （Relevance Gate，也叫重置门Reset Gate） $Γ_r$，用于表示$\widetilde{c}$和$c^{\langle t -1 \rangle}$的相关性：<br>$$<br>Γ_r=\sigma(W_r[c^{\langle t-1 \rangle},x^{\langle t \rangle}]+b_r)<br>$$<br>候选值$\widetilde{c}$的计算公式修改为：<br>$$<br>\widetilde{c}^{\langle t \rangle}=tanh(W_c[Γ_r \times c^{\langle t-1 \rangle},x^{\langle t \rangle}]+b_c)<br>$$<br> 完整的GRU内部结构如下图所示：</p><p><img src="17.png" alt="完整GRU"></p><h2 id="长短期记忆单元"><a href="#长短期记忆单元" class="headerlink" title="长短期记忆单元"></a>长短期记忆单元</h2><p><strong>长短期记忆单元（Long Short Term Memory）可以看作是门控循环单元GRU的复杂版</strong>。事实上， 在深度学习的历史上，<strong>LSTM</strong>也是更早出现的，而<strong>GRU</strong>是最近才发明出来的，它可能源于<strong>Pavia</strong>在更加复杂的<strong>LSTM</strong>模型中做出的简化。 </p><p>以下为GRU和LSTM二者的公式对比：</p><p><img src="18.png" alt="GRU和LSTM"></p><p>可以看到，GRU的主要特点在于：</p><ul><li><p>$a^{\langle t \rangle}$总是和$c^{\langle t \rangle}$相等。</p></li><li><p>使用了两个门，即更新门$Γ_u$和相关门$Γ_r$。</p></li></ul><p>而LSTM相对于GRU的变化在于：</p><ul><li>$a^{\langle t \rangle}$和$c^{\langle t \rangle}$不相等。</li><li>使用了三个门：<ul><li>去掉了用于计算候选值$\widetilde{c}$的相关门$Γ_r$。</li><li>增加了用于控制遗忘的遗忘门（Forget Gate）$Γ_f$，替换了GRU中的$1-Γ_r$。</li><li>增加了用于计算$a^{\langle t \rangle}$的输出门$Γ_o$。</li></ul></li></ul><p>完整的LSTM单元如下图所示：</p><p><img src="19.png" alt="完整LSTM单元"></p><p>完整的LSTM网络如下图所示：</p><p><img src="20.png" alt="完整LSTM网络"></p><p>可以看到，LSTM网络中，梯度的传播相较于基本RNN多了许多路径。其中，<strong>有一条贯穿$c^{\langle t \rangle}$的”高速公路“</strong>。与CNN的 ResNet 中的跳跃连接（short cut）类似，在这条路径上，<strong>假设遗忘门$Γ_f$保持等于1，那么梯度将无损地在需要进行远距离依赖的时间步间传输</strong>。 由于总的远距离梯度 = 各条路径的远距离梯度之和，即便其他远距离路径梯度消失了，只要保证有一条远距离路径梯度不消失，总的远距离梯度就不会消失（正常梯度 + 消失梯度 = 正常梯度）。因此 LSTM 通过改善<strong>一条路径</strong>上的梯度问题拯救了<strong>总体的远距离梯度</strong>。 </p><p><strong>另外需要强调的是</strong>，LSTM除了在结构上天然地克服了梯度消失的问题，更重要的是具有更多的参数来控制模型；通过四倍于RNN的参数量，可以更加精细地预测时间序列变量。 </p><h2 id="GRU与LSTM的比较"><a href="#GRU与LSTM的比较" class="headerlink" title="GRU与LSTM的比较"></a>GRU与LSTM的比较</h2><p>吴恩达老师的原话：</p><blockquote><p><strong>GRU</strong>的优点是这是个更加简单的模型，所以更容易创建一个更大的网络，而且它只有两个门，在计算性上也运行得更快，然后它可以扩大模型的规模。</p></blockquote><blockquote><p>但是<strong>LSTM</strong>更加强大和灵活，因为它有三个门而不是两个。如果你想选一个使用，我认为<strong>LSTM</strong>在历史进程上是个更优先的选择，所以如果你必须选一个，我感觉今天大部分的人还是会把<strong>LSTM</strong>作为默认的选择来尝试。虽然我认为最近几年<strong>GRU</strong>获得了很多支持，而且我感觉越来越多的团队也正在使用<strong>GRU</strong>，因为它更加简单，而且还效果还不错，它更容易适应规模更加大的问题。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我对循环神经网络（RNN）进行学习时的总结了。RNN是NLP深度学习最重要的模型之一，许多开创性的工作就是在它的基础上完成的，包括我的大创课题上下位网络构建的SOTA目前也是由LSTM保持着。接下来，我将介绍常见的预训练模型的基本原理（word2vec，bert等），未来还将介绍NLP深度学习中的Attention机制以及常用的优化、调参算法。</p><h2 id="参考文献（部分）"><a href="#参考文献（部分）" class="headerlink" title="参考文献（部分）"></a>参考文献（部分）</h2><ul><li><p><a href="http://www.ai-start.com/dl2017/html/lesson5-week1.html" target="_blank" rel="noopener">吴恩达深度学习课件</a></p></li><li><p><a href="http://dl-notes.imshuai.com/#/c5w1?id=_110-long-short-term-memory-lstm" target="_blank" rel="noopener">吴恩达深度学习笔记</a></p></li><li><p>台大李宏毅教授的深度学习视频 </p></li><li><p><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks</a> </p></li><li><p><a href="https://www.researchgate.net/publication/13853244_Long_Short-term_Memory" target="_blank" rel="noopener">Hochreiter &amp; Schmidhuber 1997. Long short-term memory</a> </p></li><li><p><a href="https://arxiv.org/pdf/1409.1259.pdf" target="_blank" rel="noopener">Cho et al., 2014. On the properties of neural machine translation: Encoder-decoder approaches</a></p></li><li><p><a href="https://arxiv.org/pdf/1412.3555.pdf" target="_blank" rel="noopener">Chung et al., 2014. Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling</a> </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：条件随机场模型</title>
      <link href="/2020/04/04/nlp-zi-xue-bi-ji-tiao-jian-sui-ji-chang-mo-xing/"/>
      <url>/2020/04/04/nlp-zi-xue-bi-ji-tiao-jian-sui-ji-chang-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是我在学习苏州大学李正华老师的中文信息处理课程（<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">中文信息处理（Chinese Information Processing）Course Resources</a>）时，对于条件随机场模型（Condition Random Field Model）的一些个人见解和思考，同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己对于该模型的理解，如有错误欢迎在评论区指出，非常感谢！</p><h2 id="从问题出发"><a href="#从问题出发" class="headerlink" title="从问题出发"></a>从问题出发</h2><p>与之前的讲解类似，我们在这里依旧围绕自然语言处理中的经典问题<strong>词性标注问题</strong>进行讨论和解释。</p><ul><li>给定一个句子X，输出句子中每一个单词对应的词性。</li></ul><p><img src="1.png" alt="词性标注任务"></p><h2 id="条件随机场模型的由来"><a href="#条件随机场模型的由来" class="headerlink" title="条件随机场模型的由来"></a>条件随机场模型的由来</h2><p>我在之前已经讨论过了隐马尔可夫模型（HMM）和对数线性模型（Log-Linear Model），我觉得，有了之前的过程基础，我们接下来对于条件随机场模型的学习将变得非常轻松，因为<strong>实际上条件随机场模型只是隐马尔可夫模型和对数线性模型的结合。</strong>当我们打好了基础，剩下来的只有细微的调整和修补。</p><p>首先，我们来看下面这张图，它阐述了我们要学习的条件随机场模型和之前的两个模型的关系。<strong>顺便说一下，本文讨论的条件随机场模型都是线性链条件随机场（ Linear-chain CRF），这是NLP中常用的CRF形式，此外还有全连接条件随机场（Generl Graph CRF），一般用在CV中，这里就不多叙述。</strong></p><p><img src="2.png" alt="HMM、Log-Linear Model、LC-CRF的关系"></p><p>这张图将三者的关系描述的很清楚。你可以这样去理解LC-CRF的由来：</p><ul><li>LC-CRF可以看作是<strong>分类模型Log-Linear Model加入了HMM中的转移特征（齐次马尔可夫假设）从而转变成为的结构化分类模型</strong>，从而可以进行Seq2Seq的标注。也就是说，对于样本的预测不再是相互独立的，对于某个样本的预测需要考虑前面（Forward）或者后面（Backward）样本预测的结果。</li><li>LC-CRF也可以看作是<strong>生成模型HMM中引入了Log-Linear Model中的自定义特征函数，把它变成了一个判别模型，解决了HMM的输出独立性假设问题和有限元马尔可夫假设问题</strong>， 不仅可以表达观测之间的依赖，还可表示当前观测与前后多个状态之间的复杂依赖。 </li></ul><p>LC-CRF本质上结合了HMM和Log-Linear Model的优点，从而效果更好，更加强大。也就是说，<strong>LC-CRF是Log-Linear Model的序列扩展，是Global Log-Linear Model！</strong></p><p>其实介绍到这里，我觉得CRF已经没有多少要说得了，如果你深入地理解了对数线性模型和隐马尔可夫模型，那么CRF的训练和预测过程你一定能够轻松学会。</p><h2 id="LC-CRF的训练"><a href="#LC-CRF的训练" class="headerlink" title="LC-CRF的训练"></a>LC-CRF的训练</h2><p><strong>LC-CRF是一个判别模型</strong>，所以它的训练过程和Log-Linear Model非常类似。</p><h3 id="构建特征空间"><a href="#构建特征空间" class="headerlink" title="构建特征空间"></a>构建特征空间</h3><p>与Log-Linear Model类似，首先，我们需要为LC-CRF构建<strong>特征空间（Feature Space）</strong>。构建特征空间的方法也与之前类似，<strong>我们采用预先定义好的特征模板（Feature Template）对训练集中的每一个词进行特征抽取</strong>。这里，我们使用如下的特征模板：</p><p><img src="3.png" alt="LC-CRF的特征模板"></p><p>你可能会发现：02-15号特征和我们之前在Log-Linear Model中定义的特征模板是一致。这些特征我们称之为<strong>Unigram特征</strong>，也就是一元特征，包含了词特征、字特征，例如当前词是什么，上一个词是什么，当前词的前缀后缀等。它考虑的是当前词的特征信息，也就是说只考虑了一元隐状态。</p><p>需要特别注意，<strong>我们新加入了01号特征，考虑了当前词性和上一个词性的关系（二元隐状态），这称为Bigram特征，也就是二元特征。</strong>正是因为有了二元特征，我们才可以考虑不同时间步输出之间的关系，将Log-Linear Model序列化，并且使用Viterbi算法进行全局动态规划解码。<strong>二元特征的定义符合了HMM中的一阶马尔可夫假设，其实就是HMM模型中的状态转移矩阵</strong>。下面这张图简单地描述了Unigram特征和Bigram特征。</p><p><img src="4.png" alt="Unigram特征和Bigram特征"></p><p>与Log-Linear Model类似，这里的特征使用One-hot表示，特征抽取可以进行“段+偏移”优化。具体细节可以参考我的对数线性模型博客。</p><h3 id="定义假设函数"><a href="#定义假设函数" class="headerlink" title="定义假设函数"></a>定义假设函数</h3><p>LC-CRF与Log-Linear Model的假设函数并不相同，<strong>因为它是序列模型，所以输出的是预测的整个序列的概率。</strong></p><p>我们先定义一个长度为$n$的句子$S$标注为词性序列$Y$的分值为：<br>$$<br>Score(S,Y)=\sum_{i=1}^{n}w_i^T x_i<br>$$<br>其中，$w_i$是这个句子第$i$个词的特征权重向量，$x_i$是它的特征向量。这里它们都是列向量，需要对$w_i$进行转置处理，然后进行矩阵相乘。将所有词的分值进行相加，得到的是整个句子的总分。</p><p>如果我们对这个句子的所有可能的词性序列求解最大分值，并将最大分值的词性序列作为当前句子的标注结果，你会发现这种做法其实也是Work的。<strong>这其实就是将我们之前提到的Linear Model的全局化，也就是Global Linear Model。</strong>有关线性模型的更多知识可以参考我的上一篇博客，训练的方法依然可以使用我们在Linear Model的在线学习法。</p><p><strong>为了将Global Linear Model转化为Global Log-Linear Model，也就是我们的LC-CRF模型，我们还需要对所得的分值Score进行Softmax函数运算，从而将所得的分值归一化为概率Probability</strong>。从线性模型到对数线性模型的转化也可以看我的上一篇博客。这里，我们使用Softmax函数，得到长度为$n$的句子$S$标注为词性序列$Y$的条件概率，也就是我们模型的假设函数为：<br>$$<br>P(Y|S)=\frac{e^{Score(S,Y)}}{\sum_{Y^{‘}\in{T^n}}e^{Score(S,Y^{‘})}}<br>$$<br>其中，$T^n$为当前句子所有可能的词性标注序列集合。<strong>可以看到，我们使用一个Softmax指数模型来表示整个标签序列的联合概率, 这个概率条件依赖于给定的完整观察序列。 这是一种全局归一化的方式。</strong></p><p>特别地，HMM模型和Log-Linear Model的结合其实还有另外一种方式，即<strong>最大熵隐马尔可夫模型（MEMM）</strong>，这个模型和LC-CRF非常类似，唯一的区别在于，<strong>它的概率归一化的时刻在于每一个时间步（Local归一化），而LC-CRF的概率归一化时刻在整个序列计算完成后（全局归一化）。</strong>虽然MEMM也是Work的，但它存在着<strong>标注偏置</strong>的缺陷，导致其无法在维特比算法的解码过程中确保全局最优。具体为什么会这样，可以看<a href="https://blog.csdn.net/yzxnuaa/article/details/79626265" target="_blank" rel="noopener">这篇博客</a>，我就不过多的进行说明。</p><h3 id="参数训练"><a href="#参数训练" class="headerlink" title="参数训练"></a>参数训练</h3><p>与Log-Linear Model一样，我们对于LC-CRF的参数拟合依然是可以通过<strong>梯度下降法</strong>进行的。这里，我们选用<strong>交叉熵损失函数</strong>作为优化的目标函数，从最大熵模型和极大似然估计法推导出交叉熵损失函数的过程可以参考我的上一篇博客。</p><p>各权重梯度的求解需要使用到前向后向算法的合作，具体计算过程的推导大家可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/12-crf/main.pdf" target="_blank" rel="noopener">李老师的讲义</a>，这里就不进行叙述了，可以自己动手推导一遍。<strong>特别注意的是，当你对Softmax的交叉熵损失函数求$w_i$的梯度时，条件概率$P(Y|S)$的分母上也含有$w_i$，不能忘记求偏导，这导致我一开始怎么也无法推导出正确的梯度。</strong></p><p>至于梯度下降过程中的细节，如正则化、学习率下降等，均在我的上一篇博客中有说明。大家可以动手自己实践一下，仅需要在Log-Linear Model的基础上进行一些修改即可。</p><h2 id="LC-CRF的预测"><a href="#LC-CRF的预测" class="headerlink" title="LC-CRF的预测"></a>LC-CRF的预测</h2><p>LC-CRF跟HMM一样，一般预测用的都是<strong>维特比（Viterbi）算法</strong>。这个算法是一个简单的动态规划，在我的HMM博客有详细的说明。</p><p><strong>需要注意的是，LC-CRF是全局归一化，即分值和概率的转化放在最后一步进行，所以在维特比算法的动态规划状态矩阵中计算的是当前词性序列的累计得分，使用的是累加。而在HMM中，状态矩阵中计算的是概率，使用的是发射概率和转移概率的累乘。</strong></p><p><img src="5.png" alt="维特比算法示意图"></p><h2 id="HMM和CRF的关系"><a href="#HMM和CRF的关系" class="headerlink" title="HMM和CRF的关系"></a>HMM和CRF的关系</h2><p><strong>与HMM相比，CRF其实是它的泛化，添加了不受限制的特征模板，从而可以不仅仅局限在HMM的观测独立性假设和齐次马尔可夫假设上。</strong>如果你对HMM的核心概率公式，即已知观测序列$s$，求解生成观测序列$l$的概率的概率公式（HMM是生成模型，这里是联合概率），求对数后，将得到：<br>$$<br>logP(l,s)=log(P(l_0)\prod_{i=1}^nP(l_i|l_{i-1})P(s_i|l_i))<br>\\\\=logP(l_0)+\sum_{i=1}^nlogP(l_i|l_{i-1})+\sum_{i=1}^nlogP(s_i|l_i)<br>$$<br> 我们可以将HMM的这个式子和我们的CRF的分值计算公式进行对比：<br>$$<br>Score(l,s)=\sum_{i=1}^{n}\sum_{j=1}^{m}\lambda_jf_j(s,i,l_i,l_{i-1})<br>$$</p><p>其中，$f_j$表示第$j$个特征，$\lambda_j$表示它的特征权重。</p><p>由于CRF需要使用Bigram特征，这里的特征还需要考虑前面一个隐状态$l_{i-1}$是什么。</p><p>由于$f_j$的取值总为0或1，我们可以发现： <strong>如果我们把第一个HMM式子中的log形式的概率看做是第二个CRF式子中的特征函数的权重的话，其实，CRF和HMM具有相同的形式。换句话说，我们可以构造一个CRF，使它与HMM的对数形式相同 ，只需要将特征模板限定为初始特征、转移特征和发射特征。也就是说 ，每一个HMM模型其实都等价于某个CRF！</strong></p><p> 但是，CRF要比HMM更加强大，原因主要有两点： </p><ul><li><strong>CRF可以定义数量更多，种类更丰富的特征函数</strong>。  HMM模型具有天然具有局部性，就是说，在HMM模型中，当前的单词只依赖于当前的标签，当前的标签只依赖于前一个标签。这样的局部性限制了HMM只能定义相应类型的特征函数，而CRF的特征模板不受限制，可以考虑各种类型的特征。</li><li><strong>CRF可以使用任意的特征权重</strong> 。HMM的特征权重是对数概率，也就是说它必须取负值，也只能取负值。而且既然是概率那么它一定要满足概率完备性条件才可以，但是CRF的特征权重你是可以随意取值的。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我对NLP中的CRF模型的学习笔记，由于很多知识在前面的两篇博客——HMM模型和Log-Linear模型中已经讲解过，所以本文写的比较简略。但只要认真的学习了前面两个模型，其实CRF已经迎刃而解了。</p><p>接下来，我将继续学习NLP的相关知识，并尝试练习使用深度学习模型。</p><h2 id="参考资料（部分）"><a href="#参考资料（部分）" class="headerlink" title="参考资料（部分）"></a>参考资料（部分）</h2><p><a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">苏州大学李正华老师的课件</a></p><p><a href="https://www.jianshu.com/p/55755fc649b1" target="_blank" rel="noopener">如何轻松愉快地理解条件随机场（CRF）？</a></p><p><a href="https://www.zhihu.com/question/35866596" target="_blank" rel="noopener">如何用简单易懂的例子解释条件随机场（CRF）模型？它和HMM有什么区别？</a></p><p><a href="https://www.cnblogs.com/kerwins-AC/p/9584862.html" target="_blank" rel="noopener">条件随机场</a></p><p>李航老师《统计学习方法》</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer题解</title>
      <link href="/2020/03/21/jian-zhi-offer-ti-jie/"/>
      <url>/2020/03/21/jian-zhi-offer-ti-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近随便投了字节跳动的暑期实习生，没想到简历过关了，4.12日先去笔试。考虑到Leetcode上面的题目比较多，决定先把《剑指Offer》上的所有题目都刷一遍。</p><h2 id="1-数组中重复的数字"><a href="#1-数组中重复的数字" class="headerlink" title="1. 数组中重复的数字"></a>1. <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中重复的数字</a></h2><p>思路：使用<strong>哈希表或者集合</strong>等数据结构，遍历数组中的数字，当数字没有出现在集合中时，将其加入集合，当数字已经出现在集合中时，说明其重复了，直接返回。</p><p>时间复杂度：$O(n)$，n为数组大小。</p><p>空间复杂度:  $O(n)$</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dic<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-二维数组中的查找"><a href="#2-二维数组中的查找" class="headerlink" title="2.  二维数组中的查找"></a>2. <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener"> 二维数组中的查找</a></h2><p>思路：有些类似于<strong>二叉查找树</strong>的思路，从右上角开始搜索，左侧的数字都比当前数小，下方的数字都比当前数大。如果当前数小于目标，则向下移动一格，大于目标，则向左移动一格，等于目标返回True，超出边界时需要返回False。</p><p>时间复杂度：$O(m+n)$，这是从右上角搜索到左下角的最坏情况，m为行数，n为列数。</p><p>空间复杂度:  $O(1)$</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findNumberIn2DArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> matrix<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            row<span class="token operator">=</span><span class="token number">0</span>            col<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>                    col<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">elif</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>                    row<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-替换空格"><a href="#3-替换空格" class="headerlink" title="3.替换空格"></a>3.<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">替换空格</a></h2><p>思路：将字符串转换为字符列表进行遍历替换即可。（也可以直接调用字符串的replace函数）</p><p><strong>注意：Python中常见的不可变类型有数字、字符串和元组，可变类型有列表和字典。区别主要是： 当不可变数据类型的对应变量的值发生了改变，那么它对应的内存地址也会发生改变。 而可变数据类型可以在不改变内存地址的前提下修改对应内存的值。所以，如果我们要原地修改字符串的内容，需要将其转换为列表。</strong></p><p>时间复杂度：$O(n)$，n为原字符串长度。</p><p>空间复杂度:  $O(m)$，m为替换空格后字符串长度。</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">replaceSpace</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        stLi<span class="token operator">=</span>list<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>stLi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> stLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">' '</span><span class="token punctuation">:</span>                stLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'%20'</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>stLi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-从尾到头打印链表"><a href="#4-从尾到头打印链表" class="headerlink" title="4.从尾到头打印链表"></a>4.<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">从尾到头打印链表</a></h2><p>思路1：递归法，递归结束条件为当前指针为None，利用递归的机制进行求解。<strong>（非尾递归，会先将当前层递归函数保存在栈空间中，等待下层递归函数执行完返回）</strong></p><p>时间复杂度：$O(n)$，n为链表长度。</p><p>空间复杂度:  $O(n)$。</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reversePrint</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>reversePrint<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">[</span>head<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token keyword">if</span> head<span class="token operator">!=</span>None <span class="token keyword">else</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：值 A if 条件语句 else 值B，如果条件满足则值A，否则值B。</p><p>思路2：<strong>辅助栈</strong>，利用栈的性质（先进后出）求解。</p><p>时间复杂度：$O(n)$，n为链表长度。</p><p>空间复杂度:  $O(n)$。</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reversePrint</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        p<span class="token operator">=</span>head        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> result<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-重建二叉树"><a href="#5-重建二叉树" class="headerlink" title="5. 重建二叉树"></a>5. <a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">重建二叉树</a></h2><p>思路：我们生成二叉树主要有两种做法，一是利用标记了空节点的层次遍历序列，二是利用前序（后序）遍历加上中序遍历。后者的具体做法是<strong>分治法</strong>：</p><ul><li><strong>前序遍历的第 1 个结点一定是二叉树的根结点</strong>；</li><li>在中序遍历中，根结点把中序遍历序列分成了两个部分，左边部分构成了二叉树的根结点的左子树，右边部分构成了二叉树的根结点的右子树。</li><li>查找根结点在中序遍历序列中的位置，可以遍历，也可以在一开始就记录下来。</li></ul><p><img src="5.png" alt="分治法"></p><p>通过分治，我们可以递归求解。</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>preL<span class="token punctuation">,</span>preR<span class="token punctuation">,</span>inL<span class="token punctuation">,</span>inR<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> preL<span class="token operator">></span>preR <span class="token operator">or</span> inL<span class="token operator">></span>inR<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当前子树为空</span>                <span class="token keyword">return</span> None            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preL<span class="token punctuation">]</span><span class="token punctuation">)</span>            inPos<span class="token operator">=</span>inorder<span class="token punctuation">.</span>index<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            leftLen<span class="token operator">=</span>inPos<span class="token operator">-</span>inL            root<span class="token punctuation">.</span>left<span class="token operator">=</span>build<span class="token punctuation">(</span>preL<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>preL<span class="token operator">+</span>leftLen<span class="token punctuation">,</span>inL<span class="token punctuation">,</span>inPos<span class="token number">-1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#分治，划分左子树和右子树的序列</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>build<span class="token punctuation">(</span>preL<span class="token operator">+</span>leftLen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>preR<span class="token punctuation">,</span>inPos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>inR<span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token keyword">if</span> preorder<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> build<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>preorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>inorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-用两个栈实现队列"><a href="#6-用两个栈实现队列" class="headerlink" title="6. 用两个栈实现队列"></a>6. <a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">用两个栈实现队列</a></h2><p>思路： 我们可以设计栈A用于入队操作，栈B用于将元素倒序，从而实现出队操作。 </p><ul><li><p><strong>加入队尾 <code>appendTail()</code>函数：</strong> 将数字 <code>val</code> 加入栈 <code>A</code> 即可。</p></li><li><p>删除队首<code>deleteHead()</code>函数：</p><p>有以下三种情况。</p><ol><li><strong>当栈 <code>B</code> 不为空：</strong> <code>B</code>中仍有已完成倒序的元素，因此直接返回 <code>B</code> 的栈顶元素。</li><li><strong>否则，当 <code>A</code> 为空：</strong> 即两个栈都为空，无元素，因此返回 -1 。</li><li><strong>否则：</strong> 将栈 <code>A</code> 元素全部转移至栈 <code>B</code> 中，实现元素倒序，并返回栈 <code>B</code> 的栈顶元素。</li></ol></li></ul><p>时间复杂度：入队$O(1)$，出队$O(n)$</p><p>空间复杂度：$O(n)$</p><p>这个思路只需要保证入队、出队操作的正确返回即可，不需要维护一个真正的用栈模拟的队列。还可以用栈A模拟队列，辅助栈B用于模拟队列的入队或者出队操作，不过那样会比较慢，因为每一次使用辅助栈B都会涉及倒序操作。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">CQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>A<span class="token punctuation">,</span> self<span class="token punctuation">.</span>B <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">appendTail</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>A<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">deleteHead</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>B<span class="token punctuation">:</span>             <span class="token keyword">return</span> self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>A<span class="token punctuation">:</span>             <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>A<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>A<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7.斐波那契数列"></a>7.<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">斐波那契数列</a></h2><p>思路：经典题，<strong>动态规划</strong>求解，相较于递归节约时间和空间。</p><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        fib<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            fib<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>fib<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>fib<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">1000000007</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#实际上python只需要在return时取余即可，这里是向java等语言看齐，防止越界</span>        <span class="token keyword">return</span> fib<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事实上，这道题的DP状态矩阵还可以进一步优化，仅<strong>使用两个变量存储</strong>，降为$O(1)$。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a <span class="token operator">+</span> b        <span class="token keyword">return</span> a <span class="token operator">%</span> <span class="token number">1000000007</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-青蛙跳台阶问题"><a href="#8-青蛙跳台阶问题" class="headerlink" title="8.青蛙跳台阶问题"></a>8.<a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">青蛙跳台阶问题</a></h2><p>思路：依然是<strong>动态规划</strong>问题，青蛙跳到第1级台阶只有一个路径，第2级台阶只有两个路径，第n级台阶的路径为跳到第n-2级台阶的路径数加上跳到第n-1级台阶的路径数之和。    </p><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numWays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        a<span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span>        <span class="token keyword">if</span> n<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> a        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            a<span class="token punctuation">,</span>b<span class="token operator">=</span>b<span class="token punctuation">,</span>a<span class="token operator">+</span>b        <span class="token keyword">return</span> b<span class="token operator">%</span><span class="token number">1000000007</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-旋转数组的最小数字"><a href="#9-旋转数组的最小数字" class="headerlink" title="9.旋转数组的最小数字"></a>9.<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">旋转数组的最小数字</a></h2><p>思路：这种类型的题目，如果我们直接使用线性级别的时间复杂度肯定能做，但没啥意思。查找、排序的题目如果想达到对数级别的时间复杂度，一定要尝试<strong>二分法（减治思想）</strong>。</p><ul><li>本题的思路是通过二分法减治<strong>排除必不可能是最小值的元素</strong>。<ul><li>首先，与常规二分法一样，我们设置两个指针left和right指向数组的左右边界。mid=（left+right）//2</li><li>我们比较numbers[mid]与numbers[right]的值，分为以下三种情况:<ul><li>numbers[mid]&lt;numbers[right]：根据旋转数组的性质，说明从numbers[mid]到numbers[right]必然是升序序列，所以mid+1到right的数字必然大于mid位置的数字，所以它们都不可能是最小值，可以排除，进入[left，mid]闭区间查找最小值。</li><li>numbers[mid]&gt;numbers[right]：根据旋转数组的性质，说明旋转点必然在numbers[mid+1]到numbers[right]之间，进入[mid+1，right]闭区间查找最小值。</li><li>numbers[mid]==numbers[right]：此时，我们不知道最小值在[left，mid]闭区间还是[mid+1，right]闭区间中， 例 [1, 0, 1, 1, 1]中，最小值在[left，mid]，例[1, 1, 1, 0, 1]中，最小值在[mid+1，right]中。虽然我们无法进行二分减治，但是此时我们确定了两个相等的数，并且我们知道删除其中一个不影响最终寻找最小值，我们可以将right减1，缩小区间，再次尝试二分。</li><li>迭代二分后，最终left将超过right，此时left的位置即为最小值的位置。</li></ul></li></ul></li><li>为什么不比较numbers[mid]与numbers[left]的值？<ul><li>例子[1,2,3,4,5]中，numbers[mid]&gt;numbers[left]，最小值在[left，mid]中，但在例子[3,4,5,1,2]中，numbers[mid]&gt;numbers[left]，最小值却在[mid+1，right]中，考虑到未旋转的特殊情况，我们不能使用中间数与首个数比较。</li></ul></li></ul><p>时间复杂度：$O(logn)$</p><p>空间复杂度：$O(1)$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> numbers<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#二分查找这里是小于等于，因为二分查找需要比较最后一个长度为1的区间的值与目标是否相等，这里仅需找到最后一个长度为1的区间即可</span>            mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">if</span> numbers<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>numbers<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">elif</span> numbers<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>numbers<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                right<span class="token operator">=</span>mid            <span class="token keyword">else</span><span class="token punctuation">:</span>                right<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> numbers<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-矩阵中的路径"><a href="#10-矩阵中的路径" class="headerlink" title="10.矩阵中的路径"></a>10.<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">矩阵中的路径</a></h2><p>思路：这类走迷宫问题，我们首先很容易想到的就是<strong>DFS+回溯算法</strong>。类似的题目还有解数独、全排列、皇后问题等。基本的思路就是尝试从矩阵中的每个位置出发，如果当前位置的字符等于目标字符串的首字符，那么继续向左、右、上、下四个方向尝试匹配，目前字符串的指针加1。如果目标字符串的指针到达其长度，说明已经完成匹配，可以返回True。特别地，在这里，同一位置的字符不能重复选择，我们需要设置一个visited矩阵。</p><p><img src="10.png" alt="复杂度分析"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exist</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> board<span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index<span class="token operator">==</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span>word<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">and</span> visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">:</span>                    visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                    res<span class="token operator">=</span>backtrack<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token number">-1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token number">-1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#这里不能直接return，否则无法回溯</span>                    visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">False</span><span class="token comment" spellcheck="true">#回溯已访问矩阵</span>                    <span class="token keyword">return</span> res        <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">##尝试每个位置出发</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PS：这里的visited矩阵可以不用开，直接原地修改board矩阵的元素为False即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exist</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index<span class="token operator">==</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span>word<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>                    tmp<span class="token punctuation">,</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token boolean">False</span>                    res<span class="token operator">=</span>backtrack<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token number">-1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token number">-1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                    board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span>tmp                    <span class="token keyword">return</span> res        <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-机器人的运动范围"><a href="#11-机器人的运动范围" class="headerlink" title="11. 机器人的运动范围"></a>11.<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener"> 机器人的运动范围</a></h2><p>思路：DFS，有点类似于二叉树的节点数统计。判断当前位置是否可以到达的条件是：</p><ol><li>没有越界；</li><li>数位和小于k；</li><li>未访问过。</li></ol><p>一旦该位置不可到达，立刻返回0；如果该位置可达，那么返回1+dfs(row+1,col)+dfs(row,col+1)，表示当前节点可达且继续向右、下方遍历。</p><p>注意，此处机器人虽然可以向上、下、左、右进行遍历，但是我们发现一个地图上所有的格子都可以通过向右走和向下走到达，那么为了防止重复的判断，我们只向下和向右走。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">movingCount</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;</span>m <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;</span>n <span class="token operator">and</span> <span class="token punctuation">(</span>row<span class="token operator">//</span><span class="token number">10</span><span class="token operator">+</span>row<span class="token operator">%</span><span class="token number">10</span><span class="token operator">+</span>col<span class="token operator">//</span><span class="token number">10</span><span class="token operator">+</span>col<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span>k <span class="token operator">and</span> visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">:</span>                visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>dfs<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token operator">+</span>dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：$O(mn)$</p><p>空间复杂度：$O(mn)$</p><h2 id="12-剪绳子"><a href="#12-剪绳子" class="headerlink" title="12.剪绳子"></a>12.<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">剪绳子</a></h2><p>思路：动态规划，dp[i]为整数i可以拆分得到的最大乘积。转移方程为：从1到i-1遍历分解因子j，选择分解后乘积最大的结果，作为当前的状态值。需要注意的是max(dp[i-j],i-j)这一步，因为整数i拆分后的最大乘积不一定大于i，所以要进行比较，例如dp[2]=1&lt;2，所以2并不需要拆分。</p><ul><li>时间复杂度：$O(N^2)$，两侧 <code>for</code> 循环。</li><li>空间复杂度：$O(N)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">integerBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token operator">-</span>j<span class="token punctuation">)</span><span class="token operator">*</span>j<span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，我们通过<a href="https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-shu-xue-fang-fa-han-wan-zheng-t/" target="_blank" rel="noopener">数学证明</a>可以得知，只要尽量把整数i分解为更多的3或2即可，省去了许多分解因子的比较。</p><p>同时，我们还可以使用滚动数组的方法减少状态矩阵的空间占用。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">integerBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            <span class="token number">3</span> <span class="token operator">*</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><h2 id="13-剪绳子-II"><a href="#13-剪绳子-II" class="headerlink" title="13.剪绳子 II"></a>13.<a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/" target="_blank" rel="noopener">剪绳子 II</a></h2><p>思路：和上一题一样，由于我们求导得到的极大值点为e，所以我们要尽量把整数分解为更多的3或者2。最后结果取余1000000007即可（python没有溢出的问题），否则要用快速幂取余法求余数。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">integerBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            <span class="token number">3</span> <span class="token operator">*</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">1000000007</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-二进制中1的个数"><a href="#14-二进制中1的个数" class="headerlink" title="14.二进制中1的个数"></a>14.<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">二进制中1的个数</a></h2><p>思路：根据十进制数与二进制数进行转换的方法，按位判断。</p><ul><li>时间复杂度：$O(logN)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hammingWeight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        count<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                count<span class="token operator">+=</span><span class="token number">1</span>            n<span class="token operator">//=</span><span class="token number">2</span>        <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化的思路：根据以下事实：</p><ul><li>一个数 n与一个比它小 1 的数（n - 1）进行与运算（&amp;）之后，得到的结果会消除 n中最低位的 1.</li></ul><pre><code>示例1: 7 &amp; 600111      &amp;   =》 0011000110示例2: 8 &amp; 701000      &amp;   =》 0000000111</code></pre><p>可以看到，通过与运算不断地消去1，直到 n==0 即可。统计消去的次数，即为n中1的个数。</p><ul><li>时间复杂度：$O(M)$。M为1的个数。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hammingWeight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        count<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            n<span class="token operator">&amp;</span><span class="token operator">=</span>n<span class="token number">-1</span>            count<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="15-数值的整数次方"><a href="#15-数值的整数次方" class="headerlink" title="15.数值的整数次方"></a>15.<a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">数值的整数次方</a></h2><p>思路：快速幂算法，曾经在我的另一篇博客中有提到，第50题。基本思想是二分递归。</p><ul><li>时间复杂度：$O(logN)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">myPow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> float<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">fastpow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">1</span>            half<span class="token operator">=</span>fastpow<span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> half<span class="token operator">*</span>half            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> x<span class="token operator">*</span>half<span class="token operator">*</span>half        <span class="token keyword">if</span> n<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>            n<span class="token operator">=</span><span class="token operator">-</span>n            x<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span>x        <span class="token keyword">return</span> fastpow<span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="16-打印从1到最大的n位数"><a href="#16-打印从1到最大的n位数" class="headerlink" title="16.打印从1到最大的n位数"></a>16.<a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">打印从1到最大的n位数</a></h2><p>思路：这道题没什么好说的，如果用python的列表很好做。但如果是其他语言的话，数字可能在后期会溢出。当可能溢出时，需要把问题转化为大数加法，应考虑进位和最高位是否进位的问题。此外，还可以将其转化为0-9在n个位置上的全排列问题。后两种解法都需要考虑怎么去除最前面的0。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">printNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>pow<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="17-删除链表的节点"><a href="#17-删除链表的节点" class="headerlink" title="17.删除链表的节点"></a>17.<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">删除链表的节点</a></h2><p>思路：数据结构中单链表的最基础操作，使用一个指针，当其next节点的值为需要删除的值时，通过移动next指针指向next节点的next指针，完成删除操作。</p><p>特别地，为了不讨论在链表头部删除节点的特殊情况，我们额外添加一个空的头节点。</p><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def deleteNode(self, head: ListNode, val: int) -&gt; ListNode:        dummyhead=ListNode(0)        dummyhead.next=head        p=dummyhead        while (p.next!=None):            if p.next.val==val:                p.next=p.next.next                break            p=p.next        return dummyhead.next</code></pre><h2 id="18-正则表达式匹配"><a href="#18-正则表达式匹配" class="headerlink" title="18.正则表达式匹配"></a>18.<a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">正则表达式匹配</a></h2><p>思路：动态规划求解，这道题我在我的另一篇博客里有提及。</p><ul><li>时间复杂度：$O(MN)$。</li><li>空间复杂度：$O(MN)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> p<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                first_match<span class="token operator">=</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">or</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'.'</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">and</span> p<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'*'</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">or</span> <span class="token punctuation">(</span>first_match <span class="token operator">and</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>first_match <span class="token operator">and</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="19-表示数值的字符串"><a href="#19-表示数值的字符串" class="headerlink" title="19. 表示数值的字符串"></a>19.<a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener"> 表示数值的字符串</a></h2><p>这道题个人感觉纯靠耐心，利用判断慢慢做，暂时先不做了</p><h2 id="20-调整数组顺序使奇数位于偶数前面"><a href="#20-调整数组顺序使奇数位于偶数前面" class="headerlink" title="20. 调整数组顺序使奇数位于偶数前面"></a>20. <a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">调整数组顺序使奇数位于偶数前面</a></h2><p>思路：双指针法，我的思路来自于快速排序。指针left指向数组最左侧，指针right指向数组最右侧，如果left处的数字是一个奇数，说明该位置上的数字没问题，我们将left加1；如果是一个偶数，则将其与right处的数字交换，此时right处的数字必为偶数，我们可以将right减1。接着，我们看right处的数字，如果它是一个偶数，说明right处数字没问题，可以将right减1，否则，我们将其与left处的数字交换，此时left处必是奇数，我们可以将left+1.</p><p>由于数组中必然一半是奇数，一半是偶数，上述算法当left==right时跳出即可，说明所有数字已成功移动。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exchange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp<span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>tmp        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                swap<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>                right<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                left<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                right<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                swap<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>                left<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="21-链表中倒数第k个节点"><a href="#21-链表中倒数第k个节点" class="headerlink" title="21.链表中倒数第k个节点"></a>21.<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">链表中倒数第k个节点</a></h2><p>思路：快慢指针法，构建一前一后间隔为k的两个指针，当前方的指针指向None时，返回后方指针。特别地，要讨论一下当快指针到达正数第k个节点之前，慢指针将不会出发。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getKthFromEnd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        p<span class="token operator">=</span>head        q<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>k<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>next                q<span class="token operator">=</span>q<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                k<span class="token operator">-=</span><span class="token number">1</span>                q<span class="token operator">=</span>q<span class="token punctuation">.</span>next        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="22-反转链表"><a href="#22-反转链表" class="headerlink" title="22.反转链表"></a>22.<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">反转链表</a></h2><p>思路：有点类似于主站的k个一组反转链表，简化版，可以用头插法或者尾插法实现翻转。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        p<span class="token operator">=</span>head        q<span class="token operator">=</span>head<span class="token punctuation">.</span>next        <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            p<span class="token punctuation">.</span>next<span class="token operator">=</span>q<span class="token punctuation">.</span>next            q<span class="token punctuation">.</span>next<span class="token operator">=</span>head            head<span class="token operator">=</span>q            q<span class="token operator">=</span>p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这道题由于所有插入均在头部，所以不需要使用dummy head。</p><p>另一种方案是使用双指针进行翻转。通过两个间隔为1节点的快慢指针，不断修改快指针的节点的next指针为慢指针的节点，并使他们不断向前移动即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        p<span class="token operator">=</span>None        q<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp<span class="token punctuation">,</span>q<span class="token punctuation">.</span>next<span class="token operator">=</span>q<span class="token punctuation">.</span>next<span class="token punctuation">,</span>p            p<span class="token punctuation">,</span>q<span class="token operator">=</span>q<span class="token punctuation">,</span>tmp        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="23-合并两个排序的链表"><a href="#23-合并两个排序的链表" class="headerlink" title="23. 合并两个排序的链表"></a>23. <a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">合并两个排序的链表</a></h2><p>思路：这题类似于主站的第21题，我曾在另一篇博客里详细说过，主要的思路是用两个指针比较两个链表中的元素，并选取较小的放入新链表。</p><ul><li>时间复杂度：$O(M+N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> l2<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        dummyhead<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        p<span class="token punctuation">,</span>q<span class="token operator">=</span>l1<span class="token punctuation">,</span>l2        r<span class="token operator">=</span>dummyhead        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None <span class="token operator">and</span> q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>                r<span class="token punctuation">.</span>next<span class="token operator">=</span>p                p<span class="token operator">=</span>p<span class="token punctuation">.</span>next                r<span class="token operator">=</span>r<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                r<span class="token punctuation">.</span>next<span class="token operator">=</span>q                q<span class="token operator">=</span>q<span class="token punctuation">.</span>next                r<span class="token operator">=</span>r<span class="token punctuation">.</span>next        <span class="token keyword">if</span> p<span class="token operator">==</span>None<span class="token punctuation">:</span>            r<span class="token punctuation">.</span>next<span class="token operator">=</span>q        <span class="token keyword">else</span><span class="token punctuation">:</span>            r<span class="token punctuation">.</span>next<span class="token operator">=</span>p        <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>归并排序中合并相邻链表的常规做法，需要注意的是当插入空链表时需要分类讨论，为了减少判断，我们可以使用一个伪头结点。</p><h2 id="24-树的子结构"><a href="#24-树的子结构" class="headerlink" title="24.树的子结构"></a>24.<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">树的子结构</a></h2><p>思路：我们先使用先序遍历，遍历树A。然后调用另一个函数，判断A的当前子树是否与B匹配。如果当前子树与B匹配，返回True，否则继续尝试遍历A当前子树的左子树和右子树，看它们与B是否匹配。</p><p>匹配的函数：</p><ol><li>如果当前节点B为空，说明树B已经匹配至越过叶子节点，返回True</li><li>如果当前节点A为空，说明树A已经匹配至越过叶子节点，但树B还没有匹配完，失配了，返回False</li><li>如果当前节点A和节点B均非空，且A的值与B的值相等，则继续尝试匹配A、B节点的左节点和右节点。</li><li>如果A的值与B的值不等，说明失配，返回False。</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSubStructure</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> B<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>B<span class="token operator">==</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token operator">==</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">.</span>val<span class="token operator">==</span>B<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> match<span class="token punctuation">(</span>A<span class="token punctuation">.</span>left<span class="token punctuation">,</span>B<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> match<span class="token punctuation">(</span>A<span class="token punctuation">.</span>right<span class="token punctuation">,</span>B<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> A<span class="token operator">==</span>None <span class="token operator">or</span> B<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> match<span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>isSubStructure<span class="token punctuation">(</span>A<span class="token punctuation">.</span>left<span class="token punctuation">,</span>B<span class="token punctuation">)</span> <span class="token operator">or</span> self<span class="token punctuation">.</span>isSubStructure<span class="token punctuation">(</span>A<span class="token punctuation">.</span>right<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="25-二叉树的镜像"><a href="#25-二叉树的镜像" class="headerlink" title="25.二叉树的镜像"></a>25.<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">二叉树的镜像</a></h2><p>思路：观察镜像翻转后的二叉树可知，我们可以从上向下进行递归翻转。对于每一个节点，我们将其左子树和右子树交换，然后递归进入左子树和右子树的根节点，继续交换它们的左右子树。你会发现，如果你将当前层调整至镜像后，下一层节点其实已经被两个一组翻转了，只需要交换两个一组内部的节点即可完成翻转。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(N)$。递归要占用栈空间。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token operator">=</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>root<span class="token punctuation">.</span>left            self<span class="token punctuation">.</span>mirrorTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>mirrorTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="26-对称的二叉树"><a href="#26-对称的二叉树" class="headerlink" title="26.对称的二叉树"></a>26.<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">对称的二叉树</a></h2><p>思路：</p><ul><li>对称二叉树规律：<ul><li>对于树中任意两个对称节点A和B，一定有：<ul><li>A.val = B.val：即此两对称节点值相等。</li><li>A 的 左子节点 和 B的 右子节点 对称；</li><li>A 的 右子节点 和 B的 左子节点 对称。</li><li>如果A、B均为空，我们认为它们是对称的。</li><li>如果A、B中一个空一个非空，则必然不对称。</li></ul></li></ul></li><li>根据以上规律，考虑从顶至底递归判断每对节点是否对称，从而判断树是否为对称二叉树。</li></ul><p><img src="26.png" alt="规律"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> A<span class="token operator">==</span>None <span class="token operator">and</span> B<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> A<span class="token operator">==</span>None <span class="token operator">or</span> B<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> A<span class="token punctuation">.</span>val<span class="token operator">==</span>B<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> match<span class="token punctuation">(</span>A<span class="token punctuation">.</span>left<span class="token punctuation">,</span>B<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token operator">and</span> match<span class="token punctuation">(</span>A<span class="token punctuation">.</span>right<span class="token punctuation">,</span>B<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> match<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">if</span> root <span class="token keyword">else</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(N)$。递归要占用栈空间。</li></ul><h2 id="27-顺时针打印矩阵"><a href="#27-顺时针打印矩阵" class="headerlink" title="27.顺时针打印矩阵"></a>27.<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">顺时针打印矩阵</a></h2><p>思路：螺旋矩阵，模拟题，做过很多次了。主站第54题，可以看我的另一篇博客。</p><ul><li>时间复杂度：$O(MN)$。</li><li>空间复杂度：$O(N)$。递归要占用栈空间。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        level<span class="token operator">=</span><span class="token number">0</span>        row<span class="token operator">=</span><span class="token number">0</span>        col<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">if</span> matrix<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        result<span class="token operator">=</span><span class="token punctuation">[</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">]</span>        count<span class="token operator">=</span><span class="token number">1</span>        row_nums<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span>        col_nums<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        size<span class="token operator">=</span>row_nums<span class="token operator">*</span>col_nums        <span class="token keyword">while</span> count<span class="token operator">&lt;</span>size<span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col_nums<span class="token operator">-</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>                col<span class="token operator">+=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>row_nums<span class="token operator">-</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>                row<span class="token operator">+=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col_nums<span class="token operator">-</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>                col<span class="token operator">-=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>row_nums<span class="token operator">-</span>level<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                row<span class="token operator">-=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            level<span class="token operator">+=</span><span class="token number">1</span>            col<span class="token operator">+=</span><span class="token number">1</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>            count<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="28-包含min函数的栈"><a href="#28-包含min函数的栈" class="headerlink" title="28.包含min函数的栈"></a>28.<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">包含min函数的栈</a></h2><p>思路：入栈、出栈、取栈顶元素的操作都很简单，Java中可以用数组或者链表来模拟，而python中可以直接用列表来模拟。唯一的难点在于如何找到当前最小值。如果取最小值的时候遍历整个栈，时间复杂度会是线性的，比较高。我们可以以空间换时间，通过建立一个辅助栈，记录当前栈中的某个元素及其之前的所有元素中的最小值。</p><ul><li>时间复杂度：$O(1)$。</li><li>空间复杂度：$O(N)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MinStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>A<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>B<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>A<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> x<span class="token operator">&lt;</span>self<span class="token punctuation">.</span>B<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">else</span> self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>B<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>A<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>A<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>B<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your MinStack object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MinStack()</span><span class="token comment" spellcheck="true"># obj.push(x)</span><span class="token comment" spellcheck="true"># obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.top()</span><span class="token comment" spellcheck="true"># param_4 = obj.min()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="29-栈的压入、弹出序列"><a href="#29-栈的压入、弹出序列" class="headerlink" title="29.栈的压入、弹出序列"></a>29.<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">栈的压入、弹出序列</a></h2><p>思路：辅助栈模拟法。通过采用一个辅助栈模拟压入、弹出的过程。按照压入序列，每次往辅助栈中压入一个数字，同时查看弹出序列中的第 i 个元素是否为辅助栈的栈顶元素（i初始为0），是则从辅助栈中弹出该元素，并将 i 加1，尝试弹出下一个元素，否则继续压入数字。如果最终辅助栈为空，说明弹出序列在当前压入序列下合法。</p><ul><li>时间复杂度：$O(N)$。将所有元素一遍入栈，一遍出栈，需要 $O(2N)$。</li><li>空间复杂度：$O(N)$。使用了辅助栈 <code>st</code>。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">validateStackSequences</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pushed<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> popped<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        i<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> pushed<span class="token punctuation">:</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>popped<span class="token punctuation">)</span> <span class="token operator">and</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>popped<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                i<span class="token operator">+=</span><span class="token number">1</span>         <span class="token keyword">return</span> <span class="token boolean">True</span> <span class="token keyword">if</span> stack<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="30-I-从上到下打印二叉树"><a href="#30-I-从上到下打印二叉树" class="headerlink" title="30. I. 从上到下打印二叉树"></a>30.<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener"> I. 从上到下打印二叉树</a></h2><p>思路：基本的BFS，队列实现。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            i<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">while</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>None<span class="token punctuation">:</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span>                i<span class="token operator">+=</span><span class="token number">1</span>            queue<span class="token operator">=</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">]</span>        <span class="token keyword">return</span> queue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="31-II-从上到下打印二叉树-II"><a href="#31-II-从上到下打印二叉树-II" class="headerlink" title="31.II. 从上到下打印二叉树 II"></a>31.<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">II. 从上到下打印二叉树 II</a></h2><p>思路：依然是BFS的基本题，采用队列的方式。每一层开始时记录下当前队列中的节点数目 L，并开始让父节点出队，左右子节点非空入队，共重复L次，即完成了一层的遍历，将当前队列中的节点添加至结果数组中。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">]</span><span class="token punctuation">)</span>                l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span>                    queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="32-III-从上到下打印二叉树-III"><a href="#32-III-从上到下打印二叉树-III" class="headerlink" title="32. III. 从上到下打印二叉树 III"></a>32.<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener"> III. 从上到下打印二叉树 III</a></h2><p>思路：依然是BFS的基本题，使用一个level变量记录一下当前的层数即可。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        level<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> level<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span>                    queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                level<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> result   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33.二叉搜索树的后序遍历序列"></a>33.<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">二叉搜索树的后序遍历序列</a></h2><p>思路：这道题就是看数组是否满足某一个二叉搜索树的后序遍历。我们知道：</p><ul><li>后序遍历的最后一个节点都是根节点。数组顺序为： [ 左子树 | 右子树 | 根节点 ] 。</li><li>对于二叉搜索树的任意一个节点，左子树的所有节点必然小于它，右子树的所有节点必然大于它。</li></ul><p>根据上述两个性质，我们可以进行递归分治判断，我们先判断根节点的的左子树是否均比他小，右子树是否均比他大，若成立，则继续判断左子树和右子树是否符合二叉搜索树的定义。至于如何划分子树，可以根据根节点来划分，如果出现了比根节点大的值，则该节点及其后在根节点之前的所有节点均为右子树的节点。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">verifyPostorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> postorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> left<span class="token operator">>=</span>right<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            p<span class="token operator">=</span>left            <span class="token keyword">while</span> <span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">&lt;</span>postorder<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                p<span class="token operator">+=</span><span class="token number">1</span>            pos<span class="token operator">=</span>p            <span class="token keyword">while</span> <span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">></span>postorder<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                p<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> p<span class="token operator">==</span>right<span class="token punctuation">:</span>                <span class="token keyword">return</span> match<span class="token punctuation">(</span>left<span class="token punctuation">,</span>pos<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">and</span> match<span class="token punctuation">(</span>pos<span class="token punctuation">,</span>right<span class="token number">-1</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> match<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>postorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>时间复杂度：$O(N^2)$。最坏情况下是当二叉树退化为链表。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><h2 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34.二叉树中和为某一值的路径"></a>34.<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">二叉树中和为某一值的路径</a></h2><p>思路：递归搜索+回溯。类似于组合数的问题，我在另一篇博客中有提到过，基本做法是从根节点向下递归搜索，如果当前节点为空，则直接返回，如果当前节点不为空，则将当前节点加入至当前路径列表，并将它的值加入至当前路径和中。接着讨论两种情况：（1）当前节点为叶子节点且当前路径和为0，那么将当前路径加入至结果列表中；（2）否则，继续搜索左孩子节点和右孩子节点。讨论完成后，回溯至最初的状态。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>re<span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            re<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            sum<span class="token operator">-=</span>root<span class="token punctuation">.</span>val            <span class="token keyword">if</span> sum<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> root<span class="token punctuation">.</span>left<span class="token operator">==</span>None <span class="token operator">and</span> root<span class="token punctuation">.</span>right<span class="token operator">==</span>None<span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>re<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>re<span class="token punctuation">,</span>sum<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>re<span class="token punctuation">,</span>sum<span class="token punctuation">)</span>            re<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            sum<span class="token operator">+=</span>root<span class="token punctuation">.</span>val        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> re<span class="token punctuation">]</span> <span class="token keyword">for</span> re <span class="token keyword">in</span> result<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>时间复杂度：$O(N)$。本质上就是一次先序遍历加上判断的过程。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35.复杂链表的复制"></a>35.<a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">复杂链表的复制</a></h2><p>思路：这题本质上是模拟复杂链表的深拷贝。既然是深拷贝，我们就不能直接引用，而是应该使用新建值相同的节点类的方式进行拷贝。但是这道题有一个问题，就是存在random指针指向链表中的任意节点或者 <code>null</code>。 所以如何保证拷贝random指针的节点和拷贝next指针的节点的一致性，是我们需要解决的问题。也就是说，如果我们按照next指针顺序进行拷贝节点的话，如果需要拷贝的节点已经因为之前被某个节点的random指针指向，而已经被拷贝过了，如何知道它已经拷贝且正确指向他呢？</p><p>我的思路是使用一个哈希表，哈希表的key是原链表中的节点，哈希表的value是新拷贝得到的节点。当我们进行拷贝时，如果需要拷贝的节点尚且不在哈希表的key中，则我们可以进行拷贝，并将原节点-新节点的键值对保存进哈希表中，当我们再次拷贝某节点，会发现它已被拷贝过，直接将next或random指针指向它即可。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。哈希表使用了额外的空间。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""# Definition for a Node.class Node:    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):        self.val = int(x)        self.next = next        self.random = random"""</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">copyRandomList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Node'</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> head<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        copyhead<span class="token operator">=</span>Node<span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token operator">=</span>copyhead        q<span class="token operator">=</span>head        visited<span class="token operator">=</span><span class="token punctuation">{</span>head<span class="token punctuation">:</span>copyhead<span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> q<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span>                <span class="token keyword">if</span> q<span class="token punctuation">.</span>next <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    visited<span class="token punctuation">[</span>q<span class="token punctuation">.</span>next<span class="token punctuation">]</span><span class="token operator">=</span>Node<span class="token punctuation">(</span>q<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                p<span class="token punctuation">.</span>next<span class="token operator">=</span>visited<span class="token punctuation">[</span>q<span class="token punctuation">.</span>next<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                p<span class="token punctuation">.</span>next<span class="token operator">=</span>None            <span class="token keyword">if</span> q<span class="token punctuation">.</span>random<span class="token operator">!=</span>None<span class="token punctuation">:</span>                <span class="token keyword">if</span> q<span class="token punctuation">.</span>random <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    visited<span class="token punctuation">[</span>q<span class="token punctuation">.</span>random<span class="token punctuation">]</span><span class="token operator">=</span>Node<span class="token punctuation">(</span>q<span class="token punctuation">.</span>random<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                p<span class="token punctuation">.</span>random<span class="token operator">=</span>visited<span class="token punctuation">[</span>q<span class="token punctuation">.</span>random<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                p<span class="token punctuation">.</span>random<span class="token operator">=</span>None            p<span class="token punctuation">,</span>q<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">,</span>q<span class="token punctuation">.</span>next        <span class="token keyword">return</span> copyhead<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他思路：</p><p><img src="35.png" alt></p><ul><li>我们可以将链表看成是graph，利用BFS或者DFS+哈希表进行求解。本质思想和直接迭代按照单链表的next指针顺序复制是一样的。</li></ul><h2 id="35-二叉搜索树与双向链表"><a href="#35-二叉搜索树与双向链表" class="headerlink" title="35.二叉搜索树与双向链表"></a>35.<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">二叉搜索树与双向链表</a></h2><p>思路：首先，我们知道，二叉搜索树的性质有一条是中序遍历所得到的结果是升序排序的序列。恰好，我们要构造的双向链表也是升序排序的，所以我们会想到使用中序遍历来进行原地转换。</p><p>具体算法如下：</p><ul><li><p>设置全局变量head，tail指针，指向当前链表的头尾节点，初始均为None。（为什么一定要全局节点，因为这里的指针是不可变类型，所以在内部函数中对其修改不会改变外层的值，如果是可变类型则会产生改变）</p></li><li><p>开始中序遍历，如果当前节点为空，那么什么也不做，直接返回。如果当前节点非空，先递归遍历左子树。如果当前head指针非空，说明当前节点是二叉搜索树的第一个节点，即最小值，自然也就是双向链表的head节点，那么让head指向他。如果当前tail非空，说明左子树的遍历已经为双向链表加入了节点，且tail指向的是当前双向链表的尾部节点，那么进行如下修改：（1）让当前节点的left指针指向当前tail（2）让当前tail的right指针指向当前节点。接下来，无论tail是否为空，让它指向当前节点。上述三个操作相当于把当前节点加入至双向链表尾部，并让tail指向他。接下来，递归遍历右子树。简而言之，上述过程就是按照中序遍历的顺序不断原地修改二叉搜索树，tail指针始终指向当前节点的前一个节点。</p></li><li><p>完成中序遍历后，我们获得了一个头尾尚未连接的双向链表，此时我们将头节点和尾节点连接即可。</p></li><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(1)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""# Definition for a Node.class Node:    def __init__(self, val, left=None, right=None):        self.val = val        self.left = left        self.right = right"""</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>head<span class="token operator">=</span>None        self<span class="token punctuation">.</span>tail<span class="token operator">=</span>None    <span class="token keyword">def</span> <span class="token function">treeToDoublyList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Node'</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>             inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>head<span class="token operator">==</span>None<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>head<span class="token operator">=</span>root            <span class="token keyword">if</span> self<span class="token punctuation">.</span>tail<span class="token operator">!=</span>None<span class="token punctuation">:</span>                root<span class="token punctuation">.</span>left<span class="token operator">=</span>self<span class="token punctuation">.</span>tail                self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>right<span class="token operator">=</span>root            self<span class="token punctuation">.</span>tail<span class="token operator">=</span>root            inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>left<span class="token operator">=</span>self<span class="token punctuation">.</span>tail        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>head        <span class="token keyword">return</span> self<span class="token punctuation">.</span>head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="36-序列化二叉树"><a href="#36-序列化二叉树" class="headerlink" title="36.序列化二叉树"></a>36.<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">序列化二叉树</a></h2><p>思路：这道题我曾经在大二的数据结构课上做过，可以用两种方式来解决。这里我们先说层次遍历的解法。</p><p>BFS的解法：</p><ul><li>序列化：BFS的序列化按照常规做法，依然是使用队列来完成。先将根节点加入队列。每次从队首取出一个节点，如果当前节点为空，那么向序列化的字符串中添加一个”*”作为占位符，否则将它的value添加进字符串，中间用“，”隔开。然后，将其左右孩子节点均加入队列中。重复上述过程直到队列为空。</li></ul><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Encodes a tree to a single string.        :type root: TreeNode        :rtype: str        """</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span>        data<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token operator">==</span>None<span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>node<span class="token punctuation">.</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">","</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>反序列化：BFS的反序列化较为复杂，由于不是完全二叉树，不可以直接用下标运算求解子节点位置，需要使用一个辅助队列来存放当前剩余的需要处理的节点，并使用一个指针来遍历序列化字符串中逗号隔开的每个元素。</li></ul><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Decodes your encoded data to tree.        :type data: str        :rtype: TreeNode        """</span>        data<span class="token operator">=</span>data<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"*"</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None        root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span>        i<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">"*"</span><span class="token punctuation">:</span>                leftNode<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                node<span class="token punctuation">.</span>left<span class="token operator">=</span>leftNode                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>leftNode<span class="token punctuation">)</span>            i<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">"*"</span><span class="token punctuation">:</span>                rightNode<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                node<span class="token punctuation">.</span>right<span class="token operator">=</span>rightNode                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>rightNode<span class="token punctuation">)</span>            i<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一种更为简单直观的方式是DFS的做法，直接使用先序遍历求解。</p><ul><li>序列化：先序遍历，每次将当前节点加入至序列化字符串中，如果当前节点为空，则加入“*”占位符，否则加入value，然后递归遍历左子树和右子树。</li></ul><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Encodes a tree to a single string.        :type root: TreeNode        :rtype: str        """</span>        data<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        preorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">","</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>反序列化：依然是先序遍历的方式递归重建二叉树。</li></ul><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Decodes your encoded data to tree.        :type data: str        :rtype: TreeNode        """</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">:</span>            now<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> now<span class="token operator">==</span><span class="token string">"*"</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> None            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>left<span class="token operator">=</span>build<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>build<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            <span class="token keyword">return</span> root        queue<span class="token operator">=</span>data<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> build<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="37-字符串的排列"><a href="#37-字符串的排列" class="headerlink" title="37.字符串的排列"></a>37.<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">字符串的排列</a></h2><p>思路：全排列问题，采用DFS+递归的方式解决。需要注意的是这里应该进行去重，去重的思路有两种：</p><ul><li>哈希表或者集合的方式去重。</li><li>先对字符串进行字典序排序（字符串没有sort函数，必须调用全局函数sorted（）），如果当前序号的字符等于前一个字符，且前一个字符尚未被访问，则可以跳过对他的搜索。因为它的所有组合已经被前一个字符的搜索所覆盖了。具体可以参考主站的第47题<a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">全排列 II</a>。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">permutation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        s<span class="token operator">=</span>sorted<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">DFS</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token operator">==</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token boolean">True</span> <span class="token operator">and</span> <span class="token operator">not</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">and</span> visited<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                        DFS<span class="token punctuation">(</span>st<span class="token operator">+</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">False</span>        DFS<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(N*N!)$。N为字符串长度</li><li>空间复杂度：$O(N*N!)$。</li></ul><h2 id="38-数组中出现次数超过一半的数字"><a href="#38-数组中出现次数超过一半的数字" class="headerlink" title="38.数组中出现次数超过一半的数字"></a>38.<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中出现次数超过一半的数字</a></h2><p>思路：排序然后取中位数即可。因为假如某个数字出现次数超过一半，则排序后必然出现在中间位置上。</p><ul><li>时间复杂度：$O(NlogN)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="39-最小的k个数"><a href="#39-最小的k个数" class="headerlink" title="39.最小的k个数"></a>39.<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">最小的k个数</a></h2><p>思路：经典的TOP K问题！常规的做法是直接排序一下，用快排的话是$O(NlogN)$。为了能更快，主要思路有有两种，分别是使用堆（优先队列）或者快速选择。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li>基本思路：使用一个大顶堆来存储数组中前k小的元素。一开始，先使用数组中前K个元素建大顶堆，此时，堆顶的元素为前K个元素中的最大值。然后从K+1个元素向后依次遍历，如果当前元素小于大顶堆的堆顶元素，说明堆顶元素不仅大于堆中的K-1个元素，且大于当前元素，必不可能是前K小的元素。所以，我们将当前元素加入至堆中，并调整堆至继续符合大顶堆。继续向后遍历，维护大顶堆，直到遍历到数组末尾，此时堆中的元素即为数组的前K小的值。</li><li>时间复杂度：$O(nlogk)$，因为元素出堆和入队平均都需要$O(logk)$的时间复杂度，与此同时，最坏的情况下（降序排列），需要对所有的元素进行插入操作，所以时间复杂度为$O(nlogk)$。</li><li>空间复杂度：$O(k)$，使用了一个大小为k的堆。</li><li>Python中提供了高级数据结构heapq，详情可以看这篇博客<a href="https://blog.csdn.net/jamfiy/article/details/88185512" target="_blank" rel="noopener">python高级（堆heapq模块）</a>，它以列表为基础提供了小顶堆的操作。为了使用大顶堆，我们对堆中所有的元素进行取反操作，并再返回结果时恢复符号。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getLeastNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        heap<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>heap<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#将列表转换为堆</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token operator">-</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#前K个数字入堆</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token operator">-</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#这个函数的意思是，如果当前数比堆顶元素大，那么入堆并将堆顶元素出堆，否则不变</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> heap<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><ul><li><p>基本思路：在数组中找第K小（大）的元素，或者前K小（大）的元素，可以使用快速排序变形的算法，我们称之为快速选择（quick select），都是分治法。</p></li><li><p>让我们回顾快速排序的思路。快速排序中有一步很重要的操作是 partition（划分），从数组中随机选取一个枢纽元素 v，然后原地移动数组中的元素，使得比 v 小的元素在 v 的左边，比 v 大的元素在 v 的右边，如下图所示：</p><p><img src="39.jpg" alt="快速排序"></p><p>这个 partition 操作是原地进行的，需要 $O(n)$ 的时间，接下来，快速排序会递归地排序左右两侧的数组。而快速选择（quick select）算法的不同之处在于，接下来只需要递归地选择一侧的数组。快速选择算法想当于一个“不完全”的快速排序，因为我们只需要知道最小的 k 个数是哪些，并不需要知道它们的顺序。</p><p>我们的目的是寻找最小的 k 个数。假设经过一次 partition 操作，枢纽元素位于下标 m，也就是说，左侧的数组有 m 个元素，是原数组中最小的 m 个数。那么：</p><ul><li>若 k = m，我们就找到了最小的 k 个数，就是左侧的数组；</li><li>若 k&lt;m ，则最小的 k 个数一定都在左侧数组中，我们只需要对左侧数组递归地 parition 即可；</li><li>若 k&gt;m，则左侧数组中的 m 个数都属于最小的 k 个数，我们还需要在右侧数组中寻找最小的 k-m个数，对右侧数组递归地 partition 即可。</li></ul></li><li><p>复杂度分析比较麻烦：</p><p><img src="39.png" alt="快速选择的复杂度分析"></p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getLeastNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#和快速排序中的分治一样，将当前区间首部的枢纽元素调整至正确的位置</span>            i<span class="token operator">=</span>left<span class="token operator">+</span><span class="token number">1</span>            j<span class="token operator">=</span>right            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>right <span class="token operator">and</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    i<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j<span class="token operator">></span>left <span class="token operator">and</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">>=</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    j<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">if</span> i<span class="token operator">&lt;</span>j<span class="token punctuation">:</span>                    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                    <span class="token keyword">break</span>            <span class="token keyword">return</span> j        <span class="token keyword">def</span> <span class="token function">quickSelect</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#快速选择算法</span>            m<span class="token operator">=</span>partition<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> m<span class="token operator">==</span>k<span class="token punctuation">:</span>                <span class="token keyword">return</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">elif</span> m<span class="token operator">></span>k<span class="token punctuation">:</span>                <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span>left<span class="token punctuation">,</span>m<span class="token number">-1</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span>        <span class="token keyword">if</span> k<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> k<span class="token operator">></span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> arr        <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="40-数据流中的中位数"><a href="#40-数据流中的中位数" class="headerlink" title="40.数据流中的中位数"></a>40.<a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">数据流中的中位数</a></h2><p>思路：这道题我们可以将插入的数字保存在一个数组中，然后排序数组输出中位数。很明显，这样做很低效。较好的一种思路是使用二分法查找插入的位置，保证每次插入后数组是有序的。但是这样做还不够好，我们可以通过使用两个堆来解决这一问题。</p><ul><li>我们使用一个大顶堆用于存放当前所有数据中的前一半数据（下标由0到len//2），使用一个小顶堆存放当前数组的后一半数据（下标由len//2+1到len-1）。当总长度为奇数时，我们取大顶堆中的堆顶元素作为中位数，否则取两个堆堆顶元素求平均。</li><li>由于中位数在大顶堆中，所以当前数据总数为奇数时，大顶堆规模比小顶堆大1，当数据总数为偶数时，大顶堆规模和小顶堆相等。所以插入后数据总数为奇数时，新的数先插入小顶堆，再从小顶堆堆顶取出元素插入大顶堆，使小顶堆规模不变，大顶堆规模加1，从而保证了前述的性质。插入后数据总数为偶数时，新的数先插入大顶堆，再从大顶堆堆顶取出元素插入小顶堆，使大顶堆规模不变，小顶堆规模加1。</li><li>时间复杂度：插入元素：$O(logk)$，求中位数：$O(log1)$。</li><li>Python中只有小顶堆，所以大顶堆需要用负数来模拟。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MedianFinder</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>largeHeap<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>smallHeap<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>count<span class="token operator">=</span><span class="token number">0</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>self<span class="token punctuation">.</span>largeHeap<span class="token punctuation">)</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>self<span class="token punctuation">.</span>smallHeap<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">addNum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>count<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>self<span class="token punctuation">.</span>largeHeap<span class="token punctuation">,</span><span class="token operator">-</span>heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>self<span class="token punctuation">.</span>smallHeap<span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>self<span class="token punctuation">.</span>smallHeap<span class="token punctuation">,</span><span class="token operator">-</span>heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>self<span class="token punctuation">.</span>largeHeap<span class="token punctuation">,</span><span class="token operator">-</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>count<span class="token operator">+=</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">findMedian</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None        <span class="token keyword">if</span> self<span class="token punctuation">.</span>count<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">-</span>self<span class="token punctuation">.</span>largeHeap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>self<span class="token punctuation">.</span>smallHeap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span>self<span class="token punctuation">.</span>largeHeap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your MedianFinder object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MedianFinder()</span><span class="token comment" spellcheck="true"># obj.addNum(num)</span><span class="token comment" spellcheck="true"># param_2 = obj.findMedian()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="41-连续子数组的最大和"><a href="#41-连续子数组的最大和" class="headerlink" title="41.连续子数组的最大和"></a>41.<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">连续子数组的最大和</a></h2><p>思路：动态规划，与主站53题相同。状态矩阵DP[i]表示以第i个数结尾的连续子数组的最大和。转移方程为：DP[i]=（1）nums[i]（if DP[i-1]&lt;=0） （2）DP[i-1]+nums[i]（else），转移过程中记录最大值。特别地，我们可以原地修改Nums矩阵作为DP矩阵。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> nums<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None        maxSum<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>            maxSum<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>maxSum<span class="token punctuation">)</span>        <span class="token keyword">return</span> maxSum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="42-数字-1-的个数"><a href="#42-数字-1-的个数" class="headerlink" title="42.数字 1 的个数"></a>42.<a href="https://leetcode-cn.com/problems/number-of-digit-one/" target="_blank" rel="noopener">数字 1 的个数</a></h2><p>思路：数学规律题，需要慢慢分析。个人认为面试题的可能性不大，以后再做。</p><h2 id="43-数字序列中某一位的数字"><a href="#43-数字序列中某一位的数字" class="headerlink" title="43.数字序列中某一位的数字"></a>43.<a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">数字序列中某一位的数字</a></h2><p>思路：依然是数学规律题，一位数从0到9，共10个，总占位数10位，两位数从10到99，共90个，总占位数180位…..以此类推，m位数所占位数为$(10^m-10^{m-1})*m$。从而可以推出某一位的数字是哪个数字的哪一位。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findNthDigit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">cal</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> m<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">10</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">**</span>m<span class="token number">-10</span><span class="token operator">**</span><span class="token punctuation">(</span>m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span>m        m<span class="token operator">=</span><span class="token number">0</span>        s<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> n<span class="token operator">>=</span>s<span class="token punctuation">:</span>            m<span class="token operator">+=</span><span class="token number">1</span>            s<span class="token operator">+=</span>cal<span class="token punctuation">(</span>m<span class="token punctuation">)</span>        s<span class="token operator">-=</span>cal<span class="token punctuation">(</span>m<span class="token punctuation">)</span>        <span class="token keyword">if</span> m<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>n<span class="token operator">-</span>s<span class="token punctuation">)</span><span class="token operator">//</span>m        <span class="token keyword">else</span><span class="token punctuation">:</span>            num<span class="token operator">=</span> str<span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">**</span><span class="token punctuation">(</span>m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>n<span class="token operator">-</span>s<span class="token punctuation">)</span><span class="token operator">//</span>m<span class="token punctuation">)</span>            offset<span class="token operator">=</span><span class="token punctuation">(</span>n<span class="token operator">-</span>s<span class="token punctuation">)</span><span class="token operator">%</span>m            <span class="token keyword">return</span> int<span class="token punctuation">(</span>num<span class="token punctuation">[</span>offset<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="44-把数组排成最小的数"><a href="#44-把数组排成最小的数" class="headerlink" title="44.把数组排成最小的数"></a>44.<a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">把数组排成最小的数</a></h2><p>思路：这道题主要的思路是这样的，我们需要对当前数组进行排序，排序的规则需要我们重新定义。我们比较两个字符串，如果A+B的字典序小于B+A，那么A一定在B之前。重写排序规则的方法，在Java中可以重写Comparator，Python中新建一个类，重写它的lt方法，并将其传入sorted函数的key中。</p><ul><li>时间复杂度：$O(NlogN)$。排序的时间复杂度。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">cmpSmaller</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__lt__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self <span class="token operator">+</span> y <span class="token operator">&lt;</span> y <span class="token operator">+</span> self  <span class="token comment" spellcheck="true"># 字符串拼接比较(两两比较)</span>    <span class="token comment" spellcheck="true"># 按由小到大来排列</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        res<span class="token operator">=</span>sorted<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">,</span>key<span class="token operator">=</span>cmpSmaller<span class="token punctuation">)</span>        smallest <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>res<span class="token punctuation">)</span>        <span class="token keyword">return</span> smallest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="45-把数字翻译成字符串"><a href="#45-把数字翻译成字符串" class="headerlink" title="45.把数字翻译成字符串"></a>45.<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">把数字翻译成字符串</a></h2><p>思路：先将数字转字符串便于直接获取某一位，再动态规划，状态矩阵dp[i]为前i个字符的翻译方法数目。转移时，要注意：由于单个数字必然可以转为字母，如果前一个数字字符和当前数字字符组成的新数字在[10，25]间，说明它们可以组成一个英文字母（此处，含有前缀0的数字不可以被翻译成字母，如“01”等），那么dp[i]=dp[i-1]+dp[i-2]，否则dp[i]=dp[i-1]。特别地，对于i==1时要特殊判断一下，因为涉及到字符串的初始化。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(N)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">translateNum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        num<span class="token operator">=</span>str<span class="token punctuation">(</span>num<span class="token punctuation">)</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp<span class="token operator">=</span>int<span class="token punctuation">(</span>num<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>tmp<span class="token operator">&lt;=</span><span class="token number">25</span> <span class="token operator">and</span> num<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'0'</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，像这种只用到前两个状态的动态规划，还可以使用滚动数组的方式降低空间复杂度。</p><h2 id="46-礼物的最大价值"><a href="#46-礼物的最大价值" class="headerlink" title="46.礼物的最大价值"></a>46.<a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">礼物的最大价值</a></h2><p>思路：有些类似于主站的机器人走迷宫问题，一开始这种题目我们很容易想到DFS，但是我们发现会超时，因为对许多路径进行了重复的遍历，产生了重叠子问题。很明显，这里我们要使用动态规划，dp[i] [j]为走到（i，j）格子时的最大礼物数目，转移方程见程序，选取上方或者左侧的状态中的最大值加上当前格子礼物价值作为当前状态。特别地，我们还可以原地修改grid作为我们的状态矩阵dp，不使用额外空间。</p><ul><li>时间复杂度：$O(MN)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxValue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> row<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> col<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">+=</span>grid<span class="token punctuation">[</span>row<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span>                <span class="token keyword">elif</span> row<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> col<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                    grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">+=</span>grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token keyword">elif</span> row<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> col<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                    grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">+=</span>max<span class="token punctuation">(</span>grid<span class="token punctuation">[</span>row<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">,</span>grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> grid<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="47-最长不含重复字符的子字符串"><a href="#47-最长不含重复字符的子字符串" class="headerlink" title="47.最长不含重复字符的子字符串"></a>47.<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">最长不含重复字符的子字符串</a></h2><p>思路：与主站第3题类似，采用双指针维护一个不含重复字符的滑动窗口。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span><span class="token number">1</span>        max_len<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token keyword">in</span> s<span class="token punctuation">[</span>left<span class="token punctuation">:</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                left<span class="token operator">+=</span><span class="token number">1</span>            now_len<span class="token operator">=</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">if</span> now_len<span class="token operator">></span>max_len<span class="token punctuation">:</span>                max_len<span class="token operator">=</span>now_len            right<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> max_len<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="48-丑数"><a href="#48-丑数" class="headerlink" title="48.丑数"></a>48.<a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">丑数</a></h2><p>思路：这道题我曾经在蓝桥杯上做过，基本思路就是动态规划，dp[i]为第i个丑数。具体做法是使用三个指针，分别指向2、3、5所要乘以的丑数因子，每次从三个指针指向的丑数分别乘以2、3、5所得乘积中选取最小值添加到当前丑数数组中，并将最小值对应的指针加1，继续比较。（需要注意的是，这里的最小值可能不止一个）</p><p>当然，这道题还可以用一个小顶堆来做，基本的思路是小顶堆堆顶存放当前最小丑数，每次取出最小丑数，并将它乘2、3、5的积加入堆中，继续取最小丑数，取n次。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">nthUglyNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>      dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>      p2<span class="token punctuation">,</span>p3<span class="token punctuation">,</span>p5<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>          dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>p3<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>p5<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>dp<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">:</span>              p2<span class="token operator">+=</span><span class="token number">1</span>          <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>dp<span class="token punctuation">[</span>p3<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">:</span>              p3<span class="token operator">+=</span><span class="token number">1</span>          <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>dp<span class="token punctuation">[</span>p5<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">:</span>              p5<span class="token operator">+=</span><span class="token number">1</span>      <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="49-第一个只出现一次的字符"><a href="#49-第一个只出现一次的字符" class="headerlink" title="49.第一个只出现一次的字符"></a>49.<a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/" target="_blank" rel="noopener">第一个只出现一次的字符</a></h2><p>思路：简单题，使用哈希表来存放每个字符出现的次数，输出第一个出现次数为1的字符。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">if</span> s<span class="token punctuation">:</span>            dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>            <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>                <span class="token keyword">if</span> ch <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    dic<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dic<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">for</span> key <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> key        <span class="token keyword">return</span> <span class="token string">" "</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="50-数组中的逆序对"><a href="#50-数组中的逆序对" class="headerlink" title="50.数组中的逆序对"></a>50.<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">数组中的逆序对</a></h2><p>思路：这道题的思路很难想到，需要慢慢分析。最简单的做法是暴力遍历，时间复杂度为$O(N^2)$。但很明显，时间复杂度过高，会很慢。在这里，我们使用一种归并排序的思想进行优化。</p><ul><li>正常进行归并排序。</li><li>只用添加一行代码，就是使用双指针归并两个有序数组时，如果前一个数组的指针p指向的数大于后一个数组的指针q指向的数，说明前面的数组中，自p到最后一个下标的数都大于q下标的数，都为逆序对，所以需要在全局变量count中加上len（nums1）-p。（相较于直接暴力破解，这样做可以一次确定多个逆序对）</li><li>时间复杂度：$O(NlogN)$。本质上还是归并排序</li><li>空间复杂度：$O(N)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>sum<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">mergeTwoList</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span>nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>            p<span class="token operator">=</span><span class="token number">0</span>            q<span class="token operator">=</span><span class="token number">0</span>            result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span> <span class="token operator">and</span> q<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">:</span>                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span>                    p<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>sum<span class="token operator">+=</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">-</span>p                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span>                    q<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> p<span class="token operator">==</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">:</span>                result<span class="token operator">+=</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">:</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                result<span class="token operator">+=</span>nums1<span class="token punctuation">[</span>p<span class="token punctuation">:</span><span class="token punctuation">]</span>            <span class="token keyword">return</span> result        <span class="token keyword">def</span> <span class="token function">mergesort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> nums            mid<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">return</span> mergeTwoList<span class="token punctuation">(</span>mergesort<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token punctuation">:</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>mergesort<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        mergesort<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>sum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="51-两个链表的第一个公共节点"><a href="#51-两个链表的第一个公共节点" class="headerlink" title="51.两个链表的第一个公共节点"></a>51.<a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">两个链表的第一个公共节点</a></h2><p>思路：最简单的方法是暴力比较，时间复杂度较高。可以考虑哈希表辅助比较，但是空间复杂度较高。最好的办法是双指针法，指针P指向headA，指针Q指向headB，二者同时向后遍历，如果P到达终点，那么让他重新从headB开始；如果Q到达终点，那么让他重新从headA开始，最终二者必然相遇。</p><p>双指针法原理是： 若相交，链表A： a+c, 链表B : b+c。 a+c+b+c = b+c+a+c ，则会在公共处c起点相遇。若不相交，a +b = b+a 。因此相遇处是NULL 。</p><ul><li>时间复杂度：$O(m+n)$。</li><li>空间复杂度：$O(1)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> headA<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> headB<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        p<span class="token operator">=</span>headA        q<span class="token operator">=</span>headB        <span class="token keyword">while</span> p<span class="token operator">!=</span>q<span class="token punctuation">:</span>            p<span class="token operator">=</span>headB <span class="token keyword">if</span> p<span class="token operator">==</span>None <span class="token keyword">else</span> p<span class="token punctuation">.</span>next            q<span class="token operator">=</span>headA <span class="token keyword">if</span> q<span class="token operator">==</span>None <span class="token keyword">else</span> q<span class="token punctuation">.</span>next        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="52-I-在排序数组中查找数字-I"><a href="#52-I-在排序数组中查找数字-I" class="headerlink" title="52.I. 在排序数组中查找数字 I"></a>52.<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">I. 在排序数组中查找数字 I</a></h2><p>思路：我们首先肯定想到的是顺序遍历数组，但那样无法获取log级别的时间复杂度。为了优化，我们使用二分的思想，与主站34题类似，先二分查找该数字第一次出现的位置，再二分查找其最后一次出现的位置，最后返回差值即可。</p><ul><li>时间复杂度：$O(logN)$。</li><li>空间复杂度：$O(1)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">searchLeftBound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            left<span class="token operator">=</span><span class="token number">0</span>            right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>                mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">>=</span>target<span class="token punctuation">:</span>                    right<span class="token operator">=</span>mid<span class="token number">-1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>left<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> left            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">def</span> <span class="token function">searchRightBound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            left<span class="token operator">=</span><span class="token number">0</span>            right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>                mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token punctuation">:</span>                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    right<span class="token operator">=</span>mid<span class="token number">-1</span>            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> right            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        leftBound<span class="token operator">=</span>searchLeftBound<span class="token punctuation">(</span><span class="token punctuation">)</span>        rightBound<span class="token operator">=</span>searchRightBound<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> leftBound<span class="token operator">></span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> rightBound<span class="token operator">-</span>leftBound<span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="53-II-0～n-1中缺失的数字"><a href="#53-II-0～n-1中缺失的数字" class="headerlink" title="53.II. 0～n-1中缺失的数字"></a>53.<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">II. 0～n-1中缺失的数字</a></h2><p>思路：首先我们想到的是顺序遍历检查下标，但这样依然是线性的时间复杂度。为了优化至对数级别的时间复杂度，我们还是使用二分的方法，如果中位数与下标相等，说明它及它之前的所有数都不缺失，进入右区间查找缺失的数字，否则进入左区间查找。最后返回Left，为什么是left可以自己模拟一下。当最后的left等于len（nums）时，说明当前数组所有的数字均不缺失。</p><ul><li>时间复杂度：$O(logN)$。</li><li>空间复杂度：$O(1)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>mid<span class="token punctuation">:</span>                left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                right<span class="token operator">=</span>mid<span class="token number">-1</span>        <span class="token keyword">return</span> left<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54.二叉搜索树的第k大节点"></a>54.<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">二叉搜索树的第k大节点</a></h2><p>思路：与数组中求第（前）k大（小）是一样的，两种思路：（1）堆，（2）快速选择。这里我们由于事先没有完整的数据，需要进行二叉树的遍历，所以使用堆更好。在这里我们使用大小为k的小顶堆存放前k大的数。</p><ul><li>时间复杂度：$O(NlogK)$。</li><li>空间复杂度：$O(K)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">kthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>k<span class="token operator">=</span>k        heap<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>heap<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>k<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>k<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            preOrder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            preOrder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        preOrder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> heap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，我们发现这棵树是二叉查找树，即每个节点的左子树都小于它，右子树都大于它，中序遍历得到的序列为所有元素的升序排列。我们可以稍加修改，中序遍历从左-根-右修改成右-根-左，即把遍历的结果变为所有元素的降序排列。然后我们使用一个计数变量，当遍历k次时，输出结果即可。</p><ul><li>时间复杂度：$O(K)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">kthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>k<span class="token operator">=</span>k        self<span class="token punctuation">.</span>res<span class="token operator">=</span>None        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None <span class="token operator">and</span> self<span class="token punctuation">.</span>res<span class="token operator">==</span>None<span class="token punctuation">:</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>k<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>k<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>res<span class="token operator">=</span>root<span class="token punctuation">.</span>val                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="55-I-二叉树的深度"><a href="#55-I-二叉树的深度" class="headerlink" title="55.I. 二叉树的深度"></a>55.<a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">I. 二叉树的深度</a></h2><p>思路：二叉树操作中的基本题目，递归求解，如果当前节点为空，那么当前深度为0，否则当前深度为1加上左右子树的深度的最大值。层层返回深度，根节点的深度即为二叉树的深度。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(N)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="56-II-平衡二叉树"><a href="#56-II-平衡二叉树" class="headerlink" title="56.II. 平衡二叉树"></a>56.<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">II. 平衡二叉树</a></h2><p>思路：DFS，同时使用辅助函数计算当前深度，如果当前左右子树均平衡，且他们的深度之差小于等于1，则说明当前二叉树平衡。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> match<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> match<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">and</span> abs<span class="token punctuation">(</span>depth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token operator">-</span>depth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">1</span>        <span class="token keyword">def</span> <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>max<span class="token punctuation">(</span>depth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span>depth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> match<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化：上述算法求解子树深度时会出现很多重复的计算，可以进行优化。</p><ul><li>当前节点为空：当前树满足平衡二叉树的要求，且深度为0，返回0。</li><li>当前节点左子树或右子树不是平衡二叉树：返回-1。</li><li>否则：如果左子树和右子树深度差小于等于1，说明当前树是平衡二叉树，返回当前树的深度，否则，返回-1。</li></ul><p>减少了对树深度的重复求解，使子树可以返回深度信息，不用重新遍历整个树求深度了。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>            left <span class="token operator">=</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> left <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            right <span class="token operator">=</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> right <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">return</span> max<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> abs<span class="token punctuation">(</span>left <span class="token operator">-</span> right<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="57-I-数组中数字出现的次数"><a href="#57-I-数组中数字出现的次数" class="headerlink" title="57.I. 数组中数字出现的次数"></a>57.<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">I. 数组中数字出现的次数</a></h2><p>思路：如果想要获得线性的时间复杂度和常数级的空间复杂度，这一类题我们只能使用位运算。</p><p>python的位运算：</p><blockquote><p>&amp;：按位与操作，只有 1 &amp;1 为1，其他情况为0。可用于进位运算。</p><p>|：按位或操作，只有 0|0为0，其他情况为1。</p><p>~：逐位取反。</p><p>^：异或，相同为0，相异为1。可用于加操作（不包括进位项）。</p><p>&lt;&lt;：左移操作，2的幂相关</p><p>&gt;&gt;：右移操作，2的幂相关</p></blockquote><ul><li>假如本题简化为： 除了一个数字出现一次，其他都出现了两次，让我们找到出现一次的数。 </li><li>解决方案：使用按位异或运算，由于任何数异或自己本身得到的是0，任何数异或0得到的是自己本身，所以我们可以对数组中全部的数字执行全员异或。假设全部数字两两出现，那么每一个二进制位上的1和0出现的个数必然是偶数，异或的结果必然是0，最后再异或上出现一次的数字的该二进制位的值，会保留这个值。最终全员异或的结果必是出现了一次的数。</li><li>补充：异或满足交换律，17 xor 19 xor 17 相当于 17 xor 17 xor 19 = 0 xor 19 = 19 。</li><li>这里把其他出现了两次修改为任何的偶数次，都可以全员异或求解。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        single_number <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            single_number <span class="token operator">^</span><span class="token operator">=</span> num        <span class="token keyword">return</span> single_number<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>那么假如我们将偶数次再扩展为任意次，那么对于奇数次如何求解呢？即问题变为： 除了一个数字出现一次，其他都出现了三次，让我们找到出现一次的数。 </li><li>解决方案：依然可以使用位运算。统计二进制编码每一位上1出现的次数，假设所有数字都出现了3次，那么每一位上的1必然出现了3的倍数次（包括0）。考虑到出现了一次的数，如果某一位上1出现的次数不是3的倍数，那么出现了一次的数的二进制编码在这一位上必然是1。根据上述性质，便可求解出现了一次的数的二进制编码，转回十进制即可。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            cnt <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 记录当前 bit 有多少个1</span>            bit <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i  <span class="token comment" spellcheck="true"># 记录当前要操作的 bit</span>            <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>                <span class="token keyword">if</span> num <span class="token operator">&amp;</span> bit <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                    cnt <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> cnt <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 不等于0说明唯一出现的数字在这个 bit 上是1</span>                res <span class="token operator">|</span><span class="token operator">=</span> bit        <span class="token keyword">return</span> res <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token number">32</span> <span class="token keyword">if</span> res <span class="token operator">></span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token number">31</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">else</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>注：这里的返回值是因为python的机制问题，补码上表示符号的位会被解释为数值位。要手动将其变为正确的结果。</p></li><li><p>了解完上述两道题，我们大致知道了使用位运算求解数组中出现次数特殊的数字。回到本题，本题的思路看上去和上面举的第一个例子十分类似。我们已经知道了如何求解一个数组中一个数字出现一次，其他都出现了两次的解法。为了解决当前问题，我们可以把数组划分为两个数组，每个数组中一个数字出现一次，其他都出现了两次。</p></li><li><p>如何划分：同样将整个数组异或，异或之后，得到一个数字，这个数字从二进制数的角度看，一定有位数为1。这个1是怎么来的？就是那两个只出现一次的数字，异或得到的，他们对应的位不一样，肯定是一个数对应位数出现的是0，另一个数字对应位置上出现的数字是1.据此，将这个数组分成两个部分。一部分是，对应位置出现的数是0的数组，一部分是，对应位置出现的数是1的数组，此时，这两个数组满足我们第一个例题提到的要求，我们对其分别进行全局异或，即可得到两个数字。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        result1<span class="token punctuation">,</span>result2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        tmp<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            tmp<span class="token operator">^</span><span class="token operator">=</span>num        n<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>tmp<span class="token operator">&amp;</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            n<span class="token operator">=</span>n<span class="token operator">&lt;&lt;</span><span class="token number">1</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> num<span class="token operator">&amp;</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#注意：这里不能判断其是否等于1，否则会出错。要判断其是否与运算后还是n或0。</span>                result1<span class="token operator">^</span><span class="token operator">=</span>num            <span class="token keyword">else</span><span class="token punctuation">:</span>                result2<span class="token operator">^</span><span class="token operator">=</span>num        <span class="token keyword">return</span> <span class="token punctuation">[</span>result1<span class="token punctuation">,</span>result2<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="58-II-数组中数字出现的次数-II"><a href="#58-II-数组中数字出现的次数-II" class="headerlink" title="58.II. 数组中数字出现的次数 II"></a>58.<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">II. 数组中数字出现的次数 II</a></h2><p>思路：上一题思路中的第二个例子，给出了解法。基本思路就是使用移位+与运算，统计所有数字每一位上1出现的总次数，假如某一位上1出现的总次数不为3的倍数，说明多出来的数字在这一位上取1。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            count<span class="token operator">=</span><span class="token number">0</span>            n<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i            <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>                <span class="token keyword">if</span> num<span class="token operator">&amp;</span>n<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                    count<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> count<span class="token operator">%</span><span class="token number">3</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                result<span class="token operator">|</span><span class="token operator">=</span>n        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="59-和为s的两个数字"><a href="#59-和为s的两个数字" class="headerlink" title="59.和为s的两个数字"></a>59.<a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">和为s的两个数字</a></h2><p>思路：主站n数之和的简化版，使用双指针法从两侧逼近结果，同时逼近时可以注意跳过重复的数字，减少计算量。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token operator">==</span>left<span class="token punctuation">)</span><span class="token punctuation">:</span>                    left<span class="token operator">+=</span><span class="token number">1</span>                left<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token number">-1</span><span class="token operator">==</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>                    right<span class="token operator">-=</span><span class="token number">1</span>                right<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="60-II-和为s的连续正数序列"><a href="#60-II-和为s的连续正数序列" class="headerlink" title="60.II. 和为s的连续正数序列"></a>60.<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">II. 和为s的连续正数序列</a></h2><p>思路：这道题，我们一开始可能会想到数学解法或者暴力解法，事实上并不需要那么做。我们可以使用滑动窗口法来求解。</p><p>我们使用两个指针left和right维护一个在[1，n]的连续整数区间上滑动的窗口。特别地，我们发现，由于题目要求的正数序列连续且至少含两个数，那么滑动窗口中最大的数不能超过（n+1）//2，所以我们滑动的区间可以缩小为[1，（n+1）//2]。开始时，left=1，right=2，然后right顺序向左滑动，如果当前区间和等于s，则可以将当前区间加入到结果中，如果当前区间和大于s，那么我们要收缩左边界至区间和小于等于s，特别地，如果此时区间和等于s，我们也要把当前区间加入到结果中。如果当前区间和小于s，那么继续右边界向右滑动。当右边界到达终点时，结束滑动。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findContinuousSequence</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        left<span class="token operator">=</span><span class="token number">1</span>        sum<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> right <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">(</span>target<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            sum<span class="token operator">+=</span>right            <span class="token keyword">if</span> sum<span class="token operator">==</span>target<span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">elif</span> sum<span class="token operator">></span>target<span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>sum<span class="token operator">></span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>                    sum<span class="token operator">-=</span>left                    left<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> sum<span class="token operator">==</span>target<span class="token punctuation">:</span>                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="61-I-翻转单词顺序"><a href="#61-I-翻转单词顺序" class="headerlink" title="61. I. 翻转单词顺序"></a>61.<a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/" target="_blank" rel="noopener"> I. 翻转单词顺序</a></h2><p>思路：如果用python的字符串方法split（）+join（）来做的话很简单。自己实现的话主要就是先判断一下每个单词的边界：（1）每个单词的首字符不为空格，且要么是句子的第一个字符，要么前一个字符为空格（2）每个单词的尾字符不为空格，且要么是句子的最后一个字符，要么后一个字符为空格。每找到一对边界后，将字符串切片得到的单词加入单词列表，并调用join函数拼接他们。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseWords</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        start<span class="token operator">=</span><span class="token number">0</span>        end<span class="token operator">=</span><span class="token number">0</span>        words<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">' '</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> <span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    start<span class="token operator">=</span>i                <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">or</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    end<span class="token operator">=</span>i                    words<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">[</span>start<span class="token punctuation">:</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>words<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，还可以进行两次翻转。先将整个字符串进行翻转，再对每个单词进行翻转。</p><h2 id="62-II-左旋转字符串"><a href="#62-II-左旋转字符串" class="headerlink" title="62. II. 左旋转字符串"></a>62.<a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank" rel="noopener"> II. 左旋转字符串</a></h2><p>思路：python如果使用字符串的切片将非常简单，更复杂的解法有两种：</p><ul><li>三次翻转。先将s[:k]翻转，再将s[k:]翻转，最后将整个字符串翻转。</li><li>空间换时间。直接拼接两个s为ss，取ss[k:k+(len(s))]即可。</li><li>模运算。类似于动态规划中滚动数组和顺序表队列插入的思想。设i从k到k+len（s），i对len（s）求模。节约了空间。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseLeftWords</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        res<span class="token operator">=</span><span class="token string">""</span>        l<span class="token operator">=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">,</span>n<span class="token operator">+</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token operator">+=</span>s<span class="token punctuation">[</span>i<span class="token operator">%</span>l<span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="63-I-滑动窗口的最大值"><a href="#63-I-滑动窗口的最大值" class="headerlink" title="63. I. 滑动窗口的最大值"></a>63.<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener"> I. 滑动窗口的最大值</a></h2><p>思路：这题表面看可以移动窗口并遍历寻找最大值，但实际上时间复杂度太高，为$O(NK)$，不符合要求。为了将时间复杂度降到$O(N)$，我们需要使用一个辅助双向单调队列来做。双向队列中的元素满足：（1）在当前滑动窗口内（2）单调递减。（为什么使用双向队列：因为我们希望在两端都可以取出元素）。每次添加一个新的元素，调整队列的方法为：</p><ul><li>如果当前队尾元素小于新元素，那么新元素入队后，双向队列将不符合单调递减的性质，所以将队尾元素出队，移除队尾所有比当前元素小的元素。（即辅助队列为当前窗口可能的最大值的降序排列）</li><li>如果当前队首元素下标不在窗口内，将其出队。</li></ul><p>我们先用数组的前k个元素建立该队列，然后每次滑动窗口时添加一个元素并调整队列，当前队列的首元素即为当前窗口中的最大值。在这里，我们在队列中存放下标而非实际的值，这样方便我们判断元素是否在窗口内。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(K)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> nums<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">or</span> k<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">change_queue</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span>nums<span class="token punctuation">[</span>queue<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>i<span class="token operator">-</span>k<span class="token punctuation">:</span>                queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>            change_queue<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        result<span class="token operator">=</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            change_queue<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，我使用了python的列表来模拟一个双向队列，实际上python的collections库提供了许多封装的数据结构，双向队列为deque。</p><h2 id="64-II-队列的最大值"><a href="#64-II-队列的最大值" class="headerlink" title="64. II. 队列的最大值"></a>64. <a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">II. 队列的最大值</a></h2><p>思路：和63题思路基本一致，使用一个辅助双向单调递减队列存放可能的最大值，每次有新元素入队时，调整队列；每次有元素出队时，如果该元素是当前队列最大元素，那么辅助队列也要进行pop，调整为下一个最大的元素。其实这道题本质上和上一道题是一样的，上一题你可以看作是本题的一种特殊情况：先不断让元素入队，达到窗口大小K之后，每次让新元素入队，队首元素出队。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MaxQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>dequeue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">max_value</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>dequeue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">if</span> self<span class="token punctuation">.</span>dequeue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">push_back</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>dequeue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>dequeue<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>value<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#这里与63题不一样，是小于，因为无法用下标来判断是否出队，索性保留重复的。</span>            self<span class="token punctuation">.</span>dequeue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dequeue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop_front</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>queue<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        res<span class="token operator">=</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> res<span class="token operator">==</span>self<span class="token punctuation">.</span>dequeue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>dequeue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token comment" spellcheck="true"># Your MaxQueue object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MaxQueue()</span><span class="token comment" spellcheck="true"># param_1 = obj.max_value()</span><span class="token comment" spellcheck="true"># obj.push_back(value)</span><span class="token comment" spellcheck="true"># param_3 = obj.pop_front()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="65-n个骰子的点数"><a href="#65-n个骰子的点数" class="headerlink" title="65.n个骰子的点数"></a>65.<a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">n个骰子的点数</a></h2><p>我的最初思路：DFS寻找n个骰子的点数全排列，哈希表记录每种点数和对应的排列数目，最后计算每种点数和的概率即可。时间复杂度为$O(6^n)$。</p><p>编写后，发现时间复杂度太高。再次观察，发现DFS出现了重叠子问题，就像机器人走迷宫的那道题一样。</p><p>解决的方法是采用动态规划。状态矩阵DP[i] [j]为i个骰子掷出j的点数和时的点数排列组合的数目。</p><blockquote><p>转移方程（注意越界）：</p><p>for k in range(1,7):    </p><p>dp[i] [j]=dp[i-1] [j-k]</p></blockquote><ul><li>时间复杂度：$O(N^2)$。</li><li>空间复杂度：$O(N^2)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>float<span class="token punctuation">]</span><span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">6</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> j<span class="token operator">-</span>k<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>k<span class="token punctuation">]</span>        s<span class="token operator">=</span>sum<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> num<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token operator">/</span>s<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，像这种每一个状态的转移仅依赖于之前有限个状态的动态规划，还可以使用滚动数组的方法进行空间上的优化，不必保存完整的状态。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>float<span class="token punctuation">]</span><span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">*</span>i<span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token comment" spellcheck="true">#这里一定要清零！</span>                <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> j<span class="token operator">-</span>k<span class="token operator">>=</span>i<span class="token number">-1</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+=</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>k<span class="token punctuation">]</span>        s<span class="token operator">=</span>pow<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">,</span>n<span class="token operator">*</span><span class="token number">6</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>s<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="66-扑克牌中的顺子"><a href="#66-扑克牌中的顺子" class="headerlink" title="66.扑克牌中的顺子"></a>66.<a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">扑克牌中的顺子</a></h2><p>思路：有两种思路，分别是排序和不排序的思路。</p><ul><li>不排序：遍历扑克牌，如果出现了0，那么跳过；如果当前数字重复，那么返回False；如果当前数字不重复，更新最大值和最小值。最后，如果数组中的最大值减去最小值小于5，那么说明可以组成一个顺子。</li><li>时间复杂度：$O(N)$。遍历一次数组。</li><li>空间复杂度：$O(N)$。哈希表。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isStraight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        max_value<span class="token operator">=</span><span class="token number">0</span>        min_value<span class="token operator">=</span><span class="token number">14</span>        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dic<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>            max_value<span class="token operator">=</span>max<span class="token punctuation">(</span>max_value<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            min_value<span class="token operator">=</span>min<span class="token punctuation">(</span>min_value<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> max_value<span class="token operator">-</span>min_value<span class="token operator">&lt;</span><span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>排序：对扑克牌数组进行升序排序，同时统计0的个数。对于非0的相邻数字，先看它们是否重复，再看它们之间缺失的数是否可以被0代替。例如 [0,0,1,2,5]，2和5间缺失了2个数，此时数组中有两个0，可以填补。填补后记得更新0的数量。</li><li>时间复杂度：$O(NlogN)$。排序。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isStraight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        num_zero<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                num_zero<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>                num_zero<span class="token operator">-=</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span>                <span class="token keyword">if</span> num_zero<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="67-圆圈中最后剩下的数字"><a href="#67-圆圈中最后剩下的数字" class="headerlink" title="67.圆圈中最后剩下的数字"></a>67.<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">圆圈中最后剩下的数字</a></h2><p>思路：这道题我们首先想到的是模拟，但是模拟时间复杂度很高，会超时。我尝试了一些优化的方案，都不行。实际上，这道题是数学问题，经典的约瑟夫环问题。具体推导可见<a href="https://blog.csdn.net/u011500062/article/details/72855826" target="_blank" rel="noopener">https://blog.csdn.net/u011500062/article/details/72855826 </a></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lastRemaining</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">or</span> m <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None        last <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            last <span class="token operator">=</span> <span class="token punctuation">(</span>last <span class="token operator">+</span> m<span class="token punctuation">)</span><span class="token operator">%</span>i        <span class="token keyword">return</span> last<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="68-股票的最大利润"><a href="#68-股票的最大利润" class="headerlink" title="68.股票的最大利润"></a>68.<a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">股票的最大利润</a></h2><p> 思路：买卖股票问题，遍历每一天的股票价格。如果当前价格小于当前历史最低价格时，更新当前历史最低价格。如果当前价格大于当前历史最低价格时，计算当前收益，并更新当前最大收益。即贪心算法。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        min_prices<span class="token operator">=</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        max_profit<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> price <span class="token keyword">in</span> prices<span class="token punctuation">:</span>            min_prices<span class="token operator">=</span>min<span class="token punctuation">(</span>price<span class="token punctuation">,</span>min_prices<span class="token punctuation">)</span>            <span class="token keyword">if</span> price<span class="token operator">></span>min_prices<span class="token punctuation">:</span>                max_profit<span class="token operator">=</span>max<span class="token punctuation">(</span>price<span class="token operator">-</span>min_prices<span class="token punctuation">,</span>max_profit<span class="token punctuation">)</span>        <span class="token keyword">return</span> max_profit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，上述思路其实是动态规划算法的优化版本。我们可以维护一个动态规划状态矩阵DP[i]来记录第i天时，股票的最大利润。DP[i]=max（DP[i-1]，price-min_prices）,有点类似于01背包问题。由于我们仅需要前一天的最大收益，我们之前说过，动态规划的转移仅与之前有限个状态有关时，可以优化空间复杂度。所以我们用一个变量max_profit来存放当前最大收益。</p><h2 id="69-求1-2-…-n"><a href="#69-求1-2-…-n" class="headerlink" title="69.求1+2+…+n"></a>69.<a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">求1+2+…+n</a></h2><p>思路：利用python中的and机制。</p><ul><li>如果多个变量均非0（包括None、False等），那么返回最后一个变量的值。如3 and 2 and ‘a’的返回值为’a’； </li><li>如果多个变量中存在0值，则返回第一个0值。如1 and ‘a’ and 0 and None的返回值为0。 </li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sumNums</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> n <span class="token operator">and</span> n<span class="token operator">+</span>self<span class="token punctuation">.</span>sumNums<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="70-不用加减乘除做加法"><a href="#70-不用加减乘除做加法" class="headerlink" title="70.不用加减乘除做加法"></a>70.<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">不用加减乘除做加法</a></h2><p>思路：位运算</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">:</span> int<span class="token punctuation">,</span> b<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        a <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token number">0xFFFFFFFF</span>        b <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token number">0xFFFFFFFF</span>        <span class="token keyword">while</span> b<span class="token punctuation">:</span>            carry <span class="token operator">=</span> a <span class="token operator">&amp;</span> b            a <span class="token operator">^</span><span class="token operator">=</span> b            b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>carry<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFFFFFFFF</span>        <span class="token keyword">return</span> a <span class="token keyword">if</span> a <span class="token operator">&lt;</span> <span class="token number">0x80000000</span> <span class="token keyword">else</span> <span class="token operator">~</span><span class="token punctuation">(</span>a<span class="token operator">^</span><span class="token number">0xFFFFFFFF</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="71-构建乘积数组"><a href="#71-构建乘积数组" class="headerlink" title="71. 构建乘积数组"></a>71.<a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/" target="_blank" rel="noopener"> 构建乘积数组</a></h2><p>思路：对称运算，由于 <code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code>。且不能使用除法。 那么我们先可以正向累乘，计算nums1[i]=A[0]×A[1]×…×A[i-1]。计算完成后，再反向累乘计算nums2[i]=A[i+1]×…×A[n-1]。最后，将nums1[i]和nums2[i]按位相乘即可得到最终的结果。</p><p>为了减少时空复杂度，我们反向计算A[i+1]×…×A[n-1]时，不需要再开一个数组nums2[i]，直接设置一个临时变量存放A[i+1]×…×A[n-1]，并让他与当前nums1[i]相乘即可得到最终的结果。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(N)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">constructArr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> a<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        tmp<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>res<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>a<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp<span class="token operator">*=</span>a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*=</span>tmp        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="72-把字符串转换成整数"><a href="#72-把字符串转换成整数" class="headerlink" title="72.把字符串转换成整数"></a>72.<a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/" target="_blank" rel="noopener">把字符串转换成整数</a></h2><p>思路：这种规则匹配题，没有捷径，需要细心地把每种情况都列出来加以判断。这里我贴出我一年多以前用JAVA写的代码，写的很臃肿。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    public int myAtoi<span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String newS<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">;</span>        int flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        char c<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span>str<span class="token punctuation">.</span>toCharArray<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>c<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">' '</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'+'</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token operator">|</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        newS<span class="token operator">=</span>newS<span class="token punctuation">.</span>concat<span class="token punctuation">(</span>String<span class="token punctuation">.</span>valueOf<span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">48</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">57</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        newS<span class="token operator">=</span>newS<span class="token punctuation">.</span>concat<span class="token punctuation">(</span>String<span class="token punctuation">.</span>valueOf<span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        flag<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">48</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">57</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    newS<span class="token operator">=</span>newS<span class="token punctuation">.</span>concat<span class="token punctuation">(</span>String<span class="token punctuation">.</span>valueOf<span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    flag<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">57</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    newS<span class="token operator">=</span>newS<span class="token punctuation">.</span>concat<span class="token punctuation">(</span>String<span class="token punctuation">.</span>valueOf<span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newS<span class="token punctuation">.</span>equals<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token operator">|</span><span class="token punctuation">(</span>newS<span class="token punctuation">.</span>equals<span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token operator">|</span><span class="token punctuation">(</span>newS<span class="token punctuation">.</span>equals<span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            long result<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>newS<span class="token punctuation">.</span>length<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>newS<span class="token punctuation">.</span>charAt<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result<span class="token operator">=</span><span class="token operator">-</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>Math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                    result<span class="token operator">=</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>Math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                result<span class="token operator">=</span>Long<span class="token punctuation">.</span>parseLong<span class="token punctuation">(</span>newS<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token operator">&lt;</span><span class="token operator">-</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>Math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result<span class="token operator">=</span><span class="token operator">-</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>Math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token operator">>=</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>Math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result<span class="token operator">=</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>Math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>int<span class="token punctuation">)</span>result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正则表达式解法：</p><blockquote><ul><li><code>^</code>：匹配字符串开头</li><li><code>[\+\-]</code>：代表一个+字符或-字符</li><li><code>?</code>：前面一个字符可有可无</li><li><code>\d</code>：一个数字</li><li><code>+</code>：前面一个字符的一个或多个</li></ul></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">strToInt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> str<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        INT_MAX <span class="token operator">=</span> <span class="token number">2147483647</span>        INT_MIN <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2147483648</span>        s<span class="token operator">=</span> str<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#清除两端空格</span>        res <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>r<span class="token string">'^[\+\-]?\d+'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#正则表达式：匹配位于字符串开头且接下来是一个正号或负号或没有且接下来是1到多个数字</span>        num <span class="token operator">=</span> res<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        nums <span class="token operator">=</span> int<span class="token punctuation">(</span><span class="token operator">*</span>num<span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>min<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">,</span> INT_MIN<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="74-I-二叉搜索树的最近公共祖先"><a href="#74-I-二叉搜索树的最近公共祖先" class="headerlink" title="74.I. 二叉搜索树的最近公共祖先"></a>74.<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">I. 二叉搜索树的最近公共祖先</a></h2><p>思路：递归求解，根据二叉搜索树的性质（每个节点的左子树都小于它，右子树都大于它），当当前节点不为None时：</p><ul><li>如果p、q节点的值均比当前节点的值小，那么它们的祖先必然在当前节点的左子树中。</li><li>如果p、q节点的值均比当前节点的值大，那么它们的祖先必然在当前节点的右子树中。</li><li>否则，它们的祖先必是当前节点。（这里有两种情况，一是当前节点的值位于p、q节点的值中间，说明它们两个节点必然分布在当前节点的左右子树中，当前节点必然是他们的最近祖先。二是当前节点的值等于p或者q节点的值，由于一个节点也可以是它自身的祖先，所以当前节点必然是他们的最近祖先。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">DFS</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> None            <span class="token keyword">if</span> p<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val <span class="token operator">and</span> q<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> DFS<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">elif</span> p<span class="token punctuation">.</span>val<span class="token operator">></span>root<span class="token punctuation">.</span>val <span class="token operator">and</span> q<span class="token punctuation">.</span>val<span class="token operator">></span>root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> DFS<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> root        <span class="token keyword">return</span> DFS<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非递归写法：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val <span class="token operator">and</span> q<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                root<span class="token operator">=</span>root<span class="token punctuation">.</span>left            <span class="token keyword">elif</span> p<span class="token punctuation">.</span>val<span class="token operator">></span>root<span class="token punctuation">.</span>val <span class="token operator">and</span> q<span class="token punctuation">.</span>val<span class="token operator">></span>root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                root<span class="token operator">=</span>root<span class="token punctuation">.</span>right            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> root        <span class="token keyword">return</span> None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="75-II-二叉树的最近公共祖先"><a href="#75-II-二叉树的最近公共祖先" class="headerlink" title="75.II. 二叉树的最近公共祖先"></a>75.<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">II. 二叉树的最近公共祖先</a></h2><p>思路：上一道题的复杂版，我们无法直接通过节点值的大小比较来确定公共祖先的位置，只能通过递归搜索的方法求解。</p><p>这里我们使用后序遍历。</p><ul><li>如果当前节点为空，返回None。</li><li>如果当前节点等于p或者q，返回当前节点。 （一个节点的祖先可以是自身）</li><li>递归遍历左、右子树。</li><li>如果左子树返回的节点为空，说明p、q均不在左子树中，返回右子树找到的节点。</li><li>如果右子树返回的节点为空，说明p、q均不在右子树中，返回左子树找到的节点。</li><li>如果左右子树返回的节点都不为空，说明p、q分布在左右子树中，则当前节点必然是最近的公共祖先。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> q<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None <span class="token operator">or</span> root<span class="token operator">==</span>p <span class="token operator">or</span> root<span class="token operator">==</span>q<span class="token punctuation">:</span>                <span class="token keyword">return</span> root            leftNode<span class="token operator">=</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            rightNode<span class="token operator">=</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> leftNode<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> rightNode            <span class="token keyword">if</span> rightNode<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> leftNode            <span class="token keyword">return</span> root        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：线性模型和对数线性模型</title>
      <link href="/2020/03/17/nlp-zi-xue-bi-ji-xian-xing-mo-xing-he-dui-shu-xian-xing-mo-xing/"/>
      <url>/2020/03/17/nlp-zi-xue-bi-ji-xian-xing-mo-xing-he-dui-shu-xian-xing-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是我在学习苏州大学李正华老师的中文信息处理课程（<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">中文信息处理（Chinese Information Processing）Course Resources</a>）时，对于线性模型和对数线性模型的一些个人见解和思考，同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己对于该模型的理解，如有错误欢迎在评论区指出，非常感谢！</p><h2 id="从问题出发"><a href="#从问题出发" class="headerlink" title="从问题出发"></a>从问题出发</h2><p>与隐马尔可夫模型的讲解类似，我们在这里依旧围绕自然语言处理中的经典问题<strong>词性标注问题</strong>进行讨论和解释。</p><ul><li>给定一个句子X，输出句子中每一个单词对应的词性。</li></ul><p><img src="1.png" alt="词性标注任务"></p><p>与隐马尔可夫模型不同的是，线性模型与对数线性模型将词性标注转化为了一个<strong>多元分类</strong>问题，它们将不再以整个句子序列作为模型的输入，整个句子的词性序列作为模型的输出，而是假设<strong>词语之间的预测相互独立</strong>，将问题转化为<strong>从所有可能的词性类别中选取某个词语最有可能的类别进行输出</strong>。</p><h2 id="什么是线性模型"><a href="#什么是线性模型" class="headerlink" title="什么是线性模型"></a>什么是线性模型</h2><p>线性模型（Linear Model)，又称为<strong>线性回归模型</strong>，是一种<strong>有监督学习模型</strong>。我们曾经在高中的时候学习过一种回归方法——线性回归。将这个方法泛化，就可以得到我们的线性模型。</p><p>我们以吴恩达老师在coursera上的机器学习课程中的房价预测例子进行说明。</p><p><img src="2.png" alt="房价预测"></p><p>如上图所示，假设我们得到了一个当地的房价数据集，其中包括了房子的面积、卧室数、层数、房龄等信息，同时给出了对应的房价。我们需要解决的问题就是如何<strong>利用房子的信息预测出它的价格</strong>。在机器学习中，我们把类似于面积、卧室数等这些样本的信息叫做<strong>样本的特征（Feature）</strong>，它们是我们进行预测的依据。我们把需要预测的值叫做<strong>样本的标签（Label)</strong>。训练集中的每一个样本是一个<strong>（特征，标签)二元组</strong>。</p><p>在机器学习中，样本的特征往往是人工选择的，例如上述的面积、卧室数、层数等房屋信息。如何选择合适的特征是一门高深的学问，我们称其为<strong>特征工程</strong>。特征往往不止一个，所以使用<strong>向量</strong>的形式对其进行表示。在这里，我使用列向量$\vec x=(x_1,x_2…x_n)$来表示特征向量，由于书写列向量不是很方便，所以只能这么书写，但你需要记住$\vec x$是一个列向量。</p><p>当给定某个房子的面积、卧室数、层数、房龄等特征，在线性模型中，我们会使用一个线性方程来计算房子的价格。我们使用$h$表示这个线性方程，$h$代表<strong>hypothesis</strong>(<strong>假设</strong>) ，具体公式如下：<br>$$<br>h_{w}(x)=w_0+w_1x_1+w_2x_2+…+w_nx_n<br>$$<br>我们为每个特征给定一个特征权重$w$，这个权重可以是正数也可以是负数。其中，$w_0$为<strong>偏置项</strong>（bias），专门用来表示方程中的常数项。通过训练样本学习权重$w$，我们便可使用上述方程进行预测。</p><p>为了使公式简洁一些，引入$x_0=1$，使用列向量$\vec w=(w_0,w_1…w_n)$来表示权重向量，则公式转化为：<br>$$<br>h_{w}(x)=w_0x_0+w_1x_1+w_2x_2+…+w_nx_n\<br>=w^Tx<br>$$</p><h2 id="线性模型的泛化"><a href="#线性模型的泛化" class="headerlink" title="线性模型的泛化"></a>线性模型的泛化</h2><p>看到上述的线性方程，你可能会疑惑：上述方程得到的仅仅是一条直线方程，而需要拟合的数据点往往不能通过简单的直线来拟合。换句话说， 如果仅仅使用在此之前的单元和多元线性回归，<strong>我们只能得到多维空间的高维平面</strong>。为了进一步增强泛化能力，我们可以引入<strong>幂次项特征和多项式特征</strong>。 </p><p>例如，我们的模型原先只是一个线性方程：<br>$$<br>h_{w}(x)=w_1x_1+w_2x_2<br>$$<br>为了增强拟合能力，我们可以令$x_3=x_1^2$，$x_4=x_2^2$，$x_5=x_1x_2$。于是，我们的模型将变为：<br>$$<br>h_{w}(x)=w_1x_1+w_2x_2+w_3x_3+w_4x_4+w_5x_5\<br>=w_1x_1+w_2x_2+w_3x_1^2+w_4x_2^2+w_5x_1x_2<br>$$<br>可以看到，此时我们的模型将可以拟合复杂的非线性函数。<strong>也就是说，很多复杂的模型都可以转化为线性模型进行建模。</strong></p><p>但需要注意的是：<strong>过多地使用幂次项特征和多项式特征会使模型的拟合能力太强，从而导致过拟合的问题</strong>。我将专门 写一篇blog来讲解机器学习中的过拟合问题，并介绍一些解决过拟合的办法，如正则化和dropout等。</p><h2 id="线性模型的特征提取"><a href="#线性模型的特征提取" class="headerlink" title="线性模型的特征提取"></a>线性模型的特征提取</h2><h3 id="连续型特征"><a href="#连续型特征" class="headerlink" title="连续型特征"></a>连续型特征</h3><p>特征分为连续型特征和离散型特征。<strong>连续型特征顾名思义就是取值是连续的特征，例如上述例子中的房子面积。</strong>在实际的机器学习过程中， 很少直接将连续值作为线性回归模型和逻辑回归模型的特征输入，而是将连续特征离散化为一系列0、1特征交给模型，这样做的优势有以下几点： </p><ol><li>离散特征的增加和减少都很容易，易于模型的<strong>快速迭代</strong>。</li><li>稀疏向量内积乘法运算<strong>速度快</strong>，计算结果<strong>方便存储，容易扩展</strong>。</li><li>离散化后的特征对异常数据有很强的<strong>鲁棒性</strong>：比如一个特征是年龄&gt;30是1，否则0。如果特征没有离散化，一个异常数据“年龄300岁”会给模型造成很大的干扰。</li><li>线性回归模型和逻辑回归模型属于广义线性模型，表达能力受限；单变量离散化为N个后，每个变量有单独的权重，相当于为模型引入了非线性，<strong>能够提升模型表达能力，加大拟合</strong>。</li><li>离散化后可以<strong>进行特征交叉</strong>，由M+N个变量变为M*N个变量，进一步引入非线性，提升表达能力。</li><li>特征离散化后，模型会更<strong>稳定</strong>，比如如果对用户年龄离散化，20-30作为一个区间，不会因为一个用户年龄长了一岁就变成一个完全不同的人。当然处于区间相邻处的样本会刚好相反，所以怎么划分区间是门学问。</li><li>特征离散化以后，起到了简化模型的作用，降低了模型<strong>过拟合</strong>的风险。</li></ol><h3 id="离散性特征"><a href="#离散性特征" class="headerlink" title="离散性特征"></a>离散性特征</h3><p><strong>离散型特征顾名思义就是取值是离散的特征，例如上述例子中的房龄、卧室数和层数。</strong>对于离散型特征，我们使用一种叫做<strong>one-hot</strong>的方法进行编码。</p><p>one-hot的基本思想：<strong>将离散型特征的每一种取值都看成一种状态</strong>，若你的这一特征中有N个不相同的取值，那么我们就可以将该特征抽象成N种不同的状态，one-hot编码保证了每一个取值只会使得一种状态处于“激活态”，也就是说这N种状态中只有一个状态位值为1，其他状态位都是0。举个例子，假设我们以学历为例，我们想要研究的类别为小学、中学、大学、硕士、博士五种类别，我们使用one-hot对其编码就会得到：</p><blockquote><p>小学-&gt;[1,0,0,0,0]</p><p>中学-&gt;[0,1,0,0,0]</p><p>大学-&gt;[0,0,1,0,0]</p><p>硕士-&gt;[0,0,0,1,0]</p><p>博士-&gt;[0,0,0,0,1]</p></blockquote><p><strong>特别地，如果该离散型特征只有True或False两种取值，那么我们通常用1表示True，0表示False</strong>。</p><h2 id="线性模型的训练过程"><a href="#线性模型的训练过程" class="headerlink" title="线性模型的训练过程"></a>线性模型的训练过程</h2><h3 id="定义优化目标"><a href="#定义优化目标" class="headerlink" title="定义优化目标"></a>定义优化目标</h3><p>当我们写出了假设函数$h$后，接下来我们要做的就是通过已有的训练集得到合适的模型权重$\vec w=(w_0,w_1…w_n)$。</p><p>为了进行权重的训练，首先，我们要定义三个函数：</p><ol><li><strong>损失函数（Loss Function ）</strong>：<strong>单个样本</strong>的预测值和真实值（标签）的误差。</li><li><strong>代价函数（Cost Function ）</strong>：<strong>整个训练集所有样本</strong>的预测值和真实值（标签）的误差，也就是损失函数的平均。</li><li><strong>目标函数（Object Function）</strong>：<strong>最终需要优化的函数</strong>。等于经验风险+结构风险（也就是代价函数 + 正则化项）。</li></ol><p><strong>这里，我们先不讲解正则化的知识，假设我们的目标函数即为代价函数</strong>。那么线性模型的优化问题即为最小化所有样本的误差的平均值。线性模型的误差可以用许多函数来表示，其中比较常用的一种是<strong>均方误差</strong>(Mean squared error) ，这里我们使用均方误差来描述我们的模型误差（PS：更多损失函数可以参考<a href="https://www.jiqizhixin.com/articles/091202" target="_blank" rel="noopener">机器学习中常用的损失函数你知多少？</a>）</p><p>假设训练集中样本的标签为$y$，样本的数量为$m$，预测值为假设函数的输出$h_{w}(x)$，则需要优化的目标函数为：<br>$$<br>J(w)=\frac{1}{2m}\sum_{i=1}^{m}(h_w(x^{(i)})-y^{(i)})^2<br>$$<br>我们的目标便是<strong>选择出可以使得建模误差的平方和能够最小的模型参数</strong>，即<strong>找到合适的模型权重$\vec w$，使$J(w)$取得最小值</strong>。需要注意的是，目标函数中的1/2仅仅是为了方便求导。</p><h3 id="从极大似然估计到损失函数"><a href="#从极大似然估计到损失函数" class="headerlink" title="从极大似然估计到损失函数"></a>从极大似然估计到损失函数</h3><p>在隐马尔可夫模型的讲解中，我曾经说过损失函数和极大似然估计有着紧密的联系，例如<strong>我们在逻辑回归模型里使用的交叉熵损失函数其实就是似然函数加上负号</strong>。也就是说，<strong>最优化问题既可以理解为最大化模型的似然估计，也可以理解为最小化模型的损失函数</strong>。</p><p>为什么会出现这样的现象呢？其实这并不是巧合，是可以通过数学公式进行推导的。具体推导内容可以参考这篇讲义<a href="https://wenku.baidu.com/view/78d16462c9d376eeaeaad1f34693daef5ff713d2.html" target="_blank" rel="noopener">各损失函数与最大似然</a>。</p><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><h4 id="正规方程法"><a href="#正规方程法" class="headerlink" title="正规方程法"></a>正规方程法</h4><p>正规方程法可以用于求解线性模型的目标函数取得最小值时，权重$w$的准确值。但在机器学习中，我们很少使用这种方法求解模型的权重，我在这里简单提一下它的弊端：</p><ol><li>对于一个由$n$个训练样本的特征向量$x$组成的训练集矩阵$X$，计算极值点的时间复杂度为$O(n^3)$，<strong>当训练集规模很大时，正规方程法将变得十分缓慢。</strong></li><li>正规方程法需要使用训练集矩阵$X$的逆矩阵$X^{(-1)}$，但是<strong>我们无法保证$X$一定可逆。</strong></li><li><strong>只适用于线性模型</strong>，不适合逻辑回归模型等其他模型 。</li></ol><h4 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h4><p>我们已经说过，当训练集规模很大时，例如有上百万、上千万的数据时，正规方程法将会非常缓慢，那么有没有办法能够降低时间复杂度呢？答案是有的，我们在这里可以使用<strong>梯度下降法</strong>进行求解。</p><p>为了将问题简化，我们假设模型现在只存在两个特征，对应的权重为$\theta_0$和$\theta_1$。 我们绘制一个等高线图，三个坐标分别为$\theta_0$和$\theta_1$和$J(\theta_0,\theta_1)$： </p><p><img src="3.png" alt="等高线图"></p><p>则可以看出在三维空间中存在一个使得$J(\theta_0,\theta_1)$最小的点，我们可以发现均方差损失函数的图像很明显是一个<strong>凸函数</strong>，即不存在局部最优解的问题。 </p><p>梯度下降法的相当于<strong>我们下山的过程</strong>，每次我们要走一步下山，寻找最低的地方，那么最可靠的方法便是环顾四周，寻找下山速度最快的方向前进，持续该过程，最后便能无限接近最低点。</p><p>对于函数而言，<strong>便是求得该函数对所有参数的偏导（梯度），每次根据梯度更新这些参数，直到参数收敛为止，注意这些参数必须同步进行更新</strong>。 从数学上的角度来看，梯度的方向是函数增长速度最快的方向，那么梯度的反方向就是函数减少最快的方向。那么，如果想计算一个函数的最小值，就可以使用梯度下降法的思想来做。 </p><p>假设模型共有$n$个特征，加上偏置项的特征$x_0=1$，共有$n+1$个特征。则对于某个权重参数$w_j$进行梯度下降的公式可以表示为：<br>$$<br>w_j=w_j-\alpha\frac{dJ(w)}{dw_j}=w_j-\alpha\frac{1}{m}\sum^{m}_{i=1}(h_w(x^{(i)})-y^{(i)})x_j^{(i)}<br>$$<br>其中，<strong>$\alpha$是一个由我们自己设置的超参数（hyper parameter）——学习率</strong> （<strong>learning rate</strong>），它决定了我们沿着能让目标函数下降程度最大的方向向下迈出的步子有多大。 </p><p>梯度下降的过程形象表示便是如下图所示，一步一步下降达到最低点。</p><p> <img src="3.jpg" alt="梯度下降的直观表示"></p><p>需要说明以下几点：</p><ul><li><p>$\alpha$为学习率，学习率决定了学习的速度，<strong>我们需要选择合适的学习率</strong>。</p><ul><li><p>如果$\alpha$过小，那么学习的时间就会很长，导致算法的低效。</p></li><li><p>如果$\alpha$过大，那么由于每一步更新过大，可能无法收敛到最低点。由于越偏离最低点函数的导数越大，如果$\alpha$过大，某一次更新直接跨越了最低点，来到了比更新之前<strong>更高</strong>的地方。那么下一步更新步会更大，如此反复震荡，离最低点越来越远。</p></li><li><p>以上两种情况如下图所示 ：</p><p><img src="2.jpg" alt></p></li></ul></li><li><p><strong>我们的算法不一定能达到最优解</strong>。 但是由于线性回归模型中的函数都是<strong>凸函数</strong>,所以利用梯度下降法，是可以找到全局最优解的，在这里不详细阐述。 </p></li><li><p>我们这里得到的是<strong>数值解</strong>而非解析解，存在着一定误差。</p></li></ul><p>顺便说一下，我这里举例的是<strong>批量梯度下降（batch gradient descent,BGD）</strong>，即尝试将<strong>所有样本</strong>的误差优化到最小。这种方法的优点是每次下降都是朝着全局最优的方向前进。但是，我们发现它每次都要计算所有样本的损失，这在大批量数据的情况下会非常缓慢。</p><p>还有一种梯度下降的方法叫做<strong>随机梯度下降法（ Stochastic gradient descent）</strong>，它每次选取<strong>一个随机样本</strong>，尝试优化它的损失函数。虽然随机梯度下降法每次下降是朝着局部最优的方向前进，无法保证全局的优化，但整体而言，它的下降方向还是朝着全局最优点前进的。与此同时，它的计算量相较于批量梯度下降大大减少了。</p><p>此外，还有一种方法叫做<strong>小批量梯度下降法（mini-batch gradient descent）</strong>，这是现在最为常用的一种梯度下降学习法，它是BGD和SGD的折中。它每次尝试优化一个mini-batch-size数量的样本，即减少了运算量，又降低了梯度下降方向出错的可能性。</p><h3 id="过拟合与正则化"><a href="#过拟合与正则化" class="headerlink" title="过拟合与正则化"></a>过拟合与正则化</h3><p>在前面我们提到了可以通过引入<strong>幂次项特征和多项式特征</strong>来增加模型的拟合能力。但是，模型的拟合能力过强有时候并不是一件好事。下面，我将介绍线性回归模型中的<strong>过拟合 (over-fitting) 问题</strong>。</p><p>首先，我们给出过拟合的定义：</p><blockquote><p>在统计学中，过拟合（英语：overfitting，或称过度拟合）现象是指在拟合一个统计模型时，使用过多参数。对比于可获取的数据总量来说，一个荒谬的模型只要足够复杂，是可以完美地适应数据。过拟合一般可以视为违反奥卡姆剃刀原则。当可选择的参数的自由度超过数据所包含信息内容时，这会导致最后（拟合后）模型使用任意的参数，这会减少或破坏模型一般化的能力更甚于适应数据。过拟合的可能性不只取决于参数个数和数据，也跟模型架构与数据的一致性有关。此外对比于数据中预期的噪声或错误数量，跟模型错误的数量也有关。 </p></blockquote><p>通俗的说，过拟合问题的本质是<strong>我们模型的学习能力太强，导致过于强调拟合训练集的样本，从而丢失了泛化的能力</strong>。当模型出现了过拟合的问题，它虽然能非常好地适应我们的训练集，但在新输入变量进行预测时可能会效果不好 。</p><p>我们借用吴恩达老师coursera课程中的PPT来描述过拟合、欠拟合、好的拟合三种情况。</p><p><img src="4.png" alt="拟合的情况"></p><p>在这里，我尝试用一个易于理解的例子来解释上述三种情况：</p><blockquote><p>我们可以把学生做练习题的过程看成是模型的训练过程，学生在做了很多练习题后，可以参加考试了，我们可以把考试看作为模型的预测过程。欠拟合很简单，就是平时不认真学习，做练习题和参加考试的分数自然都很低，也就是训练集和测试集的准确率都很低。那么过拟合是什么呢？过拟合就是平时只知道死记硬背，仅仅记住了练习题，却不知道举一反三，虽然平时作业分数很高，但是考试成绩却并不好，也就是训练集准确率很高，但测试集准确率很低。最佳的情况就是既认真做练习，又不局限于练习题，这种就是我们虽说的拟合较好的情况。</p></blockquote><p>为了解决过拟合的问题，我们应该引入一个<strong>参数项</strong>，<strong>在进行梯度下降的时候尽可能使得参数变小</strong>，这样可以使得很多额外的特征的权重接近于0。 这个方法也叫做<strong>正则化</strong>（regularization）。此外，还有一些防止过拟合的办法，例如神经网络中的dropout等，我会在接下来的博客中继续为大家介绍。</p><p>正则化中的参数项一般也叫做正则项，常用的正则项有以下两种：</p><ul><li>L1正则项：各个权重的<strong>绝对值之和</strong>，可以产生稀疏权值矩阵，即产生一个稀疏模型，可以用于<strong>特征选择</strong> 。同时，一定程度上 也可以防止过拟合 。</li><li>L2正则项：各个权重的<strong>平方和</strong>，可以防止模型过拟合（overfitting）。</li></ul><p>线性模型和对数线性模型中，我们通常采用的是L2正则项。加入正则项后，模型的代价函数变为：<br>$$<br>J(w)=\frac{1}{2m}[\sum_{i=1}^{m}(h_w(x^{(i)})-y^{(i)})^2+\lambda\sum_{j=1}^{n}w^2]<br>$$<br>梯度下降的公式变为：<br>$$<br>w_j=w_j-\alpha\frac{dJ(w)}{dw_j}=w_j-\alpha\frac{1}{m}\sum^{m}_{i=1}[(h_w(x^{(i)})-y^{(i)})x_j^{(i)}+\lambda w_j]<br>$$<br>我们可以发现，通过引入正则化项，可以使模型的所有参数在梯度下降时多下降一些，从而尽可能地减小。上式中，$\lambda$是一个用于控制正则化程度的超参数，我们一般称其为<strong>正则化系数</strong>，如果$\lambda$过大，则所有权重将趋近于0， 这样我们所得到的只能是一条平行于x轴的直线 。 所以对于正则化，我们要取一个合理的$\lambda$的值 。超参数的选择是机器学习中最为常见的问题，我们一般使用<strong>开发集</strong>进行调参。</p><p>顺便提一下，过拟合的情况下，增加训练集的样本数量将会使模型的性能得到提升。在当今这个海量数据的时代，数据是容易获得的，所以深度学习的常见做法是训练出一个拟合能力很强（层数深、神经元多）的神经网络，加上大规模的训练样本，再加上一些正则化的方法，所得出的模型通常性能最好。</p><h2 id="回到词性标注问题上来"><a href="#回到词性标注问题上来" class="headerlink" title="回到词性标注问题上来"></a>回到词性标注问题上来</h2><p>相信通过前面的介绍，你已经对线性模型有了基本的认识，下面我们回到词性标注任务上，简单地介绍一下如何基于多元分类的思想使用线性回归模型进行词性标注。</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>在我们之前的介绍中，你可能会发现，线性模型主要是用于解决机器学习中的<strong>回归（regression）问题</strong>。也就是说，它预测的最终结果通常是连续值。虽然与对数线性模型相比，线性模型不常用于<strong>分类（classification）</strong>，但在介绍对数线性模型之前，我们仍可以通过一些方法使其运用在分类标注词性上。</p><p>最基本的思想就是，<strong>我们通过选取词语的一些特征，训练出一个线性模型，模型的输出为该词语标注为各词性的分值（score），然后我们选取分值最大的词性作为预测的结果。</strong>通过这一转化，我们将线性回归模型运用在了分类问题上。</p><h3 id="特征获取"><a href="#特征获取" class="headerlink" title="特征获取"></a>特征获取</h3><p>与之前预测房价的例子不同，词性标注模型的特征不是事先定义好的，而是通过<strong>特征模板（feature template）</strong>在训练集中抽取而来的。特征模板需要专家进行手工的定义。目前，学术界常用的用于词性标注的特征模板如下表所示。</p><p><img src="5.png" alt="特征模板"></p><p>可以看到，我们一共使用了14种特征模板，其中包含了许多有用的信息，例如词信息，字信息，词缀信息等等。</p><p>在实际训练过程中，我们需要先构建<strong>特征空间（feature space）</strong>。它是训练集中所有特征的集合。<strong>构建的方式是：我们每次选取一个词，根据特征模板抽取相应的14种特征，并将其加入到特征空间内。需要注意的是特征空间中不能出现重复的特征。</strong></p><p>在这里，我们还可以对特征抽取进行优化。我们观察特征模板可以发现，<strong>对于每个样本，每一种特征的模板都需要抽取每一种词性的特征，而对于所有不同的词性，其特征模板的后缀都是相同的</strong>。通过计算机中经常使用的<strong>段加偏移</strong>的思想，我们可以大大减少构建特征空间所耗费的时间，将时间复杂度由$O(MN)$降为$O(M+N)$。具体的优化操作不再赘述，大家可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/9-linear-model/main2.pdf" target="_blank" rel="noopener">李老师的讲义</a>。</p><p>我在这里画出了这个线性模型的示意图，你应该就能理解为什么它的特征空间可以用二维矩阵的方式来存储，以及它是如何工作的。</p><p><img src="6.png" alt="词性标注的线性模型"></p><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>对于模型的训练，我们将采用一种叫做<strong>在线学习（Online training）</strong>的方式。这是一种经常用于<strong>推荐系统</strong>的学习算法，方便对模型进行实时训练。你可以把它看作是一种近似于我们之前所提到的随机梯度下降法的学习算法。它每次选取<strong>一个实例</strong>进行训练。由于样本的标签是经过one-hot处理的离散值，而我们模型的输出是取值范围在负无穷到正无穷 ，所以我们在这里无法使用前述的梯度下降算法进行参数的训练。取而代之的是如下的算法。</p><p><img src="7.png" alt="Online Training"></p><p>简单的讲解一下，可以看到，我们每次选取一个样本进行训练，如果该样本预测正确，那么不修改模型的参数，否则，将该样本与正确词性关联的特征权重全部加1，与错误词性关联的特征权重全部减1。你可以看作是<strong>给预测正确词性的特征一个激励，而给预测错误词性的特征一个惩罚</strong>。</p><p>特别地，我们在这里还可以使用上图中$v$作为模型特征权重，这叫做<strong>averaged perceptron</strong>，我经过实验发现使用$v$确实比$w$更好。有关学习算法的优化问题我将专门撰写一篇博客，介绍常见的优化算法，如momentum算法，RMsprop算法和Adam算法的数学原理等。</p><h2 id="什么是对数线性模型"><a href="#什么是对数线性模型" class="headerlink" title="什么是对数线性模型"></a>什么是对数线性模型</h2><p>回顾一下我们之前介绍的线性模型，它可以将词性标注转化为一个多分类问题，通过给当前词标注为每种词性的情况进行打分，并选择分值最高的词性作为当前词的标注结果，从而进行词性预测。但这样做其实存在着一些弊端：</p><ol><li><strong>一些极端值可能会大大影响分类的效果。</strong></li><li>对于分类问题，$y$取值为 0 或者1，但如果你使用的是线性模型，那么假设函数的输出值可能远大于 1，或者远小于0，即使所有训练样本的标签都等于 0 或 1。尽管我们知道标签应该取值0 或者1，但是如果算法得到的值远大于1或者远小于0的话，就会感觉很奇怪。<strong>同时，我们也就无法使用损失函数进行梯度下降优化。</strong></li></ol><p>为了解决上述问题，我们可以使用<strong>对数线性模型（log-linear model）</strong>，或许它的另一个名称更为常用，也可以叫做<strong>逻辑回归模型（logistic regression model）</strong>，不过似乎人们在使用逻辑回归模型时，默认解决的是二分类问题，这里我们称之为<strong>多分类的逻辑回归模型</strong>似乎更合适。</p><p>对数线性模型主要做的就是<strong>将线性模型输出的分值使用非线性函数映射到[0，1]区间上，即将分值转化为概率</strong>，这种形式大大减少了极端值的影响，同时概率应用在分类问题上也更易于理解，我们也可以通过样本的真实标签和预测概率定义目标函数，从而使用梯度下降法进行模型训练。</p><h2 id="从线性模型到对数线性模型"><a href="#从线性模型到对数线性模型" class="headerlink" title="从线性模型到对数线性模型"></a>从线性模型到对数线性模型</h2><p>为了将分值转化为概率，我们需要使用一些非线性函数进行映射。<strong>比较常用的两种函数分别为：Sigmoid函数和Softmax函数，前者用于二分类的对数线性模型中，而后者用于多分类的对数线性模型中。</strong>顺便提一下，在深度学习中，Sigmoid和Softmax是最为常用的几种<strong>激活函数（activation function）</strong>之一，他们为神经网络增加了非线性特征，从而使神经网络的表达能力大大增强。与此同时，他们也经常是分类任务的神经网络输出层的首选激活函数，其在输出层的作用和在对数线性模型中的作用是一样的，即将分布在任意区间内的分值转化为[0，1]上的概率。</p><h3 id="Sigmoid函数（二分类问题）"><a href="#Sigmoid函数（二分类问题）" class="headerlink" title="Sigmoid函数（二分类问题）"></a>Sigmoid函数（二分类问题）</h3><p>我们使用$z$来表示原先的线性模型的假设函数输出（注意：你可能会在别的地方看到式子的最后加上了偏差项$b$，我在这里没有将偏差项特别拎出来，而是为特征向量额外添加了一个维度$x_0=1$，来和权重$w_0$共同表示偏差）：<br>$$<br>z=w^Tx<br>$$<br>则Sigmoid函数的形式为：<br>$$<br>g(z)=\frac{1}{1+e^{-z}}<br>$$<br>可以看到，它的函数图像如下：</p><p><img src="4.jpg" alt="Sigmoid"></p><p> 可以很明显的看出，该函数将<strong>实数域映射成了[0,1]的区间</strong> ，无论线性模型的输出是什么，我们都可以将其转化为[0，1]上的值，也就是概率。</p><p>所以，加入了Sigmoid函数后，对数线性模型的假设函数变为：<br>$$<br>h_w(x)=g(z)=\frac{1}{1+e^{-z}}=\frac{1}{1+e^{-w^Tx}}<br>$$</p><h3 id="Softmax函数（多分类问题）"><a href="#Softmax函数（多分类问题）" class="headerlink" title="Softmax函数（多分类问题）"></a>Softmax函数（多分类问题）</h3><p>我们依然使用$z$来表示原先的线性模型的假设函数输出，由于多分类问题每个样本会输出多个概率值，每个概率值都是该样本标注为某个词性的概率，我们使用$z_i$来表示当前样本被标注为第$i$种词性的分值，共有$n$种词性。则Softmax函数的形式为：<br>$$<br>g(z_i)=\frac{e^{z_i}}{\sum_{j=1}^{n}{e^{z_j}}}<br>$$<br>所以，加入了Softmax函数后，对数线性模型的假设函数变为：<br>$$<br>h_w(x_i)=g(z_i)=\frac{e^{z_i}}{\sum_{j=1}^{n}{e^{z_j}}}=\frac{e^{w^T_ix}}{\sum_{j=1}^{n}{e^{w^T_jx}}}<br>$$<br>我们发现，该函数实际上对每一个类别 i 的概率进行了归一化处理，从而保证其范围在[0，1]上，此外，它还保证了对于每一个样本，其标注为每一个类别的条件概率之和为1<strong>（这也是另一种多分类方法One vs All所不能做到的）</strong>。实际上，你还可以推导发现，<strong>Sigmoid函数其实是Softmax函数在类别 n=2 时的特殊形式</strong>。</p><h2 id="对数线性模型背后的数学原理"><a href="#对数线性模型背后的数学原理" class="headerlink" title="对数线性模型背后的数学原理"></a>对数线性模型背后的数学原理</h2><p>事实上，上述两种非线性映射函数并不是科学家们一拍脑袋就定义出来的，他们都是有严格的概率统计学证明的。Sigmoid函数是Softmax函数在二分类时的特殊形式，而Softmax函数可以通过信息论中的<strong>最大熵模型</strong>进行推导。我们根据<strong>求解最大熵函数在给定的约束条件下的极值（使用拉格朗日乘子法）</strong>，可以得到最大熵模型的参数形式，也就是Softmax函数的形式。</p><p>具体证明过程可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/10-maxent-loglinear/main.pdf" target="_blank" rel="noopener">李老师的讲义</a>。</p><h2 id="定义对数线性模型的优化目标"><a href="#定义对数线性模型的优化目标" class="headerlink" title="定义对数线性模型的优化目标"></a>定义对数线性模型的优化目标</h2><p>如果我们在对数线性模型中依然使用线性回归模型的均方差损失函数进行梯度下降，我们将发现<strong>加入了非线性映射函数的均方差损失函数不再是一个凸优化问题，无法保证获得全局最优解</strong>，所以我们需要另寻新的损失函数。</p><p>按照我们惯用的做法，我们依然可以通过<strong>极大化似然估计</strong>的方式来求解对数线性模型的优化目标。</p><blockquote><p><strong>极大似然估计：利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值（模型已定，参数未知）</strong> 。</p></blockquote><p>由于我们的词性标注问题是多分类问题，所以我在这里就推导一下Softmax函数的目标函数，事实上，Sigmoid函数只是它的一种特殊情况。</p><p>我们假设当前词预测为第 i 种词性的概率为$\hat{y_i}$，根据Softmax函数，我们的模型现在是：<br>$$<br>\hat{y_i}=h_w(x_i)=\frac{e^{w^T_ix}}{\sum_{j=1}^{n}{e^{w^T_jx}}}<br>$$<br>我们已知模型的真实概率分布，也就是样本结果信息，即训练集中每一个样本的特征向量和标签。<strong>极大似然估计的目标就是找到一组合适的模型的参数，使得这些样本结果出现的概率最大。</strong>也就是说，对于每一个样本，我们都希望它被标注为正确标签的概率最大。 对于整个训练集，我们当然是期望所有样本的联合概率都达到最大。我们的目标函数，本身是个联合概率，但是假设每个样本独立，那就可以写成连乘形式：<br>$$<br>J(w)=\frac{1}{N}\prod^{N}_{i=1}\prod^{M}_{j=1}(\frac{e^{w^T_jx_i}}{\sum_{k=1}^{M}{e^{w^T_kx_i}}})^{y_{ij}}<br>$$<br>其中，$N$指样本数量，$i$指第几个样本，$M$指类别数量，$j$指第几个类别，$y_{ij}$指第$i$个样本被标注为第$j$个类别的取值是0还是1。</p><p>我们还可以发现，对于每一个样本$i$，其标签都是一个One-hot向量，即只有一个正确标签为1，其余均为0，所以我们可以对上述目标函数进行化简。设$y_{i}$为第$i$个样本的正确标签，则目标函数简化为：<br>$$<br>J(w)=\frac{1}{N}\prod^{N}_{i=1}(\frac{e^{w^T_ix_i}}{\sum_{k=1}^{M}{e^{w^T_kx_i}}})^{y_{i}}<br>$$<br>到了这一步，其实我们就可以使用当前的目标函数进行梯度下降，计算模型参数了。但是，我们发现<strong>连乘的形式会使得我们梯度求解变得很复杂，所以为了简化计算，我们可以对目标函数取对数</strong>：<br>$$<br>logJ(w)=\frac{1}{N}\sum^{N}_{i=1}y_{i}log(\frac{e^{w^T_ix_i}}{\sum_{k=1}^{M}{e^{w^T_kx_i}}})=\frac{1}{N}\sum^{N}_{i=1}y_{i}log\hat{y_i}<br>$$<br>以上就是我们极大化似然估计的目标函数，我们只需要使用梯度上升法对它进行优化即可获得最合适的$w$。此外，<strong>我们也可以加上一个负号，将其转化为最小化损失函数的形式，从而进行梯度下降求解</strong>。<br>$$<br>Loss(w)=-\frac{1}{N}\sum^{N}_{i=1}y_{i}log\hat{y_i}<br>$$<br>上面这个式子就是Softmax对数线性模型的损失函数，它其实就是我们常说的<strong>交叉熵（cross entropy）损失函数</strong>，更多有关交叉熵的知识来自于信息论，我在此就不多加介绍了。</p><p>特别地，如果你根据上述损失函数计算梯度，<strong>你会发现对于同一个特征权重，交叉熵损失函数的梯度居然神奇地和均方差损失函数一致！</strong>可以自己动手推导一遍。</p><h2 id="用对数线性模型解决词性标注问题"><a href="#用对数线性模型解决词性标注问题" class="headerlink" title="用对数线性模型解决词性标注问题"></a>用对数线性模型解决词性标注问题</h2><p>有关对数线性模型以及梯度下降法的知识在之前我已经全部介绍过了。在这里我们只需要应用即可。</p><p><strong>依然是使用我们的特征模板构建特征空间，模型使用Softmax函数进行概率转化，模型的训练方式采用随机梯度下降法，损失函数选择交叉熵损失函数。正则化方式选择L2正则化，随机打乱数据集，并使用学习率下降算法，对学习率进行模拟退火处理，使模型在梯度下降后期趋于稳定。</strong></p><p>具体代码可以参考 <a href="https://github.com/SUDA-LA/CIP" target="_blank" rel="noopener">https://github.com/SUDA-LA/CIP</a> 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我在线性模型和对数线性模型学习过程中总结的基础知识，接下来，我还会介绍条件随机场（CRF）模型，并给出其解决词性标注问题的方法。</p><h2 id="参考资料（部分）"><a href="#参考资料（部分）" class="headerlink" title="参考资料（部分）"></a>参考资料（部分）</h2><ul><li><a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">苏州大学李正华老师的课件</a></li><li>李航老师《统计学习方法》的第六章</li><li>Andrew Ng的机器学习课程</li><li>Andrew Ng的深度学习课程</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：隐马尔可夫模型</title>
      <link href="/2020/03/17/nlp-zi-xue-bi-ji-yin-ma-er-ke-fu-mo-xing/"/>
      <url>/2020/03/17/nlp-zi-xue-bi-ji-yin-ma-er-ke-fu-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是我在学习苏州大学李正华老师的中文信息处理课程（<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">中文信息处理（Chinese Information Processing）Course Resources</a>）时，对于隐马尔可夫模型的一些个人见解和思考，同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己对于该模型的理解，如有错误欢迎在评论区指出，非常感谢！</p><h2 id="从问题出发"><a href="#从问题出发" class="headerlink" title="从问题出发"></a>从问题出发</h2><p>隐马尔可夫模型（Hidden Markov Model，HMM模型）是一个序列化标注模型，也能被看作是一种seq2seq（序列到序列）模型。在对隐马尔可夫模型进行学习时，我们引入一个自然语言处理领域的经典序列化问题：<strong>词性标注任务</strong>。接下来的讲解中，将围绕这个问题进行讨论。</p><ul><li>给定一个句子X，输出句子中每一个单词对应的词性。</li></ul><p><img src="1.png" alt="词性标注任务"></p><h2 id="什么是隐马尔可夫模型"><a href="#什么是隐马尔可夫模型" class="headerlink" title="什么是隐马尔可夫模型"></a>什么是隐马尔可夫模型</h2><p>《统计学习方法》中对于隐马尔可夫模型有着如下的定义：</p><blockquote><p>隐马尔科夫是关于时序的概率模型，描述由一个隐藏的马尔科夫链随机生成不可观测的状态随机序列，再由各个状态生成一个观测而产生观测随机序列的过程，隐藏的马尔科夫链生成的随机状态的序列被称为状态序列（state sequence），每个状态生成一个观测，由此而产生的观测的随机序列，称之为观测序列（observation sequence）,序列的每一个位置都可以看作是一个时刻。</p></blockquote><p>上述定义初看比较晦涩难懂，我们需要逐步进行解释。</p><ul><li><p>首先，什么是观测序列和状态序列呢？观测序列通常指可以直接获得的序列，状态序列则是我们无法直接获得的序列，HMM模型的目的就是为了通过可观测到的数据，预测不可观测到的数据。我们结合词性标注问题来看，在此问题中，<strong>观测序列指的是句子的单词序列，而状态序列则指的是句子的词性序列</strong>。</p></li><li><p>那么，什么是马尔可夫链？马尔可夫链是具有马尔可夫性质的随机变量的一个数列，描述了一个状态序列。马尔可夫性质指的是每个状态值取决于前面有限个状态，这在HMM模型中称为<strong>齐次马尔科夫链假设</strong>。需要注意的是<strong>马尔可夫链并没有限定后一个状态的变化仅仅取决于前一个状态，而是说取决于前面有限个状态</strong>。不过为了简化模型，我们在HMM中使用一阶（二元）马尔可夫链，即每个状态仅依赖于前一个状态。带入到词性标注问题中，他指的是<strong>当前的词性仅依赖于前一个词性是什么</strong>。例如，动词后常接名词，很少再接一个动词。那么，根据齐次马尔科夫链假设，如果前一个词性是动词，我们可以推测出当前词倾向于是名词而非动词。</p></li><li><p>接下来，我们要解决的问题是观测序列如何生成状态序列。HMM模型中对于状态序列至观测序列的发射有着这样的假设：<strong>任意时刻的观察状态只仅仅依赖于当前时刻的隐藏状态</strong>。这也叫做<strong>观测独立性假设</strong>，与齐次马尔科夫链假设一样，它也是为了简化模型。带入到词性标注问题中，它指的是<strong>当前词仅与当前词性有关</strong>。举例来说，当给定一个词“苹果”，我们根据训练集统计得知名词词性发射至“苹果”的概率远大于其它词性，所以我们可以预测当前词倾向于是名词。</p></li><li><p>根据齐次马尔可夫假设和观测独立性假设，对于一个长度为$L$的句子，我们用$X=x(0),x(1)……x(L-1)$表示词序列（观测序列），$Y=y(0),y(1)…y(L-1)$表示词性序列（状态序列），那么词性序列的转移过程可以表示为：<br>$$<br>p(y_i|y_0…y_i-1)=p(y_i|y_i-1)（一阶马尔可夫性质）<br>$$</p></li></ul><p>  由词性序列$Y$产生词序列$X$的发射过程可以表示为：<br>  $$<br>  p(x_0…x_L|y_0…y_L)= \prod_{i=0}^L{p(x_i|y_i)}(观测独立性假设)<br>  $$</p><h2 id="什么样的问题需要隐马尔可夫模型"><a href="#什么样的问题需要隐马尔可夫模型" class="headerlink" title="什么样的问题需要隐马尔可夫模型"></a>什么样的问题需要隐马尔可夫模型</h2><blockquote><p>考虑一个简单的例子，有人试图通过一片海藻推断天气——民间传说告诉我们‘湿透的’海藻意味着潮湿阴雨，而‘干燥的’海藻则意味着阳光灿烂。如果它处于一个中间状态（‘有湿气’），我们就无法确定天气如何。然而，天气的状态并没有受限于海藻的状态，所以我们可以在观察的基础上预测天气是雨天或晴天的可能性。另一个有用的线索是前一天的天气状态（或者，至少是它的可能状态）——通过综合昨天的天气及相应观察到的海藻状态，我们有可能更好的预测今天的天气。 </p></blockquote><p>使用HMM模型时我们的问题一般有这两个特征：</p><ol><li><p>我们的问题是基于序列的，比如时间序列，或者状态序列。NLP中常见的机器翻译、词性标注、分词等任务都可以看作是序列化问题。</p></li><li><p>我们的问题中有两类数据，一类序列数据是可以观测到的，即观测序列；而另一类数据是不能观察到的，即隐藏状态序列，简称状态序列。比如，在机器翻译中，我们可以将源语言文本看作是观测序列，目标语言文本看作是状态序列；又比如，词性标注中，词序列是观测序列，词性序列是状态序列。</p></li></ol><h2 id="隐马尔可夫模型：生成模型OR判别模型"><a href="#隐马尔可夫模型：生成模型OR判别模型" class="headerlink" title="隐马尔可夫模型：生成模型OR判别模型"></a>隐马尔可夫模型：生成模型OR判别模型</h2><ul><li>假设样本的特征向量为$X$，标签向量为$Y$。由生成方法学习到的模型称之为生成模型，生成方法是由数据学习联合分布$P(X,Y)$：<br>$$<br>P(X,Y)=P(X|Y)P(Y)<br>$$<br>然后求出条件概率分布$P(Y∣X)$作为预测：</li></ul><p>$$<br>P(Y∣X)=\frac{P(X,Y)}{P(X)}<br>$$</p><p>​        生成模型需要先把所有训练数据的分布情况摸透，最终确定一个分布，并且此分布是包含了所有特征和标签        的联合分布$P(X,Y)$。当我们需要对新的样本的特征向量进行预测时，使用上述公式，即可求出$P(Y∣X)$，即        样本$X$被标注为标签$Y$的概率。</p><p>​        典型的生成模型有：朴素贝叶斯模型，<strong>隐马尔可夫模型</strong>，生成对抗网络（GAN），变分自编码器（VAE）。</p><ul><li><p>由判别方法学习到的模型称之为判别模型，判别方法是由数据直接学习决策函数或者条件概率分布$P(Y∣X) $作为预测的模型。典型的判别模型有：k近邻模型，感知机模型，决策树，逻辑回归模型，最大熵模型，支持向量机，提升方法和<strong>条件随机场</strong>等。</p><p>判别模型直接根据训练数据的标签$Y$，通过定义特征进行学习，使用复杂的函数映射及决策叠加等方法，最后拟合出一个较优的边界。当新的特征向量到来时，我们使用训练得到的决策界进行预测即可。比较经典的判别模型是逻辑回归模型，它通过定义损失函数，最大化似然估计，利用梯度下降等方式将决策边界的拟合转化为最小化损失函数的凸优化问题。</p></li><li><p>总结：<strong>生成模型是指对联合概率建模，判别模型是对条件概率建模 ，HMM模型属于生成模型，因为HMM模型中没有建立决策边界，而是直接对联合概率分布建模。当给定观测序列时，我们使用前向算法计算每条状态序列的概率，选取概率最大的状态序列路径作为序列标注的结果。</strong></p></li><li><p>一个简单的图示表示生成模型和判别模型的区别：</p><p><img src="4.jpg" alt="生成模型和判别模型"></p></li></ul><h2 id="隐马尔可夫模型：概率模型"><a href="#隐马尔可夫模型：概率模型" class="headerlink" title="隐马尔可夫模型：概率模型"></a>隐马尔可夫模型：概率模型</h2><p><strong>概率模型</strong>（probabilistic model ）中，我们需要利用已知变量 “推断（inference）” 未知变量的条件分布。 根据我们之前的介绍，隐马尔可夫模型就是一种概率模型。</p><p><strong>概率图模型</strong>（probabilistic graphical model ）是一类用图表达变量相关关系的概率模型。一个节点表示一个或一组随机变量，节点之间的边表示变量间的概率相关关系。根据边的性质不同，概率图模型可以分为两种：第一类使用有向无环图表示变量之间的依赖关系，称为有向图模型或贝叶斯网（ Bayesian network ）；第二类是使用无向图表示变量之间的相关关系，成为无向图模型或马尔可夫网（Markov network）。根据下图可以看出：<strong>隐马尔可夫模型属于概率图模型中的有向图模型</strong>。</p><p><img src="4.png" alt="隐马尔可夫模型示意图"></p><p>我在知乎上看到了一张很清楚的图片，分享给大家，介绍了常见概率图模型的分类。</p><p><img src="2.png" alt="概率图模型的分类"></p><h2 id="隐马尔可夫模型中需要学习的三个参数"><a href="#隐马尔可夫模型中需要学习的三个参数" class="headerlink" title="隐马尔可夫模型中需要学习的三个参数"></a>隐马尔可夫模型中需要学习的三个参数</h2><p>简单来说，HMM模型主要使用了两个特征，分别是<strong>发射特征</strong>（词性到词的概率）和<strong>转移特征</strong>（前一个词性到当前词性的概率）。特别的，我们还会引入第三个特征，即<strong>初始特征</strong>，它主要指的是句子中第一个词性是什么的概率。它本质上来说仍然是一个转移特征，只不过是从第0个词性（也就是空）转移而来。</p><p>在实际参数学习过程中，这三个特征都是以矩阵的形式存储。 <strong>关于假设，重要的一点是三个特征矩阵并不随时间的改变而改变——这个矩阵在整个系统的生命周期中是固定不变的</strong>。 </p><p>为了简化模型，HMM定义了<strong>两个假设</strong>，即我们前面提到的<strong>齐次马尔可夫假设</strong>和<strong>观测独立性假设</strong>，根据前者，我们使用了转移特征和初始特征，根据后者，我们使用了发射特征。<strong>这些假设虽然简化了模型，但同时由于过于粗糙，导致HMM只能使用三类特征，无法考虑句子中的更多信息</strong>。在我的接下来的文章中，将探讨<strong>线性模型</strong>和<strong>对数线性模型</strong>，他们虽然无法解决序列标注问题，一次只能预测一个词的词性，但是<strong>能够使用更多的特征</strong>。特别的，<strong>条件随机场</strong>结合了对数线性模型与隐马尔可夫模型的优点，实现了<strong>可以使用无限制的特征模板进行序列化标注</strong>。</p><p>HMM（隐马尔可夫模型）、LR（逻辑回归模型，即对数线性模型）、CRF（条件随机场）的关系如下图所示。</p><p><img src="3.png" alt="几种模型的对比"></p><h2 id="隐马尔可夫模型的五个要素"><a href="#隐马尔可夫模型的五个要素" class="headerlink" title="隐马尔可夫模型的五个要素"></a>隐马尔可夫模型的五个要素</h2><p>总结一下，隐马尔可夫模型的核心就是五个要素： </p><ul><li>两个序列：<ul><li>观测序列：句子（词序列）</li><li>状态序列：词性序列</li></ul></li><li>三个矩阵：<ul><li>初始概率矩阵：第一个词性的概率，实际上是一个一维向量</li><li>发射概率矩阵：词性发射到词的概率，维度为[训练集中的词性数,训练集中的词数]</li><li>状态转移概率矩阵：从一个词性变化到另一个词性的概率，维度为[训练集中的词性数,训练集中的词性数]</li></ul></li></ul><p>任何一个能用以上五个参数描述的模型都是隐马尔可夫模型。</p><ul><li>这里，我们补充一个HMM的例子：</li></ul><blockquote><p>例子：病情转化<br>假设：某一时刻只有一种疾病，且只依赖于上一时刻疾病，一种疾病只有一种症状，且只依赖于当时的疾病<br>症状（观察值）：发烧，咳嗽，咽喉肿痛，流涕<br>疾病（状态值）：感冒，肺炎，扁桃体炎，猝死<br>转移概率：从一种疾病转变到另一种疾病的概率<br>输出概率：某一疾病呈现出某一症状的概率<br>初始分布：初始疾病的概率</p></blockquote><h2 id="隐马尔可夫模型解决序列标注问题的过程"><a href="#隐马尔可夫模型解决序列标注问题的过程" class="headerlink" title="隐马尔可夫模型解决序列标注问题的过程"></a>隐马尔可夫模型解决序列标注问题的过程</h2><ol><li><p><strong>训练过程</strong>：利用训练数据，统计得到HMM模型的三个参数，也就是上一节提到的三个矩阵。主要的方法有：<strong>极大似然估计法（有监督学习）</strong>和 <strong>Baum-Welch算法（无监督学习）</strong>。</p></li><li><p><strong>预测过程</strong>：给定一个句子的词序列，通过我们训练好的模型预测出最有可能的词性序列。主要的方法为<strong>维特比算法</strong>。</p></li></ol><h2 id="隐马尔可夫模型的训练过程"><a href="#隐马尔可夫模型的训练过程" class="headerlink" title="隐马尔可夫模型的训练过程"></a>隐马尔可夫模型的训练过程</h2><h3 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h3><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">$w$</td><td align="center">观测序列中的单词</td></tr><tr><td align="center">$y$</td><td align="center">状态序列中的词性</td></tr><tr><td align="center">$N=\{y_0,…,y_n\}$</td><td align="center">状态集合，包含了数据集中所有的n个状态，即词性</td></tr><tr><td align="center">$M=\{w_0,…,w_n\}$</td><td align="center">观测集合，包含了数据集中所有的m个观测，即词</td></tr><tr><td align="center">$A=[a_{ij}]_{N*N}$</td><td align="center">状态转移矩阵，包含了词性间的转移概率，其中$a_{ij}=P(y_i|y_j)$，且这里的转移需要是两个连续出现的词性（一阶马尔可夫假设）</td></tr><tr><td align="center">$B=[b_{ij}]_{N*M}$</td><td align="center">状态发射矩阵，包含了词性到词的发射概率，其中$b_{ij}=P(w_i|y_j)$</td></tr><tr><td align="center">$C=[c_i]_N$</td><td align="center">初始状态矩阵，包含了每一个词性出现在词性序列的第一个节点的概率</td></tr></tbody></table><h3 id="极大似然估计法（有监督学习）"><a href="#极大似然估计法（有监督学习）" class="headerlink" title="极大似然估计法（有监督学习）"></a>极大似然估计法（有监督学习）</h3><p>机器学习中，有监督学习指的是训练数据给出了标签。在词性标注问题中，即指的是训练数据给出了词性序列。</p><p>在有监督学习的参数学习过程中， <strong>参数的计算频率近似于参数的概率</strong> ，我们可以利用极大似然估计法进行证明。具体证明的过程参考李老师的讲义<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/7-hmm-tagging-MLE/main.pdf" target="_blank" rel="noopener"> HMM模型中极大似然估计的由来 </a> 。基于上述推导，通过对训练数据进行统计，我们便可计算出模型的三个基本参数矩阵，并可以使用他们进行预测。</p><p>具体的<strong>训练过程</strong>如下：</p><ul><li><p>Step1.统计状态的概率分布，也就是初始概率矩阵 $C$，这一步<strong>直接计算各词性在序列首节点（即句首）出现的频率即可</strong>。</p></li><li><p>Step2. 统计状态转移矩阵 $A$，<strong>这一步需要分别统计当前词性转移至所有词性的次数$\sum_{k=1}^N{count(y_i,y_k)}$和统计当前词性转移至目标词性的次数$count(y_i,y_j)$</strong>，根据一阶马尔可夫假设，这里统计的词性间的转移次数<strong>只统计两个词性连续出现的情况</strong>。将统计得到的两个次数相除，即可得到当前训练集中某词性转移到目标词性的频率，根据极大似然估计，该频率就是状态转移概率。<br>$$<br>a_{ij}=\frac{count(y_i,y_j)}{\sum_{k=1}^N{count(y_i,y_k)}}<br>$$</p></li></ul><p>根据上述公式，我们可以预测出所有状态自身和相互转移的概率，填充状态转移矩阵。</p><ul><li>Step3. 统计状态发射矩阵 $B$，<strong>这一步需要分别统计当前词性发射至所有词的次数$\sum_{k=1}^M{count(y_i,w_k)}$和统计当前词性发射至目标词的次数$count(y_i,w_j)$</strong>。将统计得到的两个次数相除，即可得到当前数据集中某词性发射到目标词的概率，根据极大似然估计，该频率就是状态发射概率。<br>$$<br>b_{ij}=\frac{count(y_i,w_j)}{\sum_{k=1}^N{count(y_i,w_k)}}<br>$$<br>根据上述公式，我们可以预测出所有状态自身和相互转移的概率，填充状态发射矩阵。</li></ul><p>至此，我们完成了在人工标注的数据集上的隐马尔可夫模型所有参数的学习，并可以将其投入至结果预测中。</p><h2 id="Baum-Welch算法（无监督学习）"><a href="#Baum-Welch算法（无监督学习）" class="headerlink" title="Baum-Welch算法（无监督学习）"></a>Baum-Welch算法（无监督学习）</h2><p>机器学习中，无监督学习指的是训练数据没有给出标签。在词性标注问题中，即指的是训练数据只有句子，没有对应的词性。在这个问题中，无监督学习远比有监督学习复杂。这里仅给出我现在对该算法的理解，如果大家发现有问题可以在评论区指出。</p><p>我的理解是：Baum-Welch算法就是一个<strong>EM</strong>的过程，参数的求解需要使用到<strong>前向后向（Forward-Backward）算法</strong>。</p><p>EM的意思是 <strong>Expectation Maximization</strong> ，即期望最大化。这个算法一般分为两步，即E步（Expection 步）和M步（Maximization 步）：</p><ol><li>随机初始化模型参数$\theta$的初值$\theta_0$。</li><li>E步：计算联合分布的条件概率期望$Q$</li><li>M步：<strong>极大化似然函数</strong>$L(\theta)$，得到新的$\theta$</li><li>重复E、M步骤直到$\theta$收敛</li></ol><p>这里说的比较简略，从极大似然估计到EM算法的推导大家可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/7-hmm-em/main.pdf" target="_blank" rel="noopener">李老师的课件</a>以及这篇知乎上的文章<a href="https://zhuanlan.zhihu.com/p/36331115" target="_blank" rel="noopener">人人都懂EM算法</a>。</p><p>如果你有机器学习的基础，那你很可能学习过<strong>K-Means算法</strong>，这是一种无监督的聚类算法。它本质上就是一种EM算法。对于给定的许多个无标签的样本点，K-Means可以将他们聚成任意n个类别。具体的做法是先随机选取数据集中的n个点作为聚类的质心点，计算每个点到每个质心点的距离，将他们归类到距离最小的类别下；然后对于每一个类别，重新计算其质心点；我们反复迭代进行上述的归类和质心计算的步骤，直到质心不再变化。<strong>随机初始化和重置质心的过程其实就是EM算法的E步，计算样本点到质心的距离并将其聚类到最近的质心的过程其实就是EM算法的M步。</strong></p><p>K-Means算法直接对样本点进行归类，而不是计算每个类别的概率，所以属于<strong>Hard EM</strong>。Hard EM和 Soft EM的区别和我之前在吴恩达的深度学习课程上看到的 SoftMax和HardMax的区别很像，个人感觉本质是一样。</p><p><strong>总结一下，当我们的样本没有给定标注数据，即只有句子没有词性时，我们可以对需要学习的三个参数矩阵进行随机初始化（np.rand），初步确定模型，然后极大化数据的某种似然，调整得到新的参数矩阵，通过不断地迭代，参数矩阵将逐渐收敛，当它们的变化范围缩小到某个可以被接受的阈值时，我们可以停止迭代，将当前的参数矩阵用于预测。</strong></p><p><strong>EM算法的收敛性可以使用Jensen不等式来证明</strong>，具体过程非常精妙，详细内容可以参考<a href="https://www.cnblogs.com/jerrylead/archive/2011/04/06/2006936.html" target="_blank" rel="noopener">吴恩达的讲义</a>。</p><p>需要注意的是，<strong>EM算法无法保证全局最优解</strong>，和梯度下降算法非常类似，他们能够稳定达到全局最优的条件都是似然函数（损失函数）是一个凸函数。（PS：似然函数和损失函数的关系我个人认为非常紧密，后面会专门写一篇blog说一下这个问题）</p><p><strong>前向后向算法</strong>的使用，主要是因为对于网格中的每一个状态，它既计算到达此状态的“前向”概率（给定当前模型的近似估计），又计算到达此状态的“后向”概率（给定当前模型的近似估计）。 这些都可以通过利用递归进行加速计算。<strong>使用前向算法和后向算法的相互合作，我们可以得到很多有用的信息，并可以将它们运用在EM算法过程中的极大化似然估计上</strong>。（<strong>PS：这里的Forward算法和后面Viterbi算法中的Forward算法并不完全相同，这里是 sum-product ，你可以看作是神经网络中的正向传播过程，对于传至当前状态的概率进行求和；而后者是 max-product，对于传至当前状态的概率取最大值</strong> ）</p><p>这里顺带说一句，前向算法还可以用于计算序列的概率，从而选择模型。如果我们训练了多个词性标注的HMM模型，那么对于一个需要标注的句子，我们可以通过前向算法计算它在不同模型中可能出现的概率，然后选取最大概率的模型用于预测。</p><h2 id="隐马尔可夫模型的预测（解码）过程"><a href="#隐马尔可夫模型的预测（解码）过程" class="headerlink" title="隐马尔可夫模型的预测（解码）过程"></a>隐马尔可夫模型的预测（解码）过程</h2><p>学习完隐马尔可夫模型的参数后，便可以使用这三个参数矩阵对我们输入的句子进行词性预测了。在这里，我们使用一种叫做<strong>维特比（viterbi）算法</strong>的动态规划算法进行状态序列的解码，也就是词性序列的预测。</p><p>维特比算法是一种<strong>动态规划求解篱笆网络（Lattice）的最优路径问题的方法</strong>。此处，我依然不会给出详细的公式，具体公式大家可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/7-hmm-em/main.pdf" target="_blank" rel="noopener">李老师的课件</a>，我仅以通俗的语言简单地解释一下维特比算法的原理。</p><p><img src="5.png" alt="篱笆网络（Lattice）的最短路径问题"></p><p>维特比算法可以应用在任何<strong>有向无环图的最优路径计算</strong>上，这里它恰巧符合隐马尔可夫算法的解码需求。它主要分为两个步骤：</p><ol><li>前向传播计算序列的最大概率。</li><li>反向回溯确定最大概率序列的路径。</li></ol><p>维特比算法前向传播的过程主要采用了动态规划思想，因为在上述有向无环图中，同一个节点可以被多次访问，所以如果采用穷举法计算所有序列，会产生对子问题的大量重复计算。我们自然想到采用动态规划的方法来降低时间复杂度，因为这里满足动态规划的三个基本要求：（1）重叠子问题（2）最优子结构（3）无后效性。</p><p>这个算法并不难理解，我也就不一步步推给大家看了，感兴趣的同学可以看一下这个问题<a href="https://www.zhihu.com/question/20136144" target="_blank" rel="noopener">如何通俗地讲解 viterbi 算法？</a>。简单阐述一下就是：<strong>状态矩阵中，当前节点的值等于上一层各节点的值乘以对应的转移路径的权值所得结果中的最优值（max-product），同时，我们还建立一个回溯矩阵，保存状态矩阵中每个节点的值是由上一层的哪个节点转移而来。当前向传播计算到最后一层时，我们选取最后一层的节点中的最优值，并通过回溯矩阵反向回溯得到对应的最优序列。特别地，在隐马尔可夫模型中，我们在前向传播计算每个节点最优值的时候，还需要考虑发射概率。</strong></p><p>通过维特比算法，我们可以较快的利用训练好的模型去预测一个句子的最大概率词性序列，并输出。</p><p>在实际运用模型的过程中，我们还会发现这样的一个问题：训练得到的参数矩阵很可能是较为稀疏的，例如从一个词性从未发射到某个单词过。同时，训练集的规模有限，不可能包含所有的词和词性。由于状态矩阵的转移涉及概率的累乘，上述未登录的情况将导致发射或转移或初始概率为0，进而使得前向传播计算出的整条序列地概率为0。<strong>为了解决零概率问题，我们需要还引入平滑方法，例如Laplace平滑等</strong>。更多方法可以参考<a href="https://www.jianshu.com/p/a28acdc32b56" target="_blank" rel="noopener">NLP系列学习:数据平滑</a>。<br>$$<br>a_{ij}=\frac{count(y_i,y_j)+\lambda}{\sum_{k=1}^N[{count(y_i,y_k)+\lambda}]}<br>$$<br>特别注意的是，如果你使用Laplace平滑，下方的$\lambda$一定不要忘记加，我曾经写模型的时候就犯过这样的错误。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我学习隐马尔可夫模型过程中的笔记和思考，接下来我将继续介绍序列标注概率图模型中的最大熵马尔可夫模型（MEMM）和条件随机场模型（CRF），并阐明他们之间的关系。</p><h2 id="参考资料（部分）"><a href="#参考资料（部分）" class="headerlink" title="参考资料（部分）"></a>参考资料（部分）</h2><ul><li><a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/7-hmm-tagging/main.pdf" target="_blank" rel="noopener">李正华老师的课件</a></li><li>李航老师的《统计学习方法》第10章</li><li><a href="http://www.comp.leeds.ac.uk/roger/HiddenMarkovModels/html_dev/main.html" target="_blank" rel="noopener"> HMM学习最佳范例 </a></li><li><a href="https://blog.csdn.net/lukabruce/article/details/82380511" target="_blank" rel="noopener">隐马尔科夫模型（Hidden Markov Model，HMM）</a></li><li><a href="https://zhuanlan.zhihu.com/p/85454896" target="_blank" rel="noopener">一站式解决：隐马尔可夫模型（HMM）全过程推导及实现</a></li><li><a href="https://www.zhihu.com/question/35866596" target="_blank" rel="noopener">如何用简单易懂的例子解释条件随机场（CRF）模型？它和HMM有什么区别？</a></li><li><a href="https://www.zhihu.com/question/20962240" target="_blank" rel="noopener">如何用简单易懂的例子解释隐马尔可夫模型？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2020/03/17/kmp-suan-fa/"/>
      <url>/2020/03/17/kmp-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文整理了KMP算法的原理及代码，可以使用LEETCODE上的题目进行测试：<a href="https://leetcode-cn.com/problems/implement-strstr/submissions/" title="28. 实现 strStr()" target="_blank" rel="noopener">28. 实现 strStr()</a>。</p><h2 id="从Brute-Force算法说起"><a href="#从Brute-Force算法说起" class="headerlink" title="从Brute-Force算法说起"></a>从Brute-Force算法说起</h2><p>BF算法是最为简单的一种字符串匹配算法，它采用纯暴力匹配的思想。对于目标串S和模式串P，其基本匹配思路如下：</p><ul><li>枚举 i = 0, 1, 2 … , len（S）-len（P）</li><li>将 S[i : i+len（P）] 与 P 作比较。如果一致，则找到了一个匹配。</li></ul><p><img src="1.jpg" alt="BF算法匹配流程"></p><p>BF算法的缺点在于每一次都是将目标串中的指针直接回溯为i+1。</p><p>我们记 n = |S| 为串 S 的长度，m = |P| 为串 P 的长度。不难想到，最坏情况下其时间复杂度为$O(MN)$。</p><p><img src="2.jpg" alt="BF算法python实现"></p><h2 id="KMP算法：Brute-Force算法的优化"><a href="#KMP算法：Brute-Force算法的优化" class="headerlink" title="KMP算法：Brute-Force算法的优化"></a>KMP算法：Brute-Force算法的优化</h2><p>为了优化BF算法，我们需要尽可能地减少匹配的趟数。那么，我们如何达到这一目的呢？</p><p>如果把模式串视为一把标尺，在主串上移动，那么 Brute-Force 就是每次失配之后只右移一位；改进算法则是每次失配之后，移很多位，跳过那些不可能匹配成功的位置。为了减少重复匹配，我们需要在失配处计算移动的位数，而不是单纯的回退目标串和模式串中的指针。通过一个名叫“部分匹配表”的东西，我们可以跳过绝不可能匹配成功的字符串比较，从而实现算法的优化。</p><h3 id="部分匹配表"><a href="#部分匹配表" class="headerlink" title="部分匹配表"></a>部分匹配表</h3><p>部分匹配表（Partial Match Table）的含义为：</p><ul><li><p>对于长度为m的字符串P，部分匹配表是与之对应的长度为m的一个数组PMT。</p></li><li><p>PMT[i]的值等于：字符串P的前i位字符组成的子字符串中，前缀集合和后缀集合中公共子串（前缀和后缀不包括自身）的最大长度。</p></li></ul><p>对于字符串“abababca”，它的PMT如下表所示：</p><p><img src="3.png" alt="PMT"></p><p>例如，对于”aba”，它的前缀集合为{”a”, ”ab”}，后缀 集合为{”ba”, ”a”}。两个集合的交集为{”a”}，那么长度最长的元素就是字符串”a”了，长 度为1，所以对于”aba”而言，它在PMT表中对应的值就是1。再比如，对于字符串”ababa”，它的前缀集合为{”a”, ”ab”, ”aba”, ”abab”}，它的后缀集合为{”baba”, ”aba”, ”ba”, ”a”}， 两个集合的交集为{”a”, ”aba”}，其中最长的元素为”aba”，长度为3。</p><h3 id="如何使用部分匹配表进行优化"><a href="#如何使用部分匹配表进行优化" class="headerlink" title="如何使用部分匹配表进行优化"></a>如何使用部分匹配表进行优化</h3><p><img src="4.png" alt="KMT算法示意图"></p><p>我们以上图为例进行说明。当目标串S的指针为i，模式串P的指针为j时，此时匹配失败了。按照BF算法，我们会将i回退至下标为1处，j回退至下标为0处继续匹配。这显然是很笨拙的。</p><p>通过观察，我们可以发现， S[:i] 和 P[:j] 是成功匹配的，只是 S[i] 和 P[j] 不相同。</p><p>这时，我们在上一节所得的模式串的部分匹配表就派上了用场。通过 PMT[j-1] ，我们可以得知，P[:j] 这一子串中前后缀公共子串的最大长度为4。又因为 S[:i] 和 P[:j] 是相等的，所以 P[:j] 的后缀也就是 S[:i] 的后缀。那么，我们可以推知目标串i之前的4位和模式串开头的4位是相同的。就是图中的灰色部分。那这部分就不用再比较了。</p><p>有了上面的思路，我们就可以使用PMT加速字符串的查找了。我们看到如果是在 j 位 失配，那么影响 j 指针回溯的位置的其实是第 j −1 位的 PMT 值。</p><p>以上其实就是KMP算法的基本思想了，我们总结一下：KMP算法的目的是使用部分匹配表，来跳过必不可能成功的匹配，减少匹配的趟数。</p><h3 id="KMP算法的流程"><a href="#KMP算法的流程" class="headerlink" title="KMP算法的流程"></a>KMP算法的流程</h3><p>我们现在来总结一下KMP算法主程序的基本流程：</p><p>假设现在文本串 S 匹配到 tar 位置，模式串 P 匹配到 pos 位置：</p><ol><li><p>如果当前字符匹配成功，则tar++，pos++，继续匹配二者的下个字符。若当前的pos等于模式串的长度，则说明全部匹配成功，此时可以返回tar减去pos的值，即模式串在目标串中出现的首个字符的下标。</p></li><li><p>如果当前匹配失败，且pos大于0，说明此时模式串已经成功匹配了部分字符，可以尝试利用部分匹配表跳过必然无法匹配成功的子串，令pos=PMT[pos-1]。</p></li><li><p>如果匹配失败，且pos等于0，说明此时模式串的第一个字符就无法匹配，则tar++，尝试与目标串的下个字符匹配。</p></li></ol><p>根据上述的流程，我们可以编写KMP算法主体函数如下：</p><pre class="line-numbers language-python"><code class="language-python">        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span>pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>            tar<span class="token operator">=</span><span class="token number">0</span>            pos<span class="token operator">=</span><span class="token number">0</span>            PMT<span class="token operator">=</span>getPMT<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>tar<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>st<span class="token punctuation">[</span>tar<span class="token punctuation">]</span><span class="token operator">==</span>pattern<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    tar<span class="token operator">+=</span><span class="token number">1</span>                    pos<span class="token operator">+=</span><span class="token number">1</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token operator">==</span>len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> tar<span class="token operator">-</span>pos                <span class="token keyword">elif</span> <span class="token punctuation">(</span>pos<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    pos<span class="token operator">=</span>PMT<span class="token punctuation">[</span>pos<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    tar<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="KMP算法的难点：获取部分匹配表"><a href="#KMP算法的难点：获取部分匹配表" class="headerlink" title="KMP算法的难点：获取部分匹配表"></a>KMP算法的难点：获取部分匹配表</h3><p>KMP算法的基本思想其实并不难，但KMP算法主要的难点在于如何求解模式串的PMT数组。这里我们可以采取<strong>动态规划</strong>的方式求解。</p><ul><li>问题：对于模式串P，已知PMT[0],PMT[1],PMT[2]…PMT[x-1]，求解PMT[x]。</li></ul><p>观察上述问题，我们发现，该问题符合最优子结构和重叠子问题的动态规划要求，动态规划具体的转移情况我们进行分类讨论。</p><ul><li>情况一：已知now=PMT[x-1]，若P[x]==P[now]，则PMT[x]=now+1。如下图所示，因为我们已知前x-1个字符中有长度为now的公共前后缀，如果当前前缀的后一位P[now]等于当前后缀的后一位P[x]，则公共前后缀长度自然可以加1。</li></ul><p><img src="4.jpg" alt="情况1"></p><ul><li>情况二： 若P[x]!=P[now]，则令now=PMT[now-1]，再次尝试比较P[x]和P[now]，如果相等则PMT[x]=now+1，如果不相等再重复之前的过程，直到now等于0。如下图所示，此时由于子串A必然与子串B相等，则子串A的后缀与子串B的后缀必然相同，所以子串A的最大公共前后缀即为前x-1个字符中第二长的公共前后缀。</li></ul><p><img src="5.jpg" alt="情况2"></p><p>根据上述分析，我们可以编写获取模式串PMT数组的代码如下：</p><pre class="line-numbers language-python"><code class="language-python">        <span class="token keyword">def</span> <span class="token function">getPMT</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>            PMT<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#PMT[0]必定为0</span>            x<span class="token operator">=</span><span class="token number">1</span>            now<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">==</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    now<span class="token operator">+=</span><span class="token number">1</span>                    PMT<span class="token punctuation">.</span>append<span class="token punctuation">(</span>now<span class="token punctuation">)</span>                    x<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">elif</span> now<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                    now<span class="token operator">=</span>PMT<span class="token punctuation">[</span>now<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    PMT<span class="token punctuation">.</span>append<span class="token punctuation">(</span>now<span class="token punctuation">)</span>                    x<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">return</span> PMT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，KMP算法介绍完毕。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>KMP算法在我看来，主要有两方面的内容，一是通过动态规划求解模式串的部分匹配表；二是通过部分匹配表来跳过必不可能的情况，提升匹配的速度。其核心难点在于PMT动态规划的转移方程，需要静下心来自己推导一遍。</p><p>我们不难看出，对于长度为M的目标串S和长度为N的模式串P，KMP算法的时间复杂度由两部分组成：一是match函数中需要让指针遍历目标串S的每一个位置，需要耗费$O(M)$的时间，二是getPMT函数中计算部分匹配表，这一部分我们采用均摊时间复杂度分析，可以发现耗费的时间为$O(N)$。</p><p>利用KMP算法，我们将BF算法的时间复杂度$O(MN)$成功降为$O(M+N)$，使速度大大提升。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日两题</title>
      <link href="/2020/03/13/leetcode-ti-jie-chi-xu-geng-xin/"/>
      <url>/2020/03/13/leetcode-ti-jie-chi-xu-geng-xin/</url>
      
        <content type="html"><![CDATA[<h1 id="每日算法-LEETCODE-PYTHON3"><a href="#每日算法-LEETCODE-PYTHON3" class="headerlink" title="每日算法(LEETCODE,PYTHON3)"></a>每日算法(LEETCODE,PYTHON3)</h1><h2 id="2020-3-2-（2-medium）"><a href="#2020-3-2-（2-medium）" class="headerlink" title="2020.3.2 （2 medium）"></a>2020.3.2 （2 medium）</h2><h3 id="第3题-无重复的字符的最长字串"><a href="#第3题-无重复的字符的最长字串" class="headerlink" title="第3题 无重复的字符的最长字串"></a>第3题 无重复的字符的最长字串</h3><p><img src="3.png" alt="第3题 无重复的字符的最长字串"></p><h4 id="思路1-动态规划"><a href="#思路1-动态规划" class="headerlink" title="思路1 动态规划"></a>思路1 动态规划</h4><p>我的最初思路：可以采用动态规划法（区间DP），从区间为2的子串开始计算无重复字符的长度，接着计算下个更大的区间，依次类推，直到区间长度等于字符串长度。</p><ul><li><p>空间复杂度优化：这道题的动态规划状态矩阵中，可以发现有一半的空间（对角线以下）全部为0，所以可以压缩。</p></li><li><p>时间复杂度优化：分析后发现，这道题其实不需要动态规划，因为本质上没有重叠子问题。我尝试了两层循环遍历字符串的所有子串，一旦出现重复就可以跳出与当前最大长度比较，后面的子串不用再比较了，必有重复的字符。时间复杂度$O(N^2)$</p></li></ul><h4 id="思路2-滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）"><a href="#思路2-滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）" class="headerlink" title="思路2 滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）"></a>思路2 滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）</h4><p>使用左右两个指针维护一个无重复字符的窗口，两个指针初始都在0处。通过右指针不断向右延伸添加新的字符，并记录当前窗口大小，每次与当前最大值比较，如果大于当前最大值，则可以更新。当窗口延伸至新字符已存在于窗口内时。把窗口左侧的字符不断移除（左指针收缩），直到当前窗口无重复子串。继续滑动窗口，直到右指针触及字符串尾部，此时可以输出当前最大长度即可。</p><p>滑动窗口法减少了对字符串的重复遍历。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> s<span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">#字符串为空的处理</span>        left <span class="token operator">=</span> <span class="token number">0</span>        lookup <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        max_len <span class="token operator">=</span> <span class="token number">0</span>        cur_len <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            cur_len <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> lookup<span class="token punctuation">:</span>                pos<span class="token operator">=</span>len<span class="token punctuation">(</span>lookup<span class="token punctuation">)</span><span class="token operator">-</span>lookup<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#寻找重复字符出现在窗口内的最后一次位置，直接将左指针移动到该位置后面即可。</span>                lookup<span class="token operator">=</span>lookup<span class="token punctuation">[</span>pos<span class="token punctuation">:</span><span class="token punctuation">]</span>                left <span class="token operator">+=</span> pos                cur_len <span class="token operator">-=</span> pos            <span class="token keyword">if</span> cur_len <span class="token operator">></span> max_len<span class="token punctuation">:</span>max_len <span class="token operator">=</span> cur_len            lookup<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> max_len<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第4题-寻找两个有序数组的中位数"><a href="#第4题-寻找两个有序数组的中位数" class="headerlink" title="第4题 寻找两个有序数组的中位数"></a>第4题 寻找两个有序数组的中位数</h3><p><img src="4.png" alt="第4题 寻找两个有序数组的中位数"></p><h4 id="思路1-指针遍历"><a href="#思路1-指针遍历" class="headerlink" title="思路1 指针遍历"></a>思路1 指针遍历</h4><p>我的方法：归并排序的思想，通过设置两个指针对两个有序数组进行归并排序，若已排序到中位数位置，则输入当前指针指向的数。</p><p>缺点：时间复杂度$O(M+N)$，较高。空间复杂度可以优化至$O(1)$，即只存当前数和前一个数。</p><p>要想获得log级别的时间复杂度，需要使用二分法或者堆。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>        mid_pos<span class="token operator">=</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">+</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>        p<span class="token operator">=</span><span class="token number">0</span>        q<span class="token operator">=</span><span class="token number">0</span>        li<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        count<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">and</span><span class="token punctuation">(</span>q<span class="token operator">!=</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                li<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                p<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">>=</span>mid_pos<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> mid_pos<span class="token operator">%</span><span class="token number">1</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                li<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                q<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">>=</span>mid_pos<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> mid_pos<span class="token operator">%</span><span class="token number">1</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">==</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>q<span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                li<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">>=</span>mid_pos<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> mid_pos<span class="token operator">%</span><span class="token number">1</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">elif</span> <span class="token punctuation">(</span>q<span class="token operator">==</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>p<span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                li<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">>=</span>mid_pos<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> mid_pos<span class="token operator">%</span><span class="token number">1</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="思路2-递归二分"><a href="#思路2-递归二分" class="headerlink" title="思路2 递归二分"></a>思路2 递归二分</h4><p>为了使时间复杂度指数倍地下降，我们以数组[1，3，4，9]和[1，2，3，4，5，6，7，8，9，10]为例。计算得知：（1+14）/2=7.5，所以二者合并后的中位数为：第7小数和第8小数的平均值。</p><p>首先，我们学习一种二分法求解两个有序数组合并后第k小的数的方法，我们以第7小数为例：</p><p>1.先计算7整除2的商为3，然后比较第一个数组和第二个数组的第3个数（如果某个数组的元素不足3个，则比较它的最后一个数）。将较小的那个数及之前所有的数从所在的数组中去除。（此时它们必在合并后前6小的数中，具体证明可以自己推导一遍）。</p><p>2.此时，求解第7小的数变为：在更新后的两个数组中求解第4小的数（因为已经确定了3个）。</p><p>3.计算4整除2的商为2，然后比较两个数组的第2个数，与第1步中类似，将较小的数及之前的所有数从所在数组中删除。</p><p>4.此时，求解第4小的数变为：在更新后的两个数组中求解第2小的数（因为又确定了2个）。</p><p>5.重复以上过程，直到问题变为求解第1小的数，这时比较两个数组中的第1个数，返回较小值即可。</p><p>通过以上算法，我们可以用二分删除法计算出合并后第7小数和第8小数，然后便可计算中位数。</p><ul><li>时间复杂度:每进行一次循环，我们就减少 k/2 个元素，所以时间复杂度是 $O(log(k))$，而 k=（m+n）/2，所以最终的复杂也就是 O（log（m+n））。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findk</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums1<span class="token punctuation">,</span>nums2<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#求解合并后第k小数</span>        m<span class="token operator">=</span>k<span class="token operator">//</span><span class="token number">2</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">></span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#保证第一个数组较小</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>findk<span class="token punctuation">(</span>nums2<span class="token punctuation">,</span>nums1<span class="token punctuation">,</span>k<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果第一个数组为空，直接返回第二个数组的第k个数即可</span>            <span class="token keyword">return</span> nums2<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span>        i<span class="token operator">=</span>min<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#防止第一个数组长度不足m</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果求解第1小数，则直接比较二者第1个数即可</span>            <span class="token keyword">return</span> min<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">></span>nums2<span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#删除第二个数组的前m个数，再递归查找</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>findk<span class="token punctuation">(</span>nums1<span class="token punctuation">,</span>nums2<span class="token punctuation">[</span>m<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>k<span class="token operator">-</span>m<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#删除第一个数组的前i个数，再递归查找</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>findk<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums2<span class="token punctuation">,</span>k<span class="token operator">-</span>i<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">+</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#数组总长为偶数</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>findk<span class="token punctuation">(</span>nums1<span class="token punctuation">,</span>nums2<span class="token punctuation">,</span>int<span class="token punctuation">(</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">+</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span>self<span class="token punctuation">.</span>findk<span class="token punctuation">(</span>nums1<span class="token punctuation">,</span>nums2<span class="token punctuation">,</span>int<span class="token punctuation">(</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">+</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>        <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#数组总长为奇数</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>findk<span class="token punctuation">(</span>nums1<span class="token punctuation">,</span>nums2<span class="token punctuation">,</span>int<span class="token punctuation">(</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">+</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>空间复杂度:O（1）。<strong>因为这里使用了尾递归！</strong></li></ul><h4 id="什么是尾递归"><a href="#什么是尾递归" class="headerlink" title="什么是尾递归"></a>什么是尾递归</h4><p>以递归方式实现阶乘函数的实现：</p><pre class="line-numbers language-python"><code class="language-python">int recsum<span class="token punctuation">(</span>int n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">|</span><span class="token operator">|</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> n <span class="token operator">*</span> fact<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以尾递归方式实现阶乘函数的实现：</p><pre class="line-numbers language-python"><code class="language-python">int tailrecsum<span class="token punctuation">(</span>int n<span class="token punctuation">,</span> int res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> facttail<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">+</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非尾递归，下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。</p><p>尾递归，进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。</p><p><strong>尾递归的判断标准是函数运行最后一步是否调用自身，而不是是否在函数的最后一行调用自身。</strong></p><p>上述例子中：</p><ul><li><p>递归方式的倒数第二步是调用自身求解recsum（n-1），而最后一步是将recsum（n-1）的结果与n相乘并返回，所以rescum(n)的运算依赖于rescum（n-1）的运算。需要将本层函数压栈保存，当计算完最后一层后，再进行层层返回，得出结果。</p></li><li><p>尾递归方式的最后一步就是调用自身求解n-1时的结果，并将当前层的结果作为参数传入下一层，不需要再返回当前层进行运算。下层计算结果对上层“无用”（上一层运算已经做完，不依赖后续的递归），为了效率，可以直接将下一层需要的空间覆盖在上一层上。</p></li></ul><p>总结：</p><ul><li><p>尾递归，比线性递归多一个参数，这个参数是上一次调用函数得到的结果；所以，关键点在于，尾递归每次调用都在收集结果，避免了线性递归不收集结果只能依次展开消耗内存的坏处。</p></li><li><p>使用尾递归可以带来一个好处：因为进入最后一步后不再需要参考外层函数（caller）的信息，因此没必要保存外层函数的stack，递归需要用的stack只有目前这层函数的，因此避免了栈溢出风险。 </p></li></ul><p><strong>本题中，所有递归调用都是当前层递归的最后一步，所以不需要额外的栈空间保存当前层，时间复杂度为O（1）。</strong></p><h2 id="2020-3-3-（2-medium）"><a href="#2020-3-3-（2-medium）" class="headerlink" title="2020.3.3 （2 medium）"></a>2020.3.3 （2 medium）</h2><h3 id="第5题-最长回文子串"><a href="#第5题-最长回文子串" class="headerlink" title="第5题 最长回文子串"></a>第5题 最长回文子串</h3><p><img src="5.png" alt="第5题 最长回文子串"></p><h4 id="思路1："><a href="#思路1：" class="headerlink" title="思路1："></a>思路1：</h4><p>区间动态规划+状态空间压缩，利用区间首尾字符是否相等，且去除首尾字符后的子串是否为回文串，来判断当前区间是否为回文子串。</p><ul><li><p>时间复杂度：$O(N^2)$</p></li><li><p>空间复杂度：$O(N^2)$（可以压缩一半）</p></li></ul><h4 id="思路2："><a href="#思路2：" class="headerlink" title="思路2："></a>思路2：</h4><p>中心扩展法，不需要额外的状态矩阵。对于一个长度为n的字符串，有2n-1个中心（奇偶回文串分类讨论）可以选取，由中心向两侧扩散寻找该中心所能构成的最长回文子串，若大于当前最大值，则将最大值替换为当前长度。</p><ul><li><p>时间复杂度：$O(N^2)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        max_length<span class="token operator">=</span><span class="token string">''</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">!=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>expandcenter<span class="token punctuation">(</span>s<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span>len<span class="token punctuation">(</span>max_length<span class="token punctuation">)</span><span class="token punctuation">:</span>                    max_length<span class="token operator">=</span>self<span class="token punctuation">.</span>expandcenter<span class="token punctuation">(</span>s<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span>                <span class="token keyword">if</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>expandcenter<span class="token punctuation">(</span>s<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span>len<span class="token punctuation">(</span>max_length<span class="token punctuation">)</span><span class="token punctuation">:</span>                    max_length<span class="token operator">=</span>self<span class="token punctuation">.</span>expandcenter<span class="token punctuation">(</span>s<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>expandcenter<span class="token punctuation">(</span>s<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span>len<span class="token punctuation">(</span>max_length<span class="token punctuation">)</span><span class="token punctuation">:</span>                    max_length<span class="token operator">=</span>self<span class="token punctuation">.</span>expandcenter<span class="token punctuation">(</span>s<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> max_length    <span class="token keyword">def</span> <span class="token function">expandcenter</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>s<span class="token punctuation">,</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#中心扩展法向两侧搜索判断</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#奇回文串</span>            length<span class="token operator">=</span><span class="token number">1</span>            <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>                l<span class="token operator">-=</span><span class="token number">1</span>                r<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">and</span><span class="token punctuation">(</span>r<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">and</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    length<span class="token operator">+=</span><span class="token number">2</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> s<span class="token punctuation">[</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>r<span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#偶回文串</span>            length<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">and</span><span class="token punctuation">(</span>r<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">and</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    length<span class="token operator">+=</span><span class="token number">2</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> s<span class="token punctuation">[</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>r<span class="token punctuation">]</span>                l<span class="token operator">-=</span><span class="token number">1</span>                r<span class="token operator">+=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="进阶算法："><a href="#进阶算法：" class="headerlink" title="进阶算法："></a>进阶算法：</h4><p>Manacher算法，时间复杂度只有$O(N)$，但比较复杂。可以参考<a href="https://www.jianshu.com/p/392172762e55" target="_blank" rel="noopener">https://www.jianshu.com/p/392172762e55</a></p><h3 id="第6题-Z-字形变换"><a href="#第6题-Z-字形变换" class="headerlink" title="第6题 Z 字形变换"></a>第6题 Z 字形变换</h3><p><img src="6.png" alt="第6题 Z 字形变换"></p><h4 id="思路1：-1"><a href="#思路1：-1" class="headerlink" title="思路1："></a>思路1：</h4><p>通过观察变换前后的字符串，利用规律求解，直接使用下标运算。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">convert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> numRows<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        a<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>numRows<span class="token number">-2</span>        result<span class="token operator">=</span><span class="token string">''</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> s        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>numRows<span class="token punctuation">)</span><span class="token punctuation">:</span>            t<span class="token operator">=</span>i            <span class="token keyword">while</span><span class="token punctuation">(</span>t<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                result<span class="token operator">+=</span>s<span class="token punctuation">[</span>t<span class="token punctuation">]</span>                delta<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span><span class="token punctuation">(</span>numRows<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>t<span class="token operator">+</span>delta<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">and</span><span class="token punctuation">(</span>delta<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    result<span class="token operator">+=</span>s<span class="token punctuation">[</span>t<span class="token operator">+</span>delta<span class="token punctuation">]</span>                t<span class="token operator">+=</span>a        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>时间复杂度：$O(N)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><h4 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h4><p>按顺序遍历字符串，并设置与行数相等的数组。遍历时，按照Z字形变化的格式放入对应的数组（行数先加1，遍历到底部再减1，遍历到顶部再加1，直到遍历完）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">convert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> numRows<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">if</span> numRows <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token keyword">return</span> s        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">""</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>numRows<span class="token punctuation">)</span><span class="token punctuation">]</span>        i<span class="token punctuation">,</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> c            <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> i <span class="token operator">==</span> numRows <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span> flag <span class="token operator">=</span> <span class="token operator">-</span>flag            i <span class="token operator">+=</span> flag        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-3-4-（1-hard-1-medium）"><a href="#2020-3-4-（1-hard-1-medium）" class="headerlink" title="2020.3.4 （1 hard 1 medium）"></a>2020.3.4 （1 hard 1 medium）</h2><h3 id="第10题-正则表达式匹配"><a href="#第10题-正则表达式匹配" class="headerlink" title="第10题 正则表达式匹配"></a>第10题 正则表达式匹配</h3><p><img src="10.png" alt="第10题 正则表达式匹配"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>本题可以用递归求解，但时空复杂度很高。</p><p>考虑到本题符合动态规划的两个基本要求：（1）重叠子问题，（2）最优子结构。所以本题可以使用动态规划来求解。</p><p>解决可递归问题的三种方法：</p><ul><li>递归：自顶向下，代码简单，但是复杂度高，可能会进行重复的计算，同时会使用大量的栈空间。</li><li>备忘录：自顶向下，将递归中的子问题求解结果保存起来，防止重复计算，降低了时间复杂度，但栈空间的消耗依然存在。</li><li>动态规划：自底向上，使用状态矩阵，由子问题通过状态转移方程递推出最后的结果。</li></ul><p>本题中，可以使用状态矩阵$dp(i,j)$表示text[i:]和pattern[j:]是否能匹配。我们可以用更短的字符串匹配问题来表示原本的问题。</p><ul><li><p>当首字母匹配且第二个字母为”*”时，可以尝试转移到匹配0次（目标串不变，模式串变）或1次（目标串变，模式串不变，因为此时可以多次匹配）的状态矩阵。</p></li><li><p>当首字母不匹配且第二个字母为”*”时，转移到匹配0次（目标串不变，模式串变）的状态矩阵。</p></li><li><p>首字母匹配且第二个字母不为”*”时，转移到首字母匹配1次（目标串和模式串都变）的状态矩阵。</p></li><li><p>否则，当前状态为False，即无法匹配。</p></li><li><p>$dp(-1,-1)$说明此时模式串和目标串完成了全匹配，可以成功，默认为True。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span> <span class="token comment" spellcheck="true">#两个字符串都为空必然匹配</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#为什么i从len(text))开始，而j从len(pattern)-1开始：字符串为空，正则表达式不为空，可能匹配成功（存在*），而正则表达式为空，字符串不为空，必然不可能匹配成功</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                f_match<span class="token operator">=</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">and</span><span class="token punctuation">(</span>pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">in</span> <span class="token punctuation">[</span>text<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'.'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#第一个对i的限制条件是为了防止后面访问text[i]时数组越界</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">and</span><span class="token punctuation">(</span>pattern<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> f_match<span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">or</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> f_match<span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第11题-盛最多水的容器"><a href="#第11题-盛最多水的容器" class="headerlink" title="第11题 盛最多水的容器"></a>第11题 盛最多水的容器</h3><p><img src="11.png" alt="第11题 盛最多水的容器"></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h4><p>双指针法（这种从两端向内收缩的双指针我叫做双侧指针，如第3题中滑动窗口的同一侧出发的指针我叫做快慢指针）。</p><p>由于容器的容积只与短板有关，我们可以使用两个指针从数组的两侧每一次向内收缩短板，计算当前的容积，直到两个指针相交。</p><p>为什么只收缩短板：如果收缩长板，那么移动后的板长要么小于移动前的短板长度，要么大于短板长度，前者会使容积变小，后者会使容积不变，所以我们只有移动短板才可能使容积变大。</p><ul><li><p>时间复杂度：$O(N)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxArea</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        max_v<span class="token operator">=</span><span class="token number">0</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            v<span class="token operator">=</span>min<span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> v<span class="token operator">></span>max_v<span class="token punctuation">:</span>                max_v<span class="token operator">=</span>v            <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                left<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                right<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> max_v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-3-5-（4-medium）"><a href="#2020-3-5-（4-medium）" class="headerlink" title="2020.3.5 （4 medium）"></a>2020.3.5 （4 medium）</h2><h3 id="第12题-整数转罗马数字"><a href="#第12题-整数转罗马数字" class="headerlink" title="第12题 整数转罗马数字"></a>第12题 整数转罗马数字</h3><p><img src="12.png" alt="第12题 整数转罗马数字"></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路:"></a>思路:</h4><p>贪心算法，每次取当前能够匹配的最大罗马数字进行选择。类似于用最少的纸币凑出整数。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">intToRoman</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中</span>        <span class="token comment" spellcheck="true"># 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想</span>        nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>        romans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"M"</span><span class="token punctuation">,</span> <span class="token string">"CM"</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">,</span> <span class="token string">"CD"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token string">"XC"</span><span class="token punctuation">,</span> <span class="token string">"L"</span><span class="token punctuation">,</span> <span class="token string">"XL"</span><span class="token punctuation">,</span> <span class="token string">"X"</span><span class="token punctuation">,</span> <span class="token string">"IX"</span><span class="token punctuation">,</span> <span class="token string">"V"</span><span class="token punctuation">,</span> <span class="token string">"IV"</span><span class="token punctuation">,</span> <span class="token string">"I"</span><span class="token punctuation">]</span>        index <span class="token operator">=</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token string">''</span>        <span class="token keyword">while</span> index <span class="token operator">&lt;</span> <span class="token number">13</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 注意：这里是等于号，表示尽量使用大的"面值"</span>            <span class="token keyword">while</span> num <span class="token operator">>=</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>                res <span class="token operator">+=</span> romans<span class="token punctuation">[</span>index<span class="token punctuation">]</span>                num <span class="token operator">-=</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span>            index <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第15题-三数之和"><a href="#第15题-三数之和" class="headerlink" title="第15题 三数之和"></a>第15题 三数之和</h3><p><img src="15.png" alt="第15题 三数之和"></p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路:"></a>思路:</h4><p>在一个有序数组中求解两个数之和，可以使用暴力遍历的方法，但时间复杂度很高。在这里，我们可以使用双侧指针法，先在数组两端各固定一个指针。当两数之和小于target时，左指针加1（由于是有序数组，会使和变大），当两数之和大于target时，右指针减1，等于target时，保存结果，并左右指针同时向内收缩。</p><p>那么，知道了两数之和问题的解决方案后，我们可以求解三数之和（本质上，任意n数之和都可以采取相同的方法）。我们先对数组进行排序，然后固定一个数，便可将问题转化为两数之和，接着对于该数之后的所有数进行两数之和的求解。求解完成后，我们可以接着固定下一个数，直到求出所有结果。</p><p>要注意的问题：</p><ul><li><p>结果的去重（求解两数之和时，相同的数字不应重复使用。同时，固定的数若等于上个数，则他的所有情况都被上个数的遍历所包含，也可以跳过）。</p></li><li><p>性能的提升（剪枝，当右指针的数小于0时或者固定的数大于0时，三数之和必定不等于0，因为此时三个数都大于0或者都小于0）</p></li><li><p>时间复杂度：$O(N^2)+O(NlogN)=O(N^2)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    public static List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> threeSum<span class="token punctuation">(</span>int<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans <span class="token operator">=</span> new ArrayList<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 排序</span>        int len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">|</span><span class="token operator">|</span> len <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token punctuation">;</span> i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token operator">//</span> 如果当前数字大于<span class="token number">0</span>，则三数之和一定大于<span class="token number">0</span>，所以结束循环            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token operator">//</span> 去重            int L <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            int R <span class="token operator">=</span> len<span class="token number">-1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>L <span class="token operator">&lt;</span> R<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                int sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    ans<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span>asList<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;</span>R <span class="token operator">&amp;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>L<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> L<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span> <span class="token operator">//</span> 去重                    <span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;</span>R <span class="token operator">&amp;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">[</span>R<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>R<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> R<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">;</span> <span class="token operator">//</span> 去重                    L<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span>                    R<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;</span>R <span class="token operator">&amp;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>L<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        L<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span> <span class="token operator">//</span> 去重<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    L<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;</span>R <span class="token operator">&amp;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">[</span>R<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>R<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        R<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">;</span> <span class="token operator">//</span> 去重                    <span class="token punctuation">}</span> <span class="token operator">//</span> 去重                    R<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>                <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第16题-最接近的三数之和"><a href="#第16题-最接近的三数之和" class="headerlink" title="第16题 最接近的三数之和"></a>第16题 最接近的三数之和</h3><p><img src="16.png" alt="第16题 最接近的三数之和"></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路:"></a>思路:</h4><p>与第15题几乎没有区别，只是双指针收缩时，每次记录当前的三数之和，看与结果的差值是否为当前最小，最小则修改当前的最接近的三数之和。当差值为0时可以直接返回。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeSumClosest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        closest<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>        diff<span class="token operator">=</span>abs<span class="token punctuation">(</span>closest<span class="token operator">-</span>target<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            L<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span>            R<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;</span>R<span class="token punctuation">)</span><span class="token punctuation">:</span>                summa<span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>R<span class="token punctuation">]</span>                <span class="token keyword">if</span> abs<span class="token punctuation">(</span>summa<span class="token operator">-</span>target<span class="token punctuation">)</span><span class="token operator">&lt;</span>diff<span class="token punctuation">:</span>                    closest<span class="token operator">=</span>summa                    diff<span class="token operator">=</span>abs<span class="token punctuation">(</span>closest<span class="token operator">-</span>target<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>summa<span class="token operator">></span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>                    R<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">elif</span> <span class="token punctuation">(</span>summa<span class="token operator">&lt;</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>                    L<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> summa        <span class="token keyword">return</span> closest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第18题-四数之和"><a href="#第18题-四数之和" class="headerlink" title="第18题 四数之和"></a>第18题 四数之和</h3><p><img src="18.png" alt="第18题 四数之和"></p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路:"></a>思路:</h4><p>任意n数之和都求解，都可以先固定一个数，转化为n-1数之和问题，逐步转化，直到最后变为求解二数之和。这里的四数之和也是类似的道理，其去重的思想与三数之和也是一样的。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    public static List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> fourSum<span class="token punctuation">(</span>int<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span>int target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans <span class="token operator">=</span> new ArrayList<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">//</span> 排序        int len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">|</span><span class="token operator">|</span> len <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token number">-3</span> <span class="token punctuation">;</span> i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">//</span>多固定了一个数，将问题转化为内部的三数之和            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token operator">//</span> 去重            <span class="token keyword">for</span> <span class="token punctuation">(</span>int j <span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token number">-2</span><span class="token punctuation">;</span>j<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">></span> i<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&amp;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token operator">//</span> 去重                int L <span class="token operator">=</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                int R <span class="token operator">=</span> len<span class="token number">-1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>L <span class="token operator">&lt;</span> R<span class="token punctuation">)</span><span class="token punctuation">{</span>                    int sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>                        ans<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span>asList<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;</span>R <span class="token operator">&amp;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>L<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> L<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span> <span class="token operator">//</span> 去重                        <span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;</span>R <span class="token operator">&amp;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">[</span>R<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>R<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> R<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">;</span> <span class="token operator">//</span> 去重                        L<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span>                        R<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> L<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> R<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>                <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-3-6-（2-medium）"><a href="#2020-3-6-（2-medium）" class="headerlink" title="2020.3.6 （2 medium）"></a>2020.3.6 （2 medium）</h2><h3 id="第17题-电话号码的字母组合"><a href="#第17题-电话号码的字母组合" class="headerlink" title="第17题 电话号码的字母组合"></a>第17题 电话号码的字母组合</h3><p><img src="17.png" alt="第17题 电话号码的字母组合"></p><h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1:"></a>思路1:</h4><p>打表+队列，类似于BFS。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">letterCombinations</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> digits<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'2'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'f'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'4'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'g'</span><span class="token punctuation">,</span><span class="token string">'h'</span><span class="token punctuation">,</span><span class="token string">'i'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'5'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'j'</span><span class="token punctuation">,</span><span class="token string">'k'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'6'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'m'</span><span class="token punctuation">,</span><span class="token string">'n'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'7'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'q'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span><span class="token string">'s'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'8'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'t'</span><span class="token punctuation">,</span><span class="token string">'u'</span><span class="token punctuation">,</span><span class="token string">'v'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'9'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'w'</span><span class="token punctuation">,</span><span class="token string">'x'</span><span class="token punctuation">,</span><span class="token string">'y'</span><span class="token punctuation">,</span><span class="token string">'z'</span><span class="token punctuation">]</span><span class="token punctuation">}</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> char <span class="token keyword">in</span> digits<span class="token punctuation">:</span>            <span class="token keyword">if</span> result<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                result<span class="token operator">=</span>dic<span class="token punctuation">[</span>char<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                l<span class="token operator">=</span>len<span class="token punctuation">(</span>result<span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                    st<span class="token operator">=</span>result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                    result<span class="token operator">=</span>result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#出队</span>                    <span class="token keyword">for</span> c <span class="token keyword">in</span> dic<span class="token punctuation">[</span>char<span class="token punctuation">]</span><span class="token punctuation">:</span>                        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st<span class="token operator">+</span>c<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#入队</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度:$O(3^M+4^N)$</p><h4 id="思路2-1"><a href="#思路2-1" class="headerlink" title="思路2:"></a>思路2:</h4><p>这里也可以使用回溯+递归的方法，将其看作是一个类似于全排列的问题。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">letterCombinations</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> digits<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type digits: str        :rtype: List[str]        """</span>        phone <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'2'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 <span class="token string">'3'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 <span class="token string">'4'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'g'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 <span class="token string">'5'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'j'</span><span class="token punctuation">,</span> <span class="token string">'k'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 <span class="token string">'6'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'m'</span><span class="token punctuation">,</span> <span class="token string">'n'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 <span class="token string">'7'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token string">'q'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 <span class="token string">'8'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'t'</span><span class="token punctuation">,</span> <span class="token string">'u'</span><span class="token punctuation">,</span> <span class="token string">'v'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 <span class="token string">'9'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">]</span><span class="token punctuation">}</span>        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>combination<span class="token punctuation">,</span> next_digits<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># if there is no more digits to check</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>next_digits<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># the combination is done</span>                output<span class="token punctuation">.</span>append<span class="token punctuation">(</span>combination<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># if there are still digits to check</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># iterate over all letters which map </span>                <span class="token comment" spellcheck="true"># the next available digit</span>                <span class="token keyword">for</span> letter <span class="token keyword">in</span> phone<span class="token punctuation">[</span>next_digits<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true"># append the current letter to the combination</span>                    <span class="token comment" spellcheck="true"># and proceed to the next digits</span>                    backtrack<span class="token punctuation">(</span>combination <span class="token operator">+</span> letter<span class="token punctuation">,</span> next_digits<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">//</span>这里可以看作是进行了回溯，因为直接使用了新的字符串，所以不用恢复状态         output <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> digits<span class="token punctuation">:</span>            backtrack<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> digits<span class="token punctuation">)</span>        <span class="token keyword">return</span> output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第19题-删除链表的倒数第N个节点"><a href="#第19题-删除链表的倒数第N个节点" class="headerlink" title="第19题 删除链表的倒数第N个节点"></a>第19题 删除链表的倒数第N个节点</h3><p><img src="19.png" alt="第19题 删除链表的倒数第N个节点"></p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>快慢指针法+dummy head。</p><p>快指针在前遍历链表，慢指针在后用于保存快指针的前第N个节点。当快指针遍历到链表的尾部，则可以使用慢指针删除节点。这里需要注意，当要删除的节点是第一个节点时，若使用题目中给出的头指针，需要分类讨论进行操作。为了不进行分类讨论，我们在链表开头处添加一个空的头结点（dummy head）。</p><ul><li><p>时间复杂度:$O(N)$</p></li><li><p>空间复杂度:$O(1)$</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        fore_head<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        fore_head<span class="token punctuation">.</span>next<span class="token operator">=</span>head        p<span class="token operator">=</span>fore_head        back_n<span class="token operator">=</span>fore_head        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next            <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                n<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">elif</span> <span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">//</span>n减到<span class="token number">0</span>时，才能移动慢指针，否则说明前第n个元素越界                back_n<span class="token operator">=</span>back_n<span class="token punctuation">.</span>next        back_n<span class="token punctuation">.</span>next<span class="token operator">=</span>back_n<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        <span class="token keyword">return</span> fore_head<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-3-7-（1-medium-1-hard）"><a href="#2020-3-7-（1-medium-1-hard）" class="headerlink" title="2020.3.7 （1 medium 1 hard）"></a>2020.3.7 （1 medium 1 hard）</h2><h3 id="第22题-括号生成"><a href="#第22题-括号生成" class="headerlink" title="第22题 括号生成"></a>第22题 括号生成</h3><p><img src="22.png" alt="第22题 括号生成"></p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路:"></a>思路:</h4><p>二叉树的先根遍历+剪枝。使用count记录当前字符串内左括号个数减去右括号个数的值，当count&lt;0或者count&gt;n，n为剩余的目标括号对数时，进行剪枝。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">generateParenthesis</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        count<span class="token operator">=</span><span class="token number">0</span>        st<span class="token operator">=</span><span class="token string">''</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dp</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span>n<span class="token punctuation">,</span>st<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>count<span class="token operator">&lt;=</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#剪枝</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#满足要求</span>                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st<span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#先根遍历</span>                    dp<span class="token punctuation">(</span>count<span class="token number">-1</span><span class="token punctuation">,</span>n<span class="token number">-1</span><span class="token punctuation">,</span>st<span class="token operator">+</span><span class="token string">')'</span><span class="token punctuation">)</span>                    dp<span class="token punctuation">(</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>st<span class="token operator">+</span><span class="token string">'('</span><span class="token punctuation">)</span>        dp<span class="token punctuation">(</span>count<span class="token punctuation">,</span>n<span class="token punctuation">,</span>st<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第23题-合并K个排序链表"><a href="#第23题-合并K个排序链表" class="headerlink" title="第23题 合并K个排序链表"></a>第23题 合并K个排序链表</h3><p><img src="23.png" alt="第23题 合并K个排序链表"></p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路:"></a>思路:</h4><p>分治法，类似于标准归并排序的思想。先将相邻的链表两两合并，得到个数为原来一半的新链表，接着继续两两合并，重复直到只剩下最后一个链表，即为最终的结果。</p><p>两两合并的方法，采用的是双指针法，即两个链表各设置一个指针，用于比较和插入结果链表。</p><ul><li>时间复杂度：$O(NlogK)$，N是所有链表中元素的总和，K是链表个数。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lists<span class="token punctuation">:</span> List<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>list1<span class="token punctuation">,</span>list2<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#两两合并</span>            p<span class="token operator">=</span>list1            q<span class="token operator">=</span>list2            head<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            m<span class="token operator">=</span>head            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> p<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                    m<span class="token punctuation">.</span>next<span class="token operator">=</span>p                    m<span class="token operator">=</span>m<span class="token punctuation">.</span>next                    p<span class="token operator">=</span>p<span class="token punctuation">.</span>next                <span class="token keyword">else</span><span class="token punctuation">:</span>                    m<span class="token punctuation">.</span>next<span class="token operator">=</span>q                    m<span class="token operator">=</span>m<span class="token punctuation">.</span>next                    q<span class="token operator">=</span>q<span class="token punctuation">.</span>next            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">==</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                m<span class="token punctuation">.</span>next<span class="token operator">=</span>q            <span class="token keyword">elif</span> <span class="token punctuation">(</span>q<span class="token operator">==</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                m<span class="token punctuation">.</span>next<span class="token operator">=</span>p            <span class="token keyword">return</span> head<span class="token punctuation">.</span>next        amount <span class="token operator">=</span> len<span class="token punctuation">(</span>lists<span class="token punctuation">)</span>        interval <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> interval <span class="token operator">&lt;</span> amount<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#两两合并</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> amount <span class="token operator">-</span> interval<span class="token punctuation">,</span> interval <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> merge<span class="token punctuation">(</span>lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> lists<span class="token punctuation">[</span>i <span class="token operator">+</span> interval<span class="token punctuation">]</span><span class="token punctuation">)</span>            interval <span class="token operator">*=</span> <span class="token number">2</span>        <span class="token keyword">return</span> lists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">if</span> amount <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">else</span> lists<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么不使用逐一合并的算法呢？那样合并的过程写起来会很简单？</p><ul><li><p>逐一合并的时间复杂度：$O(NK)$</p></li><li><p>因为这里的两两排序实际上运用了分治法的思想，逐一合并的话，每一次合并在最坏的情况下都需要比较N个节点，而两两合并，每一轮合并的最坏情况才需要比较N个节点。逐一合并需要进行（K-1）次，而两两合并仅需要进行（logN）轮，所以时间复杂度大大降低。</p></li></ul><p><img src="23-2.png" alt="分治法"></p><h2 id="2020-3-8-（1-hard-1-medium）"><a href="#2020-3-8-（1-hard-1-medium）" class="headerlink" title="2020.3.8 （1 hard 1 medium）"></a>2020.3.8 （1 hard 1 medium）</h2><h3 id="第24题-两两交换链表中的节点"><a href="#第24题-两两交换链表中的节点" class="headerlink" title="第24题 两两交换链表中的节点"></a>第24题 两两交换链表中的节点</h3><p><img src="24.png" alt="第24题 两两交换链表中的节点"></p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路:"></a>思路:</h4><p>本质上就是两个一组翻转链表。可以使用头插法+dummy head。使用三个指针pre、p、q，将q结点插入至p结点之前，即完成了一次交换。然后移动指针至下两个节点处，继续交换。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        h<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#dummy head </span>        h<span class="token punctuation">.</span>next<span class="token operator">=</span>head        pre<span class="token operator">=</span>h        p<span class="token operator">=</span>head        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">==</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> head        <span class="token keyword">else</span><span class="token punctuation">:</span>            q<span class="token operator">=</span>p<span class="token punctuation">.</span>next            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token operator">and</span><span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                p<span class="token punctuation">.</span>next<span class="token operator">=</span>q<span class="token punctuation">.</span>next                q<span class="token punctuation">.</span>next<span class="token operator">=</span>p                pre<span class="token punctuation">.</span>next<span class="token operator">=</span>q                <span class="token comment" spellcheck="true">#两个一组翻转链表</span>                pre<span class="token operator">=</span>p                p<span class="token operator">=</span>p<span class="token punctuation">.</span>next                <span class="token keyword">if</span> p<span class="token operator">!=</span>None<span class="token punctuation">:</span>                    q<span class="token operator">=</span>p<span class="token punctuation">.</span>next                <span class="token comment" spellcheck="true">#移动至下两个节点进行操作   </span>        <span class="token keyword">return</span> h<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第25题-K-个一组翻转链表"><a href="#第25题-K-个一组翻转链表" class="headerlink" title="第25题  K 个一组翻转链表"></a>第25题  K 个一组翻转链表</h3><p><img src="25.png" alt="第25题  K 个一组翻转链表"></p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路:"></a>思路:</h4><p>上一题的扩展，使用dummy head+头插法即可。</p><ul><li>pre指针：当前组的第一个节点的前一个节点，用于插入元素。</li><li>q指针： 要插到头部的那个节点。</li><li>p指针： q节点的前一个节点，用于删除q节点。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        h<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        h<span class="token punctuation">.</span>next<span class="token operator">=</span>head        pre<span class="token operator">=</span>h        p<span class="token operator">=</span>head        count<span class="token operator">=</span><span class="token number">0</span>        t<span class="token operator">=</span>pre<span class="token punctuation">.</span>next        <span class="token keyword">while</span><span class="token punctuation">(</span>t<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#统计当前链表的长度</span>            count<span class="token operator">+=</span><span class="token number">1</span>            t<span class="token operator">=</span>t<span class="token punctuation">.</span>next        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">==</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> head        <span class="token keyword">else</span><span class="token punctuation">:</span>            q<span class="token operator">=</span>p<span class="token punctuation">.</span>next            <span class="token keyword">while</span> <span class="token punctuation">(</span>pre<span class="token operator">!=</span>None<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">&lt;</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当前链表的剩余长度是否可以进行翻转</span>                    <span class="token keyword">return</span> h<span class="token punctuation">.</span>next                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    p<span class="token punctuation">.</span>next<span class="token operator">=</span>q<span class="token punctuation">.</span>next                    q<span class="token punctuation">.</span>next<span class="token operator">=</span>pre<span class="token punctuation">.</span>next                    pre<span class="token punctuation">.</span>next<span class="token operator">=</span>q                     q<span class="token operator">=</span>p<span class="token punctuation">.</span>next                      <span class="token comment" spellcheck="true">#当前组内的节点进行头插法翻转</span>                pre<span class="token operator">=</span>p                p<span class="token operator">=</span>pre<span class="token punctuation">.</span>next                <span class="token keyword">if</span> p<span class="token operator">==</span>None<span class="token punctuation">:</span>                    <span class="token keyword">return</span> h<span class="token punctuation">.</span>next                q<span class="token operator">=</span>p<span class="token punctuation">.</span>next                count<span class="token operator">-=</span>k                <span class="token comment" spellcheck="true">#指针移动至下一组开始处</span>        <span class="token keyword">return</span> h<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-3-9-（3-easy）"><a href="#2020-3-9-（3-easy）" class="headerlink" title="2020.3.9 （3 easy）"></a>2020.3.9 （3 easy）</h2><h3 id="第26题-删除排序数组中的重复项"><a href="#第26题-删除排序数组中的重复项" class="headerlink" title="第26题 删除排序数组中的重复项"></a>第26题 删除排序数组中的重复项</h3><p><img src="26.png" alt="第26题 删除排序数组中的重复项"></p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路:"></a>思路:</h4><p>快慢指针法，慢指针指向当前数组内无重复的子序列的最后一项，快指针用于遍历整个数组。</p><ul><li>当快指针指向的元素与慢指针指向的元素不相等时，将该元素加入至慢指针维护的无重复子序列中，慢指针和快指针都加1。</li><li>当元素相等时，快指针直接遍历下一个元素。</li><li>时间复杂度：$O(N)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        slow<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> fast <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token operator">!=</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                slow<span class="token operator">+=</span><span class="token number">1</span>                nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span>        <span class="token keyword">return</span> slow<span class="token operator">+</span><span class="token number">1</span><span class="token comment" spellcheck="true">#由于慢指针指向的是子序列最后一项的下标，子序列长度需要加1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第27题-移除元素"><a href="#第27题-移除元素" class="headerlink" title="第27题 移除元素"></a>第27题 移除元素</h3><p><img src="27.png" alt="第27题 移除元素"></p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路:"></a>思路:</h4><p>同样使用快慢指针法，快指针用于遍历，慢指针维护一个没有target元素的子序列，指向该子序列末尾的后一个元素。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> val<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        slow<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> fast <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token operator">!=</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span>                slow<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，慢指针与26题有一些区别，27题的慢指针指向的是符合要求的子序列的后一项，而26题是最后一项。这是因为26题中，单个元素不可能重复，而27题中，单个元素也可能是需要被移除的。</p><h3 id="第28题-实现-strStr"><a href="#第28题-实现-strStr" class="headerlink" title="第28题 实现 strStr()"></a>第28题 实现 strStr()</h3><p><img src="27.png" alt="第28题 实现 strStr()"></p><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路:"></a>思路:</h4><p>KMP算法，具体可以看这里：<a href="/2020/03/17/kmp-suan-fa">KMP算法总结</a></p><h2 id="2020-3-10-（1-hard-1-medium）"><a href="#2020-3-10-（1-hard-1-medium）" class="headerlink" title="2020.3.10 （1 hard 1 medium）"></a>2020.3.10 （1 hard 1 medium）</h2><h3 id="第29题-两数相除"><a href="#第29题-两数相除" class="headerlink" title="第29题 两数相除"></a>第29题 两数相除</h3><p><img src="29.png" alt="第29题 两数相除"></p><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路:"></a>思路:</h4><p>我们最初很容易可以想到使用累减法来解决除法问题，但这会很慢，所以我们需要使用递归方法加速累减。</p><p>递归的具体过程是，在递归函数内部，我们在保证当前除数不大于被除数的情况下，使除数不断翻倍，并记录倍数。当除数即将大于当前被除数时，我们停止翻倍，并记录下当前的倍数，加到商上。此时，我们将除数减去当前的被除数，剩余的结果重复之前的过程，直到剩余的数小于原始的除数。</p><p>本质上，这题的思想类似于快速幂算法，都是使用翻倍来加速，利用二分思想优化至logN级别的时间复杂度。因为一个一个减肯定不如翻倍翻倍减快速。</p><p>特别的，这道题还需要考虑补码的机制问题，当被除数等于$-2^31$时，商最大只能等于$2^31-1$。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">divide</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dividend<span class="token punctuation">:</span> int<span class="token punctuation">,</span> divisor<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> dividend<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#防止除数为0</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> divisor<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#除数为1，直接返回结果，加速运算</span>            <span class="token keyword">return</span> dividend        <span class="token keyword">if</span> divisor<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#除数为-1，直接返回结果的负数，加速运算</span>            <span class="token keyword">if</span> dividend<span class="token operator">==</span><span class="token operator">-</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#考虑integer的溢出</span>                <span class="token keyword">return</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span>dividend        flag<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dividend<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>divisor<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dividend<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>divisor<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#考虑符号</span>            flag<span class="token operator">=</span><span class="token number">1</span>        dividend<span class="token operator">=</span>abs<span class="token punctuation">(</span>dividend<span class="token punctuation">)</span>        divisor<span class="token operator">=</span>abs<span class="token punctuation">(</span>divisor<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">div</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#递归求解</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">&lt;</span>divisor<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> result            count<span class="token operator">=</span><span class="token number">1</span>            result<span class="token operator">+=</span>count            b<span class="token operator">=</span>divisor            a<span class="token operator">-=</span>b            <span class="token keyword">while</span> <span class="token punctuation">(</span>b<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token operator">&lt;=</span>a<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#翻倍累减</span>                count<span class="token operator">+=</span>count                result<span class="token operator">+=</span>count                b<span class="token operator">+=</span>b                a<span class="token operator">-=</span>b            <span class="token keyword">return</span> div<span class="token punctuation">(</span>result<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#尾递归，减少栈空间调用</span>        <span class="token keyword">return</span> flag<span class="token operator">*</span><span class="token punctuation">(</span>div<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>dividend<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第30题-串联所有单词的子串"><a href="#第30题-串联所有单词的子串" class="headerlink" title="第30题 串联所有单词的子串"></a>第30题 串联所有单词的子串</h3><p><img src="30.png" alt="第30题 串联所有单词的子串"></p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路:"></a>思路:</h4><p>滑动窗口法+哈希表。</p><p>由于题目中提到了所有单词等长，那么我们对于n个长度为k的单词可以维护一个长度为k*n的滑动窗口。接着，我们利用哈希表建立words列表中的单词和单词数目的映射。然后，我们可以使用滑动窗口进行滑动匹配，每次移动一个单词的长度。对于窗口内部，我们统计每k长度的字符串，若出现了不在哈希表的键中的字符串，或者字符串出现的次数大于哈希表中对应的值时，说明此窗口失配，进行下一次匹配，否则，记录下窗口起始位置。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> words<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> s<span class="token operator">==</span><span class="token string">""</span> <span class="token operator">or</span> words<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#目标串或者待匹配列表为空</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> w <span class="token keyword">in</span> words<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#建哈希表（字典）</span>            <span class="token keyword">if</span> w <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dic<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dic<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        l<span class="token operator">=</span>len<span class="token punctuation">(</span>words<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        window<span class="token operator">=</span>l<span class="token operator">*</span>len<span class="token punctuation">(</span>words<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span>window<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#滑动匹配</span>            end<span class="token operator">=</span>i<span class="token operator">+</span>window            tmp<span class="token operator">=</span>dic<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>            flag<span class="token operator">=</span><span class="token number">1</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span>end<span class="token punctuation">,</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                w<span class="token operator">=</span>s<span class="token punctuation">[</span>j<span class="token punctuation">:</span>j<span class="token operator">+</span>l<span class="token punctuation">]</span>                <span class="token keyword">if</span> w <span class="token operator">not</span> <span class="token keyword">in</span> tmp<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    flag<span class="token operator">=</span><span class="token number">0</span>                    <span class="token keyword">break</span>                tmp<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">if</span> tmp<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>                    flag<span class="token operator">=</span><span class="token number">0</span>                    <span class="token keyword">break</span>            <span class="token keyword">if</span> flag<span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-3-11-（2-medium-1-hard）"><a href="#2020-3-11-（2-medium-1-hard）" class="headerlink" title="2020.3.11 （2 medium 1 hard）"></a>2020.3.11 （2 medium 1 hard）</h2><h3 id="第31题-下一个排列"><a href="#第31题-下一个排列" class="headerlink" title="第31题 下一个排列"></a>第31题 下一个排列</h3><p><img src="31.png" alt="第31题 下一个排列"></p><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路:"></a>思路:</h4><p>核心思想：</p><ul><li>我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。</li><li>我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：</li></ul><ol><li>在尽可能靠右的低位进行交换，需要从后向前查找</li><li>将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换</li><li>将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">nextPermutation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify nums in-place instead.        """</span>        <span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#交换数组中的两个元素</span>            temp<span class="token operator">=</span>nums<span class="token punctuation">[</span>a<span class="token punctuation">]</span>            nums<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>b<span class="token punctuation">]</span>            nums<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token operator">=</span>temp        p<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>p<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>从后向前遍历，找到从后向前看的第一个下降的位置                min_pos<span class="token operator">=</span>p                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>p<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#搜索最小的大数并交换</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>p<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        min_pos<span class="token operator">=</span>i                        <span class="token keyword">break</span>                swap<span class="token punctuation">(</span>min_pos<span class="token punctuation">,</span>p<span class="token number">-1</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>int<span class="token punctuation">(</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span>p<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#原地翻转，将大数后所有数重置为升序</span>                    swap<span class="token punctuation">(</span>p<span class="token operator">+</span>i<span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">)</span>                <span class="token keyword">break</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                p<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果为降序数组，则重置为升序数组</span>            nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这类题一定要把情况自己模拟一遍，寻找下一个转移的规律。</strong></p><h3 id="第32题-最长有效括号"><a href="#第32题-最长有效括号" class="headerlink" title="第32题 最长有效括号"></a>第32题 最长有效括号</h3><p><img src="32.png" alt="第32题 最长有效括号"></p><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路:"></a>思路:</h4><p>双向滑动窗口。</p><p>使用双指针维护一个滑动窗口。先从左向右滑动窗口，左右指针初始为0，使用一个变量count来存储当前窗口内左括号数量减去右括号数量的值。右指针不断向前遍历，当遍历到当前窗口内count&lt;0时，将左右指针都移动到当前右指针的下一个位置，重置窗口，当count==0时，使用当前窗口长度比较并尝试更新最大长度，当count&gt;0时，右指针继续向前遍历。</p><p>上述滑动完成后，再反向从右往左滑动一次窗口。此时的结果即为最大长度。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestValidParentheses</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        p<span class="token operator">=</span><span class="token number">0</span>        q<span class="token operator">=</span><span class="token number">0</span>        count<span class="token operator">=</span><span class="token number">0</span>        max_len<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"("</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                count<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">elif</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                count<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                q<span class="token operator">+=</span><span class="token number">1</span>                p<span class="token operator">=</span>q                count<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">></span>max_len<span class="token punctuation">:</span>                        max_len<span class="token operator">=</span>q<span class="token operator">-</span>p<span class="token operator">+</span><span class="token number">1</span>                q<span class="token operator">+=</span><span class="token number">1</span>        <span class="token comment" spellcheck="true">#从左向右滑动</span>        p<span class="token operator">=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        q<span class="token operator">=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        count<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"("</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                count <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                p<span class="token operator">-=</span> <span class="token number">1</span>                q <span class="token operator">=</span> p                count <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">-</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> max_len<span class="token punctuation">:</span>                        max_len <span class="token operator">=</span> q <span class="token operator">-</span> p <span class="token operator">+</span> <span class="token number">1</span>                p<span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true">#从右向左滑动</span>        <span class="token keyword">return</span> max_len<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第33题-搜索旋转排序数组"><a href="#第33题-搜索旋转排序数组" class="headerlink" title="第33题 搜索旋转排序数组"></a>第33题 搜索旋转排序数组</h3><p><img src="33.png" alt="第33题 搜索旋转排序数组"></p><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路:"></a>思路:</h4><p>由于题目要求时间复杂度在logN级别，所以必须是用二分法进行查找。但我们知道二分查找只适用于有序数组，所以我们需要使用嵌套二分。</p><p>首先，我们将数组从中间一分为二，根据旋转排序数组的性质，必然至少有一半有序。我们先判断左半数组是否有序，若有序，判断目标是否在它的范围内，若在，则在左半数组中二分查找，而不在，则去右半数组中二分查找。否则，即为右半数组有序，若目标在范围内，则在右半数组中二分，否则去左半数组中二分。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#中间数为目标</span>                <span class="token keyword">return</span> mid            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#左半数组有序</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#目标在左半数组中</span>                    right<span class="token operator">=</span>mid<span class="token number">-1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#右半数组有序</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#目标在右半数组中</span>                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    right<span class="token operator">=</span>mid<span class="token number">-1</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-3-12-（2-medium-1-hard）"><a href="#2020-3-12-（2-medium-1-hard）" class="headerlink" title="2020.3.12 （2 medium 1 hard）"></a>2020.3.12 （2 medium 1 hard）</h2><h3 id="第34题-在排序数组中查找元素的第一个和最后一个位置"><a href="#第34题-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="第34题 在排序数组中查找元素的第一个和最后一个位置"></a>第34题 在排序数组中查找元素的第一个和最后一个位置</h3><p><img src="41.png" alt="第34题 在排序数组中查找元素的第一个和最后一个位置"></p><h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路:"></a>思路:</h4><p>由于时间复杂度控制在logN级别，所以很明显需要使用二分查找。</p><p>我们以二分查找获取左边界为例进行说明。首先，我们使用的是常规二分查找的框架，即比较目标与当前区间的中位数。不过常规二分查找是当目标大于中位数时进入右区间查找，小于中位数时进入左区间查找，等于中位数时返回当前中位数的位置。不同的是，此时我们需要查找的是元素的第一个位置。所以，我们需要进行这样的修改：当中位数等于目标时，目标元素的起始位置很明显要么在中位数处，要么在中位数左侧区间，此时我们直接进入左区间查找即可，其余的做法和常规二分查找一样。你可能会疑惑万一第一个位置就是中位数怎么办。不用担心，当遍历完左区间后无法再次找到目标元素，此时会在左区间的末尾尝试进入右区间，又回到了我们原先的中位数处。</p><p>二分查找右边界的方法同理，只是将中位数等于目标时改为进入右区间查找即可。</p><p>注意，当得到左右边界后还要判定是否合法。</p><p>通过两次二分，我们可以在$O(logN)$的时间复杂度内完成查找。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">searchRange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> nums<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">getLeftBound</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#查找左边界</span>            left<span class="token operator">=</span><span class="token number">0</span>            right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>                mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">>=</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>                    right<span class="token operator">=</span>mid<span class="token number">-1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#左边界合法</span>                <span class="token keyword">return</span> left            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">def</span> <span class="token function">getRightBound</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#查找右边界</span>            left<span class="token operator">=</span><span class="token number">0</span>            right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>                mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    right<span class="token operator">=</span>mid<span class="token number">-1</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>right<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#右边界合法</span>                <span class="token keyword">return</span> right            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>getLeftBound<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">,</span>getRightBound<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第36题-有效的数独"><a href="#第36题-有效的数独" class="headerlink" title="第36题 有效的数独"></a>第36题 有效的数独</h3><p><img src="36.png" alt="第36题 有效的数独"></p><h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路:"></a>思路:</h4><p>使用三个二维数组，分别存放每一行、每一列、每一个子数独当前放置的值。依次遍历这81个格子，每次遍历时将非空格子中的数放入对应的行、列、子数独的列表中。若出现了重复，则说明当前数独无效。</p><ul><li>时间复杂度：$O(1)$</li><li>空间复杂度：$O(1)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValidSudoku</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        cols<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        rows<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        sons<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'.'</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">in</span> cols<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">in</span> rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">in</span> sons<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>j<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">False</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        cols<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                        rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                        sons<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>j<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第37题-解数独"><a href="#第37题-解数独" class="headerlink" title="第37题 解数独"></a>第37题 解数独</h3><p><img src="37.png" alt="第37题 解数独"></p><h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路:"></a>思路:</h4><p>递归+回溯。类似的问题还有走迷宫、皇后问题、全排列等，本质的思路都是去使用回溯算法递归的尝试每种可能的情况。</p><p>回溯算法模板如下：</p><blockquote><p>def backtrack(…):<br> if (符合结束条件):<br>      保存结果<br>  else:<br>      for 选择 in 选择列表：<br>          if 选择合法：<br>              进行选择<br>              backtrack(…)#递归进入下一个位置进行选择<br>              撤销选择</p></blockquote><p>本题中，我们对每一个格子进行遍历，如果当前格子非空，我们便在“1”到“9”中选择合法的数字填入当前格子，并进入下一个格子继续选择。如果一直到最后一个格子都可以成功填入数字，则说明解完了数独，可以返回真。如果当前格子无法填入任何数字，则需要回溯至上一层递归函数，去恢复数独的状态，并选择下一个数字尝试填入。</p><p>判定当前数独矩阵是否合法，参考第36题即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">solveSudoku</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify board in-place instead.        """</span>        cols<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        rows<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        sons<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">could_place</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#是否可以在当前格子放置value数字</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token keyword">in</span> cols<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>value <span class="token keyword">in</span> rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>value <span class="token keyword">in</span> sons<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>j<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">def</span> <span class="token function">place</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#放置数字</span>            cols<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>            rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>            sons<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>j<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>            board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>value        <span class="token keyword">def</span> <span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#移除数字</span>            cols<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>remove<span class="token punctuation">(</span>value<span class="token punctuation">)</span>            rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>remove<span class="token punctuation">(</span>value<span class="token punctuation">)</span>            sons<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>j<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>remove<span class="token punctuation">(</span>value<span class="token punctuation">)</span>            board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"."</span>        <span class="token keyword">def</span> <span class="token function">DFS</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#回溯函数</span>            <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">8</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#结束递归条件</span>               <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"."</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当前格子是否为空</span>                <span class="token keyword">for</span> value <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历选择</span>                    value<span class="token operator">=</span>str<span class="token punctuation">(</span>value<span class="token punctuation">)</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>could_place<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果选择合法</span>                        place<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#进行选择</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#判断是否走到行尾</span>                            <span class="token keyword">if</span> <span class="token operator">not</span><span class="token punctuation">(</span>DFS<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果当前可以递归找到解，那么直接返回真，不需要再继续选择，否则回溯继续选择。</span>                                remove<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>value<span class="token punctuation">)</span>                            <span class="token keyword">else</span><span class="token punctuation">:</span>                                <span class="token keyword">return</span> <span class="token boolean">True</span>                        <span class="token keyword">else</span><span class="token punctuation">:</span>                            <span class="token keyword">if</span> <span class="token operator">not</span><span class="token punctuation">(</span>DFS<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                remove<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>value<span class="token punctuation">)</span>                            <span class="token keyword">else</span><span class="token punctuation">:</span>                                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> DFS<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> DFS<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#统计已经存在的数</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'.'</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">in</span> cols<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">in</span> rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">in</span> sons<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>j<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        cols<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                        rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                        sons<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>j<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        DFS<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-3-13-（2-medium）"><a href="#2020-3-13-（2-medium）" class="headerlink" title="2020.3.13 （2 medium）"></a>2020.3.13 （2 medium）</h2><h3 id="第39题-组合总和"><a href="#第39题-组合总和" class="headerlink" title="第39题 组合总和"></a>第39题 组合总和</h3><p><img src="39.png" alt="第39题 组合总和"></p><h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路:"></a>思路:</h4><p>递归回溯算法+剪枝</p><p>递归组合分解，每次选择候选数组中的一个元素，用目标值减去它。</p><ul><li>若得到的结果大于0，说明还可以继续分解，将当前选择的元素加入至路径列表，并尝试继续分解。</li><li>如果当前结果等于0，说明分解成功，将当前选择的元素加入至路径列表，并将当前路径列表加入至结果列表。</li><li>如果当前结果小于0，说明无法再分解，特别地，当候选数组升序时，后面的元素很明显也无法分解，需要跳出循环。</li></ul><p><img src="39-1.png" alt="回溯法"><br>此外，有可能出现重复的结果，即虽然路径不同，但元素相同。考虑到这一问题，尝试进行剪枝：</p><ul><li>记录下当前选择的元素的下标，下一次选择元素从该下标开始。<br><img src="39-2.png" alt="剪枝"></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">combinationSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> candidates<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        candidates<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">back</span><span class="token punctuation">(</span>re<span class="token punctuation">,</span>index<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>index<span class="token punctuation">,</span>len<span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历选择</span>                num<span class="token operator">=</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                target_now<span class="token operator">=</span>target<span class="token operator">-</span>num                <span class="token keyword">if</span> target_now<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>                re<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#选择</span>                <span class="token keyword">if</span> target_now<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    res<span class="token operator">=</span>re<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>res<span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    back<span class="token punctuation">(</span>re<span class="token punctuation">,</span>i<span class="token punctuation">,</span>target_now<span class="token punctuation">)</span>                re<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#回溯恢复</span>        back<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第40题-组合总和2"><a href="#第40题-组合总和2" class="headerlink" title="第40题 组合总和2"></a>第40题 组合总和2</h3><p><img src="40.png" alt="第40题 组合总和2"></p><h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路:"></a>思路:</h4><p>和上一题类似，依然使用剪枝+递归回溯的思路来做。</p><p>有两个区别，一个是候选数组可能会出现重复，我们采用三数之和问题里类似的剪枝思路进行去重。第二个区别是数字不能重复使用，所以递归进行下一次元素的选择时，要从当前元素下标的下一个开始。</p><p><img src="40-1.png" alt="剪枝过程"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">combinationSum2</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> candidates<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        candidates<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">back</span><span class="token punctuation">(</span>re<span class="token punctuation">,</span>index<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>index<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>index<span class="token punctuation">,</span>len<span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> i<span class="token operator">!=</span>index <span class="token operator">and</span> <span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>candidates<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#去重</span>                        <span class="token keyword">continue</span>                    target_now<span class="token operator">=</span>target<span class="token operator">-</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>target_now<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">break</span>                    re<span class="token punctuation">.</span>append<span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>target_now<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>re<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        back<span class="token punctuation">(</span>re<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>target_now<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#从下一元素开始遍历，防止数字重复使用</span>                    re<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        back<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-3-14-（2-hard-1-medium）"><a href="#2020-3-14-（2-hard-1-medium）" class="headerlink" title="2020.3.14 （2 hard 1 medium）"></a>2020.3.14 （2 hard 1 medium）</h2><h3 id="第41题-缺失的第一个正数"><a href="#第41题-缺失的第一个正数" class="headerlink" title="第41题 缺失的第一个正数"></a>第41题 缺失的第一个正数</h3><p><img src="41.png" alt="第41题 缺失的第一个正数"></p><h4 id="思路-23"><a href="#思路-23" class="headerlink" title="思路:"></a>思路:</h4><p>我们很容易想到利用哈希表（即字典）进行统计，然后去寻找第一个缺失的正数。但是考虑到题目的要求为时间复杂度$O(N)$以及常数级别的空间复杂度，我们可以考虑将数组自身作为一个哈希表，对应的哈希函数为:</p><p>$$f(nums[i])=nums[i]-1$$</p><p>通过哈希函数，将可以进行映射的数组元素映射到对应位置上，然后依次遍历寻找第一个映射不正确的位置即可。</p><p>复杂度分析：</p><ul><li><p>时间复杂度：$O(N)$，这里$N$是数组的长度。<br>说明：while 循环不会每一次都把数组里面的所有元素都看一遍。如果有一些元素在这一次的循环中被交换到了它们应该在的位置，那么在后续的遍历中，由于它们已经在正确的位置上了，代码再执行到它们的时候，就会被跳过。最极端的一种情况是，在第 1 个位置经过这个 while 就把所有的元素都看了一遍，这个所有的元素都被放置在它们应该在的位置，那么 for 循环后面的部分的 while 的循环体都不会被执行。平均下来，每个数只需要看一次就可以了，while 循环体被执行很多次的情况不会每次都发生。这样的复杂度分析的方法叫做<strong>均摊复杂度分析</strong>。</p></li><li><p>空间复杂度：$O(1)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">firstMissingPositive</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>pos1<span class="token punctuation">,</span>pos2<span class="token punctuation">)</span><span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>pos1<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>pos2<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>pos2<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>pos1<span class="token punctuation">]</span>        size<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>size<span class="token punctuation">)</span><span class="token operator">and</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当当前位置的数字可以进行哈希映射，并且不在对应位置时，与对应位置的数字交换。如果重复了或者无法映射（不在范围内），则不映射。</span>                swap<span class="token punctuation">(</span>i<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#寻找第一个不符合映射规则的位置</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">return</span> size<span class="token operator">+</span><span class="token number">1</span><span class="token comment" spellcheck="true">#都符合，那么就输出下一个正数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注:为什么使用nums[i]!=nums[nums[i]-1]来判断而不是i!=nums[i]-1？</p><p>因为后者无法处理重复的数字。</p><h3 id="第42题-接雨水"><a href="#第42题-接雨水" class="headerlink" title="第42题 接雨水"></a>第42题 接雨水</h3><p><img src="42.png" alt="第42题 接雨水"></p><h4 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h4><p>双指针+左右各一次遍历。从左向右遍历时，保证左指针指向的是短板。右指针不断向前遍历，每次右指针遇到长板后，计算此时所形成的容器的容积，再将左指针移到右指针处，右指针继续向前遍历。直到右指针遍历到数组末尾。然后再用相同的方式反向搜索一遍即可。将所有容积相加即为答案。</p><ul><li><p>时间复杂度:两次遍历，$O(N)$。</p></li><li><p>空间复杂度：$O(1)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">trap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>left<span class="token operator">+</span><span class="token number">1</span>        water<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#从左向右</span>            <span class="token keyword">if</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">>=</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">:</span>                width<span class="token operator">=</span>right<span class="token operator">-</span>left<span class="token number">-1</span>                tmp<span class="token operator">=</span><span class="token number">0</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#减去被柱子占用的体积</span>                    tmp<span class="token operator">-=</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                tmp<span class="token operator">+=</span>width<span class="token operator">*</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                water<span class="token operator">+=</span>tmp                left<span class="token operator">=</span>right            right<span class="token operator">+=</span><span class="token number">1</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        left<span class="token operator">=</span>right<span class="token number">-1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#从右向左</span>            <span class="token keyword">if</span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">></span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                width<span class="token operator">=</span>right<span class="token operator">-</span>left<span class="token number">-1</span>                tmp<span class="token operator">=</span><span class="token number">0</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>                    tmp<span class="token operator">-=</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                tmp<span class="token operator">+=</span>width<span class="token operator">*</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span>                water<span class="token operator">+=</span>tmp                right<span class="token operator">=</span>left            left<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> water<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>实际上，这里并不需要两次遍历，因为从左向右和从右向左的遍历都会在最高的柱子处停下。所以我们可以同时从两侧开始逼近，每次让左右指针较小的那个移动。</p><p>同时，我们可以维护一个left_max和right_max，即左右指针当前遍历到的最高柱。利用它们可以计算当前格子的积水。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">trap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        left_max<span class="token operator">=</span><span class="token number">0</span>        right_max<span class="token operator">=</span><span class="token number">0</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        water<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>            <span class="token keyword">if</span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#确保不会越过山顶</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">>=</span>left_max<span class="token punctuation">)</span><span class="token punctuation">:</span>                    left_max<span class="token operator">=</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    water<span class="token operator">+=</span>left_max<span class="token operator">-</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#利用max变量求解当前格的积水</span>                left<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">>=</span>right_max<span class="token punctuation">)</span><span class="token punctuation">:</span>                    right_max<span class="token operator">=</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    water<span class="token operator">+=</span>right_max<span class="token operator">-</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span>                right<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> water<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组必有一个 ”山顶“（若有多个高度相同山顶，任取一个即可）。</p><p>根据”木桶原理“，山顶左侧的元素的盛水量 ，由左侧最大值决定；山顶右侧元素的盛水量，由右侧最大值决定。</p><p>双指针法的两个指针最终会停在 “山顶” 处。</p><h3 id="第43题-字符串相乘"><a href="#第43题-字符串相乘" class="headerlink" title="第43题 字符串相乘"></a>第43题 字符串相乘</h3><p><img src="43.png" alt="第43题 字符串相乘"><br>大数乘法问题，采取模拟竖式计算的方式求解。使用两个数组来存放两个数字字符串，数组的低位存数字字符串的低位。将第1个数组的第i位与第2个数组的第j位相乘，放入结果数组的第i+j位上。计算完成后，遍历结果数组，将所有大于9的进行进位操作。再反向遍历去掉最末尾的0。最后反向拼接成字符串输出即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">multiply</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num1<span class="token punctuation">:</span> str<span class="token punctuation">,</span> num2<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        numLi1<span class="token operator">=</span><span class="token punctuation">[</span>int<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> num1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        numLi2<span class="token operator">=</span><span class="token punctuation">[</span>int<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> num2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        len1<span class="token operator">=</span>len<span class="token punctuation">(</span>numLi1<span class="token punctuation">)</span>        len2<span class="token operator">=</span>len<span class="token punctuation">(</span>numLi2<span class="token punctuation">)</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>len1<span class="token operator">+</span>len2<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len1<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#模拟两个数字的每一位相乘</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len2<span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">[</span>i<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token operator">+=</span>numLi1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>numLi2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len1<span class="token operator">+</span>len2<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#进位操作</span>            <span class="token keyword">if</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">9</span><span class="token punctuation">:</span>                res<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+=</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#10</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">%=</span><span class="token number">10</span>          <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#去除结果开头的0</span>            <span class="token keyword">if</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span> <span class="token punctuation">:</span>                res<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>        res<span class="token operator">=</span><span class="token punctuation">[</span>str<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> res<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度:$O(MN)$</li><li>空间复杂度:$O(M+N)$</li></ul><h2 id="2020-3-15-（2-hard）"><a href="#2020-3-15-（2-hard）" class="headerlink" title="2020.3.15 （2 hard）"></a>2020.3.15 （2 hard）</h2><h3 id="第44题-通配符匹配"><a href="#第44题-通配符匹配" class="headerlink" title="第44题 通配符匹配"></a>第44题 通配符匹配</h3><p><img src="44.png" alt="第44题 通配符匹配"></p><h4 id="思路-25"><a href="#思路-25" class="headerlink" title="思路:"></a>思路:</h4><p>类似于第十题，可以采用相同的动态规划方法处理，甚至比第十题简单一些。由子串的匹配转移到当前串的匹配，直到转移至目标串和模式串的匹配。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> p<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#动态规划</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"*"</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">or</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">and</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"?"</span> <span class="token operator">or</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度:$O(MN)$</li><li>空间复杂度:$O(MN)$</li></ul><h4 id="更好的思路："><a href="#更好的思路：" class="headerlink" title="更好的思路："></a>更好的思路：</h4><p>有一种更好的思路来进行匹配，降低了时空复杂度，使用的是回溯和贪心的思想。具体看这里:<a href="https://leetcode-cn.com/problems/wildcard-matching/solution/tong-pei-fu-pi-pei-by-leetcode/" target="_blank" rel="noopener">40题解</a></p><h3 id="第45题-跳跃游戏2"><a href="#第45题-跳跃游戏2" class="headerlink" title="第45题 跳跃游戏2"></a>第45题 跳跃游戏2</h3><p><img src="45.png" alt="第45题 跳跃游戏2"></p><h4 id="思路-26"><a href="#思路-26" class="headerlink" title="思路:"></a>思路:</h4><p>贪心思路。在当前可以跳到的下一跳候选位置中，选择继续跳跃能够到达最远位置的候选位置，贪心地进行跳跃。当即将跳到数组末尾或者超过数组末尾时，返回当前步数加1，否则继续跳跃。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">jump</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        now<span class="token operator">=</span><span class="token number">0</span><span class="token comment" spellcheck="true">#当前位置</span>        count<span class="token operator">=</span><span class="token number">0</span><span class="token comment" spellcheck="true">#步数</span>        l<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token comment" spellcheck="true">#数组末尾位置</span>        <span class="token keyword">if</span> l<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> count        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> now<span class="token operator">+</span>nums<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">>=</span>l<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#即将到达末尾</span>                <span class="token keyword">return</span> count<span class="token operator">+</span><span class="token number">1</span>            farthest<span class="token operator">=</span><span class="token number">0</span>            next<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>now<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>now<span class="token operator">+</span>nums<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#贪心地选择能够抵达更远地方的下一跳位置</span>                farthest_now<span class="token operator">=</span>i<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                <span class="token keyword">if</span> farthest_now<span class="token operator">></span>farthest<span class="token punctuation">:</span>                    farthest<span class="token operator">=</span>farthest_now                    next<span class="token operator">=</span>i            now<span class="token operator">=</span>next            count<span class="token operator">+=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-3-16-（4-medium）"><a href="#2020-3-16-（4-medium）" class="headerlink" title="2020.3.16 （4 medium）"></a>2020.3.16 （4 medium）</h2><h3 id="第46题-全排列"><a href="#第46题-全排列" class="headerlink" title="第46题 全排列"></a>第46题 全排列</h3><p><img src="46.png" alt="第46题 全排列"></p><h4 id="思路-27"><a href="#思路-27" class="headerlink" title="思路:"></a>思路:</h4><p>深度优先搜索+回溯。</p><p>为了防止重复遍历数字，使用一个已访问矩阵来存储数字是否已被访问。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">permute</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> nums<span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>re<span class="token punctuation">)</span><span class="token operator">==</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>re<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        re<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                        dfs<span class="token punctuation">(</span>re<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                        re<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">False</span>        dfs<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，一般回溯法中将路径列表添加至结果时，需要添加一个深拷贝，而不能是引用。否则它将跟随回溯变化。</p><h3 id="第47题-全排列2"><a href="#第47题-全排列2" class="headerlink" title="第47题 全排列2"></a>第47题 全排列2</h3><p><img src="47.png" alt="第47题 全排列2"></p><h4 id="思路-28"><a href="#思路-28" class="headerlink" title="思路:"></a>思路:</h4><p>与上一题基础的全排列类似，我们依然使用的是DFS+backtrack算法，但是在这里我们需要进行剪枝处理，去重。</p><p>去重的思路是：先排序，对于多个未访问的连续的相同数字，我们每次只选择第一个进行深度优先搜索，防止重复的搜索。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">permuteUnique</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> nums<span class="token punctuation">]</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>re<span class="token punctuation">)</span><span class="token operator">==</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>re<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">and</span> visited<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#剪枝处理</span>                        <span class="token keyword">continue</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        re<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                        dfs<span class="token punctuation">(</span>re<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                        re<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">False</span>        dfs<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第48题-旋转图像"><a href="#第48题-旋转图像" class="headerlink" title="第48题 旋转图像"></a>第48题 旋转图像</h3><p><img src="48.png" alt="第48题 旋转图像"></p><h4 id="思路-29"><a href="#思路-29" class="headerlink" title="思路:"></a>思路:</h4><p>先对数组进行转置，再对其进行左右翻转。</p><p>需要进行原地修改。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify matrix in-place instead.        """</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                tmp<span class="token operator">=</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span>                matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>tmp        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                tmp<span class="token operator">=</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token operator">-</span>j<span class="token number">-1</span><span class="token punctuation">]</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token operator">-</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">=</span>tmp        <span class="token keyword">return</span> matrix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第49题-字母异位词分组"><a href="#第49题-字母异位词分组" class="headerlink" title="第49题 字母异位词分组"></a>第49题 字母异位词分组</h3><p><img src="49.png" alt="第49题 字母异位"></p><h4 id="思路-30"><a href="#思路-30" class="headerlink" title="思路:"></a>思路:</h4><p>使用哈希表进行求解。将每个单词的字母按照字典序进行排序，作为哈希表的key，那么字母异位词必然会放入同一个key中。哈希表的value为对应key的字母异位词组成的列表。在最后输出values组成的列表即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> strs<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> word <span class="token keyword">in</span> strs<span class="token punctuation">:</span>            tmp<span class="token operator">=</span>tuple<span class="token punctuation">(</span>sorted<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> tmp <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dic<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span>word<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dic<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>word<span class="token punctuation">)</span>        <span class="token keyword">return</span> list<span class="token punctuation">(</span>dic<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，还可以不用对单词进行排序，仅统计二十六个字母出现的次数，也能达到相同的效果，将时间复杂度由$O(NKlogK)$降为$O(NK)$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> strs<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> word <span class="token keyword">in</span> strs<span class="token punctuation">:</span>            tmp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> ch <span class="token keyword">in</span> word<span class="token punctuation">:</span>                tmp<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token operator">-</span>ord<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>            tmp<span class="token operator">=</span>tuple<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>            <span class="token keyword">if</span> tmp <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dic<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span>word<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dic<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>word<span class="token punctuation">)</span>        <span class="token keyword">return</span> list<span class="token punctuation">(</span>dic<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-3-17-（1-medium-1-hard）"><a href="#2020-3-17-（1-medium-1-hard）" class="headerlink" title="2020.3.17 （1 medium 1 hard）"></a>2020.3.17 （1 medium 1 hard）</h2><h3 id="第50题-Pow（x-n）"><a href="#第50题-Pow（x-n）" class="headerlink" title="第50题 Pow（x,n）"></a>第50题 Pow（x,n）</h3><p><img src="50.png" alt="第50题 Pow（x,n）"></p><h4 id="思路-31"><a href="#思路-31" class="headerlink" title="思路:"></a>思路:</h4><p>快速幂算法，采用递归的思路，通过二分法进行加速，将时间复杂度从累乘法的$O(N)$减少到$O(logN)$。基本思想是将$X^n$用两个$X^/frac{n}{2}$表示，这里需要对n的奇偶性进行分类讨论，如果是奇数，无法被2整除的话，还需要再乘以一个x。不断向下二分递归求解，直到将问题转化为求解$X^1$和$X^0$，再层层回退求解结果。</p><p>具体思路有些类似于第29题两数相除，本质思想都是使用递归二分进行加速。</p><p>特别地，当n为负数时，可以将$X^n$转化为$/frac{1}{X}^{-n}$求解。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">myPow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> float<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">fastpow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">1</span>            <span class="token keyword">if</span> n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                half<span class="token operator">=</span>fastpow<span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> half<span class="token operator">*</span>half                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> x<span class="token operator">*</span>half<span class="token operator">*</span>half        <span class="token keyword">if</span> n<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>            x<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span>x            n<span class="token operator">=</span><span class="token operator">-</span>n        <span class="token keyword">return</span> fastpow<span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，需要注意Integer类型的补码机制问题，必要时可以采用long，不过python没有这个烦恼。</p><p>也可以使用非递归方式进行求解。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">myPow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> float<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>        <span class="token keyword">if</span> n<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>            x<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span>x            n<span class="token operator">=</span><span class="token operator">-</span>n        result<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1.0</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                result<span class="token operator">*=</span><span class="token number">2</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                result<span class="token operator">=</span>result<span class="token operator">*</span>result<span class="token operator">*</span>x            n<span class="token operator">//=</span><span class="token number">2</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第51题-N皇后"><a href="#第51题-N皇后" class="headerlink" title="第51题 N皇后"></a>第51题 N皇后</h3><p><img src="51.png" alt="第51题 N皇后"></p><h4 id="思路-32"><a href="#思路-32" class="headerlink" title="思路:"></a>思路:</h4><p>和解数独和全排列等题目类似，依然是使用回溯算法进行递归求解。</p><p>在这个问题中，我们将棋盘看作是一个二维数组，按行进行递归，按列进行选择，每行选择一列放置皇后。如果每一行都能放置一个皇后，则可以将当前棋盘加入至结果数组。</p><p>特别地，我们需要判断当前位置是否可以放置一个皇后。由于皇后会攻击同行、同列、四个对角线上的棋子，所以我们需要保证当前行、当前列、当前四个对角线上没有别的皇后。前两个很好判断，对角线可以使用两个皇后的横坐标与纵坐标的差值绝对值是否相等来判断。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">solveNQueens</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">couldplace</span><span class="token punctuation">(</span>chessboard<span class="token punctuation">,</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#是否可以放置</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> chessboard<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>col <span class="token operator">or</span> abs<span class="token punctuation">(</span>i<span class="token operator">-</span>row<span class="token punctuation">)</span><span class="token operator">==</span>abs<span class="token punctuation">(</span>chessboard<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">def</span> <span class="token function">trans</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#将棋盘转化为输出格式</span>            result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> li<span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'Q'</span><span class="token operator">+</span><span class="token string">'.'</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> result        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">back</span><span class="token punctuation">(</span>chessboard<span class="token punctuation">,</span>row<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#递归回溯</span>            <span class="token keyword">if</span> row<span class="token operator">>=</span>n<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当前行数若超过棋盘范围，则已放置完，可将当前棋盘加入结果数组</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>chessboard<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#进行选择</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>couldplace<span class="token punctuation">(</span>chessboard<span class="token punctuation">,</span>row<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        chessboard<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token operator">=</span>i                        back<span class="token punctuation">(</span>chessboard<span class="token punctuation">,</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                        chessboard<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token comment" spellcheck="true">#回溯</span>        chessboard<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        back<span class="token punctuation">(</span>chessboard<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>trans<span class="token punctuation">(</span>result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，我使用了一种优化方法，每一次并没有存储真实的棋盘，而是开了一个二维数组，每个数组放置当前行的皇后位置。最后将其转化为输出格式即可。</p><h2 id="2020-3-18-（1-easy-2-medium）"><a href="#2020-3-18-（1-easy-2-medium）" class="headerlink" title="2020.3.18 （1 easy 2 medium）"></a>2020.3.18 （1 easy 2 medium）</h2><h3 id="第53题-最大子序和"><a href="#第53题-最大子序和" class="headerlink" title="第53题 最大子序和"></a>第53题 最大子序和</h3><p><img src="53.png" alt="第53题 最大子序和"></p><h4 id="思路-33"><a href="#思路-33" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划，状态矩阵dp[i]为以元素nums[i]结尾的子数组的最大连续和，转移方程为dp[i]=（1）nums[i]（if dp[i-1]&lt;=0） （2）dp[i-1]+nums[i]（if dp[i-1]&gt;0）。因为当前只有前面的连续子数组最大和为正数，才能对当前连续子数组最大和产生正贡献，否则只会使其变小。</p><p>特别地，为了节约空间，我们可以将nums列表原地修改为dp列表。</p><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(1)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        max_sum<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>            max_sum<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>max_sum<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#比较当前连续子数组和是否大于全局最大值</span>        <span class="token keyword">return</span> max_sum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第54题-螺旋矩阵"><a href="#第54题-螺旋矩阵" class="headerlink" title="第54题 螺旋矩阵"></a>第54题 螺旋矩阵</h3><p><img src="54.png" alt="第54题 螺旋矩阵"></p><h4 id="思路-34"><a href="#思路-34" class="headerlink" title="思路:"></a>思路:</h4><p>按圈模拟指针的变化。这一类题目需要自己寻找一下指针变化的规律。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        level<span class="token operator">=</span><span class="token number">0</span><span class="token comment" spellcheck="true">#圈数</span>        row<span class="token operator">=</span><span class="token number">0</span>        col<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">if</span> matrix<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        result<span class="token operator">=</span><span class="token punctuation">[</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">]</span>        count<span class="token operator">=</span><span class="token number">1</span><span class="token comment" spellcheck="true">#步数</span>        row_nums<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span>        col_nums<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        size<span class="token operator">=</span>row_nums<span class="token operator">*</span>col_nums        <span class="token keyword">while</span> count<span class="token operator">&lt;</span>size<span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col_nums<span class="token operator">-</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>                col<span class="token operator">+=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>row_nums<span class="token operator">-</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>                row<span class="token operator">+=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col_nums<span class="token operator">-</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>                col<span class="token operator">-=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>row_nums<span class="token operator">-</span>level<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                row<span class="token operator">-=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            <span class="token comment" spellcheck="true">#模拟顺时针的遍历，这里写的比较冗余，实际上可以使用列表+取余的方式简化增量的计算。</span>            level<span class="token operator">+=</span><span class="token number">1</span>            col<span class="token operator">+=</span><span class="token number">1</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>            count<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第55题-跳跃游戏"><a href="#第55题-跳跃游戏" class="headerlink" title="第55题 跳跃游戏"></a>第55题 跳跃游戏</h3><p><img src="55.png" alt="第55题 跳跃游戏"></p><h4 id="思路-35"><a href="#思路-35" class="headerlink" title="思路:"></a>思路:</h4><p>我们基于这样的一个假设：如果能跳到位置i，那么位置i之前的所有位置0，1…i-1都能跳到。</p><p>那么问题已经迎刃而解了，我们遍历每一个位置，如果当前位置无法被跳到（大于当前所能到达的最远位置），则说明后面的所有位置都无法跳到，自然也就无法到达数组的末尾。如果当前位置可以跳到，将其所能到达的最远位置与当前最远位置比较，取最大值进行更新当前最远位置。</p><p>时间复杂度：$O(N)$</p><p>空间复杂度: $O(1)$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canJump</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        farthest<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">></span>farthest<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            farthest<span class="token operator">=</span>max<span class="token punctuation">(</span>farthest<span class="token punctuation">,</span>i<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以和跳跃游戏2一样采用贪心算法求解，不过时间复杂度会高一些。</p><h2 id="2020-3-19-（2-medium-1-hard）"><a href="#2020-3-19-（2-medium-1-hard）" class="headerlink" title="2020.3.19 （2 medium 1 hard）"></a>2020.3.19 （2 medium 1 hard）</h2><h3 id="第56题-合并区间"><a href="#第56题-合并区间" class="headerlink" title="第56题 合并区间"></a>第56题 合并区间</h3><p><img src="56.png" alt="第56题 合并区间"></p><h4 id="思路-36"><a href="#思路-36" class="headerlink" title="思路:"></a>思路:</h4><p>先按每个区间的左边界，为所有区间进行升序排序。接着，遍历每个区间，若当前区间的右边界大于或等于下一区间的左边界，那么说明二者有重复，可以进行合并。合并后，新区间的左边界为当前区间的左边界（升序排序），有边界为两个区间右边界的最大值（两种情况）。将下一区间原地修改为合并后的新区间，可以节约空间，并将当前区间置空。完成后，继续向前遍历。</p><p>最后，将所有空列表进行删除处理，返回最终的列表即可。</p><p>时间复杂度：$O(N)$</p><p>空间复杂度：$O(1)$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> intervals<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>            intervals<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">>=</span>intervals<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    intervals<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                    intervals<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>intervals<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    intervals<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> intervals<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第57题-插入区间"><a href="#第57题-插入区间" class="headerlink" title="第57题 插入区间"></a>第57题 插入区间</h3><p><img src="57.png" alt="第57题 插入区间"></p><h4 id="思路-37"><a href="#思路-37" class="headerlink" title="思路:"></a>思路:</h4><p>二分查找插入位置，插入新区间，然后采用上一题的思路进行合并。插入需要耗费$O(logN)$，合并需要耗费$O(N)$，总时间复杂度为$O(NlogN)$。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> intervals<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> newInterval<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>            left<span class="token operator">=</span><span class="token number">0</span>            right<span class="token operator">=</span>len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>                mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> mid                <span class="token keyword">elif</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>                    right<span class="token operator">=</span>mid<span class="token number">-1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">return</span> left        insert_pos<span class="token operator">=</span>search<span class="token punctuation">(</span>newInterval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        intervals<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>insert_pos<span class="token punctuation">,</span>newInterval<span class="token punctuation">)</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">>=</span>intervals<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    intervals<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                    intervals<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>intervals<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    intervals<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> intervals<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还可以使用贪心算法，先将新区间插入至插入位置，并将其与前一个区间尝试合并。再向后遍历，尝试合并，直到无法进行合并。</p><h3 id="第60题-第k个排列"><a href="#第60题-第k个排列" class="headerlink" title="第60题 第k个排列"></a>第60题 第k个排列</h3><p><img src="60.png" alt="第60题 第k个排列"></p><h4 id="思路-38"><a href="#思路-38" class="headerlink" title="思路:"></a>思路:</h4><p>DFS算法，因为n！种排列本质是由n组n-1！排列组合而成，根据这一性质，我们可以得知当前的偏移值在哪一组n-1！中，从而计算得到当前位置上应填入的数字，接着取余数获取新的偏移值，不断递归，直到获取最终结果。</p><p>这里的DFS不需要进行回溯，因为每一位数字只有一个是符合条件的，不需要恢复状态去进行下一个选择。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getPermutation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#求解n!</span>            result<span class="token operator">=</span><span class="token number">1</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                result<span class="token operator">*=</span>i            <span class="token keyword">return</span> result        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>k<span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> result            f<span class="token operator">=</span>factorial<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span>            base<span class="token operator">=</span>k<span class="token operator">//</span>f            offset<span class="token operator">=</span>k<span class="token operator">%</span>f            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>visited<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> base<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#第base个未访问过的元素，即为当前位置上应该填入的数字</span>                        result<span class="token operator">+=</span>str<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span>offset<span class="token punctuation">,</span>result<span class="token punctuation">)</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        base<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>n<span class="token punctuation">,</span>k<span class="token number">-1</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#这里数组从0开始，需要将k减1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-3-20-（4-medium）"><a href="#2020-3-20-（4-medium）" class="headerlink" title="2020.3.20 （4 medium）"></a>2020.3.20 （4 medium）</h2><h3 id="第61题-旋转链表"><a href="#第61题-旋转链表" class="headerlink" title="第61题 旋转链表"></a>第61题 旋转链表</h3><p><img src="61.png" alt="第61题 旋转链表"></p><h4 id="思路-39"><a href="#思路-39" class="headerlink" title="思路:"></a>思路:</h4><p>快慢指针法+头插法。</p><p>先统计链表的长度L，令K=K%L，放置进行重复的旋转。再使用快慢指针定位链表最后K个元素的起始位置和终止位置，并将这K个元素插入至链表头部即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        dummyhead<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        dummyhead<span class="token punctuation">.</span>next<span class="token operator">=</span>head        fast<span class="token operator">=</span>slow<span class="token operator">=</span>dummyhead        l<span class="token operator">=</span><span class="token number">0</span>        p<span class="token operator">=</span>dummyhead        <span class="token keyword">if</span> head<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>next                l<span class="token operator">+=</span><span class="token number">1</span>            k<span class="token operator">%=</span>l            <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>k<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next                    k<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next                    fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next            fast<span class="token punctuation">.</span>next<span class="token operator">=</span>dummyhead<span class="token punctuation">.</span>next            dummyhead<span class="token punctuation">.</span>next<span class="token operator">=</span>slow<span class="token punctuation">.</span>next            slow<span class="token punctuation">.</span>next<span class="token operator">=</span>None        <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以将原先的链表修改成一个环，再从原倒数第K%L个元素处断开环，新得到的链表即为旋转后链表。</p><h3 id="第62题-不同路径"><a href="#第62题-不同路径" class="headerlink" title="第62题 不同路径"></a>第62题 不同路径</h3><p><img src="62.png" alt="第62题 不同路径"></p><h4 id="思路-40"><a href="#思路-40" class="headerlink" title="思路:"></a>思路:</h4><p>我的最初思路想当然地考虑到了DFS+回溯算法，这也是这一类走迷宫问题的常用算法。</p><p>但是，我很快观察到，这道题里有重叠的子问题，那么使用递归将非常缓慢。例如，从位置（0，1）和位置（1，0）都可以走到位置（1，1），如果我们使用递归，将重复从位置（1，1）向下搜索可行解两次，导致了不必要的时间消耗。</p><p>解决重叠子问题的方法就是动态规划。这道题里，我们的状态矩阵dp[i][j]为到达网格中（i，j）位置的路径数目，转移方程为：</p><ol><li>dp[i][j]=1,if i==0 and j==0;</li><li>dp[i][j]=dp[i-1][j],if i&gt;0 and j==0;</li><li>dp[i][j]=dp[i][j-1],if j&gt;0 and i==0;</li><li>dp[i][j]=dp[i-1][j]+dp[i][j-1],if i&gt;0 and j&gt;0.</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#状态矩阵</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#状态转移</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token keyword">elif</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token keyword">elif</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第63题-不同路径2"><a href="#第63题-不同路径2" class="headerlink" title="第63题 不同路径2"></a>第63题 不同路径2</h3><p><img src="63.png" alt="第63题 不同路径"></p><h4 id="思路-41"><a href="#思路-41" class="headerlink" title="思路:"></a>思路:</h4><p>思路与上一题基本一致，唯一的区别在于当状态矩阵转移到有障碍物的位置时，应将状态矩阵该位置修改为0.因为很明显该位置有了障碍物后不可达。</p><p>特别地，我们可以将题目提供的数组原地修改为状态矩阵，便可只适用常数级别的额外空间。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">uniquePathsWithObstacles</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> obstacleGrid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> obstacleGrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#初始位置有障碍物，并不可能到达终点</span>            <span class="token keyword">return</span> <span class="token number">0</span>        obstacleGrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>obstacleGrid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>obstacleGrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">or</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#将有障碍物的位值设为不可达</span>                    obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>                <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#状态转移</span>                    <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                        obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>obstacleGrid<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                    <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                        obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>                    <span class="token keyword">elif</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                        obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>obstacleGrid<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">return</span> obstacleGrid<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第64题-最小路径和"><a href="#第64题-最小路径和" class="headerlink" title="第64题 最小路径和"></a>第64题 最小路径和</h3><p><img src="64.png" alt="第64题 最小路径和"></p><h4 id="思路-42"><a href="#思路-42" class="headerlink" title="思路:"></a>思路:</h4><p>与62、63题思路基本一致，仍然是动态规划的思想。转移方程略有不同，核心是当前位置上的数字加上上方位置和左侧位置的路径和的最小值。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+=</span>grid<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                    grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+=</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token keyword">elif</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                    grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+=</span>min<span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>grid<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> grid<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-3-29-（1-medium-1-hard）"><a href="#2020-3-29-（1-medium-1-hard）" class="headerlink" title="2020.3.29 （1 medium 1 hard）"></a>2020.3.29 （1 medium 1 hard）</h2><h3 id="第72题-编辑距离"><a href="#第72题-编辑距离" class="headerlink" title="第72题 编辑距离"></a>第72题 编辑距离</h3><p><img src="72.png" alt="第72题 编辑距离"></p><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>动态规划的经典模板题之一，设dp[i] [j]为word1的前i个字符调整至word2的前j个字符所需的最少操作数目。则dp转移方程为：</p><ul><li>dp[i] [j]=0，if i==0 and j==0（空字符串到空字符串，不需要编辑）</li><li>dp[i] [j]=i，if i&gt;0 and j==0（word1的前i个字符调整至空字符串，需要删除i次）</li><li>dp[i] [j]=j，if i==0 and j&gt;0（空字符串调整至word2的前j个字符串，需要添加j次）</li><li>dp[i] [j]=dp[i-1] [j-1]，if i&gt;0 and j&gt;0 and word1[i-1]==word2[j-1] （如果word1的第i个字符和word2的第j个字符相等，那么这一位上不需要操作，直接看word1的前i-1个字符调整至word2的前j-1个字符需要几步即可）</li><li>dp[i] [j]=min（dp[i-1] [j]，dp[i] [j-1], dp[i-1] [j-1]）+1，if i&gt;0 and j&gt;0 and word1[i-1]!=word2[j-1] （如果word1的第i个字符和word2的第j个字符不相等，那我们假设当前的匹配是由添加、删除、替换一个字符而来的，比较三者操作前的状态需要的最少操作数目，选取最小值加上当前这一步，作为当前的最少操作数目）</li></ul><blockquote><p>以 word1 为 “horse”，word2 为 “ros”，且 dp[5] [3] 为例，即要将 word1的前 5 个字符转换为 word2的前 3 个字符，也就是将 horse 转换为 ros，因此有：</p><p>(1) dp[i-1] [j-1]，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 2 个字符 ro，然后将第五个字符 word1[4]（因为下标基数以 0 开始） 由 e 替换为 s（即替换为 word2 的第三个字符，word2[2]）</p><p>(2) dp[i] [j-1]，即先将 word1 的前 5 个字符 horse 转换为 word2 的前 2 个字符 ro，然后在末尾补充一个 s，即插入操作</p><p>(3) dp[i-1] [j]，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 3 个字符 ros，然后删除 word1 的第 5 个字符</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word1<span class="token punctuation">:</span> str<span class="token punctuation">,</span> word2<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>word2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>word1<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>word1<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>word2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>                <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>j                <span class="token keyword">elif</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> word1<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span>word2<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度: $O(MN)$。</li><li>空间复杂度：$O(MN)$。</li><li>这一题有些类似于通识符匹配的那道题。</li></ul><h3 id="第75题-颜色分类"><a href="#第75题-颜色分类" class="headerlink" title="第75题 颜色分类"></a>第75题 颜色分类</h3><p><img src="75.png" alt="第75题 颜色分类"></p><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>三路快排的思想。使用三个指针curr，p0，p2。curr用于遍历数组，p0用于表示全0区间的右边界的下一个位置，p2用于表示全2区间的左边界的下一个位置。具体扫描算法如下：</p><ul><li>当curr小于p2时（说明所有元素尚且没有被扫描完）：<ul><li>如果nums[curr]==0，那么将nums[curr]与nums[p0]交换，并且curr加1，p0加1，相当于全0区间向右扩展了，且由于当前数必然是1或者0，所以可以向后继续遍历（因为之前的元素都已经被遍历过，如果是2会被交换到后面去）。</li><li>如果nums[curr]==2，那么将nums[curr]与nums[p2]交换，并且p2减1，相当于全2区间向左扩展了。由于此时交换过来的数字我们不知道是0、1还是2，所以curr不能加一，还需要继续判断当前元素。</li><li>如果nums[curr]==1，那么直接使curr加1，向后继续遍历。</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortColors</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify nums in-place instead.        """</span>        curr<span class="token punctuation">,</span>p0<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        p2<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token operator">&lt;=</span>p2<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>p0<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>p0<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span>                curr<span class="token operator">+=</span><span class="token number">1</span>                p0<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                curr<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span>                p2<span class="token operator">-=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度: $O(N)$。</li><li>空间复杂度：$O(1)$。</li><li>这道题既有些像快排，使用指针维护区间的思想也有些像26题和27题。</li></ul><h2 id="2020-3-30-（1-medium-1-hard）"><a href="#2020-3-30-（1-medium-1-hard）" class="headerlink" title="2020.3.30 （1 medium 1 hard）"></a>2020.3.30 （1 medium 1 hard）</h2><h3 id="第76题-最小覆盖子串"><a href="#第76题-最小覆盖子串" class="headerlink" title="第76题 最小覆盖子串"></a>第76题 最小覆盖子串</h3><p><img src="76.png" alt="第76题 最小覆盖子串"></p><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><p>经典的滑动窗口题，类似的题目还有 <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">无重复字符的最长子串</a> 、 <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">找到字符串中所有字母异位词</a> 等。基本思路都是使用双指针维护一个符合题目要求的滑动区间。</p><p>本题中，我们使用双指针left和right，right负责向前遍历搜索，如果区间[left：right+1]包含了T中所有的字母，我们尝试移动left，保证当前区间仍然包含T中所有的字母。如果left移动后区间不符合要求，我们记录当前区间，将其与最小覆盖子串比较，更新最小覆盖子串。然后，right继续向前搜索，直到最后一个字符。</p><ul><li>时间复杂度：$O(M+N)$, M为s长度，N为t长度。 在最坏的情况下，可能会对S中的每个元素遍历两遍，左指针和右指针各一遍。 </li><li>空间复杂度：$O(1)$。最多128个字符。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span><span class="token number">0</span>        count_t<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#哈希表统计t中每个字符出现的次数</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> t<span class="token punctuation">:</span>            <span class="token keyword">if</span> ch <span class="token operator">not</span> <span class="token keyword">in</span> count_t<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                count_t<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                count_t<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>        formed<span class="token operator">=</span><span class="token number">0</span><span class="token comment" spellcheck="true">#已覆盖的字符数（指的是不重复的字符）</span>        min_length<span class="token operator">=</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span>        min_st<span class="token operator">=</span><span class="token string">""</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#右区间遍历搜索s的所有字符</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token keyword">in</span> count_t<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> count_t<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当前字符所有出现次数被完全覆盖</span>                    formed<span class="token operator">+=</span><span class="token number">1</span>                count_t<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">if</span> formed<span class="token operator">==</span>len<span class="token punctuation">(</span>count_t<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#完全覆盖了t中所有的字符</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#左区间收缩，尝试寻找最小覆盖字串</span>                    <span class="token keyword">if</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token keyword">in</span> count_t<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        count_t<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>                        <span class="token keyword">if</span> count_t<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#失去匹配</span>                            formed<span class="token operator">-=</span><span class="token number">1</span>                            left<span class="token operator">+=</span><span class="token number">1</span>                            <span class="token keyword">break</span>                    left<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> right<span class="token operator">-</span>left<span class="token operator">&lt;</span>min_length<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#记录失配前的最小子串，更新当前最小覆盖字串</span>                        min_length<span class="token operator">=</span>right<span class="token operator">-</span>left                        min_st<span class="token operator">=</span>s<span class="token punctuation">[</span>left<span class="token number">-1</span><span class="token punctuation">:</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>            right<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> min_st<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第79题-单词搜索"><a href="#第79题-单词搜索" class="headerlink" title="第79题 单词搜索"></a>第79题 单词搜索</h3><p><img src="79.png" alt="第79题 单词搜索"></p><h4 id="思路-43"><a href="#思路-43" class="headerlink" title="思路:"></a>思路:</h4><p>DFS模板题，剑指Offer原题，基本思路就是从每一个单元格开始向上下左右四个方向递归深搜，如果当前单元格不越界且匹配，那么继续搜索下一个字符。考虑到不能搜索重复的单元格，需要使用visited矩阵进行判断，并对其回溯。为了减少空间复杂度，可以原地修改board为visited。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exist</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>            <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index<span class="token operator">==</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> index<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span>word<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>                    tmp<span class="token punctuation">,</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token boolean">False</span>                    <span class="token keyword">if</span> dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> dfs<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token number">-1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> dfs<span class="token punctuation">(</span>row<span class="token number">-1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">True</span>                    board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span>tmp            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-3-31（2-hard）"><a href="#2020-3-31（2-hard）" class="headerlink" title="2020.3.31（2 hard）"></a>2020.3.31（2 hard）</h2><h3 id="第84题-柱状图中最大的矩形"><a href="#第84题-柱状图中最大的矩形" class="headerlink" title="第84题 柱状图中最大的矩形"></a>第84题 <a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">柱状图中最大的矩形</a></h3><p><img src="84.png" alt="第84题 柱状图中最大的矩形"></p><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>由于矩形的面积和区间内最小高度的柱子有关，我们先尝试基本做法动态规划，DP求解数组中每一个区间的最小高度，然后乘以区间的宽度，尝试更新当前最大面积。尝试后发现超时，时间复杂度为$O(n^2)$。</p><p>为了减少时间复杂度，我们可以尝试分治法。通过观察，可以发现，最大面积矩形存在于以下几种情况：</p><ol><li><p>确定了最矮柱子以后，矩形的宽尽可能往两边延伸。</p></li><li><p>在最矮柱子左边的最大面积矩形（子问题）。</p></li><li><p>在最矮柱子右边的最大面积矩形（子问题）。</p></li></ol><p>找到了划分子问题的方法，我们可以尝试分治算法求解。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> heights<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> left<span class="token operator">></span>right <span class="token operator">or</span> left<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">or</span> right<span class="token operator">>=</span>len<span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            tmp<span class="token operator">=</span>heights<span class="token punctuation">[</span>left<span class="token punctuation">:</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>            min_height<span class="token operator">=</span>min<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>            min_pos<span class="token operator">=</span>tmp<span class="token punctuation">.</span>index<span class="token punctuation">(</span>min_height<span class="token punctuation">)</span><span class="token operator">+</span>left            <span class="token keyword">return</span> max<span class="token punctuation">(</span>min_height<span class="token operator">*</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>max<span class="token punctuation">(</span>recur<span class="token punctuation">(</span>left<span class="token punctuation">,</span>min_pos<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>recur<span class="token punctuation">(</span>min_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> recur<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而，我们发现，虽然分治法的平均时间复杂度为$O(nlogn)$，但依然存在着缺陷，即假如数组有序，那么分治法将退化为暴力算法，时间复杂度为$O(n^2)$。</p><p>为了进一步优化，我们需要尝试以空间换时间的算法。我们知道，这道题还有一种暴力的思路，就是类似于最小回文子串问题的中心扩展法，即“ 依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度多少。 ”</p><p><img src="84-2.png" alt="暴力求解"></p><p>这个算法的核心思想是找到每个高度的柱子左侧和右侧的第一个高度小于它的柱子，利用他们所夹的区间和当前柱子的高度即可得到当前高度的矩形的最大面积。时间复杂度为$O(n^2)$。</p><p>那么有没有办法优化它呢？我们可以使用一个单调栈来解决这个问题。</p><ul><li>栈中存放当前高度数组的下标，并在当前高度数组的两端增加高度为0的哨兵，以减少判断。</li><li>遍历高度数组，维持当前栈的非递减性。如果当前高度小于栈顶下标的高度，那么说明栈顶元素必然被当前高度和之前某个高度夹在中间，根据我们之前的中心扩散算法，可以得到该栈顶元素代表的高度的矩阵的最大面积。具体的做法是：栈顶元素不断出栈，查看它出栈后的栈顶元素是否小于它，小于则找到了左边界，然后利用我们当前遍历到的高度作为右边界，计算当前矩阵最大面积，尝试更新结果。</li><li>继续上述过程，直到当前高度大于或等于栈顶下标高度，此时，将当前高度入栈，继续向前并遍历。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> heights<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        heights<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>heights<span class="token operator">+</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#引入哨兵</span>        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>heights<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#此时栈顶下标高度的矩形的面积可被确定</span>                now<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">while</span> heights<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">==</span>heights<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#寻找左边界，即第一个小于栈顶元素的高度</span>                    stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                res<span class="token operator">=</span>max<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">-</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>heights<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#更新结果</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#当前下标入栈（为什么是下标，因为我们要计算矩形的宽度）</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$，每个元素都要出栈、入栈各一次。</li><li>空间复杂度：$O(n)$，维护一个单调栈。</li></ul><h3 id="85题-最大矩形"><a href="#85题-最大矩形" class="headerlink" title="85题 最大矩形"></a>85题 <a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">最大矩形</a></h3><p><img src="85.png" alt="第85题 最大矩形"></p><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><p>基本思路是将求解矩阵中的最大矩形转化为84题中的柱状图中的最大矩形，然后再使用84题的单调栈方法求解。对于矩阵的每一个位置，我们可以求解其位置上“1”的高度，然后对于矩阵中的每一行，我们可以计算出当前行上”1“矩阵的最大面积，并尝试更新结果。</p><ul><li>时间复杂度：$O(MN)$，计算高度时遍历一次矩阵，计算最大面积时再遍历一次矩阵，共2MN次。</li><li>空间复杂度：$O(N)$，每一次求解每行的最大面积时，需要使用一个与列数大小相等的单调栈。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maximalRectangle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">getLargestArea</span><span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token punctuation">:</span>            heights<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>heights<span class="token operator">+</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            res<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>heights<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    now<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>heights<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">==</span>heights<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                    res<span class="token operator">=</span>max<span class="token punctuation">(</span>heights<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">-</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">return</span> res        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>int<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span> <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'0'</span> <span class="token keyword">else</span> <span class="token number">1</span><span class="token operator">+</span>matrix<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>            res<span class="token operator">=</span>max<span class="token punctuation">(</span>getLargestArea<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-1-（3-medium）"><a href="#2020-4-1-（3-medium）" class="headerlink" title="2020.4.1 （3 medium）"></a>2020.4.1 （3 medium）</h2><h3 id="94题-二叉树的中序遍历"><a href="#94题-二叉树的中序遍历" class="headerlink" title="94题 二叉树的中序遍历"></a>94题 <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></h3><p><img src="94.png" alt="第94题"></p><h5 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h5><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="非递归解法"><a href="#非递归解法" class="headerlink" title="非递归解法"></a>非递归解法</h5><p>思路：使用辅助栈。只要弄懂了递归的过程，就可以使用栈来模拟。</p><p>每到一个节点 A，因为根的访问在中间，将 A 入栈。然后遍历左子树，接着访问 A，最后遍历右子树。在访问完 A 后，A 就可以出栈了。因为 A 和其左子树都已经访问完成。</p><p>二叉树的先序、中序、后序遍历的非递归解法都是使用一个辅助栈来暂存需要回过头来访问的节点，从而代替递归函数的返回过程。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        p<span class="token operator">=</span>root        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">or</span> stack<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历左子树，不断将当前节点入栈，因为要遍历完左子树才能访问</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>left            p<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#遍历完左子树后，取出栈顶元素，进行访问</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>right<span class="token comment" spellcheck="true">#继续遍历右子树</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(N)$，所有节点各入栈出栈一次。</li><li>空间复杂度：$O(N)$，最坏情况下需要大小为N的辅助栈。</li></ul><h3 id="144题-二叉树的前序遍历"><a href="#144题-二叉树的前序遍历" class="headerlink" title="144题 二叉树的前序遍历"></a>144题 <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历</a></h3><p><img src="144.png" alt="第144题"></p><h5 id="递归解法-1"><a href="#递归解法-1" class="headerlink" title="递归解法"></a>递归解法</h5><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        preorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="非递归解法-1"><a href="#非递归解法-1" class="headerlink" title="非递归解法"></a>非递归解法</h5><p>思路：依然使用辅助栈，先将当前节点的右孩子入栈保存，然后访问当前节点，接着遍历当前节点的左孩子。遍历完左子树后，继续遍历右子树。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        p<span class="token operator">=</span>root        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">or</span> stack<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#先访问当前节点</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#暂存右孩子至栈中，等遍历完左子树开始访问</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>left<span class="token comment" spellcheck="true">#遍历左孩子</span>            p<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#遍历完左子树后，开始遍历右子树</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="145题-二叉树的后序遍历"><a href="#145题-二叉树的后序遍历" class="headerlink" title="145题 二叉树的后序遍历"></a>145题 二叉树的后序遍历</h3><p><img src="145.png" alt="第145题"></p><h5 id="递归解法-2"><a href="#递归解法-2" class="headerlink" title="递归解法"></a>递归解法</h5><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>                postorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                postorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        postorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="非递归解法-2"><a href="#非递归解法-2" class="headerlink" title="非递归解法"></a>非递归解法</h5><p>思路：我们知道，二叉树的后序遍历是“左-右-根”，而二叉树的逆前序遍历是“右-左-根”，所以我们可以使用辅助栈实现二叉树的逆前序遍历后，再将结果翻转，即为后序遍历。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        p<span class="token operator">=</span>root        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">or</span> stack<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>right            p<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-2-（2-medium-1easy）"><a href="#2020-4-2-（2-medium-1easy）" class="headerlink" title="2020.4.2 （2 medium 1easy）"></a>2020.4.2 （2 medium 1easy）</h2><h3 id="96题-不同的二叉搜索树"><a href="#96题-不同的二叉搜索树" class="headerlink" title="96题 不同的二叉搜索树"></a>96题 <a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">不同的二叉搜索树</a></h3><p><img src="96.png" alt="第96题"></p><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><p>动态规划求解，DFS太耗费时间。我们设状态矩阵DP[i]为1..i为节点的二叉搜索树的数目，f[i]为以i为根节点的二叉搜索树数目，则有：</p><ul><li>DP[i]=f[1]+f[2]+…+f[i]，即计算以1到i的每个节点为根节点的二叉搜索树数目之和。</li><li>f[j]=DP[j-1]*DP[i-j]，即以j为根节点的二叉搜索树，左侧有j-1个节点，右侧有i-j个节点，又因为j+1到i为节点的二叉搜索树数目与1到i-j的二叉搜索树一致，所以可以用DP[i-j]来代替。则左右两边子树组合数目为DP[j-1]乘以DP[i-j]。</li><li>则动态规划转移方程为：DP[i]=DP[0] <em> DP[i-1]+DP[1] </em> DP[i-2]+…+DP[i] * DP[0]</li><li>这个动态规划方程在数学上有一个名字，叫做“卡特兰数”</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token comment" spellcheck="true">#注意，这里的0个数组成的二叉搜索树数目为1，这是因为左子树为空也合法。</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>dp<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="98题-验证二叉搜索树"><a href="#98题-验证二叉搜索树" class="headerlink" title="98题 验证二叉搜索树"></a>98题 <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a></h3><p><img src="98.png" alt="第98题"></p><h4 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h4><p>我们知道，如果我们中序遍历二叉搜索树，那么得到的序列必然是递增的，我们就可以通过这一性质验证二叉搜索树。我们中序遍历二叉搜索树，并且记录下当前中序遍历得到的序列的最后一个元素值，如果当前元素值大于它，说明满足二叉搜索树的性质，可以继续递归判断。如果非递增了，就返回False。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>last_value<span class="token operator">=</span>None        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#我们认为空子树是二叉搜索树，方便递归</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历左子树，看是否满足递增</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>last_value<span class="token operator">==</span>None <span class="token operator">or</span> root<span class="token punctuation">.</span>val<span class="token operator">></span>self<span class="token punctuation">.</span>last_value<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#看当前节点是否满足递增</span>                    self<span class="token punctuation">.</span>last_value<span class="token operator">=</span>root<span class="token punctuation">.</span>val                    <span class="token keyword">if</span> inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#看右子树是否满足递增</span>                        <span class="token keyword">return</span> <span class="token boolean">True</span><span class="token comment" spellcheck="true">#如果左中右都满足，返回True</span>            <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token comment" spellcheck="true">#如果有一项不满足，返回False</span>        <span class="token keyword">return</span> inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="101题-对称二叉树"><a href="#101题-对称二叉树" class="headerlink" title="101题 对称二叉树"></a>101题 <a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">对称二叉树</a></h3><p><img src="101.png" alt="第101题"></p><h4 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer类似题，递归求解法，我们知道，两个节点对称的条件为：</p><ol><li>两个节点均为空。</li><li>两个节点均不为空，且节点a的值等于节点b的值，且节点a的左子树和节点b的右子树镜像，节点b的左子树和节点a的右子树镜像。</li></ol><p>当根节点非空时，我们递归判断左右子树是否对称即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> a<span class="token operator">==</span>None <span class="token operator">and</span> b<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> a<span class="token operator">!=</span>None <span class="token operator">and</span> b<span class="token operator">!=</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> a<span class="token punctuation">.</span>val<span class="token operator">==</span>b<span class="token punctuation">.</span>val <span class="token operator">and</span> match<span class="token punctuation">(</span>a<span class="token punctuation">.</span>left<span class="token punctuation">,</span>b<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">and</span> match<span class="token punctuation">(</span>a<span class="token punctuation">.</span>right<span class="token punctuation">,</span>b<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> match<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(n)$。</li></ul><h2 id="2020-4-3-（2-medium-1easy）"><a href="#2020-4-3-（2-medium-1easy）" class="headerlink" title="2020.4.3 （2 medium 1easy）"></a>2020.4.3 （2 medium 1easy）</h2><h3 id="第104题-二叉树的最大深度"><a href="#第104题-二叉树的最大深度" class="headerlink" title="第104题 二叉树的最大深度"></a>第104题 <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a></h3><p><img src="104.png" alt="第104题"></p><h4 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h4><p>数据结构基本题，剑指offer二叉树原题，递归搜索即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第105题-从前序与中序遍历序列构造二叉树"><a href="#第105题-从前序与中序遍历序列构造二叉树" class="headerlink" title="第105题  从前序与中序遍历序列构造二叉树"></a>第105题 <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener"> 从前序与中序遍历序列构造二叉树</a></h3><p><img src="105.png" alt="第105题"></p><h4 id="思路：-10"><a href="#思路：-10" class="headerlink" title="思路："></a>思路：</h4><p>数据结构基本题，剑指offer二叉树原题，分治法即可。</p><ul><li>前序遍历确定当前子树的根节点。</li><li>中序遍历确定左右子树节点数目。</li><li>根据左右子树节点数目，从前序、中序遍历中切分出左、右子树的前序、中序遍历，分治法确定当前节点左右孩子。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>preL<span class="token punctuation">,</span>preR<span class="token punctuation">,</span>inL<span class="token punctuation">,</span>inR<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> preL<span class="token operator">></span>preR <span class="token operator">or</span> inL<span class="token operator">></span>inR<span class="token punctuation">:</span>                <span class="token keyword">return</span> None            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preL<span class="token punctuation">]</span><span class="token punctuation">)</span>            in_pos<span class="token operator">=</span>inorder<span class="token punctuation">[</span>inL<span class="token punctuation">:</span>inR<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preL<span class="token punctuation">]</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>left<span class="token operator">=</span>build<span class="token punctuation">(</span>preL<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>preL<span class="token operator">+</span>in_pos<span class="token punctuation">,</span>inL<span class="token punctuation">,</span>inL<span class="token operator">+</span>in_pos<span class="token number">-1</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>build<span class="token punctuation">(</span>preL<span class="token operator">+</span>in_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>preR<span class="token punctuation">,</span>inL<span class="token operator">+</span>in_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>inR<span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token keyword">return</span> build<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>preorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>inorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第114题-二叉树展开为链表"><a href="#第114题-二叉树展开为链表" class="headerlink" title="第114题 二叉树展开为链表"></a>第114题 <a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表</a></h3><p><img src="114.png" alt="第114题"></p><h4 id="思路：-11"><a href="#思路：-11" class="headerlink" title="思路："></a>思路：</h4><p>我自己的方法有些类似于剑指Offer中的二叉树转双向链表。</p><ul><li>使用一个全局变量tail作为指针，指向当前已生成链表中的最后一个节点。</li><li>先序遍历二叉树，每次修改tail指针的左节点为当前节点，即使用left指针模拟链表的next指针。</li><li>调整链表，使用right指针模拟next指针，并将left指针置空。（为什么不直接用right指针模拟？因为先序遍历是根-左-右的顺序，对左孩子的遍历可能导致根节点的right指针被覆盖，导致无法继续遍历右孩子）</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">flatten</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify root in-place instead.        """</span>        self<span class="token punctuation">.</span>tail<span class="token operator">=</span>None        <span class="token keyword">def</span> <span class="token function">flat</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>tail<span class="token operator">!=</span>None<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>left<span class="token operator">=</span>root            self<span class="token punctuation">.</span>tail<span class="token operator">=</span>root            flat<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            flat<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">change</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token operator">=</span>None<span class="token punctuation">,</span>root<span class="token punctuation">.</span>left            change<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                 flat<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        change<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(n)$。</li></ul><h2 id="2020-4-4-（2-hard-1easy）"><a href="#2020-4-4-（2-hard-1easy）" class="headerlink" title="2020.4.4 （2 hard 1easy）"></a>2020.4.4 （2 hard 1easy）</h2><h3 id="124题-二叉树中的最大路径和"><a href="#124题-二叉树中的最大路径和" class="headerlink" title="124题  二叉树中的最大路径和"></a>124题 <a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener"> 二叉树中的最大路径和</a></h3><p><img src="124.png" alt="第124题"></p><h4 id="思路：-12"><a href="#思路：-12" class="headerlink" title="思路："></a>思路：</h4><p>我的思路是递归求解，先给出代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>max_sum<span class="token operator">=</span>root<span class="token punctuation">.</span>val        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            left_sum<span class="token operator">=</span>max<span class="token punctuation">(</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>            right_sum<span class="token operator">=</span>max<span class="token punctuation">(</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>            now_path_sum<span class="token operator">=</span>root<span class="token punctuation">.</span>val<span class="token operator">+</span>left_sum<span class="token operator">+</span>right_sum            self<span class="token punctuation">.</span>max_sum<span class="token operator">=</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>max_sum<span class="token punctuation">,</span>now_path_sum<span class="token punctuation">)</span>            <span class="token keyword">return</span> root<span class="token punctuation">.</span>val<span class="token operator">+</span>max<span class="token punctuation">(</span>left_sum<span class="token punctuation">,</span>right_sum<span class="token punctuation">)</span>        recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>max_sum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果当前节点为空，我们的递归函数返回0，表示经过该节点的最大路径和为0。</p><p>接着我们递归计算左子树和右子树，如果递归函数返回值大于0，说明加上它有可能会使当前节点路径和变大，否则不走路径和小于0的子树。</p><p>当前节点的最大路径和即为当前节点的值加上左子树和0的最大值加上右子树和0的最大值，加上后即可尝试更新当前二叉树的最大路径和。</p><p>接下来是进行返回，也是本题中最容易出错的地方！返回值不是当前节点的最大路径和，而是只能走一边的子树，因为二叉树的节点不能被重复访问！</p><h3 id="128题-最长连续序列"><a href="#128题-最长连续序列" class="headerlink" title="128题  最长连续序列"></a>128题 <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener"> 最长连续序列</a></h3><p><img src="128.png" alt="第128题"></p><h4 id="思路：-13"><a href="#思路：-13" class="headerlink" title="思路："></a>思路：</h4><p>我们先从暴力算法想起，暴力算法的做法是遍历数组中的每一个数，查看他的下一个数是否在数组中，如果在，那么就再查看下一个数，直到出现不在数组中的数，记录下当前长度并尝试更新最大长度。由于数组无序，所以每次查找都需要$O(n)$的时间复杂度，最坏情况下（即数组降序），需要的时间复杂度为$O(n^3)$。</p><p>为了优化至$O(n)$的时间复杂度，首先，我们可以建立辅助的数据结构——哈希表。这里，我们使用哈希集合，hashset和hashmap的区别在于，hashset只存key不存value，而hashmap存了键值对。我们知道，哈希集合的查找时间复杂度仅需$O(1)$（直接哈希函数），所以此时的时间复杂度已经降为$O(n^2)$。</p><p>为了进一步优化，我们进行剪枝操作，当我们访问到num，假如num-1已经在hashset中，那么我们就不对他进行向后搜索。即：我们现在只对序列开头的数进行向后搜索。因为我们使用的是hashset，所以判断num-1是否存在依然很快。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        hashset<span class="token operator">=</span>set<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        first_num<span class="token operator">=</span><span class="token number">0</span>        max_length<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> num<span class="token number">-1</span> <span class="token operator">not</span> <span class="token keyword">in</span> hashset<span class="token punctuation">:</span>                length<span class="token operator">=</span><span class="token number">1</span>                <span class="token keyword">while</span> num<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">in</span> hashset<span class="token punctuation">:</span>                    num<span class="token operator">+=</span><span class="token number">1</span>                    length<span class="token operator">+=</span><span class="token number">1</span>                max_length<span class="token operator">=</span>max<span class="token punctuation">(</span>length<span class="token punctuation">,</span>max_length<span class="token punctuation">)</span>        <span class="token keyword">return</span> max_length<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(n)$。</li></ul><h3 id="136题-只出现一次的数字"><a href="#136题-只出现一次的数字" class="headerlink" title="136题 只出现一次的数字"></a>136题 <a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">只出现一次的数字</a></h3><p><img src="136.png" alt="第136题"></p><h4 id="思路：-14"><a href="#思路：-14" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，异或运算，一个数异或自身为0，异或0为自身。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            result<span class="token operator">^</span><span class="token operator">=</span>num        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-5-（2-medium-1easy）"><a href="#2020-4-5-（2-medium-1easy）" class="headerlink" title="2020.4.5 （2 medium 1easy）"></a>2020.4.5 （2 medium 1easy）</h2><h3 id="139题-单词拆分"><a href="#139题-单词拆分" class="headerlink" title="139题 单词拆分"></a>139题 <a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">单词拆分</a></h3><p><img src="139.png" alt="第139题"></p><h4 id="思路：-15"><a href="#思路：-15" class="headerlink" title="思路："></a>思路：</h4><p>这类题最常见的解法就是动态规划法了。类似的问题还有：正则表达式匹配等。</p><p>我在一开始却尝试了DFS，递归超时了。<strong>类似的题目是不能用DFS的！必然超时！希望自己以后能记住这个教训！因为这道题存在着重叠子问题，就像走迷宫问题一样，假设字符串s的前 i 个字符的匹配可以通过多条路径得到，那么它们从第 i 个字符往后的路径都是相同的，如果使用递归，由于无法记录递归过程中的状态，会产生大量的重复计算。</strong>解决的方案可以是带备忘录的递归，但动态规划显然更加有效。</p><p>我们使用DP求解。DP状态矩阵dp[i]为s的前i个字符是否匹配。转移方程为：遍历wordDict中的word，dp[i]=dp[i-len（word）]（if i-len（word）&gt;=0 and dp[i-len（word）] and s[i-len（word）:i]==word）。即假如前i个字符的末尾存在wordDict中的某个单词，且去除该单词后，前i-len（word）个字符也能拆分，说明前i个字符可以被拆分。</p><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> wordDict<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>minLen<span class="token punctuation">,</span> maxLen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                start<span class="token operator">=</span>i<span class="token operator">-</span>j                <span class="token keyword">if</span>  start<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> dp<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>start<span class="token punctuation">:</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> wordSet<span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                    <span class="token keyword">break</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="141题-环形链表"><a href="#141题-环形链表" class="headerlink" title="141题 环形链表"></a>141题 <a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表</a></h3><p><img src="141.png" alt="第141题"></p><h4 id="思路：-16"><a href="#思路：-16" class="headerlink" title="思路："></a>思路：</h4><p>hashset存放已经访问过的节点，遍历链表，如果访问到已存在hashset中的节点时，返回True，即存在环，否则将当前节点加入hashset，继续向前遍历。</p><ul><li>时间复杂度：$O(n)$，哈希表的查找为$O(1)$</li><li>空间复杂度：$O(n)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        nodes<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        p<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> p <span class="token keyword">in</span> nodes<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            nodes<span class="token punctuation">.</span>add<span class="token punctuation">(</span>p<span class="token punctuation">)</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了更进一步的优化时间复杂度和空间复杂度，我们可以原地修改链表，对访问过的节点的值设为”visited“，如果遍历到已访问节点，return True。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        p<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>val<span class="token operator">==</span><span class="token string">"visited"</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            p<span class="token punctuation">.</span>val<span class="token operator">=</span><span class="token string">"visited"</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h3 id="142题-环形链表-II"><a href="#142题-环形链表-II" class="headerlink" title="142题 环形链表 II"></a>142题 <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">环形链表 II</a></h3><p><img src="142.png" alt="第142题"></p><p>这道题要求我们不能原地修改链表，所以141题中的第二种方法就不能使用，只能使用哈希集合的方法。但是，有没有方法能够不使用额外的数据结构呢？</p><p>我们可以使用Floyd算法，采用快慢指针的做法求出环形链表的环入口节点。</p><ul><li>定义双指针fast、slow，均指向head节点。</li><li>fast、slow向前遍历，fast每次走两步，slow每次走一步。</li><li>假如fast走到了None，说明链表无环，直接返回None。</li><li>否则，fast和slow必然会在环中的某一个节点处相遇，此时，fast节点走过的路程为f，slow节点走过的路程为s，环的长度为b，则必有：（1）f=2s（因为快指针每次走两步，慢指针走一步，快指针的路程必然是慢指针的两倍），（2）f=s+nb（要想相遇，快指针必然比慢指针多走了n圈）。二者相减，得：s=nb，f=2nb。</li><li>我们知道，想要从起点走到环入口，需要走a+nb，其中，a是指从链表起点到环入口的步数，nb为在环中转圈的步数。所以，我们已有：s=nb，只要让慢指针再走a步，即可到达环入口节点。</li><li>我们可以移动fast到头节点，让快指针和慢指针每次都走一步，最终，快慢指针将在环入口处相遇，此时:f=a,s=a+nb。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        fast<span class="token operator">=</span>head        slow<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> fast<span class="token operator">==</span>None <span class="token operator">or</span> fast<span class="token punctuation">.</span>next<span class="token operator">==</span>None <span class="token operator">or</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> None            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next            <span class="token keyword">if</span> fast<span class="token operator">==</span>slow<span class="token punctuation">:</span>                <span class="token keyword">break</span>        fast<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token operator">!=</span>slow<span class="token punctuation">)</span><span class="token punctuation">:</span>            fast<span class="token punctuation">,</span>slow<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">,</span>slow<span class="token punctuation">.</span>next        <span class="token keyword">return</span> slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="2020-4-6-（3-medium）"><a href="#2020-4-6-（3-medium）" class="headerlink" title="2020.4.6 （3 medium）"></a>2020.4.6 （3 medium）</h2><h3 id="146题-LRU缓存机制"><a href="#146题-LRU缓存机制" class="headerlink" title="146题 LRU缓存机制"></a>146题 <a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LRU缓存机制</a></h3><p><img src="146.png" alt="第146题"></p><h4 id="思路：-17"><a href="#思路：-17" class="headerlink" title="思路："></a>思路：</h4><p>基本思路是使用一个类似于队列的数据结构，我们将最近使用的键值对放置到队首，这样队尾键值对必然是最近最少使用的。当添加新的键值对，而缓存已满时，我们需要将队尾的键值对出队，并将新的键值对添加到队首，从而实现了LRU缓存机制。</p><p>特别地，题目要求我们使用$O(1)$级别的时间复杂度，我们很容易便想到了哈希表，其查找节点的时间复杂度为$O(1)$（类似于为链表中的节点建立索引）。更进一步，我们需要修改原先的队列为双向链表，因为只有双向链表可以保证删除节点的时间复杂度在$O(1)$，而我们需要在以下两种情况进行删除节点操作（插入节点都是在头部，均为$O(1)$：</p><ul><li>当我们需要进行get操作时，需要将被访问的键值对的节点移动到双向链表开头，需要先删除，再插入。</li><li>当我们需要进行put操作，而缓存已满时，需要将尾部键值对删除。</li></ul><p>所以，使用双向链表是必要的。特别地，为了减少插入、删除过程中的额外判断，我们使用链表中经常需要用到的伪头节点和伪尾节点。（如果直接使用字典，虽然python3中dictionary是有序的，但无法选择插入的位置）</p><p>算法的基本流程如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// key 映射到 Node(key, val)</span>HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Node<span class="token operator">></span> map<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Node(k1, v1) &lt;-> Node(k2, v2)...</span>DoubleList cache<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key 不存在<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                将数据 <span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> 提到开头；        <span class="token keyword">return</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key 已存在<span class="token punctuation">)</span> <span class="token punctuation">{</span>        把旧的数据删除；        将新节点 x 插入到开头；    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cache 已满<span class="token punctuation">)</span> <span class="token punctuation">{</span>            删除链表的最后一个数据腾位置；            删除 map 中映射到该数据的键；        <span class="token punctuation">}</span>         将新节点 x 插入到开头；        map 中新建 key 对新节点 x 的映射；    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们自己实现双向链表、节点、以及调整节点至开头，插入节点至开头，删除尾部节点操作后，完整的代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>key<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>key<span class="token operator">=</span>key        self<span class="token punctuation">.</span>val<span class="token operator">=</span>val        self<span class="token punctuation">.</span>next<span class="token operator">=</span>None        self<span class="token punctuation">.</span>prev<span class="token operator">=</span>None<span class="token keyword">class</span> <span class="token class-name">LinkedList</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>head<span class="token operator">=</span>Node<span class="token punctuation">(</span>None<span class="token punctuation">,</span>None<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>tail<span class="token operator">=</span>Node<span class="token punctuation">(</span>None<span class="token punctuation">,</span>None<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token operator">=</span>self<span class="token punctuation">.</span>tail        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev<span class="token operator">=</span>self<span class="token punctuation">.</span>head    <span class="token keyword">def</span> <span class="token function">move_to_head</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>        node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next<span class="token operator">=</span>node<span class="token punctuation">.</span>next        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev<span class="token operator">=</span>node<span class="token punctuation">.</span>prev        node<span class="token punctuation">.</span>prev<span class="token operator">=</span>self<span class="token punctuation">.</span>head        node<span class="token punctuation">.</span>next<span class="token operator">=</span>self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token operator">=</span>node        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev<span class="token operator">=</span>node        <span class="token keyword">return</span> node<span class="token punctuation">.</span>val    <span class="token keyword">def</span> <span class="token function">add_to_head</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>        node<span class="token punctuation">.</span>prev<span class="token operator">=</span>self<span class="token punctuation">.</span>head        node<span class="token punctuation">.</span>next<span class="token operator">=</span>self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token operator">=</span>node        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev<span class="token operator">=</span>node    <span class="token keyword">def</span> <span class="token function">pop_tail</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        node<span class="token operator">=</span>self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev        node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next<span class="token operator">=</span>self<span class="token punctuation">.</span>tail        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev<span class="token operator">=</span>node<span class="token punctuation">.</span>prev        <span class="token keyword">return</span> node<span class="token punctuation">.</span>key<span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> capacity<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>capacity<span class="token operator">=</span>capacity        self<span class="token punctuation">.</span>hashmap<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        self<span class="token punctuation">.</span>length<span class="token operator">=</span><span class="token number">0</span>        self<span class="token punctuation">.</span>linkedlist<span class="token operator">=</span>LinkedList<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>hashmap<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>move_to_head<span class="token punctuation">(</span>self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">put</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">:</span> int<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>hashmap<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>val<span class="token operator">=</span>value            self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>move_to_head<span class="token punctuation">(</span>self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> self<span class="token punctuation">.</span>length<span class="token operator">&lt;</span>self<span class="token punctuation">.</span>capacity<span class="token punctuation">:</span>            node<span class="token operator">=</span>Node<span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>add_to_head<span class="token punctuation">(</span>node<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span>node            self<span class="token punctuation">.</span>length<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            node<span class="token operator">=</span>Node<span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>            key_del<span class="token operator">=</span>self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>pop_tail<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>hashmap<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>key_del<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>add_to_head<span class="token punctuation">(</span>node<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span>node<span class="token comment" spellcheck="true"># Your LRUCache object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = LRUCache(capacity)</span><span class="token comment" spellcheck="true"># param_1 = obj.get(key)</span><span class="token comment" spellcheck="true"># obj.put(key,value)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后总结一下，我们维护一个链表，链表中数据从前至后依次为上次使用时间从近至远。为了减低时间复杂度，我们使用双向链表和哈希表减少调整链表所花费的时间。</p><h3 id="148题-排序链表"><a href="#148题-排序链表" class="headerlink" title="148题 排序链表"></a>148题 <a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">排序链表</a></h3><p><img src="148.png" alt="第148题"></p><h4 id="思路-44"><a href="#思路-44" class="headerlink" title="思路:"></a>思路:</h4><p>由于时间复杂度需要在$O(nlogn)$，所以可用的算法有：归并排序，快速排序，堆排序等。考虑到合并链表比较方便，所以我们在这里选用归并排序。</p><p>与常规的归并排序类似，我们进行递归合并。先调用自身函数归并排序左半部分和右半部分，再调用合并两个有序链表的函数归并左右部分。</p><p>这里需要注意的是，当前需要排序的是链表而非数组，所以我们无法通过下标运算直接得到中间节点，对当前链表进行二分划分。假如我们直接遍历链表得到长度再遍历长度的一半找到中间节点，则时间复杂度为$O(3n/2)$。为了优化，我们可以使用快慢指针法。让快指针每次走两步，慢指针每次走一步，当快指针走到链表终点时，慢指针必然位于中间节点。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">getMiddle</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> head<span class="token operator">==</span>None <span class="token operator">or</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> head            slow<span class="token operator">=</span>head            fast<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token operator">!=</span>None <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next                fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            <span class="token keyword">return</span> slow        <span class="token keyword">def</span> <span class="token function">mergeTwoList</span><span class="token punctuation">(</span>head1<span class="token punctuation">,</span>head2<span class="token punctuation">)</span><span class="token punctuation">:</span>            dummyhead<span class="token operator">=</span>ListNode<span class="token punctuation">(</span>None<span class="token punctuation">)</span>            p1<span class="token operator">=</span>dummyhead            p2<span class="token operator">=</span>head1            p3<span class="token operator">=</span>head2            <span class="token keyword">while</span> <span class="token punctuation">(</span>p2<span class="token operator">!=</span>None <span class="token operator">and</span> p3<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> p2<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>p3<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                    p1<span class="token punctuation">.</span>next<span class="token operator">=</span>p2                    p2<span class="token operator">=</span>p2<span class="token punctuation">.</span>next                    p1<span class="token operator">=</span>p1<span class="token punctuation">.</span>next                <span class="token keyword">else</span><span class="token punctuation">:</span>                    p1<span class="token punctuation">.</span>next<span class="token operator">=</span>p3                    p3<span class="token operator">=</span>p3<span class="token punctuation">.</span>next                    p1<span class="token operator">=</span>p1<span class="token punctuation">.</span>next            p1<span class="token punctuation">.</span>next<span class="token operator">=</span>p2 <span class="token keyword">if</span> p2<span class="token operator">!=</span>None <span class="token keyword">else</span> p3            <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next        <span class="token keyword">if</span> head<span class="token operator">==</span>None <span class="token operator">or</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        mid<span class="token operator">=</span>getMiddle<span class="token punctuation">(</span>head<span class="token punctuation">)</span>        tmp<span class="token operator">=</span>mid<span class="token punctuation">.</span>next        mid<span class="token punctuation">.</span>next<span class="token operator">=</span>None        head1<span class="token operator">=</span>self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>head<span class="token punctuation">)</span>        head2<span class="token operator">=</span>self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>        <span class="token keyword">return</span> mergeTwoList<span class="token punctuation">(</span>head1<span class="token punctuation">,</span>head2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="152题-乘积最大子数组"><a href="#152题-乘积最大子数组" class="headerlink" title="152题 乘积最大子数组"></a>152题 <a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">乘积最大子数组</a></h3><p><img src="152.png" alt="第152题"></p><h4 id="思路-45"><a href="#思路-45" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划，类似于最大连续子序和问题。我们使用dp[i]表示前i个数字中子数组的最大乘积。动态规划转移方程为：</p><blockquote><p>maxDP[i + 1] = max(maxDP[i] <em> A[i + 1], A[i + 1],minDP[i] </em> A[i + 1])<br>minDP[i + 1] = min(minDP[i] <em> A[i + 1], A[i + 1],maxDP[i] </em> A[i + 1])<br>dp[i + 1] = max(dp[i], maxDP[i + 1])</p></blockquote><p>在这里，maxDP[i] 是以第i个数字结尾的子数组的最大乘积，minDP[i]是以第i个数字结尾的子数组的最小乘积。之所以我们需要保留最小乘积，是因为考虑到第i+1个数字是负数的情况。</p><p>由于我们发现，所有的动态规划转移方程都只需要用到前一个状态，所以我们只需要使用三个变量即可代替状态矩阵（滚动数组法优化DP空间的思想）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProduct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        imax<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        imin<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        max_product<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>                imax<span class="token punctuation">,</span>imin<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>imin<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>imax<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                imax<span class="token punctuation">,</span>imin<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>imax<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>imin<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            max_product<span class="token operator">=</span>max<span class="token punctuation">(</span>imax<span class="token punctuation">,</span>max_product<span class="token punctuation">)</span>        <span class="token keyword">return</span> max_product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，imax和imin必须同步更新，因为imin的更新需要使用到imax的值，如果imax的值先被改变，结果将出错。</p><h2 id="2020-4-7-（4-easy）"><a href="#2020-4-7-（4-easy）" class="headerlink" title="2020.4.7 （4 easy）"></a>2020.4.7 （4 easy）</h2><h3 id="155题-最小栈"><a href="#155题-最小栈" class="headerlink" title="155题 最小栈"></a>155题 <a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">最小栈</a></h3><p><img src="155.png" alt="第155题"></p><h4 id="思路：-18"><a href="#思路：-18" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，我们可以使用一个辅助栈，存放栈内前i个元素中的最小值，以空间换时间。</p><ul><li>时间复杂度：$O(1)$。</li><li>空间复杂度：$O(n)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MinStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>stack1<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>stack2<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack2<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>min<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">getMin</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your MinStack object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MinStack()</span><span class="token comment" spellcheck="true"># obj.push(x)</span><span class="token comment" spellcheck="true"># obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.top()</span><span class="token comment" spellcheck="true"># param_4 = obj.getMin()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="160题-相交链表"><a href="#160题-相交链表" class="headerlink" title="160题 相交链表"></a>160题 <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">相交链表</a></h3><p><img src="160.png" alt="第160题"></p><h4 id="思路：-19"><a href="#思路：-19" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，我们最容易想到的方法是采用哈希表的方式，记录下A、B链表中的每一个节点，找到第一个重复的节点返回。但有没有方法可以不使用额外的空间呢？答案是有的，我们可以使用双指针法，这有些类似于环形链表142题。</p><p>我们创建指针p指向headA，指针q指向headB，使二者向前遍历链表A和B。当p遍历到链表A结尾时，令p=headB，当q遍历到链表B结尾时，令q=headA。如果链表A和链表B存在相交点时，p和q继续向后遍历，必然会在相交点处相等。如果不存在相交点，p和q继续向后遍历，必然会同时遍历到链表结尾。</p><p>原理：</p><p><img src="160-1.png" alt="第160题示意图"></p><p>假如相交，则a+b+c必然等于c+b+a！p指针和q指针在链表相交点处必然走过相同的路程。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> headA<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> headB<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> headA<span class="token operator">==</span>None <span class="token operator">or</span> headB<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        p<span class="token operator">=</span>headA        q<span class="token operator">=</span>headB        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>next<span class="token operator">==</span>None <span class="token operator">and</span> q<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> None            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next <span class="token keyword">if</span> p<span class="token punctuation">.</span>next<span class="token operator">!=</span>None <span class="token keyword">else</span> headB            q<span class="token operator">=</span>q<span class="token punctuation">.</span>next <span class="token keyword">if</span> q<span class="token punctuation">.</span>next<span class="token operator">!=</span>None <span class="token keyword">else</span> headA        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="169题-多数元素"><a href="#169题-多数元素" class="headerlink" title="169题 多数元素"></a>169题 <a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">多数元素</a></h3><p><img src="169.png" alt="第169题"></p><h4 id="思路：-20"><a href="#思路：-20" class="headerlink" title="思路："></a>思路：</h4><p>常规的做法有：（1）哈希表记录各元素出现的次数，选择出现次数最多的元素（时：$O(n)$，空：$O(n)$）（2）排序法，取中值。（时：$O(nlogn)$，空：$O(1)$）</p><p>为了获得最优的时空复杂度，我们还可以使用投票算法：</p><ul><li>如果我们把众数记为 +1，把其他数记为 -1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。 </li><li>我们遍历数组，使用count记录下当前投票和。如果count等于0，那么就更新候选人。接着进行投票，如果当前值等于候选人，count加1，否则count减1。</li><li>投票算法证明：<ol><li>如果候选人不是maj（多数元素） 则 maj,会和其他非候选人一起反对 会反对候选人,所以候选人一定会下台(maj==0时发生换届选举)</li><li>如果候选人是maj , 则maj 会支持自己，其他候选人会反对，同样因为maj 票数超过一半，所以maj 一定会成功当选</li></ol></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        count<span class="token operator">=</span><span class="token number">0</span>        candidate<span class="token operator">=</span>None        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                candidate<span class="token operator">=</span>num            count<span class="token operator">+=</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">if</span> num<span class="token operator">==</span>candidate <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> candidate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><h3 id="198题-打家劫舍"><a href="#198题-打家劫舍" class="headerlink" title="198题 打家劫舍"></a>198题 <a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">打家劫舍</a></h3><p><img src="198.png" alt="第198题"></p><h4 id="思路：-21"><a href="#思路：-21" class="headerlink" title="思路："></a>思路：</h4><p>动态规划模板题，有些类似于01背包问题。动态规划状态矩阵dp[i]用于表示偷前i家的最大金额，转移方程为：</p><ul><li>dp[i]=max（dp[i-1]，dp[i-2]+nums[i]）</li></ul><p>即考虑偷当前这家和不偷当前这家的收益谁更大，选择最大收益。（偷这家就不能偷上一家）</p><p>由于只用到前两个状态，所以我们可以使用滚动数组的思想进行空间优化。</p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        a<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        b<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            a<span class="token punctuation">,</span>b<span class="token operator">=</span>b<span class="token punctuation">,</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>        <span class="token keyword">return</span> b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-8（3-medium-1-easy）"><a href="#2020-4-8（3-medium-1-easy）" class="headerlink" title="2020.4.8（3 medium 1 easy）"></a>2020.4.8（3 medium 1 easy）</h2><h3 id="200题-岛屿数量"><a href="#200题-岛屿数量" class="headerlink" title="200题 岛屿数量"></a>200题 <a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">岛屿数量</a></h3><p><img src="200.png" alt="第200题"></p><h4 id="思路：-22"><a href="#思路：-22" class="headerlink" title="思路："></a>思路：</h4><p>DFS模板题，使用一个visited矩阵来存放某个位置是否已被访问过。</p><p>遍历grid矩阵，每次遇到尚未被访问的岛屿时，将计数变量加1，再使用DFS遍历该岛屿的所有土地，并标记为已访问，访问过的土地或者水域都不会进行访问。这样，将会把该岛屿的所有土地都访问一次，然后终止递归。最后，所有的岛屿将被遍历一次，计数变量的值即为岛屿数。</p><p>特别地，为了减少空间占用，我们还可以原地修改grid矩阵来表示已访问过。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numIslands</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> row<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">or</span> row<span class="token operator">>=</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span> <span class="token operator">or</span> col<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">or</span> col<span class="token operator">>=</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span>            <span class="token keyword">if</span> grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"1"</span><span class="token punctuation">:</span>                grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"0"</span>                dfs<span class="token punctuation">(</span>row<span class="token number">-1</span><span class="token punctuation">,</span>col<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token number">-1</span><span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        islands<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"1"</span><span class="token punctuation">:</span>                    islands<span class="token operator">+=</span><span class="token number">1</span>                    dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span>        <span class="token keyword">return</span> islands<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(mn)$。</li><li>空间复杂度：$O(mn)$，递归栈。</li></ul><p>这道题还可以用<a href="https://blog.csdn.net/qq_41593380/article/details/81146850" target="_blank" rel="noopener">并查集</a>来做。基本思路就是将连同的陆地合并到同一个集合中，最后统计集合数目即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numIslands</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">class</span> <span class="token class-name">UnionFind</span><span class="token punctuation">:</span>            <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>count <span class="token operator">=</span> n                self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">def</span> <span class="token function">get_count</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> self<span class="token punctuation">.</span>count            <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>                now<span class="token operator">=</span>p                <span class="token keyword">while</span> p <span class="token operator">!=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">:</span>                    p <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span>                <span class="token keyword">while</span> now <span class="token operator">!=</span> p<span class="token punctuation">:</span>                    now<span class="token punctuation">,</span>self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">=</span>self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">,</span>p                <span class="token keyword">return</span> p            <span class="token keyword">def</span> <span class="token function">is_connected</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token keyword">def</span> <span class="token function">union</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>                p_root <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span>                q_root <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>                <span class="token keyword">if</span> p_root <span class="token operator">!=</span> q_root<span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>q_root<span class="token punctuation">]</span><span class="token operator">=</span>p_root                    self<span class="token punctuation">.</span>count<span class="token operator">-=</span><span class="token number">1</span>        row <span class="token operator">=</span> len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 特判</span>        <span class="token keyword">if</span> row <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        col <span class="token operator">=</span> len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">get_index</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> x <span class="token operator">*</span> col <span class="token operator">+</span> y        <span class="token comment" spellcheck="true"># 注意：我们不用像 DFS 和 BFS 一样，4 个方向都要尝试，只要看一看右边和下面就可以了</span>        directions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 多开一个空间，把水域 "0" 都归到这个虚拟的老大上</span>        dummy_node <span class="token operator">=</span> row <span class="token operator">*</span> col        <span class="token comment" spellcheck="true"># 多开的一个空间就是那个虚拟的空间</span>        uf <span class="token operator">=</span> UnionFind<span class="token punctuation">(</span>dummy_node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 如果是水域，都连到那个虚拟的空间去</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">:</span>                    uf<span class="token punctuation">.</span>union<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> dummy_node<span class="token punctuation">)</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true"># 向下向右如果都是陆地，即 "1"，就要合并一下</span>                    <span class="token keyword">for</span> direction <span class="token keyword">in</span> directions<span class="token punctuation">:</span>                        new_x <span class="token operator">=</span> i <span class="token operator">+</span> direction<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                        new_y <span class="token operator">=</span> j <span class="token operator">+</span> direction<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                        <span class="token keyword">if</span> new_x <span class="token operator">&lt;</span> row <span class="token operator">and</span> new_y <span class="token operator">&lt;</span> col <span class="token operator">and</span> grid<span class="token punctuation">[</span>new_x<span class="token punctuation">]</span><span class="token punctuation">[</span>new_y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">:</span>                            uf<span class="token punctuation">.</span>union<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> get_index<span class="token punctuation">(</span>new_x<span class="token punctuation">,</span> new_y<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 不要忘记把那个虚拟结点减掉</span>        <span class="token keyword">return</span> uf<span class="token punctuation">.</span>get_count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>顾名思义，并查集的主要操作有两个，分别是并和查。类似于这种最小连通子树的问题，我们使用图结构未免过于复杂，所以并查集能够很好的解决这一问题。</p><p>我们使用一个数组parent存放每个节点的父节点。</p><ul><li>查操作：如果节点A的父节点是自身，那么他就是所在树的根节点，否则向上递归搜索，直到找到所在树的根节点。（查询每个节点所在子树的根节点，如果A和B所在子树的根节点相同，则说明它们是连通的）</li><li>特别地，为了进行路径压缩，我们在查操作递归查找到根节点后，将递归路径上的所有节点的父节点设置为根节点，从而确保所有的节点都可以在两步之内找到根节点。</li><li>并操作：合并节点A和节点B所在的子树。具体做法是：查找A所在子树的根节点，查找B所在子树的根节点，修改A的根节点的父节点为B的根节点。</li><li>初始情况下，我们设定每一个位置都是一个集合（子树），并查集的count数为总位置数目加1（有一个虚拟节点）。然后我们遍历所有位置，如果当前位置是陆地，则合并右方和下方的陆地至当前位置的子树，每次合并后将count数减1，说明集合数减1。如果当前位置是水域，则将其合并到伪节点下。</li><li>最后，我们将并查集内的集合数目减1，即为岛屿数目（其中有一个集合是水域的集合）。</li></ul><h3 id="206题-反转链表"><a href="#206题-反转链表" class="headerlink" title="206题 反转链表"></a>206题 <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a></h3><p><img src="206.png" alt="第206题"></p><h4 id="思路：-23"><a href="#思路：-23" class="headerlink" title="思路："></a>思路：</h4><p>可以使用头插法，遍历链表中的每个节点都插入到头部即可。</p><p>也可以使用快慢指针法，慢指针开始时指向None，快指针指向Head。每次将快指针的next指向慢指针，即实现了反转。然后将快慢指针同时向前移动一个节点，继续修改快指针的next。、</p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        p<span class="token operator">=</span>None        q<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp<span class="token punctuation">,</span>q<span class="token punctuation">.</span>next<span class="token operator">=</span>q<span class="token punctuation">.</span>next<span class="token punctuation">,</span>p            p<span class="token punctuation">,</span>q<span class="token operator">=</span>q<span class="token punctuation">,</span>tmp        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="207题-课程表"><a href="#207题-课程表" class="headerlink" title="207题  课程表"></a>207题 <a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener"> 课程表</a></h3><p><img src="207.png" alt="第207题"></p><h4 id="思路：-24"><a href="#思路：-24" class="headerlink" title="思路："></a>思路：</h4><p>这是一个有向图找环路的问题，基本的思路是拓扑排序。</p><p>我们每次找到一个入度为0的节点，将其从图上删除，并删除以它为起点的所有边，修改相应的边终点的入度。循环执行上述操作，直到图中不存在节点，说明无环。如果无法将节点全部清空，说明存在环。</p><ul><li>时间复杂度：$O(N + M)$： 遍历一个图需要访问所有节点和所有临边；</li><li>空间复杂度：$O(N + M)$： 为建立邻接表所需额外空间。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canFinish</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> numCourses<span class="token punctuation">:</span> int<span class="token punctuation">,</span> prerequisites<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        indegree<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>numCourses<span class="token punctuation">)</span><span class="token punctuation">]</span>        hashmap<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>numCourses<span class="token punctuation">)</span><span class="token punctuation">:</span>            hashmap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> edge <span class="token keyword">in</span> prerequisites<span class="token punctuation">:</span>            indegree<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>            hashmap<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> hashmap<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果还剩下节点，那么继续删除节点</span>            flag<span class="token operator">=</span><span class="token boolean">False</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>indegree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    flag<span class="token operator">=</span><span class="token boolean">True</span>                    <span class="token keyword">for</span> next <span class="token keyword">in</span> hashmap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                        indegree<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>                    indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>                    hashmap<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">if</span> flag<span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果不存在入度为0的节点，那么说明必然存在环路</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span class="token comment" spellcheck="true">#节点可以被全部删除，说明无环</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="215题-数组中的第K个最大元素"><a href="#215题-数组中的第K个最大元素" class="headerlink" title="215题 数组中的第K个最大元素"></a>215题 <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">数组中的第K个最大元素</a></h3><p><img src="215.png" alt="第215题"></p><h4 id="思路：-25"><a href="#思路：-25" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，两种做法：快速选择法和辅助堆。具体解析可见剑指Offer的博客。</p><p>辅助堆：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        heap<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>heap<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>heap<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(nlogk)$，堆的插入、删除都需要$O(logk)$，最坏情况下，每个数字都要入堆出堆一次。</li><li>空间复杂度：$O(k)$，辅助堆。</li></ul><p>快速选择：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#和快速排序中的分治一样，将当前区间首部的枢纽元素调整至正确的位置</span>            i<span class="token operator">=</span>left<span class="token operator">+</span><span class="token number">1</span>            j<span class="token operator">=</span>right            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>right <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    i<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j<span class="token operator">></span>left <span class="token operator">and</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">>=</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    j<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">if</span> i<span class="token operator">&lt;</span>j<span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                    <span class="token keyword">break</span>            <span class="token keyword">return</span> j        <span class="token keyword">def</span> <span class="token function">quickSelect</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#快速选择算法</span>            m<span class="token operator">=</span>partition<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> m<span class="token operator">==</span>k<span class="token punctuation">:</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span>            <span class="token keyword">elif</span> m<span class="token operator">></span>k<span class="token punctuation">:</span>                <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span>left<span class="token punctuation">,</span>m<span class="token number">-1</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>k<span class="token punctuation">)</span>        random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#非常重要！</span>        <span class="token keyword">if</span> k<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> k<span class="token operator">></span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> nums        <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span>k<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是：如果数组有序，那么快速选择法的时间复杂度会大幅提高。（原理和快排一样，当数组有序时，会退化成冒泡排序，时间复杂度升至$O(MN)$）所以我们需要提前随机打乱数组。</p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><h2 id="2020-4-9（2-medium-2-easy）"><a href="#2020-4-9（2-medium-2-easy）" class="headerlink" title="2020.4.9（2 medium 2 easy）"></a>2020.4.9（2 medium 2 easy）</h2><h3 id="221题-最大正方形"><a href="#221题-最大正方形" class="headerlink" title="221题  最大正方形"></a>221题 <a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener"> 最大正方形</a></h3><p><img src="221.png" alt="第221题"></p><h4 id="思路：-26"><a href="#思路：-26" class="headerlink" title="思路："></a>思路：</h4><p>动态规划算法，但很难想到。我们使用状态矩阵dp[i] [j]来表示以第i行第j列的1为右下角顶点的正方形的边长，则动态规划转移方程为：</p><ul><li>dp[i] [j]=0 （if grid[i] [j]==0）</li><li>dp[i] [j]=min(dp[i-1] [j], dp[i] [j-1], dp[i-1] [j-1]) （if grid[i] [j]==1）</li></ul><p>为什么当格子为1时，动态规划转移方程会是那样呢？</p><p>事实上，可以画图自己推导一遍，和木桶短板原理类似：</p><p><img src="221-1.png" alt="dp原理"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maximalSquare</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        m<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"1"</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#只有行号、列号都大于0时，我们才可以使用dp转移方程</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>                    m<span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span>        <span class="token keyword">return</span> m<span class="token operator">*</span>m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(mn)$。</li><li>空间复杂度：$O(mn)$。</li></ul><p>这道题我们可以进一步压缩状态矩阵（很多Dp题目都可以，状态转移只要和之前的有限个状态有关即可。如果我们不需要用到之前的状态，就可以不保存他们）</p><h3 id="226题-翻转二叉树"><a href="#226题-翻转二叉树" class="headerlink" title="226题 翻转二叉树"></a>226题 <a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">翻转二叉树</a></h3><p><img src="226.png" alt="第226题"></p><h4 id="思路：-27"><a href="#思路：-27" class="headerlink" title="思路："></a>思路：</h4><p>递归翻转，翻转当前根节点的左右孩子，同时递归翻转左右孩子的左右孩子，直到当前节点为空。</p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(n)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>invertTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>invertTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以非递归，使用一个辅助队列即可，稍微复杂一些：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span>        <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token operator">!=</span>None<span class="token punctuation">:</span>                node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>node<span class="token punctuation">.</span>right<span class="token operator">=</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span>node<span class="token punctuation">.</span>left                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="234题-回文链表"><a href="#234题-回文链表" class="headerlink" title="234题 回文链表"></a>234题 <a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">回文链表</a></h3><p><img src="234.png" alt="第234题"></p><h4 id="思路：-28"><a href="#思路：-28" class="headerlink" title="思路："></a>思路：</h4><p>如果我们单纯的使用辅助的数据结构，题目将会很容易解决，例如，我们可以使用另一个链表存放翻转过的链表，再比较二者遍历是否完全相等。也可以将链表存放进数组中，使用双指针从两端遍历。</p><p>但是，为了获得$O(1)$的时间复杂度，我们必须原地对链表进行修改。</p><p>具体流程如下：</p><ul><li>先使用快慢指针法找到链表的中间位置。</li><li>然后使用快慢指针法将链表的后半部分翻转。</li><li>然后将快指针移动到head，快慢指针同时向中间遍历，如果出现了val不相等，则不是回文链表，如果直到快慢指针某一个为空时，均相等，则是回文链表。</li></ul><p><img src="234-1.png" alt="第234题"></p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> head<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">if</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token comment" spellcheck="true">##特判</span>        fast<span class="token operator">=</span>head<span class="token punctuation">.</span>next        slow<span class="token operator">=</span>head        <span class="token keyword">while</span> fast<span class="token operator">!=</span>None <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span>            slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        <span class="token comment" spellcheck="true">##找到中间位置</span>        fast<span class="token operator">=</span>slow<span class="token punctuation">.</span>next        slow<span class="token punctuation">.</span>next<span class="token operator">=</span>None        <span class="token keyword">while</span> fast<span class="token operator">!=</span>None<span class="token punctuation">:</span>            tmp<span class="token operator">=</span>fast<span class="token punctuation">.</span>next            fast<span class="token punctuation">.</span>next<span class="token operator">=</span>slow            slow<span class="token operator">=</span>fast            fast<span class="token operator">=</span>tmp        <span class="token comment" spellcheck="true">##翻转后半部分</span>        fast<span class="token operator">=</span>head        <span class="token keyword">while</span> fast<span class="token operator">!=</span>None <span class="token operator">and</span> slow<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">if</span> fast<span class="token punctuation">.</span>val<span class="token operator">!=</span>slow<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next            slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next        <span class="token comment" spellcheck="true">##</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="236题-二叉树的最近公共祖先"><a href="#236题-二叉树的最近公共祖先" class="headerlink" title="236题 二叉树的最近公共祖先"></a>236题 <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">二叉树的最近公共祖先</a></h3><p><img src="236.png" alt="第236题"></p><h4 id="思路：-29"><a href="#思路：-29" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题。递归法，我们可以直接使用题目给出的函数框架进行先根递归：</p><ul><li>如果当前节点为空，必然不是公共祖先，返回None。</li><li>如果当前节点的值是p或者q的值，那么可能是公共祖先，返回当前节点。</li><li>我们从左右子树中递归搜索：<ul><li>如果左右子树均返回了节点，说明p和q分布在当前节点的两侧，则当前节点必然是他们的最近祖先。</li><li>如果只有左子树返回了节点，那么公共祖先必然在左子树中，返回该节点。</li><li>如果只有右子树返回了节点，那么公共祖先必然右左子树中，返回该节点。</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>p<span class="token punctuation">.</span>val <span class="token operator">or</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> root        leftNode<span class="token operator">=</span>self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>        rightNode<span class="token operator">=</span>self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>        <span class="token keyword">if</span> leftNode<span class="token operator">!=</span>None <span class="token operator">and</span> rightNode<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> root        <span class="token keyword">if</span> rightNode<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> rightNode        <span class="token keyword">if</span> leftNode<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> leftNode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-10（3-medium-1-hard）"><a href="#2020-4-10（3-medium-1-hard）" class="headerlink" title="2020.4.10（3 medium 1 hard）"></a>2020.4.10（3 medium 1 hard）</h2><h3 id="238题-除自身以外数组的乘积"><a href="#238题-除自身以外数组的乘积" class="headerlink" title="238题 除自身以外数组的乘积"></a>238题 <a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">除自身以外数组的乘积</a></h3><p><img src="238.png" alt="第238题"></p><h4 id="思路：-30"><a href="#思路：-30" class="headerlink" title="思路："></a>思路：</h4><p>首先，我们注意到题目要求我们不能使用除法，所以我们无法通过求所有数的乘积后挨个进行除法的方式获取结果。此外，题目要求我们使用$O(n)$的时间复杂度，所以我们也不能使用暴力两层循环的方式。</p><p>较好的思路是使用类似于动态规划的思想，先顺序DP求出前缀乘积数组L（L[i]=L[i-1]*nums[i-1])，再倒序DP求出后缀乘积数组R，对于第i个位置的结果res[i]=L[i]*R[i]。</p><p>更进一步，我们可以减少空间复杂度。由于结果数组不算额外空间，我们可以将L数组存入res数组，再倒序计算R数组。因为此时R数组不需要保存所有的状态，只需要保存一个状态用于转移，所以我们只需要用一个变量保存它即可。</p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">productExceptSelf</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> nums<span class="token punctuation">]</span>        res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>res<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>        R<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*=</span>R            R<span class="token operator">=</span>R<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="239题-滑动窗口最大值"><a href="#239题-滑动窗口最大值" class="headerlink" title="239题 滑动窗口最大值"></a>239题 <a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">滑动窗口最大值</a></h3><p><img src="239.png" alt="第239题"></p><h4 id="思路：-31"><a href="#思路：-31" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题。为了获得线性时间复杂度，我们需要维护一个单调双向队列。</p><ul><li>队列中存放的是数组元素的下标。</li><li>队列中的元素单调递减，队首元素为当前窗口内最大的元素下标，第二个元素为在队首元素下标之后第二大的元素下标（一定要在队首元素之后！如果在队首元素下标之前，那么它将比队首元素更早被移出窗口，不可能成为继续滑动窗口后的最大元素），第三个元素为在第二个元素下标之后第三大的元素下标。依次类推。</li><li>我们遍历nums数组中的所有元素下标i，如果此时双向队列为空，我们直接将i入队。否则，我们计算i-k的值与队首元素下标值是否相等，相等则说明此时队首元素下标值已经被恰好移出窗口，我们需要将其出队。接着，我们需要调整双向队列，使其保持递减的性质。并将队列中比nums[i]小的元素下标值出队。（因为此时元素i不仅比他们大，而且还在它们的后面，所以它们再也不可能是某个滑动窗口的最大值了，可以删掉）</li><li>当i大于等于k-1时，说明此时窗口大小达到要求，可以开始统计滑动窗口的最大值。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        dequeue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> dequeue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">-</span>k<span class="token operator">==</span>dequeue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    dequeue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">while</span> dequeue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>dequeue<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    dequeue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            dequeue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">if</span> i<span class="token operator">>=</span>k<span class="token number">-1</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>dequeue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(k)$。</li></ul><h3 id="74题-搜索二维矩阵"><a href="#74题-搜索二维矩阵" class="headerlink" title="74题 搜索二维矩阵"></a>74题 <a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">搜索二维矩阵</a></h3><p><img src="74.png" alt="第74题"></p><h4 id="思路：-32"><a href="#思路：-32" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，我们观察这个二维矩阵，可以发现它其实可以转化为二叉搜索树来进行查询。</p><ul><li>我们从右上角开始查询，可以发现，当前元素左侧的元素都比自己小，下方的元素都比自己大。所以，我们可以使用二叉搜索树的思想：如果目标元素比当前元素大，向下方搜索，否则向左侧搜索。</li><li>当搜索到边界仍然无法找到target，我们可以返回False。找到了target，我们可以返回True。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">searchMatrix</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        row<span class="token operator">=</span><span class="token number">0</span>        col<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>                row<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">elif</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>                col<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(m+n)$，最多需要走到左下角位置。</li><li>空间复杂度：$O(1)$。</li></ul><h3 id="240题-搜索二维矩阵-II"><a href="#240题-搜索二维矩阵-II" class="headerlink" title="240题 搜索二维矩阵 II"></a>240题 <a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">搜索二维矩阵 II</a></h3><p><img src="240.png" alt="第240题"></p><h4 id="思路：-33"><a href="#思路：-33" class="headerlink" title="思路："></a>思路：</h4><p>与74题非常类似，只是从左下角开始搜索而已。此外，还可以使用二分查找的方法，因为每行都是有序的，不过时间复杂度远远高于之前的方法。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">searchMatrix</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type matrix: List[List[int]]        :type target: int        :rtype: bool        """</span>        row<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        col<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> <span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>                col<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">elif</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>                row<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-11（1-easy-2-medium-1-hard）"><a href="#2020-4-11（1-easy-2-medium-1-hard）" class="headerlink" title="2020.4.11（1 easy 2 medium 1 hard）"></a>2020.4.11（1 easy 2 medium 1 hard）</h2><h3 id="279题-完全平方数"><a href="#279题-完全平方数" class="headerlink" title="279题 完全平方数"></a>279题 <a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">完全平方数</a></h3><p><img src="279.png" alt="第279题"></p><h4 id="思路：-34"><a href="#思路：-34" class="headerlink" title="思路："></a>思路：</h4><p>这道题的基本解法和剪绳子问题类似，是一个类似于完全背包问题的动态规划问题。状态矩阵dp[i]用于保存数字i的最小完全平方数。转移方程为：dp[i]=min(dp[i],dp[i-j**2]+1)（j从1到i的平方根）（自底向上，递归是自顶向下）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> math<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numSquares</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>int<span class="token punctuation">(</span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n\sqrt{n})$，两层循环。</li><li>空间复杂度：$O(n)$。</li></ul><p>以下图为例。我们知道，动态规划算法是从记忆化递归转变而来的，属于DFS的思想。但是，这道题使用BFS更好，因为我们要求的不是节点为0时的最大深度，而是最小深度，所以从上至下逐层递归（BFS）比每次走到树的底部（DFS）更为合适。</p><p><img src="279-1.png" alt></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> math<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numSquares</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span>        tmpSet<span class="token operator">=</span>set<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            res<span class="token operator">+=</span><span class="token number">1</span>            l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                now<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>int<span class="token punctuation">(</span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    tmp<span class="token operator">=</span>now<span class="token operator">-</span>j<span class="token operator">*</span>j                    <span class="token keyword">if</span> tmp<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> res                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        <span class="token keyword">if</span> tmp <span class="token operator">not</span> <span class="token keyword">in</span> tmpSet<span class="token punctuation">:</span>                            tmpSet<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>                            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>        <span class="token keyword">return</span> n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用BFS，同时，为了防止对相同值的重复搜索，我们可以对树进行剪枝。使用临时哈希集合来保存已搜索过的值，防止重复搜素。当我们找到了第一个被完全平方数拆分至0的节点，返回其深度，即为最小完全平方数目。</p><h3 id="283题-移动零"><a href="#283题-移动零" class="headerlink" title="283题 移动零"></a>283题 <a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零</a></h3><p><img src="283.png" alt="第283题"></p><h4 id="思路：-35"><a href="#思路：-35" class="headerlink" title="思路："></a>思路：</h4><p>基本思路可以采用冒泡排序，两层循环，时间复杂度很高，为$O(n^2)$。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify nums in-place instead.        """</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>较好的思路是使用快慢双指针，有些类似于之前做过的数组去除某个元素和去重的问题。我们使用慢指针来维护一个无零的区间（指向该区间的后一个元素），快指针来对数组元素进行遍历。如果当前值非零，那么就与慢指针指向的元素交换，慢指针加一。（慢指针如果停在某个位置，而不是和快指针同步向前遍历，说明此时必然遇到了0，所以交换后，零元素必然向末尾靠近）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify nums in-place instead.        """</span>        slow<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> fast <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span>                slow<span class="token operator">+=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$，一次循环。</li><li>空间复杂度：$O(1)$。</li></ul><h3 id="287题-寻找重复数"><a href="#287题-寻找重复数" class="headerlink" title="287题 寻找重复数"></a>287题 <a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">寻找重复数</a></h3><p><img src="287.png" alt="第287题"></p><h4 id="思路：-36"><a href="#思路：-36" class="headerlink" title="思路："></a>思路：</h4><p>这道题可以用的思路很多，但大多数被题目条件所限制：</p><ul><li>最简单的是哈希表，value存放key出现的次数，如果出现了次数等于2的数字，那么必然是重复数。时间复杂度为$O(n)$，空间复杂度为$O(n)$。但题目不给使用额外空间。</li><li>我们还可以使用排序的方法，对数组进行排序。接着再遍历数组，如果当前值和下一个值相等，那么是重复的。时间复杂度为$O(nlogn)$，空间复杂度为$O(1)$。</li></ul><p>实际上，这道题可以看作是一个链表找环路的问题。我们可以把数组的下标看作是节点的地址，数组的值看作是next指针，由于重复值的next相同，所以它们必然会产生环路，我们只要找到环路的入口地址即可（由于环路入口地址必然被入度大于1，即元素值出现次数大于1，即为重复元素）。接着的具体解题思路和之前做过的142题类似。使用快慢指针，快指针每次走2步，慢指针每次走1步，二者相遇后，再让慢指针回到链表头部。二者每次走1步，相遇时即为链表入口。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        slow<span class="token operator">=</span><span class="token number">0</span>        fast<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            slow<span class="token operator">=</span>nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span>            fast<span class="token operator">=</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> slow<span class="token operator">==</span>fast<span class="token punctuation">:</span>                <span class="token keyword">break</span>        slow<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> slow<span class="token operator">!=</span>fast<span class="token punctuation">:</span>            slow<span class="token operator">=</span>nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span>            fast<span class="token operator">=</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span>        <span class="token keyword">return</span> slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="297题-二叉树的序列化与反序列化"><a href="#297题-二叉树的序列化与反序列化" class="headerlink" title="297题 二叉树的序列化与反序列化"></a>297题 <a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">二叉树的序列化与反序列化</a></h3><p><img src="297.png" alt="第297题"></p><h4 id="思路：-37"><a href="#思路：-37" class="headerlink" title="思路："></a>思路：</h4><p>剑指offer原题，数据结构课原题，有两种做法：（1）DFS（先根遍历，栈）（2）BFS（层次遍历，队列）</p><ul><li>DFS的做法：<ul><li>序列化：先序遍历将当前节点的val存入字符串。</li><li>反序列化：将字符串切割成数组。使用先序遍历再次遍历，需要使用外层变量index来记录当前已访问的元素下标。（也可以使用队列来做，本质都是一样的）。</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Encodes a tree to a single string.        :type root: TreeNode        :rtype: str        """</span>        data<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        preorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">","</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>data<span class="token punctuation">)</span>         <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Decodes your encoded data to tree.        :type data: str        :rtype: TreeNode        """</span>        data<span class="token operator">=</span>data<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>index<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>index<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"*"</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>index<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">return</span> None            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>index<span class="token operator">+=</span><span class="token number">1</span>            root<span class="token punctuation">.</span>left<span class="token operator">=</span>build<span class="token punctuation">(</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>build<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token triple-quoted-string string">'''        def build(queue):             now=queue.pop(0)            if now=="*":            return None            root=TreeNode(int(now))            root.left=build(queue)            root.right=build(queue) return root        queue=data.split(",")        return build(queue)        '''</span>        <span class="token keyword">return</span> build<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Your Codec object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># codec = Codec()</span><span class="token comment" spellcheck="true"># codec.deserialize(codec.serialize(root))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>BFS的做法：<ul><li>序列化：使用辅助队列层次遍历，将节点存入data字符串中保存。</li><li>反序列化：先将data字符串切割成数组。然后使用index指针遍历数组，将待处理节点放入一个队列保存。每次将一个节点出队，使移动index指针，使index指向的元素生成它的左右孩子，再将非空的左右孩子入队保存（因为它们也需要处理，尝试生成左右孩子）。开始时使用data数组的首个元素构建root节点，将root入队，index初始值设为1。最后将root返回即可。</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Encodes a tree to a single string.        :type root: TreeNode        :rtype: str        """</span>        data<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span>        <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token operator">==</span>None<span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">","</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Decodes your encoded data to tree.        :type data: str        :rtype: TreeNode        """</span>        data<span class="token operator">=</span>data<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        index<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">if</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"*"</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None        <span class="token keyword">else</span><span class="token punctuation">:</span>            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> index<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">"*"</span><span class="token punctuation">:</span>                node<span class="token punctuation">.</span>left<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            index<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">"*"</span><span class="token punctuation">:</span>                node<span class="token punctuation">.</span>right<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            index<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> root<span class="token comment" spellcheck="true"># Your Codec object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># codec = Codec()</span><span class="token comment" spellcheck="true"># codec.deserialize(codec.serialize(root)) </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-12（2-medium-1-hard）"><a href="#2020-4-12（2-medium-1-hard）" class="headerlink" title="2020.4.12（2 medium 1 hard）"></a>2020.4.12（2 medium 1 hard）</h2><h3 id="300题-最长上升子序列"><a href="#300题-最长上升子序列" class="headerlink" title="300题 最长上升子序列"></a>300题 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长上升子序列</a></h3><p><img src="300.png" alt="300题"></p><h4 id="思路：-38"><a href="#思路：-38" class="headerlink" title="思路："></a>思路：</h4><p>首先，我们可以通过$O(n^2)$的时间复杂度来解决这道题。与最大连续子序列类似，我们可以使用动态规划的方法，dp[i]表示以第i个数字结尾的子序列的最大长度。转移方程：dp[i]=max（dp[i]，dp[j]+1）(if j&lt;i and nums[j]&lt;nums[i])。也就是说，如果第i个数大于在它之前的第j个数，那么它就可以接在以第j个数结尾的最长上升子序列后形成一个更长的上升子序列。我们只需要找到第i个数和之前每个数结尾的最长上升子序列形成的子序列的最大长度即可。</p><ul><li>时间复杂度：$O(n^2)$。</li><li>空间复杂度：$O(n)$，无法进行状态压缩，因为要用到之前每个状态。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> nums<span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>            res<span class="token operator">=</span>max<span class="token punctuation">(</span>res<span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了获取题目要求的$O(nlogn)$的时间复杂度，我们必须要用到二分查找。那么怎么进行二分查找呢？</p><ul><li>首先，我们继续使用动态规划的方法。不过状态矩阵的含义要进行改变，dp[i]表示长度为i的上升子序列的最小结尾值。</li><li>我们遍历nums矩阵，每次遍历时，在当前的dp矩阵中二分查找nums[j]的插入位置，如果插入位置处的dp[i]大于nums[j]，即可将dp[j]修改为nums[j]，说明长度为i的上升子序列的最小结尾值可以更新了。如果插入位置等于len（dp），说明nums[j]比当前所有长度的序列的最小结尾值都大，可以接在它们的后面形成更长的上升子序列，我们将nums[j]加入到dp的末尾。</li><li>当我们遍历完nums[j]后，所得dp数组的长度即为上升序列的最大长度。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Dynamic programming + Dichotomy.</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> <span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> dp<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                left<span class="token operator">=</span><span class="token number">0</span>                right<span class="token operator">=</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>                flag<span class="token operator">=</span><span class="token number">0</span>                <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>                    mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                        flag<span class="token operator">=</span><span class="token number">1</span>                        <span class="token keyword">break</span>                    <span class="token keyword">elif</span> dp<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                        left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        right<span class="token operator">=</span>mid<span class="token number">-1</span>                <span class="token keyword">if</span> flag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> left<span class="token operator">==</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>dp<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="301题-删除无效的括号"><a href="#301题-删除无效的括号" class="headerlink" title="301题 删除无效的括号"></a>301题 <a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/" target="_blank" rel="noopener">删除无效的括号</a></h3><p><img src="301.png" alt="301题"></p><h4 id="思路：-39"><a href="#思路：-39" class="headerlink" title="思路："></a>思路：</h4><p>由于这道题需要的是删除的次数最小，所以BFS很明显比DFS划算，就像昨天做过的最小完全平方数问题一样， 从上至下逐层搜索很明显比每次搜索到底部划算。</p><p><img src="301-1.png" alt="BFS"></p><p>树的每层都是对上一层节点删掉某个括号后得到的新字符串，为了防止重复搜索，这里对重复的字符串进行去重。如果某一层中出现了某个合法的括号串，那么返回该层所有合法的括号串。否则，继续向下层遍历。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeInvalidParentheses</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            count<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>                <span class="token keyword">if</span> ch<span class="token operator">==</span><span class="token string">"("</span><span class="token punctuation">:</span>                    count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">elif</span> ch<span class="token operator">==</span><span class="token string">")"</span><span class="token punctuation">:</span>                    count<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                nowStr<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> isValid<span class="token punctuation">(</span>nowStr<span class="token punctuation">)</span><span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nowStr<span class="token punctuation">)</span>                <span class="token keyword">if</span> res<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nowStr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        newStr<span class="token operator">=</span>nowStr<span class="token punctuation">[</span><span class="token punctuation">:</span>j<span class="token punctuation">]</span><span class="token operator">+</span>nowStr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>                        <span class="token keyword">if</span> newStr <span class="token operator">not</span> <span class="token keyword">in</span> queue<span class="token punctuation">:</span>                            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>newStr<span class="token punctuation">)</span>            <span class="token keyword">if</span> res<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码在python3下运行超时，所以我们要进一步优化，使用集合来完成去重剪枝操作。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeInvalidParentheses</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        level<span class="token operator">=</span><span class="token punctuation">{</span>s<span class="token punctuation">}</span>        <span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            count<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>                <span class="token keyword">if</span> ch<span class="token operator">==</span><span class="token string">"("</span><span class="token punctuation">:</span>                    count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">elif</span> ch<span class="token operator">==</span><span class="token string">")"</span><span class="token punctuation">:</span>                    count<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            l<span class="token operator">=</span>len<span class="token punctuation">(</span>level<span class="token punctuation">)</span>            res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> st <span class="token keyword">in</span> level<span class="token punctuation">:</span>                <span class="token keyword">if</span> isValid<span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st<span class="token punctuation">)</span>            <span class="token keyword">if</span> res<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> res            nextlevel<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> st <span class="token keyword">in</span> level<span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> <span class="token string">"()"</span><span class="token punctuation">:</span>                        nextlevel<span class="token punctuation">.</span>add<span class="token punctuation">(</span>st<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token operator">+</span>st<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            level<span class="token operator">=</span>nextlevel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="309题-最佳买卖股票时机含冷冻期"><a href="#309题-最佳买卖股票时机含冷冻期" class="headerlink" title="309题 最佳买卖股票时机含冷冻期"></a>309题 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">最佳买卖股票时机含冷冻期</a></h3><p><img src="309.png" alt="309题"></p><h4 id="思路：-40"><a href="#思路：-40" class="headerlink" title="思路："></a>思路：</h4><p>动态规划求解股票问题。每天存在三种状态：</p><ul><li>持仓：hold，指继续持有股票</li><li>空仓：sold，指卖出所有股票</li><li>冷冻期：rest，指什么也不做</li></ul><p>转换关系（一共有3乘3共9种转换的可能，只有以下几种可能且值得被比较）：</p><ul><li>sold：<ul><li>前一天hold，当日卖出股票</li></ul></li><li>hold： 可由两个情况转换来<ul><li>前一天hold，当日rest</li><li>前一天rest，当日买入股票变为hold（前一天sold转移不到hold，因为卖出股票后必须经历一天冷冻期）</li></ul></li><li>rest：<ul><li>前一天sold，当日必须rest</li><li>前一天rest，当日继续rest（前一天hold，当日继续rest的情况与hold中的第一种情况重复了，社区）</li></ul></li></ul><p>所以:</p><ul><li>sold[i] = hold[i-1] + price[i];</li><li>hold[i] = max(hold[i-1], rest[i-1] - price[i])</li><li>rest[i] = max(rest[i-1], sold[i-1])</li></ul><p>特别地，由于只用到前面有限个状态，我们可以进行状态压缩。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> prices<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        sold<span class="token operator">=</span><span class="token number">0</span>        hold<span class="token operator">=</span><span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        rest<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> price <span class="token keyword">in</span> prices<span class="token punctuation">:</span>            sold<span class="token punctuation">,</span>hold<span class="token punctuation">,</span>rest<span class="token operator">=</span>hold<span class="token operator">+</span>price<span class="token punctuation">,</span>max<span class="token punctuation">(</span>hold<span class="token punctuation">,</span>rest<span class="token operator">-</span>price<span class="token punctuation">)</span><span class="token punctuation">,</span>max<span class="token punctuation">(</span>rest<span class="token punctuation">,</span>sold<span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>sold<span class="token punctuation">,</span>hold<span class="token punctuation">,</span>rest<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-13（1-medium-1-hard）"><a href="#2020-4-13（1-medium-1-hard）" class="headerlink" title="2020.4.13（1 medium 1 hard）"></a>2020.4.13（1 medium 1 hard）</h2><h3 id="312题-戳气球"><a href="#312题-戳气球" class="headerlink" title="312题 戳气球"></a>312题 <a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">戳气球</a></h3><p><img src="312.png" alt="312题"></p><h4 id="思路：-41"><a href="#思路：-41" class="headerlink" title="思路："></a>思路：</h4><p>首先，我想到的是简单的DFS，暴力求解，时间复杂度很高，为$O(N!)$：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token operator">+</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>maxres<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> count<span class="token operator">==</span>n<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>maxres<span class="token operator">=</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxres<span class="token punctuation">,</span>res<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                        tmp<span class="token operator">=</span>nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>i<span class="token punctuation">)</span>                        dfs<span class="token punctuation">(</span>res<span class="token operator">+</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>tmp<span class="token punctuation">)</span><span class="token punctuation">,</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                        nums<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>i<span class="token punctuation">,</span>tmp<span class="token punctuation">)</span>        dfs<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxres<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了优化递归回溯算法，我们通常需要用到的是动态规划或者备忘录。为了使用它们，首先我们需要定义状态矩阵和划分子问题。</p><p>这里，我们定义dp[i] [j]为从第i个气球到第j个气球这个区间所能获得的最大硬币数量。按照我们的惯性思维，我们会先选区间内的一个气球被戳破，然后去求解该气球左侧区间的最大硬币数和右侧区间的最大硬币数之和。但是这道题里这样做是不行的，因为当你戳破了一个气球后，左区间右侧和右区间左侧的气球发生了改变，导致结果发生了改变。所以这样划分状态间互相产生了依赖，也就是说，我们无法保证动态规划的无后效性。</p><p>所以，我们需要重新定义子问题。我们先选取区间内的一个气球k，现在不是让它最先被戳破了，而是让它在这个区间内最后被戳破。这样，保证了dp[i] [k-1] 和 dp[k+1] [j] 两侧的气球始终不变，保证了状态矩阵的稳定。从而状态转移方程为：</p><p>dp[i] [j]=dp [i] [k-1] + dp[k+1] [j] + nums[k]*nums[i-1]*nums[j+1]</p><p>因为k气球是i到j区间内最后被扎破的，所以i到k-1和k+1到j的气球已经全部被扎破了，此时，k气球左侧和右侧的气球便一定是i-1和j+1气球。</p><p>考虑到这道题自顶向下求解比较容易理解，我们采用带备忘录的递归来做。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token operator">+</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">></span>j <span class="token operator">or</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> j<span class="token operator">==</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>                <span class="token keyword">return</span> <span class="token number">0</span>            <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>            nowMax<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                nowMax<span class="token operator">=</span>max<span class="token punctuation">(</span>nowMax<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>recur<span class="token punctuation">(</span>i<span class="token punctuation">,</span>k<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span>recur<span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>nowMax            <span class="token keyword">return</span> nowMax        <span class="token keyword">return</span> recur<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了进一步优化我们还是使用动态规划，这里用的是区间DP，从小区间向大区间转移。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>                j <span class="token operator">=</span> i <span class="token operator">+</span> k                <span class="token keyword">for</span> t <span class="token keyword">in</span> range<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(这里的dp[i] [j] 表示的区间为（i，j），和我之前用的不太一样，不包括第i个和第j个气球。)</p><h3 id="第322题-零钱兑换"><a href="#第322题-零钱兑换" class="headerlink" title="第322题 零钱兑换"></a>第322题 <a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">零钱兑换</a></h3><p><img src="322.png" alt="322题"></p><h4 id="思路：-42"><a href="#思路：-42" class="headerlink" title="思路："></a>思路：</h4><p>与前两天刚做过的最小完全平方数组合那道题非常像，可以用DFS和BFS来遍历情况，由于我们需要取的是最小的组合，所以用BFS很明显更好。</p><p>我们使用辅助队列来进行BFS，再使用一个hashset来辅助我们去重（hashset查找元素时间复杂度为$O(1)$，优于直接列表查询）。</p><p>我们按层对队列中的金额使用硬币面值进行拆分，得到的新金额入队（重复的不入，如果在此之前已经入过队，说明必然更早完成凑成总金额，小于0的也不入）。如果成功拆分得到0，则将层数返回，即为最小硬币数目。如果无法拆分得到0，返回-1.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> coins<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> amount<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> amount<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        hashset<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span>amount<span class="token punctuation">]</span>        level<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            level<span class="token operator">+=</span><span class="token number">1</span>            l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                now<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> coin <span class="token keyword">in</span> coins<span class="token punctuation">:</span>                    tmp<span class="token operator">=</span>now<span class="token operator">-</span>coin                    <span class="token keyword">if</span> tmp<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> level                    <span class="token keyword">if</span> tmp <span class="token operator">not</span> <span class="token keyword">in</span> hashset <span class="token operator">and</span> tmp<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                        hashset<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-13（3-medium）"><a href="#2020-4-13（3-medium）" class="headerlink" title="2020.4.13（3 medium）"></a>2020.4.13（3 medium）</h2><h3 id="337题-打家劫舍-III"><a href="#337题-打家劫舍-III" class="headerlink" title="337题 打家劫舍 III"></a>337题 <a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">打家劫舍 III</a></h3><p><img src="337.png" alt="337题"></p><h4 id="思路：-43"><a href="#思路：-43" class="headerlink" title="思路："></a>思路：</h4><p>打家劫舍问题在不久前刚做过1和2，基本思路就是使用动态规划，类似于背包问题。当前状态有两种可能的隐状态转移而来，分别是偷当前这家和不偷当前这家。具体到本问题，假设偷当前这家人，那么只能从二叉树当前节点的孙子节点处继续偷；如果不偷当前这家人，那么可以从孩子节点开始偷。</p><p>特别地，由于二叉树的遍历采用递归比较容易理解，所以这题我们暂时不用DP来做，使用带备忘录的递归。备忘录采用哈希表实现，key为节点，value为以该节点为根节点的子树中所能偷到的最大金额。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                do_now<span class="token operator">=</span>root<span class="token punctuation">.</span>val                do_next<span class="token operator">=</span><span class="token number">0</span>                <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>                    do_next<span class="token operator">+=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>left<span class="token punctuation">]</span>                    do_now<span class="token operator">+=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">]</span>                    do_now<span class="token operator">+=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right<span class="token punctuation">]</span>                <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token operator">!=</span>None<span class="token punctuation">:</span>                    do_next<span class="token operator">+=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>right <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>right<span class="token punctuation">]</span>                    do_now<span class="token operator">+=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left<span class="token punctuation">]</span>                    do_now<span class="token operator">+=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right<span class="token punctuation">]</span>                dic<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>do_next<span class="token punctuation">,</span>do_now<span class="token punctuation">)</span>                <span class="token keyword">return</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">]</span>        <span class="token keyword">return</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="338题-比特位计数"><a href="#338题-比特位计数" class="headerlink" title="338题  比特位计数"></a>338题 <a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener"> 比特位计数</a></h3><p><img src="338.png" alt="338题"></p><h4 id="思路：-44"><a href="#思路：-44" class="headerlink" title="思路："></a>思路：</h4><p>动态规划思想，dp[i]为数字i的二进制中1的数目。分析比特位转移的规律，可以发现：</p><ul><li>如果i是偶数，那么dp[i]=dp[i//2]。左移，末尾补0，例如dp[4]=1（100）等于dp[2]=1（10）。</li><li>如果i是奇数，那么dp[i]=dp[i-1]+1。此时无需进位，直接加1即可。</li></ul><p>上述规律是因为，二进制数，偶数最低位都为0，奇数最低位都为1。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countBits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">return</span> dp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="附：二进制数有多少个1"><a href="#附：二进制数有多少个1" class="headerlink" title="附：二进制数有多少个1"></a>附：二进制数有多少个1</h4><p>一个数字n，求他的二进制形式有多少个1，可以使用位运算的方式来进行。通过与运算(n)&amp;(n-1)，可以做到每次去除n的最后一位1，更新n，重复计算直到n为0。计算的次数即为n中1的个数。</p><p>所以我们也可以根据上述性质进行动态规划：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countBits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token operator">&amp;</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="347题-前-K-个高频元素"><a href="#347题-前-K-个高频元素" class="headerlink" title="347题 前 K 个高频元素"></a>347题 <a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">前 K 个高频元素</a></h3><p><img src="347.png" alt="347题"></p><h4 id="思路：-45"><a href="#思路：-45" class="headerlink" title="思路："></a>思路：</h4><p>最简单的方法很明显是哈希表记录下每个元素出现的次数，然后对哈希表中的元素按照出现次数进行排序，选取前k个值。</p><p>只要我们用哈希表记录下了每个元素出现次数，那么选取出现次数的前k大值就转变为了我们常做的前k大（小）问题。</p><p>可以使用堆或者快速选择法进行解决。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: List[int]        """</span>         count <span class="token operator">=</span> collections<span class="token punctuation">.</span>Counter<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>           <span class="token keyword">return</span> heapq<span class="token punctuation">.</span>nlargest<span class="token punctuation">(</span>k<span class="token punctuation">,</span> count<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span>count<span class="token punctuation">.</span>get<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（python中重写堆的比较方法比较麻烦，就直接调用它的封装好的函数）</p><p>除此之外，我们还可以使用一个不基于比较的排序方法——计数排序，它是桶排序的一种，以空间来换时间。已知数值的区间，我们可以建立一个与区间大小相等的列表list。如果一个数出现的次数为n，那么就在list[n]处新添这个数的值。最后遍历计数区间，从大到小输出k个数即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        hashtable<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            hashtable<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">if</span> num <span class="token operator">not</span> <span class="token keyword">in</span> hashtable<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> hashtable<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        li<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> key <span class="token keyword">in</span> hashtable<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            li<span class="token punctuation">[</span>hashtable<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> l <span class="token keyword">in</span> li<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> num <span class="token keyword">in</span> l<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>                <span class="token keyword">if</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">==</span>k<span class="token punctuation">:</span>                    <span class="token keyword">return</span> res        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-14（3-medium）"><a href="#2020-4-14（3-medium）" class="headerlink" title="2020.4.14（3 medium）"></a>2020.4.14（3 medium）</h2><h3 id="394题-字符串解码"><a href="#394题-字符串解码" class="headerlink" title="394题 字符串解码"></a>394题 <a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">字符串解码</a></h3><p><img src="394.png" alt="394题"></p><h4 id="思路：-46"><a href="#思路：-46" class="headerlink" title="思路："></a>思路：</h4><p>类似的问题，包括带有括号的算式计算，这里的括号是可以嵌套的。针对这种嵌套的子问题，我们可以使用两种思路来解决，分别是：（1）辅助栈（2）递归。</p><p>首先我们来看辅助栈的解法。我们先设立两个关键的遍历mul和res，分别用于存储当前中括号内的结果和该结果的乘数。我们每次遍历原始的字符串s，然后分四种情况讨论：</p><ul><li>当s[i]为数字时，将其添加到当前乘数mul的末尾；</li><li>当s[i]为字母时，将其添加到当前结果res的末尾；</li><li>当s[i]为”[“时，说明需要进入下一个嵌套的中括号内部进行处理，将当前的res和mul入栈保存，并清空它们;</li><li>当s[i]为”]”时，说明当前中括号内部的字符串已经处理完毕，即为res。我们从栈顶取出一组res和mul，即为当前中括号外部的中括号内目前的res和mul，使用mul对当前res进行重复拼接，在拼接到外层res的末尾，继续向后计算。</li></ul><p>遍历完s后，res的结果即为最终结果。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">decodeString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        res<span class="token operator">=</span><span class="token string">""</span>        mul<span class="token operator">=</span><span class="token number">0</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        i<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> i <span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token string">'0'</span><span class="token operator">&lt;=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token string">'9'</span><span class="token punctuation">:</span>                mul<span class="token operator">=</span>mul<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>int<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">elif</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'['</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>mul<span class="token punctuation">,</span>res<span class="token punctuation">]</span><span class="token punctuation">)</span>                res<span class="token operator">=</span><span class="token string">""</span>                mul<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">elif</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">']'</span><span class="token punctuation">:</span>                tmp<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                res<span class="token operator">=</span>tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>res<span class="token operator">*</span>tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                mul<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res<span class="token operator">+=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            i<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>稍加修改，即可得到递归写法。此处为了防止重复遍历，当遍历到”]”时，返回当前的res和当前的索引。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">decodeString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">,</span> multi <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span>            <span class="token keyword">while</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token string">'0'</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token string">'9'</span><span class="token punctuation">:</span>                    multi <span class="token operator">=</span> multi <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> int<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">elif</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'['</span><span class="token punctuation">:</span>                    i<span class="token punctuation">,</span> tmp <span class="token operator">=</span> dfs<span class="token punctuation">(</span>s<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                    res <span class="token operator">+=</span> multi <span class="token operator">*</span> tmp                    multi <span class="token operator">=</span> <span class="token number">0</span>                <span class="token keyword">elif</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">']'</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> i<span class="token punctuation">,</span> res                <span class="token keyword">else</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">return</span> res        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="399-题-除法求值"><a href="#399-题-除法求值" class="headerlink" title="399 题 除法求值"></a>399 题 <a href="https://leetcode-cn.com/problems/evaluate-division/" target="_blank" rel="noopener">除法求值</a></h3><p><img src="399.png" alt="399题"></p><h4 id="思路：-47"><a href="#思路：-47" class="headerlink" title="思路："></a>思路：</h4><p>这道题，我们可以将其转化为图论问题。以等式中出现的每一个变量为顶点，有根据等式建立有向带权图，有向边的含义为起点是终点的几倍。例如“a/b=3”，那么我们就可以建立节点a和接点b，边a-&gt;b的权值为3，边b-&gt;a的权值为1/3。</p><p>所以，除法求值的问题转化为有向带权图的搜索问题，我们可以采用BFS和DFS两类做法来解决。例如：已知 a / b = 2.0, b / c = 3.0 ，我们可以根据上述等式建图，当求解a/c时，只需要将顶点a到顶点c路径上的权值累乘即可。</p><p>这里我们使用DFS来解决。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">calcEquation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> equations<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> values<span class="token punctuation">:</span> List<span class="token punctuation">[</span>float<span class="token punctuation">]</span><span class="token punctuation">,</span> queries<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>float<span class="token punctuation">]</span><span class="token punctuation">:</span>        graph<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#使用defaultdict较为方便，不需要判断key是否在dict的keys中，如果不在的话defaultdict会按照构造函数给定的参数自动为其赋值</span>        weights<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span><span class="token punctuation">)</span>        visited<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> idx<span class="token punctuation">,</span>eq <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>equations<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#enumerate方法可以额外返回迭代对象每个元素的数组下标</span>            graph<span class="token punctuation">[</span>eq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>eq<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            graph<span class="token punctuation">[</span>eq<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>eq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            weights<span class="token punctuation">[</span>tuple<span class="token punctuation">(</span>eq<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">=</span>values<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>            weights<span class="token punctuation">[</span>tuple<span class="token punctuation">(</span>eq<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span>values<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> start <span class="token operator">not</span> <span class="token keyword">in</span> graph<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">or</span> end <span class="token operator">not</span> <span class="token keyword">in</span> graph<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#出现了未在等式中出现的变量，直接返回0</span>                <span class="token keyword">return</span> <span class="token number">0</span>            <span class="token keyword">if</span> start<span class="token operator">==</span>end<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#被除数与除数相等</span>                <span class="token keyword">return</span> <span class="token number">1.0</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span> <span class="token keyword">in</span> weights<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#被除数与除数直接相连</span>                <span class="token keyword">return</span> weights<span class="token punctuation">[</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> nextV <span class="token keyword">in</span> graph<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#深度优先搜索</span>                <span class="token keyword">if</span> nextV <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#防止重复遍历，进入环路</span>                    visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>nextV<span class="token punctuation">)</span>                    res<span class="token operator">=</span>dfs<span class="token punctuation">(</span>nextV<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token operator">*</span>weights<span class="token punctuation">[</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>nextV<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#继续深搜</span>                    <span class="token keyword">if</span> res<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#一旦出现了合法结果，就返回</span>                        weights<span class="token punctuation">[</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">=</span>res<span class="token comment" spellcheck="true">#将被除数和除数修改为直接相连，方便以后的搜索</span>                        visited<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>nextV<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#注意：这里如果不加回溯的话，由于return直接跳出，将导致回溯错误</span>                        <span class="token keyword">return</span> res                    visited<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>nextV<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#回溯</span>            <span class="token keyword">return</span> <span class="token number">0</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> query <span class="token keyword">in</span> queries<span class="token punctuation">:</span>            r<span class="token operator">=</span>dfs<span class="token punctuation">(</span>query<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>query<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>r <span class="token keyword">if</span> r<span class="token operator">!=</span><span class="token number">0</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#为什么用0不直接用-1标识不合法结果：除法运算必然结果不为0，但结果可能为-1.</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这题还可以用带权的并查集来解决。</p><h3 id="406-题-根据身高重建队列"><a href="#406-题-根据身高重建队列" class="headerlink" title="406 题 根据身高重建队列"></a>406 题 <a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">根据身高重建队列</a></h3><p><img src="406.png" alt="406题"></p><h4 id="思路：-48"><a href="#思路：-48" class="headerlink" title="思路："></a>思路：</h4><p>假设所有人都一样高，即（h，k）中的k均相同，那么重建队列将会很简单，直接将对应的人放在k位置处即可。</p><p>现在，每个人的高度可能不同。但上述方案也是可行的，因为个子矮的人相对于个子高的人是不可见的，所以我们只需要从高到低将每个人插入到对应位置即可。如果产生了碰撞，那么个子高的人会向后移动，事实上这对个子高的人的有序性不会产生影响，因为无论你在他之前插入多少矮个子的人，对他都是不可见的。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reconstructQueue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> people<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        people<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> person <span class="token keyword">in</span> people<span class="token punctuation">:</span>            people<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>person<span class="token punctuation">)</span>            people<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>person<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>person<span class="token punctuation">)</span>        <span class="token keyword">return</span> people<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n^2)$，排序需要&amp;O(nlogn)&amp;，而移动需要插入和删除各一次。由于这里是列表，而不是链表，所以移动需要&amp;O(n^2)&amp;的时间复杂度。</li><li>空间复杂度：$O(1)$，原地修改。</li></ul><h2 id="2020-4-16-（2-medium-2-easy）"><a href="#2020-4-16-（2-medium-2-easy）" class="headerlink" title="2020.4.16 （2 medium 2 easy）"></a>2020.4.16 （2 medium 2 easy）</h2><h3 id="416题-分割等和子集"><a href="#416题-分割等和子集" class="headerlink" title="416题 分割等和子集"></a>416题 <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">分割等和子集</a></h3><p><img src="416.png" alt="416题"></p><h4 id="思路：-49"><a href="#思路：-49" class="headerlink" title="思路："></a>思路：</h4><h5 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h5><p>这道题是0-1背包问题的扩展，首先，我们来看0-1背包问题：</p><blockquote><p>假设有n个重量为W1，W2，W3….Wn，价值为V1，V2，V3…..Vn的物品，需要放入一个容量为C的背包，每个物品最多被选中1次（0-1背包），问能放入物品的最大价值是多少？</p></blockquote><p>这道题是一道非常经典的动态规划题，其状态矩阵可能需要思考一段时间后才能定义出来。在本题中，动态规划的状态矩阵为dp[i] [j]，其中，i表示前i个物品，j表示容量为j，该状态矩阵的含义是前i个物品放入容量为j的背包中所能放入的最大价值。</p><p>我们知道，每一个物品只有两种选择：放或者不放。所以，动态规划转移时，当前状态有两种选择：</p><ul><li>dp[i-1] [j] （不放第i个物品，此时，总价值不变，前i-1个物品所能放入的背包容量仍然是j）</li><li>dp[i-1] [j-Wi]+Vi （放置第j个物品，此时总价值加上第j个物品的价值，但前i-1个物品所能放入的背包容量被占用了Wi的大小）</li></ul><p>我们只需要在每次转移时，从上述两个可能的源状态中选取最大的那个即可。特别地，当j&lt;Wi时，只能选择第一种源状态。当i==0时，也需要特判，直接初始化即可，如果dp[0] [j]大于等于W0就等于V0，否则，等于0。</p><pre class="line-numbers language-python"><code class="language-python">w<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>v<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">,</span><span class="token number">63</span><span class="token punctuation">]</span>c<span class="token operator">=</span><span class="token number">10</span>dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#0号物品的特判</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">>=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token number">0</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> j<span class="token operator">>=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假如我们需要找到最大价值的子集具体是哪些物品，可以从动态规划矩阵的最后一个位置进行回溯，回溯的具体方法是：看dp[i] [j] 等于 dp[i-1] [j] 还是 dp[i-1] [j-Wi]+Vi ，即可知第i个物品有没有被放入最大价值子集。</p><pre class="line-numbers language-python"><code class="language-python">i<span class="token operator">=</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span>j<span class="token operator">=</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>        i<span class="token operator">-=</span><span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#因为转移时只有两种可能，所以直接用else即可</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#此时，i号物品被放入最大价值子集</span>        j<span class="token operator">-=</span><span class="token punctuation">[</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>        i<span class="token operator">-=</span><span class="token number">1</span>    <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#0号元素需要特判</span>    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们知道，动态规划时，如果每个状态只和之前有限个状态有关，那么可以采用滚动数组的方式进行空间优化，01背包问题也可以这么做。由于dp[i] [j]的转移只和  dp[i-1] [j] 和 dp[i-1] [j-Wi]+Vi 有关，所以我们只需要存储一维列表即可。我们使用一维列表存放原状态矩阵上一行的值，然后从后向前计算，更新这个一维列表，即计算当前行的值。之所以从后向前，是因为前面的值在后面的计算中可能需要用到，这样做可以防止它们在被使用之前被覆盖。</p><pre class="line-numbers language-python"><code class="language-python">w<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>v<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">,</span><span class="token number">63</span><span class="token punctuation">]</span>c<span class="token operator">=</span><span class="token number">10</span>dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#需要先初始化0号物品的情况，0号物品可以正向计算</span>    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">>=</span>w<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token number">0</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> j<span class="token operator">>=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="回到本题"><a href="#回到本题" class="headerlink" title="回到本题"></a>回到本题</h5><p>我们再次分析本题，发现本题可以抽象成为一个01背包问题：第i个物品的价值和重量等于nums[i]，背包最大容量等于sum（nums）//2，求解最大价值子集，使其等于背包容量（即总和的一半）。</p><p>特别地，sum（nums）如果为奇数，必然找不到两个等和子集。一旦找到等于sum（nums）//2的价值时，可以提前退出。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canPartition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>                c<span class="token operator">=</span>sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> c<span class="token operator">%</span><span class="token number">2</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            c<span class="token operator">//=</span><span class="token number">2</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#需要先初始化0号物品的情况，0号物品可以正向计算</span>            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">>=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> j<span class="token operator">>=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>c<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了进一步进行优化，减少计算量，我们进一步抽象原本的问题。现在，动态规划状态矩阵 dp[i] [j] 是一个布尔值，代表nums的前i个数字是否可以拥有一个子集，值与j相等。则动态规划转移方程为：</p><ul><li>dp[i] [j]=dp[i-1] [j] or dp[i-1] [j-nums[i]]</li></ul><p>也就是说，如果（1）选择第i个数字（2）不选第i个数字 两种情况中有一个可以在前i个数字中构造一个子集 等于j，那么dp[i] [j] 就可以为真。</p><p>特别地，dp[i] [0] 始终为真。因为所有数字都是正整数，所以它们的和必然大于0，我们这里让dp[i] [0] 为真是让其作为一个哨兵元素，试想当nums[i]==j时，我们可以通过这个哨兵元素，得到dp[i] [j]= dp[i-1] [0]=True，从而不需要做额外的判断。</p><p>如果某一行的dp[i] [c]为真，说明前i个数字中存在子集和为c，可以说存在等和子集。</p><p>如果需要求解等和子集的内容，我们可以通过回溯指针实现，和01背包类似。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canPartition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>                c<span class="token operator">=</span>sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> c<span class="token operator">%</span><span class="token number">2</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            c<span class="token operator">//=</span><span class="token number">2</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#需要先初始化0号物品的情况，0号物品可以正向计算</span>            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span> <span class="token keyword">if</span> j<span class="token operator">==</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token boolean">False</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> j<span class="token operator">>=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">or</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>                <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，直接进行布尔运算，比计算数值更快速。</p><h3 id="437题-路径总和-III"><a href="#437题-路径总和-III" class="headerlink" title="437题 路径总和 III"></a>437题 <a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">路径总和 III</a></h3><p><img src="437.png" alt="437题"></p><h4 id="思路：-50"><a href="#思路：-50" class="headerlink" title="思路："></a>思路：</h4><p>最简单的方法是使用双层循环，以树中的每一个节点为起点，进行DFS，寻找路径和等于目标值的路径。这一方法也叫做双重递归。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#第一层递归</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#以树中每个节点为起点进行递归</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>pathsum<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#第二层递归</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>                pathsum<span class="token operator">+=</span>root<span class="token punctuation">.</span>val<span class="token comment" spellcheck="true">#记录下截止到当前节点的路径和</span>                <span class="token keyword">if</span> pathsum<span class="token operator">==</span>sum<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当路径和为sum时，结果数目加1</span>                    self<span class="token punctuation">.</span>res<span class="token operator">+=</span><span class="token number">1</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>pathsum<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>pathsum<span class="token punctuation">)</span>                pathsum<span class="token operator">-=</span>root<span class="token punctuation">.</span>val<span class="token comment" spellcheck="true">#回溯</span>        preorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，这样效率很低，因为会产生许多子树的重复遍历。</p><p>较好的思路是使用前缀和的方法。我们知道，任何一个有序数组的某一个区间[i，j]的和都可以由 j 的前缀和减去 i 的前缀和得到（第 i 的数字的前缀和指的是第0个数字+第1个数字+…+第 i 个数字），同理，本题中各路径和也可以由前缀和得到。我们通过记忆化递归的方法，使用备忘录记录下每个节点的前缀和，可以防止重复的递归。</p><p>求解节点 i 到 节点 j 的路径和，只需使用 j 的前缀和减去 i 的前缀和即可，这里的前缀和指的是根节点到当前节点处的路径上节点值总和。</p><p>我们使用前序遍历搜索，记录下当前路径列表和当前前缀和。然后将当前节点的前缀和与路径列表上每一个节点的前缀和相减，查看是否有路径和等于目标值。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        ht<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        self<span class="token punctuation">.</span>res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>path<span class="token punctuation">,</span>pathsum<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>                pathsum<span class="token operator">+=</span>root<span class="token punctuation">.</span>val                <span class="token keyword">if</span> pathsum<span class="token operator">==</span>sum<span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>res<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> root <span class="token operator">not</span> <span class="token keyword">in</span> ht<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    ht<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token operator">=</span>pathsum<span class="token comment" spellcheck="true">#前缀和备忘录</span>                <span class="token keyword">for</span> node <span class="token keyword">in</span> path<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历路径列表，采用前缀和相减的方式计算路径和</span>                    <span class="token keyword">if</span> pathsum<span class="token operator">-</span>ht<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token operator">==</span>sum<span class="token punctuation">:</span>                        self<span class="token punctuation">.</span>res<span class="token operator">+=</span><span class="token number">1</span>                path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#理论上，这个路径添加应该放在开头，但是因为自身路径和相减没有意义，所以放在这里更好</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>path<span class="token punctuation">,</span>pathsum<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>path<span class="token punctuation">,</span>pathsum<span class="token punctuation">)</span>                path<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#回溯</span>                pathsum<span class="token operator">-=</span>root<span class="token punctuation">.</span>val        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="438题-找到字符串中所有字母异位词"><a href="#438题-找到字符串中所有字母异位词" class="headerlink" title="438题 找到字符串中所有字母异位词"></a>438题 <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">找到字符串中所有字母异位词</a></h3><p><img src="438.png" alt="438题"></p><h4 id="思路：-51"><a href="#思路：-51" class="headerlink" title="思路："></a>思路：</h4><p>和第76题有些许相似，都是使用滑动窗口法。</p><p>使用两个指针start，end在待匹配串s上滑动区间[start,end)。其中，end=start+len（p）。</p><p>使用哈希表hashtable存放模式串p中的所有字母及其出现的次数。使用哈希表now存放当前滑动区间内的所有字母及其出现次数。</p><p>在s串上进行滑动匹配：</p><ul><li>如果now为空，说明滑动区间在起始位置或者刚刚被整体挪动过多个位置，此时需要重新统计当前滑动区间内的字母和出现次数。这里的统计采用倒序的方式，当倒序遍历到一个不在模式串p中的字母时，整体挪动滑动区间至该字母后面（所有包含此字母的区间都不必访问了），并清空now。否则将其使用哈希表now对当前字母进行统计。</li><li>如果now不为空，说明是由前一个滑动区间向后滑动一个位置得到，此时不需要整体更新，只需要将新遍历到的字母（end-1位置）加入到哈希表now即可。如果新遍历到的字母不在模式串p中，那么依然移动区间至新字母后。</li><li>如果当前区间内未出现不在模式串p中的字母，那么就尝试将当前区间统计哈希表now与模式串统计哈希表hashtable进行比较，如果相等，则将start加入到结果数组中。此时，无论是否相等，我们都需要将当前区间向前滑动一个位置。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> copy<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findAnagrams</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> p<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        l<span class="token operator">=</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span>        hashtable<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> p<span class="token punctuation">:</span>            <span class="token keyword">if</span> ch <span class="token operator">not</span> <span class="token keyword">in</span> hashtable<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                hashtable<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                hashtable<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>        start<span class="token operator">=</span><span class="token number">0</span>        end<span class="token operator">=</span>start<span class="token operator">+</span>l        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        now<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">while</span> end<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            flag<span class="token operator">=</span><span class="token boolean">False</span>            <span class="token keyword">if</span> now<span class="token operator">==</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>end<span class="token number">-1</span><span class="token punctuation">,</span>start<span class="token number">-1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> hashtable<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        flag<span class="token operator">=</span><span class="token boolean">True</span>                        start<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span>                        end<span class="token operator">=</span>start<span class="token operator">+</span>l                        now<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>                        <span class="token keyword">break</span>                    <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> now<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        now<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        now<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>end<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token keyword">in</span> hashtable<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> s<span class="token punctuation">[</span>end<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token keyword">in</span> now<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        now<span class="token punctuation">[</span>s<span class="token punctuation">[</span>end<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        now<span class="token punctuation">[</span>s<span class="token punctuation">[</span>end<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    start<span class="token operator">=</span>end                    end<span class="token operator">=</span>start<span class="token operator">+</span>l                    now<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>                    flag<span class="token operator">=</span><span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token operator">not</span> flag<span class="token punctuation">:</span>                <span class="token keyword">if</span> now<span class="token operator">==</span>hashtable<span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>start<span class="token punctuation">)</span>                now<span class="token punctuation">[</span>s<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>                start<span class="token operator">+=</span><span class="token number">1</span>                end<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="448题-找到所有数组中消失的数字"><a href="#448题-找到所有数组中消失的数字" class="headerlink" title="448题  找到所有数组中消失的数字"></a>448题 <a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener"> 找到所有数组中消失的数字</a></h3><p><img src="448.png" alt="448题"></p><h4 id="思路：-52"><a href="#思路：-52" class="headerlink" title="思路："></a>思路：</h4><p>和之前做过的第41题类似，采用原地哈希映射的方式，将数字i映射到数组下标为i-1的位置上。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findDisappearedNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>pos1<span class="token punctuation">,</span>pos2<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#一定要这样交换！python的机制问题，否则会出错。</span>            nums<span class="token punctuation">[</span>pos1<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>pos2<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>pos2<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>pos1<span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                swap<span class="token punctuation">(</span>i<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">!=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-17-（2-medium，3-easy）"><a href="#2020-4-17-（2-medium，3-easy）" class="headerlink" title="2020.4.17 （2 medium，3 easy）"></a>2020.4.17 （2 medium，3 easy）</h2><h3 id="461题-汉明距离"><a href="#461题-汉明距离" class="headerlink" title="461题 汉明距离"></a>461题 汉明距离</h3><p><img src="461.png" alt="461题"></p><h4 id="思路：-53"><a href="#思路：-53" class="headerlink" title="思路："></a>思路：</h4><p>比较简单，可以用按位异或+统计1的个数的方法来进行汉明距离的统计。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">,</span> y<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        x<span class="token operator">=</span>x<span class="token operator">^</span>y        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> x<span class="token punctuation">:</span>            x<span class="token operator">&amp;</span><span class="token operator">=</span>x<span class="token number">-1</span>            res<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="494题-目标和"><a href="#494题-目标和" class="headerlink" title="494题 目标和"></a>494题 <a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">目标和</a></h3><p><img src="494.png" alt="494题"></p><h4 id="思路：-54"><a href="#思路：-54" class="headerlink" title="思路："></a>思路：</h4><p>这道题，我的思路是使用BFS 的方法，进行所有计算路径的遍历，同时在遍历过程中，合并和重复的路径，防止重复遍历。</p><p>有点类似于之前的完全平方和问题和找零钱问题。不过这道题与找零钱的不同之处在于：找零钱只需要知道是否有组合，本题还需要知道组合的数目。所以本题要用到哈希表存放当前层的和以及每个和的组合数目。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> S<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        ht<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#初始情况下，哈希表中只有一个0（为什么不用队列，因为哈希表按key存取，合并相同和的组合更方便）</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历数组中所有数</span>            tmp<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>            <span class="token keyword">for</span> key <span class="token keyword">in</span> list<span class="token punctuation">(</span>ht<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历1...num所有的和</span>                newnums<span class="token operator">=</span><span class="token punctuation">[</span>key<span class="token operator">+</span>num<span class="token punctuation">,</span>key<span class="token operator">-</span>num<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#每个和与当前数的+和-进行相加</span>                <span class="token keyword">for</span> newnum <span class="token keyword">in</span> newnums<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#结果存入临时哈希表</span>                    <span class="token keyword">if</span> newnum <span class="token operator">not</span> <span class="token keyword">in</span> tmp<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        tmp<span class="token punctuation">[</span>newnum<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">*</span>ht<span class="token punctuation">[</span>key<span class="token punctuation">]</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        tmp<span class="token punctuation">[</span>newnum<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span><span class="token operator">*</span>ht<span class="token punctuation">[</span>key<span class="token punctuation">]</span>            ht<span class="token operator">=</span>tmp<span class="token comment" spellcheck="true">#更新本层BFS后的哈希表</span>        <span class="token keyword">return</span> ht<span class="token punctuation">[</span>S<span class="token punctuation">]</span> <span class="token keyword">if</span> S <span class="token keyword">in</span> ht<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token comment" spellcheck="true">#返回最后一层结果中，key（即和）为S的组合数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，我们还可以使用01背包的动态规划解法。假设动态规划状态矩阵dp[i] [j]为前 i 个数字和为 j 一共有多少种情况，则动态规划转移方程为：</p><ul><li>dp[i] [j] = dp[j-nums[i]] + dp[j+nums[i]]</li></ul><p>也就是说，上述动态规划转移方程考虑了是否选取当前数字的两种情况，进行状态转移。</p><p>这里的 j 的范围是数组nums所有数字之和可能的值域，即[-sum，sum]，特别的，由于每层状态的转移只依赖上一层状态，所以我们可以进行状态压缩。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> S<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        summa<span class="token operator">=</span>sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> summa<span class="token operator">&lt;</span>abs<span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果数组元素之和小于S，必不可能计算出S</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token operator">-</span>summa<span class="token punctuation">,</span>summa<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#从[-sum,sum]共2*sum+1个元素，dp[sum]即为和为0的情况</span>        dp<span class="token punctuation">[</span>summa<span class="token operator">+</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        dp<span class="token punctuation">[</span>summa<span class="token operator">-</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            next<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token operator">-</span>summa<span class="token punctuation">,</span>summa<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#需要注意！这里的本层元素依赖的上一层元素，其上一层的j可能大于也可能小于当前层的j，所以无法只用一个数组通过倒序（like 01背包模板）遍历的方式更新，要使用辅助数组，和上面BFS解法的辅助哈希表类似。</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                add<span class="token operator">=</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token comment" spellcheck="true">#考虑越界的情况</span>                minus<span class="token operator">=</span>dp<span class="token punctuation">[</span>j<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>j<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">0</span>                next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>add<span class="token operator">+</span>minus            dp<span class="token operator">=</span>next        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>summa<span class="token operator">+</span>S<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="538题-二叉搜索树转换为累加树"><a href="#538题-二叉搜索树转换为累加树" class="headerlink" title="538题 二叉搜索树转换为累加树"></a>538题 <a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">二叉搜索树转换为累加树</a></h3><p><img src="538.png" alt="538题"></p><h4 id="思路：-55"><a href="#思路：-55" class="headerlink" title="思路："></a>思路：</h4><p>我们知道，二叉搜索树的中序遍历（左、中、右）得到的节点，其val是依次递增的，同理，反向中序遍历（右、中、左）得到的节点，其val依次递减。</p><p>这样我们将反向中序遍历所得到的节点的val依次累加并更新当前节点的val，即可使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 </p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">convertBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>s<span class="token operator">=</span><span class="token number">0</span><span class="token comment" spellcheck="true">#用于记录遍历到当前节点前的所有节点值得累加和</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>                recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                root<span class="token punctuation">.</span>val<span class="token operator">+=</span>self<span class="token punctuation">.</span>s                self<span class="token punctuation">.</span>s<span class="token operator">=</span>root<span class="token punctuation">.</span>val                recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="543题-二叉树的直径"><a href="#543题-二叉树的直径" class="headerlink" title="543题 二叉树的直径"></a>543题 <a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">二叉树的直径</a></h3><p><img src="543.png" alt="543题"></p><h4 id="思路：-56"><a href="#思路：-56" class="headerlink" title="思路："></a>思路：</h4><p>可以后序遍历来做。</p><p>以当前节点为根节点的子树，其最大直径上的节点数为：递归搜索左子树返回的值加上递归搜索右子树返回的值再加1。递归函数的返回值的含义是：以当前节点为一个端点的路径的最大节点数。它与最大直径的区别在于：最大直径路径只需要经过root即可，返回的路径需要以root为端点。具体为什么这么做是因为如果直接返回当前节点的最大直径路径，无法与上一层节点组成有效路径，会出现环路。</p><p>我们每次递归时，尝试用当前子树的最大直径路径上的节点数更新全局变量Self.max_d。最后将他的值减去1，即为最大直径路径上的边数。此外，还需要对空树进行特判。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">diameterOfBinaryTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>max_d<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                left<span class="token operator">=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                right<span class="token operator">=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>max_d<span class="token operator">=</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>max_d<span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">+</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>max<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>        recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>max_d<span class="token number">-1</span> <span class="token keyword">if</span> root<span class="token operator">!=</span>None <span class="token keyword">else</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-18-（2-medium，2-easy）"><a href="#2020-4-18-（2-medium，2-easy）" class="headerlink" title="2020.4.18 （2 medium，2 easy）"></a>2020.4.18 （2 medium，2 easy）</h2><h3 id="560题-和为K的子数组"><a href="#560题-和为K的子数组" class="headerlink" title="560题 和为K的子数组"></a>560题 <a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">和为K的子数组</a></h3><p><img src="560.png" alt="560题"></p><h4 id="思路：-57"><a href="#思路：-57" class="headerlink" title="思路："></a>思路：</h4><p>一开始想用区间DP，发现超时了。</p><p>联想到我们前几天做过的寻找二叉树中路径和为k的路径这一问题，我们不难想到本题也可以用前缀和来解决。子数组nums[i：j]可以通过前缀和prefixsum[j]-prefixsum[i]求解。比较它的值是否为k即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">subarraySum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        prefixsum<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        prefixsum<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>prefixsum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            prefixsum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>prefixsum<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>prefixsum<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>prefixsum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> prefixsum<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span>prefixsum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>k<span class="token punctuation">:</span>                    res<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n^2)$。</li><li>空间复杂度：$O(n)$。</li></ul><p>由于我们比较的对象为：prefixsum[j]-prefixsum[i]==k，可以转化为prefixsum[j]-k=prefixsum[i]，所以我们只需要在每次统计前缀和prefixsum[j]时，顺便看是否已经有统计到的前缀和prefixsum[i]等于此时的前缀和prefixsum[j]减去k即可。特别地，对于prefixsum[j]-k=prefixsum[i]，j 之前可能有多个 i 符合该条件。我们可以使用哈希表来进行优化。</p><p>哈希表ht的key为前缀和的值，value为目前有几个前缀和等于key。我们只需要为结果加上ht[prefixsum[j]-k]即可。每次遍历数组需要对哈希表进行更新。</p><pre class="line-numbers language-PYTHON"><code class="language-PYTHON">class Solution:    def subarraySum(self, nums: List[int], k: int) -> int:        prefixsum=0        ht={0:1}        res=0        for num in nums:            prefixsum+=num            if prefixsum-k in ht.keys():                res+=ht[prefixsum-k]            if prefixsum in ht.keys():                ht[prefixsum]+=1            else:                ht[prefixsum]=1        return res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，可以将时间复杂度降为$O(n)$。</p><h3 id="581题-最短无序连续子数组"><a href="#581题-最短无序连续子数组" class="headerlink" title="581题 最短无序连续子数组"></a>581题 <a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">最短无序连续子数组</a></h3><p><img src="581.png" alt="581题"></p><h4 id="思路：-58"><a href="#思路：-58" class="headerlink" title="思路："></a>思路：</h4><p>我们知道，一个单调递增的序列，其每个数字都大于之前所有数字，也就是大于它们的最大值。一个单调递减的序列，其每个数字小于之前所有数字。</p><p>本题中，我们只需要正向遍历数组，找到不符合单调递增性质的最后一个数字，作为最短无序连续数组的右边界。接着反向遍历数组，找到不符合单调递减性质的最后一个数字，作为左边界。即可找到结果。</p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findUnsortedSubarray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        max_now<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        right<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>max_now<span class="token punctuation">:</span>                right<span class="token operator">=</span>i            max_now<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>max_now<span class="token punctuation">)</span>        min_now<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        left<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>min_now<span class="token punctuation">:</span>                left<span class="token operator">=</span>i            min_now<span class="token operator">=</span>min<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>min_now<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span> <span class="token keyword">if</span> right<span class="token operator">-</span>left<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token keyword">else</span> right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本质上是在维护一个单调栈。</p><h3 id="617题-合并二叉树"><a href="#617题-合并二叉树" class="headerlink" title="617题 合并二叉树"></a>617题 <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">合并二叉树</a></h3><p><img src="617.png" alt="617题"></p><h4 id="思路：-59"><a href="#思路：-59" class="headerlink" title="思路："></a>思路：</h4><p>我们采用递归的方式对二叉树进行合并，将t2子树合并到t1子树上去。如果t1子树为空，那么直接返回t2子树。如果t2子树为空，那么直接返回t1子树。否则，将t2节点的值加到t1上，然后分别合并二者的左子树和右子树。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> t1<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> t2<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> t1<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> t2        <span class="token keyword">elif</span> t2<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> t1        <span class="token keyword">else</span><span class="token punctuation">:</span>            t1<span class="token punctuation">.</span>val<span class="token operator">+=</span>t2<span class="token punctuation">.</span>val            t1<span class="token punctuation">.</span>left<span class="token operator">=</span>self<span class="token punctuation">.</span>mergeTrees<span class="token punctuation">(</span>t1<span class="token punctuation">.</span>left<span class="token punctuation">,</span>t2<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            t1<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>mergeTrees<span class="token punctuation">(</span>t1<span class="token punctuation">.</span>right<span class="token punctuation">,</span>t2<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">return</span> t1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="621题-任务调度器"><a href="#621题-任务调度器" class="headerlink" title="621题 任务调度器"></a>621题 <a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">任务调度器</a></h3><p><img src="621.png" alt="621题"></p><h4 id="思路：-60"><a href="#思路：-60" class="headerlink" title="思路："></a>思路：</h4><p>可以采用找规律的数学解法。</p><p>因为相同任务必须要有时间片为 n 的间隔，所以我们先把出现次数最多的任务 A 安排上（当然你也可以选择任务 B）。例子中 n = 2，那么任意两个任务 A 之间都必须间隔 2 个单位的时间：</p><blockquote><p>A -&gt; (单位时间) -&gt; (单位时间) -&gt; A -&gt; (单位时间) -&gt; (单位时间) -&gt; A</p></blockquote><p>中间间隔的单位时间可以用来安排别的任务，也可以处于“待命”状态。当然，为了使总任务时间最短，我们要尽可能地把单位时间分配给其他任务。现在把任务 B 安排上：</p><blockquote><p>A -&gt; B -&gt; (单位时间) -&gt; A -&gt; B -&gt; (单位时间) -&gt; A -&gt; B</p></blockquote><p>很容易观察到，前面两个 A 任务一定会固定跟着 2 个单位时间的间隔。最后一个 A 之后是否还有任务跟随取决于是否存在与任务 A 出现次数相同的任务。</p><p>所以整体的解题步骤如下：</p><ol><li>计算每个任务出现的次数</li><li>找出出现次数最多的任务，假设出现次数为 x</li><li>计算至少需要的时间 (x - 1) * (n + 1)，记为 min_time</li><li>计算出现次数为 x 的任务总数 count，计算最终结果为 min_time + count。特别注意，这里的最终结果必须大于任务数目，因为最小时间是任务数目（无拥塞）。</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">leastInterval</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tasks<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        task_table<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> len<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span>        <span class="token keyword">for</span> task <span class="token keyword">in</span> tasks<span class="token punctuation">:</span>            <span class="token keyword">if</span> task <span class="token keyword">in</span> task_table<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                task_table<span class="token punctuation">[</span>task<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                task_table<span class="token punctuation">[</span>task<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        max_times<span class="token operator">=</span>max<span class="token punctuation">(</span>list<span class="token punctuation">(</span>task_table<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        res<span class="token operator">=</span><span class="token punctuation">(</span>max_times<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        res<span class="token operator">+=</span>list<span class="token punctuation">(</span>task_table<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>count<span class="token punctuation">(</span>max_times<span class="token punctuation">)</span>        <span class="token keyword">return</span> res <span class="token keyword">if</span> res<span class="token operator">>=</span>len<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span> <span class="token keyword">else</span> len<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-19-（2-medium）"><a href="#2020-4-19-（2-medium）" class="headerlink" title="2020.4.19 （2 medium）"></a>2020.4.19 （2 medium）</h2><h3 id="647题-回文子串"><a href="#647题-回文子串" class="headerlink" title="647题 回文子串"></a>647题 <a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">回文子串</a></h3><p><img src="647.png" alt="647题"></p><h4 id="思路：-61"><a href="#思路：-61" class="headerlink" title="思路："></a>思路：</h4><p>中心扩展法，类似于求解最大回文子串问题，只需要稍微修改一下，每一次扩展时将计数变量加1即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countSubstrings</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">centerexpand</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>i <span class="token operator">and</span> j<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token operator">+=</span><span class="token number">1</span>                i<span class="token operator">-=</span><span class="token number">1</span>                j<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">return</span> res        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res1<span class="token operator">=</span>centerexpand<span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span>            res2<span class="token operator">=</span>centerexpand<span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> res1<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                res<span class="token operator">+=</span>res1            <span class="token keyword">if</span> res2<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                res<span class="token operator">+=</span>res2        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><h3 id="739题-每日温度"><a href="#739题-每日温度" class="headerlink" title="739题 每日温度"></a>739题 <a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">每日温度</a></h3><p><img src="739.png" alt="739题"></p><h4 id="思路：-62"><a href="#思路：-62" class="headerlink" title="思路："></a>思路：</h4><p>使用单调栈来做。这题使用一个单调递减栈，栈内存放天数和该天的温度，温度从栈底到栈顶依次单调递减。遍历数组T。如果第i天的温度小于等于栈顶元素的温度，那么直接将（i，T（i））入栈。如果大于栈顶元素温度，说明此时必然是第一次高过此温度，则可以将栈顶元素的天数j的结果记录为：res[j]=i-j。</p><p>也就是说，我们的单调递减栈存放的是尚未有温度升高超过的各天和它们的温度。每次向后遍历一天，查看当天气温是否比栈顶最低气温高，是则将二者天数差值保存进结果数组，并且将栈顶元素出栈，比较当天气温与栈中第二低的气温；否则入栈保存，继续向后遍历。</p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(n)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> T<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> stack<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">or</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> stack<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    j<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                    res<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">-</span>j                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-20-（3-easy，1-medium）"><a href="#2020-4-20-（3-easy，1-medium）" class="headerlink" title="2020.4.20 （3 easy，1 medium）"></a>2020.4.20 （3 easy，1 medium）</h2><h3 id="88题-合并两个有序数组"><a href="#88题-合并两个有序数组" class="headerlink" title="88题 合并两个有序数组"></a>88题 <a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">合并两个有序数组</a></h3><p><img src="88.png" alt="88题"></p><h4 id="思路：-63"><a href="#思路：-63" class="headerlink" title="思路："></a>思路：</h4><p>这道题是经典的归并排序问题，可以使用双指针法来做。</p><p>唯一需要注意的是，本题将第一个数组原地修改为结果数组，如果从前向后归并排序，那么可能会将第一个数组中尚未被遍历到的数字覆盖掉。为了解决这一问题，我们可以从后向前归并排序。指针p指向数组nums1最后一个非零元素，q指向nums2最后一个非零元素，r指向nums1的尾部。具体流程如代码所示：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify nums1 in-place instead.        """</span>        p<span class="token operator">=</span>m<span class="token number">-1</span>        q<span class="token operator">=</span>n<span class="token number">-1</span>        r<span class="token operator">=</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> q<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#将p和q中较大的数字放在r上</span>                nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span>                q<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span>                p<span class="token operator">-=</span><span class="token number">1</span>            r<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">while</span> q<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#因为如果是nums1的前面有数字没有被遍历完，由于是原地修改nums1，所以此时无需移动，也就没有必要判断nums1未遍历完的情况，只需要判断nums2未遍历完的情况。</span>            nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span>            r<span class="token operator">-=</span><span class="token number">1</span>            q<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> nums1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="122题-买卖股票的最佳时机-II"><a href="#122题-买卖股票的最佳时机-II" class="headerlink" title="122题 买卖股票的最佳时机 II"></a>122题<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener"> 买卖股票的最佳时机 II</a></h3><p><img src="122.png" alt="122题"></p><h4 id="思路：-64"><a href="#思路：-64" class="headerlink" title="思路："></a>思路：</h4><p>所有的买卖股票问题本质上都可以使用动态规划来解决。状态矩阵dp[i] [j]为第 i 天的第 j 个选择总收益。本题中，存在两种选择：（特别地，在有冷冻期的那道题，我们需要特别讨论冷冻状态）</p><ul><li>当日持仓（持有股票）：有前一日持仓，当日继续持仓和前一日空仓，当日买入股票持仓两种情况。由于需要得到的是最大利润，所以我们选取两种情况各自所能获得的最大利润作为当日状态。</li><li>当日空仓（不持有股票）：有前一日空仓，当日继续空仓和前一日持仓，当日卖出股票空仓两种情况。由于需要得到的是最大利润，所以我们选取两种情况各自所能获得的最大利润作为当日状态。</li></ul><p>得到了DP矩阵和转移方程，我们就可以求解。通过动态规划，我们可以获得最后一天持仓和空仓的最大收益。由于最后一天持仓无法卖出，必然小于空仓的收益，所以我们直接返回最后一天空仓的收益即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(n)$。</li></ul><p>特别地，本题还可以用贪心算法来做。假设我们是一个特别保守的股票交易员，一旦当前买入的股票第二天能够赚钱，就迅速买入并在第二天卖出。如下图所示，也就是统计所有上升的小段。</p><p><img src="122-1.png" alt="122题"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>prices<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                res<span class="token operator">+=</span>prices<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><h3 id="217题-存在重复元素"><a href="#217题-存在重复元素" class="headerlink" title="217题 存在重复元素"></a>217题 <a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener">存在重复元素</a></h3><p><img src="217.png" alt="217题"></p><h4 id="思路：-65"><a href="#思路：-65" class="headerlink" title="思路："></a>思路：</h4><p>可以使用哈希集合来存放已出现过的数字。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">containsDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        hs<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> num <span class="token operator">not</span> <span class="token keyword">in</span> hs<span class="token punctuation">:</span>                hs<span class="token punctuation">.</span>add<span class="token punctuation">(</span>num<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="230题-二叉搜索树中第K小的元素"><a href="#230题-二叉搜索树中第K小的元素" class="headerlink" title="230题 二叉搜索树中第K小的元素"></a>230题 <a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">二叉搜索树中第K小的元素</a></h3><p><img src="230.png" alt="230题"></p><h4 id="思路：-66"><a href="#思路：-66" class="headerlink" title="思路："></a>思路：</h4><p>通过中序遍历二叉搜素树，可以获得它的升序序列。使用类变量count存放当前遍历的次数，如果达到k，那么返回当前节点的元素值（剪枝）。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">kthSmallest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res<span class="token operator">=</span>None        self<span class="token punctuation">.</span>count<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>res<span class="token operator">!=</span>None<span class="token punctuation">:</span>                    <span class="token keyword">return</span>                inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>count<span class="token operator">==</span>k<span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>res<span class="token operator">=</span>root<span class="token punctuation">.</span>val                <span class="token keyword">if</span> self<span class="token punctuation">.</span>res<span class="token operator">!=</span>None<span class="token punctuation">:</span>                    <span class="token keyword">return</span>                inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-21-（4-easy）"><a href="#2020-4-21-（4-easy）" class="headerlink" title="2020.4.21 （4 easy）"></a>2020.4.21 （4 easy）</h2><h3 id="231题-2的幂"><a href="#231题-2的幂" class="headerlink" title="231题 2的幂"></a>231题 <a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">2的幂</a></h3><p><img src="231.png" alt="231题"></p><h4 id="思路：-67"><a href="#思路：-67" class="headerlink" title="思路："></a>思路：</h4><p>简单题，当n小于1时，不可能是2的幂，当n大于等于1时，如果能被2持续整除而没有余数，直到等于1，说明它是2的幂。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> n<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">while</span> n<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            n<span class="token operator">=</span>n<span class="token operator">//</span><span class="token number">2</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(logN)$</li></ul><p>但同时，我们可以使用位运算的极简解法。我们知道：n&amp;（n-1）是去除n的二进制中最后一位1（之前的位运算题目有涉及）。同时，假设一个数是2的幂，那么它的二进制数必然只有最高位为1。所以，n&amp;（n-1）必然等于0。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">return</span> n<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> n<span class="token operator">&amp;</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(1)$</li></ul><h3 id="235题-二叉搜索树的最近公共祖先"><a href="#235题-二叉搜索树的最近公共祖先" class="headerlink" title="235题 二叉搜索树的最近公共祖先"></a>235题 <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a></h3><p><img src="235.png" alt="235题"></p><h4 id="思路：-68"><a href="#思路：-68" class="headerlink" title="思路："></a>思路：</h4><p>简单题，剑指Offer原题。由于本题是一个二叉搜索树，分类讨论的情况为：</p><ul><li><p>如果root的值位于p、q值之间，说明root必然是它们的最近公共祖先。</p></li><li><p>如果root的值均大于p、q，说明p、q必在root的左子树，递归查找。</p></li><li><p>如果root的值均小于p、q，说明p、q必在root的右子树，递归查找。</p></li><li><p>如果root的值等于p的值或者q的值，说明root必然是它们的最近公共祖先 （<strong>一个节点也可以是它自己的祖先</strong>） 。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>p<span class="token punctuation">.</span>val <span class="token operator">or</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>q<span class="token punctuation">.</span>val <span class="token punctuation">:</span>            <span class="token keyword">return</span> root        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">></span>p<span class="token punctuation">.</span>val <span class="token operator">and</span> root<span class="token punctuation">.</span>val<span class="token operator">></span>q<span class="token punctuation">.</span>val <span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>p<span class="token punctuation">.</span>val <span class="token operator">and</span> root<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>q<span class="token punctuation">.</span>val <span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>        <span class="token keyword">if</span> q<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>p<span class="token punctuation">.</span>val <span class="token operator">or</span> p<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="237题-删除链表中的节点"><a href="#237题-删除链表中的节点" class="headerlink" title="237题 删除链表中的节点"></a>237题 <a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">删除链表中的节点</a></h3><p><img src="237.png" alt="237题"></p><h4 id="思路：-69"><a href="#思路：-69" class="headerlink" title="思路："></a>思路：</h4><p>这道题并没有给出链表的头节点，我一开始以为题目出错了。因为常规的删除节点方法都需要用到被删除节点的前一个节点。</p><p>但其实删除链表的节点也可以不使用前一个节点，而是将当前节点值与后一个节点交换。这样，删除当前节点就转变为删除当前节点的下一个节点，也就可以使用常规方法修改前一个节点的next指针删除节点了。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type node: ListNode        :rtype: void Do not return anything, modify node in-place instead.        """</span>        node<span class="token punctuation">.</span>val<span class="token operator">=</span>node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val        node<span class="token punctuation">.</span>next<span class="token operator">=</span>node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="292题-Nim-游戏"><a href="#292题-Nim-游戏" class="headerlink" title="292题 Nim 游戏"></a>292题 <a href="https://leetcode-cn.com/problems/nim-game/" target="_blank" rel="noopener">Nim 游戏</a></h3><p><img src="292.png" alt="292题"></p><h4 id="思路：-70"><a href="#思路：-70" class="headerlink" title="思路："></a>思路：</h4><p>一开始，我想到了动态规划解法。dp[i]为石头数为 i 时，玩家能否获胜。转移方程为：</p><ul><li>dp[i] = True，if i &lt;=3</li><li>dp[i] = not(dp[i-1] and dp[i-2] and dp[i-3]) ,if i&gt;3</li></ul><p>当 i 大于3时，我们需要看当前的玩家拿走1、2或3个石头后，对方剩余的石头数能否获胜。如果三种情况下对方均能获胜，则dp [i]为False，否则为 True。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canWinNim</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">not</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">and</span> dp<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span> <span class="token operator">and</span> dp<span class="token punctuation">[</span>i<span class="token number">-3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，这在python下会超时。</p><p>我们继续分析：由状态转移方程可以得知：只要dp[i-1]或dp[i-2]或dp[i-3]中存在一个为假，则dp[i]为真。所以，dp[i]为假，必然导致dp[i+1]、dp[i+2]、dp[i+3]为真。由于dp[i+1]、dp[i+2]、dp[i+3]为真，所以dp[i+4]必然为假。</p><p>综上所述，我们发现规律：当 i 被4整除时，必然失败，否则必然获胜。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canWinNim</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">return</span> n<span class="token operator">%</span><span class="token number">4</span><span class="token operator">!=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该问题又叫巴比博弈，设最多能拿M块石头，共有N块石头，则结果的真假为N%（M+1）！=0。</p><h2 id="2020-4-22-（2-medium-2-easy）"><a href="#2020-4-22-（2-medium-2-easy）" class="headerlink" title="2020.4.22 （2 medium 2 easy）"></a>2020.4.22 （2 medium 2 easy）</h2><h3 id="89题-格雷编码"><a href="#89题-格雷编码" class="headerlink" title="89题 格雷编码"></a>89题 格雷编码</h3><p><img src="89.png" alt="89题"></p><h4 id="思路：-71"><a href="#思路：-71" class="headerlink" title="思路："></a>思路：</h4><p>一开始尝试了深搜+回溯，貌似超时了。于是，我们想到使用动态规划法去优化。</p><p>这道题的动态规划状态比较特殊。我们使用每一个不同位数时的格雷编码数组，去递归下一个位数时的格雷编码数组。</p><p>那么动态规划是如何转移的呢？格雷编码是采用镜像反射法递推的。</p><p>根据信息论的知识，去除最高位后，格雷码本身是镜像对称的。我们只需要将第 i 位时刻的格雷编码，倒序后进行拼接，前半部分补全0，后半部分补全1，即可。</p><p><img src="89-1.png" alt="89题"></p><p>二进制的最高位补0，意味着不变，补1，意味着加上2的当前位数减1次方。这里，我们可以使用一个变量head来进行补1操作，并通过移位运算进行更新。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">grayCode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        head<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token operator">+=</span><span class="token punctuation">[</span>x<span class="token operator">+</span>head <span class="token keyword">for</span> x <span class="token keyword">in</span> res<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>            head<span class="token operator">&lt;&lt;</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="344-题-反转字符串"><a href="#344-题-反转字符串" class="headerlink" title="344 题 反转字符串"></a>344 题 <a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">反转字符串</a></h3><p><img src="344.png" alt="344题"></p><h4 id="思路：-72"><a href="#思路：-72" class="headerlink" title="思路："></a>思路：</h4><p>没什么好说的，简单题，双指针法即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify s in-place instead.        """</span>        l<span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> l<span class="token operator">&lt;</span>r<span class="token punctuation">:</span>            s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span>            l<span class="token operator">+=</span><span class="token number">1</span>            r<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="557题-反转字符串中的单词-III"><a href="#557题-反转字符串中的单词-III" class="headerlink" title="557题 反转字符串中的单词 III"></a>557题 <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">反转字符串中的单词 III</a></h3><p><img src="557.png" alt="557题"></p><h4 id="思路：-73"><a href="#思路：-73" class="headerlink" title="思路："></a>思路：</h4><p>我的思路是：首先，遍历字符串，使用变量L记录一个单词的开始。每当遇到空格，我们就将L到当前字符前一个位置的字符串进行翻转，即翻转了一个单词，并修改L为当前字符下一个位置，即新单词的开头。需要注意的是，最后一个单词由于末尾没有空格，需要遍历完成后单独翻转。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseWords</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">reverse</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> l<span class="token operator">&lt;</span>r<span class="token punctuation">:</span>                s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                l<span class="token operator">+=</span><span class="token number">1</span>                r<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">if</span> s<span class="token operator">==</span><span class="token string">""</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">""</span>        s<span class="token operator">=</span>list<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        l<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">" "</span><span class="token punctuation">:</span>                reverse<span class="token punctuation">(</span>l<span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">)</span>                l<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span>        reverse<span class="token punctuation">(</span>l<span class="token punctuation">,</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="71题-简化路径"><a href="#71题-简化路径" class="headerlink" title="71题 简化路径"></a>71题 <a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">简化路径</a></h3><p><img src="71.png" alt="71题"></p><h4 id="思路：-74"><a href="#思路：-74" class="headerlink" title="思路："></a>思路：</h4><p>我们使用一个地址栈来保存当前所在的路径各级目录。将题目给出的原路径按照“/”进行分割，即可得到原始的各目录操作。</p><p>接下来对每个目录操作进行处理：</p><ul><li>如果当前操作为”..”，则将地址栈中的栈顶目录出栈，也就是等于从当前目录返回上级目录。需要注意的是，如果栈为空，那么直接跳过即可。</li><li>如果当前操作为”.”，那么什么也不做，保持在当前目录。特别注意，由于切片机制，可能会出现全空的目录操作，对于这种情况，我们也直接continue。</li><li>如果当前操作为其他，说明它们必定是下一级目录的名称，直接将其入栈保存即可，相当于执行了cd命令。</li></ul><p>最后，我们将地址栈中的各级目录使用”/“进行拼接。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">simplifyPath</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> path<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        li<span class="token operator">=</span>path<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>        now_path<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> op <span class="token keyword">in</span> li<span class="token punctuation">:</span>            <span class="token keyword">if</span> op<span class="token operator">==</span><span class="token string">".."</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> now_path <span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    now_path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">elif</span> op <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                now_path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>op<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">"/"</span><span class="token operator">+</span><span class="token string">"/"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>now_path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(len(path))$</li></ul><h2 id="2020-5-1-（5-easy-1-medium）"><a href="#2020-5-1-（5-easy-1-medium）" class="headerlink" title="2020.5.1 （5 easy 1 medium）"></a>2020.5.1 （5 easy 1 medium）</h2><h3 id="225题-用队列实现栈"><a href="#225题-用队列实现栈" class="headerlink" title="225题  用队列实现栈"></a>225题  <a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">用队列实现栈</a></h3><p><img src="225.png" alt="225题"></p><h4 id="思路：-75"><a href="#思路：-75" class="headerlink" title="思路："></a>思路：</h4><p>我们知道，队列的特性是：先进先出，它的pop操作在头部，push操作在尾部。而栈的特性是先进后出，它的push和pop操作都在尾部。</p><p>为了用队列来模拟栈，我们有如下几种方式：</p><ul><li><p>使用辅助队列修改入队操作，确保新入队的元素位于队首。这样，我们实现了栈的后进先出特性，相当于模拟了栈。我们可以这么操作：</p><ul><li>先将新元素入辅助队列</li><li>再将主队列中所有的元素入辅助队列</li><li>交换辅助队列和主队列（减少判断）</li></ul><p><img src="225-2.png" alt="225-1"></p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>helper <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Push element x onto stack.        """</span>        self<span class="token punctuation">.</span>helper<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>helper<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>helper<span class="token punctuation">,</span> self<span class="token punctuation">.</span>queue <span class="token operator">=</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">,</span> self<span class="token punctuation">.</span>helper    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Removes the element on top of the stack and returns that element.        """</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Get the top element.        """</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Returns whether the stack is empty.        """</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>使用辅助队列修改出队操作，将最后一个元素之前的所有元素先入辅助队列保存，再取出最后一个元素。这样，我们也实现了栈的后进先出特性，相当于模拟了栈。我们可以这么操作：</p><ul><li>先将队列中除了队尾元素的所有元素入辅助队列</li><li>队尾元素出队，作为结果</li><li>交换辅助队列和主队列（减少判断）</li></ul><p><img src="225-1.png" alt="225-2"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>helper <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Push element x onto stack.        """</span>        self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Removes the element on top of the stack and returns that element.        """</span>        <span class="token keyword">while</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>helper<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>queue<span class="token punctuation">,</span> self<span class="token punctuation">.</span>helper <span class="token operator">=</span> self<span class="token punctuation">.</span>helper<span class="token punctuation">,</span> self<span class="token punctuation">.</span>queue        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Get the top element.        """</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#这里要修改一下</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Returns whether the stack is empty.        """</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>为了不使用额外空间，我们可以只用主队列进行原地修改。具体的思路是这样的：</p><ul><li>入队操作时，先记录下当前的队列长度L，将新元素入队。</li><li>接着将队首元素出队，再入队。重复L次，相当于不使用额外空间的第一种方法。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Push element x onto stack.        """</span>        L <span class="token operator">=</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">while</span> L<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            L<span class="token operator">-=</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Removes the element on top of the stack and returns that element.        """</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Get the top element.        """</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Returns whether the stack is empty.        """</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="面试题-10-01-合并排序的数组"><a href="#面试题-10-01-合并排序的数组" class="headerlink" title="面试题 10.01. 合并排序的数组"></a><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/" target="_blank" rel="noopener">面试题 10.01. 合并排序的数组</a></h3><p><img src="10.1.png" alt="10.1"></p><h4 id="思路：-76"><a href="#思路：-76" class="headerlink" title="思路："></a>思路：</h4><p>这道题因为是合并两个排序链表，我们很容易想到mergesort的mergetwolist部分。但是，这道题有一个问题就是如果使用双指针正向合并的话，会导致一些元素尚且没有被访问到即被覆盖，所以我们要进行逆向双指针法从后向前，从大到小排序。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> B<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify A in-place instead.        """</span>        r <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token comment" spellcheck="true">#r指针用于存放逆向放入元素的位置</span>        m <span class="token operator">-=</span> <span class="token number">1</span>        n <span class="token operator">-=</span> <span class="token number">1</span>         <span class="token keyword">while</span> m<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> n<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> A<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;</span> B<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">:</span>                A<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> B<span class="token punctuation">[</span>n<span class="token punctuation">]</span>                n <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                A<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>m<span class="token punctuation">]</span>                m <span class="token operator">-=</span> <span class="token number">1</span>            r <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">if</span> m<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果是B数组放完了，即n&lt;0，我们不需要再调整A数组了，所以不必判断</span>            <span class="token keyword">while</span> n<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">:</span>                A<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> B<span class="token punctuation">[</span>n<span class="token punctuation">]</span>                r <span class="token operator">-=</span> <span class="token number">1</span>                n <span class="token operator">-=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="994题-腐烂的橘子"><a href="#994题-腐烂的橘子" class="headerlink" title="994题 腐烂的橘子"></a>994题 <a href="https://leetcode-cn.com/problems/rotting-oranges/" target="_blank" rel="noopener">腐烂的橘子</a></h3><p><img src="994.png" alt="994"></p><h4 id="思路：-77"><a href="#思路：-77" class="headerlink" title="思路："></a>思路：</h4><p>有点像元胞自动机中的生命游戏。我们使用类似于BFS的思路进行解题。</p><p>我们使用两个辅助队列进行BFS。每一时刻的bad队列中存放的是当前所有腐烂的橘子位置，fresh队列中存放的是当前所有新鲜橘子的位置。特别地，为了防止重复搜索，我们将隔了一个时刻的腐烂橘子丢弃。</p><p>我们每次从bad队列中出队一个腐烂的橘子，用它的四个正方向坐标从fresh队列中取出新鲜橘子放入bad队列，相当于把它们“污染”了。然后将这个腐烂的橘子丢弃。如果最后没有新鲜的橘子了，即fresh队列为空，我们就可以返回当前的时刻数。如果fresh队列不为空，但bad队列已经为空，说明此时必然不可能全部腐烂，返回-1.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">orangesRotting</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        fresh <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        bad <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        offset <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">:</span>                    bad<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">elif</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                    fresh<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        time <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> fresh<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            L <span class="token operator">=</span> len<span class="token punctuation">(</span>bad<span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">:</span>                pos <span class="token operator">=</span> bad<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> off <span class="token keyword">in</span> offset<span class="token punctuation">:</span>                    row <span class="token operator">=</span> pos<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> off<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                    col <span class="token operator">=</span> pos<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> off<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                    <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">[</span>row<span class="token punctuation">,</span>col<span class="token punctuation">]</span> <span class="token keyword">in</span> fresh<span class="token punctuation">:</span>                        fresh<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token punctuation">[</span>row<span class="token punctuation">,</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                        bad<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>row<span class="token punctuation">,</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>            time <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> fresh<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> bad<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> time<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1103-分糖果-II"><a href="#1103-分糖果-II" class="headerlink" title="1103 分糖果 II"></a>1103 <a href="https://leetcode-cn.com/problems/distribute-candies-to-people/" target="_blank" rel="noopener">分糖果 II</a></h3><p><img src="1103.png" alt="1103"></p><h4 id="思路：-78"><a href="#思路：-78" class="headerlink" title="思路："></a>思路：</h4><p>使用取余运算来模拟循环访问，暴力分糖，直到糖分完。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">distributeCandies</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> candies<span class="token punctuation">:</span> int<span class="token punctuation">,</span> num_people<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>num_people<span class="token punctuation">)</span><span class="token punctuation">]</span>        s <span class="token operator">=</span> <span class="token number">1</span>        i <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> candies<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> s            candies <span class="token operator">-=</span> s            <span class="token keyword">if</span> candies <span class="token operator">></span> s<span class="token punctuation">:</span>                s <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#不足以再分一次，就将剩下的糖果全部分光</span>                s <span class="token operator">=</span> candies            i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> num_people        <span class="token keyword">return</span> ans<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以使用数学方法，等差数列进行推导。</p><h3 id="409题-最长回文串"><a href="#409题-最长回文串" class="headerlink" title="409题 最长回文串"></a>409题 <a href="https://leetcode-cn.com/problems/longest-palindrome/" target="_blank" rel="noopener">最长回文串</a></h3><p><img src="409.png" alt="409"></p><h4 id="思路：-79"><a href="#思路：-79" class="headerlink" title="思路："></a>思路：</h4><p>贪心思想。统计一下小于每个字符出现次数的最大偶数之和（回文串必须是左右对称的），如果由字符出现次数为奇数，那么还需再加1即可（回文串长度为奇数时，中心的字符可以只出现一次）。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dic <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>            dic<span class="token punctuation">[</span>ch<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token number">0</span>        flag <span class="token operator">=</span> <span class="token boolean">True</span>        <span class="token keyword">for</span> key <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">//</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">2</span>            <span class="token keyword">if</span> flag <span class="token operator">and</span> dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                res <span class="token operator">+=</span> <span class="token number">1</span>                flag <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="876题-链表的中间结点"><a href="#876题-链表的中间结点" class="headerlink" title="876题 链表的中间结点"></a>876题 <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">链表的中间结点</a></h3><p><img src="876.png" alt="876"></p><h4 id="思路：-80"><a href="#思路：-80" class="headerlink" title="思路："></a>思路：</h4><p>最简单的方法是先遍历一次得到长度，再遍历二分之长度次得到中间节点。但那肯定不是我们想要的。</p><p>好的方法是使用快慢指针法，快指针的速度是慢指针的两倍，这样当快指针走完链表时，慢指针一定指向链表的中间节点。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">middleNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        slow<span class="token punctuation">,</span> fast <span class="token operator">=</span> head<span class="token punctuation">,</span> head        <span class="token keyword">while</span> fast<span class="token operator">!=</span>None <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        <span class="token keyword">return</span> slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1013题-将数组分成和相等的三个部分"><a href="#1013题-将数组分成和相等的三个部分" class="headerlink" title="1013题 将数组分成和相等的三个部分"></a>1013题 <a href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/" target="_blank" rel="noopener">将数组分成和相等的三个部分</a></h3><p><img src="1013.png" alt="1013"></p><h4 id="思路：-81"><a href="#思路：-81" class="headerlink" title="思路："></a>思路：</h4><p>首先，我们求解数组总和，如果它不是3的倍数，直接返回False。</p><p>接着，我们以当前数组总和的三分之一作为目标，分别从左右两侧寻找 i 和 j ，使其能在头尾各构成区间达到数组总和的三分之一，如果 i 小于 j 且和 j 之间存在大于1的空间，则数组必然能划分为三个和相等的部分。</p><p>我们寻找i 和 j 时使用贪心的思想，一旦找到立马跳出循环。因为这样可以使中间的区间[i+1：j]尽可能地大。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canThreePartsEqualSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        s <span class="token operator">=</span> sum<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        <span class="token keyword">if</span> s<span class="token operator">%</span><span class="token number">3</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        tar <span class="token operator">=</span> s<span class="token operator">//</span><span class="token number">3</span>        now <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            now <span class="token operator">+=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">if</span> now <span class="token operator">==</span> tar<span class="token punctuation">:</span>                <span class="token keyword">break</span>        now <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            now <span class="token operator">+=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            <span class="token keyword">if</span> now <span class="token operator">==</span> tar<span class="token punctuation">:</span>                <span class="token keyword">break</span>        <span class="token keyword">return</span> i<span class="token operator">&lt;</span>j<span class="token number">-1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-17-16-按摩师"><a href="#面试题-17-16-按摩师" class="headerlink" title="面试题 17.16. 按摩师"></a><a href="https://leetcode-cn.com/problems/the-masseuse-lcci/" target="_blank" rel="noopener">面试题 17.16. 按摩师</a></h3><p><img src="17.16.png" alt="17.16"></p><h4 id="思路：-82"><a href="#思路：-82" class="headerlink" title="思路："></a>思路：</h4><p>很明显，这道题和买卖股票问题还有打家劫舍问题类似，都是时刻+状态的二维动态规划问题。dp[i] [0] 为 i 时刻接受预约的总最大预约时长，dp[i] [1] 为 i 时刻拒绝预约的总最大预约时长。转移方程为：</p><ul><li>dp[i] [0] = dp[i-1] [1] + nums[i] ，因为无法连续接受预约，所以上一时刻必须是拒绝预约的状态</li><li>dp[i] [1] = max（dp[i-1] [0]，dp[i-1] [1]），拒绝预约，此时刻将不会增加时长，我们在上一时刻的两个状态中选取最大的时长。</li></ul><p>特别地，由于只依赖有限个状态，我们可以使用滚动数组进行DP状态压缩。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">massage</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        accept <span class="token operator">=</span> <span class="token number">0</span>        refuse <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            refuse<span class="token punctuation">,</span> accept <span class="token operator">=</span> max<span class="token punctuation">(</span>accept<span class="token punctuation">,</span>refuse<span class="token punctuation">)</span><span class="token punctuation">,</span> refuse <span class="token operator">+</span> num        <span class="token keyword">return</span> max<span class="token punctuation">(</span>accept<span class="token punctuation">,</span>refuse<span class="token punctuation">)</span><span class="token triple-quoted-string string">"""time    0   1   2   3accept  1   2   4   3refuse  0   1   2   4"""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-2-（2-easy-3-medium）"><a href="#2020-5-2-（2-easy-3-medium）" class="headerlink" title="2020.5.2 （2 easy 3 medium）"></a>2020.5.2 （2 easy 3 medium）</h2><h3 id="199题-二叉树的右视图"><a href="#199题-二叉树的右视图" class="headerlink" title="199题 二叉树的右视图"></a>199题 <a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">二叉树的右视图</a></h3><p><img src="199.png" alt="199"></p><h4 id="思路：-83"><a href="#思路：-83" class="headerlink" title="思路："></a>思路：</h4><p>这道题，本质上我们要求的只是每一层节点最右边的值，那么我们很容易就会想到BFS，因为它是按层来遍历的。</p><p>我们只需要每次将该层最右的节点值放入结果列表即可。</p><pre class="line-numbers language-PYTHON"><code class="language-PYTHON"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def rightSideView(self, root: TreeNode) -> List[int]:        res = []        if root!=None:            queue = [root]            while queue!=[]:                L = len(queue)                for i in range(L):                    node = queue.pop(0)                    if node.left!=None:                        queue.append(node.left)                    if node.right!=None:                        queue.append(node.right)                    if i==L-1:                        res.append(node.val)        return res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样，一般能用BFS解决的题目都可以用DFS解决。我们知道，先根遍历，每层的最左侧节点必然最先被访问。那么我们只需要对先根遍历稍作修改即可，改为“根-右-左”，即可访问每层最右节点。</p><p>我们在DFS的时候记录下当前的层数，如果当前层数大于res数组长度，说明该层还没有被访问过，记录下首个访问的节点即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>                <span class="token keyword">if</span> depth<span class="token operator">></span>len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1106题-拼写单词"><a href="#1106题-拼写单词" class="headerlink" title="1106题 拼写单词"></a>1106题 <a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/" target="_blank" rel="noopener">拼写单词</a></h3><p><img src="1106.png" alt="1106"></p><h4 id="思路：-84"><a href="#思路：-84" class="headerlink" title="思路："></a>思路：</h4><p>这题较为简单的做法是使用哈希表计数来做，看单词的字符和数目是否能在chars中得到满足。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countCharacters</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> words<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">,</span> chars<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>            dic <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>            <span class="token keyword">for</span> ch <span class="token keyword">in</span> word<span class="token punctuation">:</span>                dic<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">return</span> dic        dic <span class="token operator">=</span> count<span class="token punctuation">(</span>chars<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> word <span class="token keyword">in</span> words<span class="token punctuation">:</span>            word_dic <span class="token operator">=</span> count<span class="token punctuation">(</span>word<span class="token punctuation">)</span>            flag <span class="token operator">=</span> <span class="token boolean">True</span>            <span class="token keyword">for</span> key <span class="token keyword">in</span> word_dic<span class="token punctuation">:</span>                <span class="token keyword">if</span> key <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">or</span> dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">&lt;</span>word_dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">:</span>                    flag <span class="token operator">=</span> <span class="token boolean">False</span>                    <span class="token keyword">break</span>            <span class="token keyword">if</span> flag<span class="token punctuation">:</span>                res <span class="token operator">+=</span> len<span class="token punctuation">(</span>word<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个简洁的写法是这样的：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">countCharacters</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> words<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">,</span> chars<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        ans <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> w <span class="token keyword">in</span> words<span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> w<span class="token punctuation">:</span>                <span class="token keyword">if</span> w<span class="token punctuation">.</span>count<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">></span> chars<span class="token punctuation">.</span>count<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                ans<span class="token operator">+=</span>len<span class="token punctuation">(</span>w<span class="token punctuation">)</span>        <span class="token keyword">return</span> ans<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用到了Python语言的语法机制： 当 for 循环被 break 中断后，其后的 else 语句就不执行了 ； for 循环正常执行结束后，else 语句里面的内容也会正常执行。 </p><p>但是不推荐这样写，容易混乱，别人也不方便看。</p><h3 id="151题-翻转字符串里的单词"><a href="#151题-翻转字符串里的单词" class="headerlink" title="151题 翻转字符串里的单词"></a>151题 <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">翻转字符串里的单词</a></h3><p><img src="151.png" alt="151"></p><h4 id="思路：-85"><a href="#思路：-85" class="headerlink" title="思路："></a>思路：</h4><p>python比较简单，直接split后翻转拼接即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseWords</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>s<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个调函数的时间复杂度在底层也是$O(n)$的。</p><p>如果想自己从底层实现的话，可以考虑一下先根据下标原地翻转字符串，然后根据空格切分出每个单词，并将其挨个翻转即可。时间复杂度应该也是类似的，我就不实现了。</p><h3 id="892-三维形体的表面积"><a href="#892-三维形体的表面积" class="headerlink" title="892  三维形体的表面积"></a>892 <a href="https://leetcode-cn.com/problems/surface-area-of-3d-shapes/" target="_blank" rel="noopener"> 三维形体的表面积</a></h3><p><img src="892.png" alt="892"></p><h4 id="思路：-86"><a href="#思路：-86" class="headerlink" title="思路："></a>思路：</h4><p>遍历一下每个格子，统计该格子的立方体表面积，然后看四个正方向上是否有立方体，如果有那么必然会导致当前立方体的该方向上的侧面积被覆盖，被覆盖的大小和二者高度的最小值有关。</p><ul><li>时间复杂度：$O(n^2)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">surfaceArea</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        v <span class="token operator">=</span> <span class="token number">0</span>        offsets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                    v <span class="token operator">+=</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">*</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                    <span class="token keyword">for</span> offset <span class="token keyword">in</span> offsets<span class="token punctuation">:</span>                        new_i <span class="token operator">=</span> i <span class="token operator">+</span> offset<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                        new_j <span class="token operator">=</span> j <span class="token operator">+</span> offset<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                        <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>new_i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>new_j<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> grid<span class="token punctuation">[</span>new_i<span class="token punctuation">]</span><span class="token punctuation">[</span>new_j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                            v <span class="token operator">-=</span> min<span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> grid<span class="token punctuation">[</span>new_i<span class="token punctuation">]</span><span class="token punctuation">[</span>new_j<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695 岛屿的最大面积"></a>695 <a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">岛屿的最大面积</a></h3><p><img src="695.png" alt="695"></p><h4 id="思路：-87"><a href="#思路：-87" class="headerlink" title="思路："></a>思路：</h4><p>和岛屿数目类似，这种题目主要就两类做法：（1）搜索：DFS或者BFS（2）并查集</p><p>我写了一下DFS的解法，岛屿题的DFS都不需要回溯，因为每个格子最多只需要访问一遍就好了。</p><ul><li>时间复杂度：$O(n^2)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxAreaOfIsland</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        offsets<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>                s <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">for</span> offset <span class="token keyword">in</span> offsets<span class="token punctuation">:</span>                    new_row <span class="token operator">=</span> row <span class="token operator">+</span> offset<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                    new_col <span class="token operator">=</span> col <span class="token operator">+</span> offset<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                    <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>new_row<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>new_col<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        s <span class="token operator">=</span> dfs<span class="token punctuation">(</span>new_row<span class="token punctuation">,</span>new_col<span class="token punctuation">,</span>s<span class="token punctuation">)</span>            <span class="token keyword">return</span> s        maxS <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                maxS <span class="token operator">=</span> max<span class="token punctuation">(</span>dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>maxS<span class="token punctuation">)</span>        <span class="token keyword">return</span> maxS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-3-（4easy-1medium）"><a href="#2020-5-3-（4easy-1medium）" class="headerlink" title="2020.5.3 （4easy 1medium）"></a>2020.5.3 （4easy 1medium）</h2><h3 id="100题-相同的树"><a href="#100题-相同的树" class="headerlink" title="100题 相同的树"></a>100题 <a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">相同的树</a></h3><p><img src="100.png" alt="100"></p><h4 id="思路-46"><a href="#思路-46" class="headerlink" title="思路:"></a>思路:</h4><p>先序遍历判断即可，先判断当前根节点是否相等或同时为空，然后递归判断左子树和右子树是否相等。</p><ul><li>时间复杂度：$O(n)$，n为节点数，每个节点都访问一次</li><li>时间复杂度:最优情况（完全平衡二叉树）时为 $O(log(n))$，最坏情况下（完全不平衡二叉树）时为 $O(n)$，用于维护递归栈。</li></ul><p>也可以使用层次遍历，非递归地判断，本质上一样的。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> q<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> p<span class="token operator">==</span>None <span class="token operator">and</span> q<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">elif</span> p<span class="token operator">!=</span>None <span class="token operator">and</span> q<span class="token operator">!=</span>None <span class="token operator">and</span> p<span class="token punctuation">.</span>val<span class="token operator">==</span>q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>isSameTree<span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">,</span>q<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>isSameTree<span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">,</span>q<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="202题-快乐数"><a href="#202题-快乐数" class="headerlink" title="202题 快乐数"></a>202题 <a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">快乐数</a></h3><p><img src="202.png" alt="202"></p><h4 id="思路：-88"><a href="#思路：-88" class="headerlink" title="思路："></a>思路：</h4><p>模拟即可，同时用一个哈希集合存放已经生成过的数，如果产生了重复的数字，那么必然是进入了死循环。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isHappy</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        hs <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> n <span class="token keyword">in</span> hs<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            hs<span class="token punctuation">.</span>add<span class="token punctuation">(</span>n<span class="token punctuation">)</span>            next_n <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">while</span> n<span class="token punctuation">:</span>                next_n <span class="token operator">+=</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span>                n <span class="token operator">=</span> n <span class="token operator">//</span> <span class="token number">10</span>            <span class="token keyword">return</span> test<span class="token punctuation">(</span>next_n<span class="token punctuation">)</span>        <span class="token keyword">return</span> test<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="836题-矩形重叠"><a href="#836题-矩形重叠" class="headerlink" title="836题 矩形重叠"></a>836题 <a href="https://leetcode-cn.com/problems/rectangle-overlap/" target="_blank" rel="noopener">矩形重叠</a></h3><p><img src="836.png" alt="836"></p><h4 id="思路：-89"><a href="#思路：-89" class="headerlink" title="思路："></a>思路：</h4><p>这题我们需要用逆向思维求解，如果直接讨论矩形重叠的情况可能会比较复杂：需要讨论一个矩形的四个顶点分别在另一个矩形内部，或者包含这个矩形的情况。</p><p>如果我们直接讨论矩形不重叠的情况，将变得容易许多：</p><ul><li>第一个矩形位于第二个矩形左侧且不相交，需要满足第一个矩形右边的横坐标小于等于第二个矩形左边的横坐标。</li><li>第一个矩形位于第二个矩形右侧且不相交，需要满足第一个矩形左边的横坐标大于等于第二个矩形右边的横坐标。</li><li>第一个矩形位于第二个矩形上方且不相交，需要满足第一个矩形下边的纵坐标大于等于第二个矩形下边的纵坐标。</li><li>第一个矩形位于第二个矩形下方且不相交，需要满足第一个矩形上边的纵坐标小于等于第二个矩形下边的纵坐标。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isRectangleOverlap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> rec1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> rec2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token operator">not</span><span class="token punctuation">(</span>rec1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>rec2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">or</span> rec1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">>=</span>rec2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">or</span> rec1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">>=</span>rec2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">or</span> rec1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>rec2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="289题-生命游戏"><a href="#289题-生命游戏" class="headerlink" title="289题 生命游戏"></a>289题 <a href="https://leetcode-cn.com/problems/game-of-life/" target="_blank" rel="noopener">生命游戏</a></h3><p><img src="289.png" alt="289"></p><h4 id="思路：-90"><a href="#思路：-90" class="headerlink" title="思路："></a>思路：</h4><p>这题没什么复杂的，需要讨论清楚情况。</p><p>特别地，我们可以使用额外的状态来进行标记，从而两次遍历实现原地修改数组。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">gameOfLife</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify board in-place instead.        -1:当前时刻存活，下一时刻死亡        -2：当前时刻死亡，下一时刻存活        """</span>        offsets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> offset <span class="token keyword">in</span> offsets<span class="token punctuation">:</span>                new_i<span class="token punctuation">,</span> new_j <span class="token operator">=</span> i <span class="token operator">+</span> offset<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> j <span class="token operator">+</span> offset<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>new_i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>new_j<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> board<span class="token punctuation">[</span>new_i<span class="token punctuation">]</span><span class="token punctuation">[</span>new_j<span class="token punctuation">]</span> <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    res<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">return</span> res        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                res <span class="token operator">=</span> count<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> res<span class="token operator">==</span><span class="token number">3</span><span class="token punctuation">:</span>                    board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span>                <span class="token keyword">elif</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> res<span class="token operator">&lt;</span><span class="token number">2</span> <span class="token operator">or</span> res<span class="token operator">></span><span class="token number">3</span><span class="token punctuation">:</span>                        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                    board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>                <span class="token keyword">elif</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">:</span>                    board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1071题-字符串的最大公因子"><a href="#1071题-字符串的最大公因子" class="headerlink" title="1071题 字符串的最大公因子"></a>1071题 <a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/" target="_blank" rel="noopener">字符串的最大公因子</a></h3><p><img src="1071.png" alt="1071"></p><h4 id="思路：-91"><a href="#思路：-91" class="headerlink" title="思路："></a>思路：</h4><p>简单的做法是直接求出二者长度的所有公因数，然后从公因数从大到小截取子串暴力判断。</p><p>实际上根据数学推导，我们可以得知两个性质：</p><ul><li><strong>如果存在一个符合要求的字符串 <code>X</code>，那么也一定存在一个符合要求的字符串 <code>X&#39;</code>，它的长度为 <code>str1</code>和 <code>str2</code> 长度的最大公约数</strong>。 </li><li><strong>如果 <code>str1</code> 和 <code>str2</code> 拼接后等于 <code>str2</code>和 <code>str1</code> 拼接起来的字符串（注意拼接顺序不同），那么一定存在符合条件的字符串 <code>X</code></strong>。 </li></ul><p>具体推导见 <a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/solution/zi-fu-chuan-de-zui-da-gong-yin-zi-by-leetcode-solu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/solution/zi-fu-chuan-de-zui-da-gong-yin-zi-by-leetcode-solu/</a> </p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> math<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">gcdOfStrings</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> str1<span class="token punctuation">:</span> str<span class="token punctuation">,</span> str2<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">if</span> str1<span class="token operator">&lt;</span>str2<span class="token punctuation">:</span>            str1<span class="token punctuation">,</span> str2 <span class="token operator">=</span> str2<span class="token punctuation">,</span> str1        <span class="token keyword">if</span> str1 <span class="token operator">+</span> str2<span class="token operator">==</span>str2 <span class="token operator">+</span> str1<span class="token punctuation">:</span>            <span class="token keyword">return</span> str2<span class="token punctuation">[</span><span class="token punctuation">:</span>math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>len<span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-4-（5-easy-1-medium）"><a href="#2020-5-4-（5-easy-1-medium）" class="headerlink" title="2020.5.4 （5 easy 1 medium）"></a>2020.5.4 （5 easy 1 medium）</h2><h3 id="445题-两数相加-II"><a href="#445题-两数相加-II" class="headerlink" title="445题  两数相加 II"></a>445题 <a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener"> 两数相加 II</a></h3><p><img src="445.png" alt="445"></p><h4 id="思路：-92"><a href="#思路：-92" class="headerlink" title="思路："></a>思路：</h4><p>这道题如果可以先翻转链表，那么将变成简单的大数相加问题，只不过以链表形式实现。</p><p>但是题目的进阶要求我们不对链表进行翻转。为了减少时间复杂度，我们可以使用栈来实现倒序遍历（实际上，如果不使用辅助栈，我们也可以通过多次遍历对齐数位再计算，但会比较费时间）</p><p>我们先将数字存入栈中，然后按照常规大数加法进行求解。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> l2<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">linkedlist2stack</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">:</span>            stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            p <span class="token operator">=</span> head            <span class="token keyword">while</span> p<span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next            <span class="token keyword">return</span> stack        stack1<span class="token punctuation">,</span> stack2 <span class="token operator">=</span> linkedlist2stack<span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">,</span> linkedlist2stack<span class="token punctuation">(</span>l2<span class="token punctuation">)</span>        res <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#dummy head</span>        p <span class="token operator">=</span> res        c <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> stack1 <span class="token operator">or</span> stack2 <span class="token operator">or</span> c<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#当两个数字的所有数位没有被访问完，或者进位不为0时，循环计算当前最高位</span>            a <span class="token operator">=</span> stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> stack1 <span class="token keyword">else</span> <span class="token number">0</span>            b <span class="token operator">=</span> stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> stack2 <span class="token keyword">else</span> <span class="token number">0</span>            now <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c            c <span class="token operator">=</span> now <span class="token operator">//</span> <span class="token number">10</span>            now <span class="token operator">%=</span> <span class="token number">10</span>            q <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>now<span class="token punctuation">)</span>            q<span class="token punctuation">.</span>next <span class="token operator">=</span> res<span class="token punctuation">.</span>next            res<span class="token punctuation">.</span>next <span class="token operator">=</span> q        <span class="token keyword">return</span> res<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="999题-可以被一步捕获的棋子数"><a href="#999题-可以被一步捕获的棋子数" class="headerlink" title="999题 可以被一步捕获的棋子数"></a>999题 <a href="https://leetcode-cn.com/problems/available-captures-for-rook/" target="_blank" rel="noopener">可以被一步捕获的棋子数</a></h3><p><img src="999.png" alt="999"></p><h4 id="思路：-93"><a href="#思路：-93" class="headerlink" title="思路："></a>思路：</h4><p>我们可以先找到白车，然后在四个正方向上做递归搜索，统计可以捕获的黑卒个数。</p><p>需要注意，像这种多方向搜索问题，一般可以使用方向数组简化代码。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numRookCaptures</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        offsets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>offset<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>j<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'B'</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'p'</span><span class="token punctuation">:</span>                    count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    count <span class="token operator">=</span> search<span class="token punctuation">(</span>i<span class="token operator">+</span>offset<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>j<span class="token operator">+</span>offset<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>offset<span class="token punctuation">,</span>count<span class="token punctuation">)</span>            <span class="token keyword">return</span> count        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'R'</span><span class="token punctuation">:</span>                    res <span class="token operator">=</span> <span class="token number">0</span>                    <span class="token keyword">for</span> offset <span class="token keyword">in</span> offsets<span class="token punctuation">:</span>                        res <span class="token operator">+=</span> search<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>offset<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> res        <span class="token keyword">return</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="125题-验证回文串"><a href="#125题-验证回文串" class="headerlink" title="125题 验证回文串"></a>125题 <a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">验证回文串</a></h3><p><img src="125.png" alt="125"></p><h4 id="思路：-94"><a href="#思路：-94" class="headerlink" title="思路："></a>思路：</h4><p>先遍历原串，使用ascii码挑选出所有数字和字母，并将字母转小写。</p><p>判断一下新的字符串是否等于翻转后的结果即可知道它是否为回文串了。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        new_S <span class="token operator">=</span> <span class="token string">""</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> ord<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span>ord<span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token operator">&lt;=</span>ord<span class="token punctuation">(</span><span class="token string">'z'</span><span class="token punctuation">)</span> <span class="token operator">or</span> ord<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span>ord<span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token operator">&lt;=</span>ord<span class="token punctuation">(</span><span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                new_S <span class="token operator">+=</span> ch        <span class="token keyword">return</span> new_S<span class="token operator">==</span>new_S<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="69题-x-的平方根"><a href="#69题-x-的平方根" class="headerlink" title="69题  x 的平方根"></a>69题 <a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener"> x 的平方根</a></h3><p><img src="69.png" alt="69"></p><h4 id="思路：-95"><a href="#思路：-95" class="headerlink" title="思路："></a>思路：</h4><p>这道题其实蛮重要的，如果直接暴力迭代的话很简单，但优化的思想非常值得学习，特别是牛顿迭代法解决凸优化的数值解问题，涉及到了一些机器学习的知识。</p><p>首先，我们可以采用二分查找法优化暴力解决的时间复杂度。因为一个数的平方根必然不会大于它的1/2，我们只需要从0到它的1/2进行二分搜索即可。</p><p>如果找不到精确值，这里我们需要返回的是right，因为当区间最后缩到一个数时，这个数的平方如果大于目标数，结果四舍五入是当前数，left+1，right不变，那么就返回right。这个数的平方如果小于目标数，结果四舍五入是当前数减1，left不变，right-1，还是需要返回right。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>            left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> x<span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>                mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>                <span class="token keyword">if</span> mid <span class="token operator">*</span> mid<span class="token operator">==</span>x<span class="token punctuation">:</span>                    <span class="token keyword">return</span> mid                <span class="token keyword">elif</span> mid <span class="token operator">*</span> mid<span class="token operator">&lt;</span>x<span class="token punctuation">:</span>                    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">return</span> right        <span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> x        <span class="token keyword">return</span> binarySearch<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着，我们可以尝试牛顿迭代法，和梯度下降类似，它也是通过不断迭代来逼近最小损失点。</p><p>我们需要先定义损失，本题中为预测值x的平方与a的差值，很明显，这个差值越小，x越接近a的平方根。</p><p><img src="69-1.png" alt="牛顿迭代法的推导"></p><p>上图为牛顿迭代法的推导。当f（x）小于某个阈值时，我们可以退出迭代。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        x0 <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> abs<span class="token punctuation">(</span>x0<span class="token operator">*</span>x0<span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">:</span>            x0 <span class="token operator">=</span> <span class="token punctuation">(</span>x0 <span class="token operator">+</span> x <span class="token operator">/</span> x0<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>        <span class="token keyword">return</span> int<span class="token punctuation">(</span>x0<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="914题-卡牌分组"><a href="#914题-卡牌分组" class="headerlink" title="914题 卡牌分组"></a>914题 <a href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/" target="_blank" rel="noopener">卡牌分组</a></h3><p><img src="914.png" alt="914"></p><h4 id="思路：-96"><a href="#思路：-96" class="headerlink" title="思路："></a>思路：</h4><p>我们先使用哈希表，一次遍历求出每种数字的牌数。</p><ul><li>如果只存在一种数字，那么看该数字的牌数是否大于1.</li><li>如果存在多种数字，求它们牌数的最大公因数，看是否大于1.（求解公因子可以使用python的math.gcd函数，也可以使用辗转相减法等方法）</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">import</span> math<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hasGroupsSizeX</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> deck<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dic <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> deck<span class="token punctuation">:</span>            dic<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        li <span class="token operator">=</span> list<span class="token punctuation">(</span>dic<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> li<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">1</span>        gcd <span class="token operator">=</span> math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>li<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> li<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            gcd <span class="token operator">=</span> math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>gcd<span class="token punctuation">,</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> gcd<span class="token operator">></span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="118题-杨辉三角"><a href="#118题-杨辉三角" class="headerlink" title="118题 杨辉三角"></a>118题 <a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">杨辉三角</a></h3><p><img src="118.png" alt="118"></p><h4 id="思路：-97"><a href="#思路：-97" class="headerlink" title="思路："></a>思路：</h4><p>模拟一下即可，可以看作是一种动态规划。最外层的两个数字始终是1。当前层除了左右两侧的两个1以外，每一个数字都是上层的左上方和右上方的数的和。 </p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">generate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> numRows<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> numRows<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> numRows<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> numRows<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> numRows<span class="token operator">></span><span class="token number">2</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>numRows<span class="token punctuation">)</span><span class="token punctuation">:</span>                lastRow <span class="token operator">=</span> res<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>                nowRow <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>lastRow<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    nowRow<span class="token punctuation">.</span>append<span class="token punctuation">(</span>lastRow<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>lastRow<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nowRow<span class="token operator">+</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-5-（3-medium，1-easy）"><a href="#2020-5-5-（3-medium，1-easy）" class="headerlink" title="2020.5.5 （3 medium，1 easy）"></a>2020.5.5 （3 medium，1 easy）</h2><h3 id="83题-删除排序链表中的重复元素"><a href="#83题-删除排序链表中的重复元素" class="headerlink" title="83题 删除排序链表中的重复元素"></a>83题 <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表中的重复元素</a></h3><p><img src="83.png" alt="83"></p><h4 id="思路：-98"><a href="#思路：-98" class="headerlink" title="思路："></a>思路：</h4><p>因为链表是有序的，我们只要比较相邻的两个节点，看它们值是否相等，相等则删掉后一个节点即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        p <span class="token operator">=</span> head        <span class="token keyword">while</span> p <span class="token operator">and</span> p<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> p<span class="token punctuation">.</span>val<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#需要注意的是：这里删掉后一个节点之后，新的下一个节点也可能与当前节点重复，所以不能冒然移动指针，还要继续判断</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="945题-使数组唯一的最小增量"><a href="#945题-使数组唯一的最小增量" class="headerlink" title="945题  使数组唯一的最小增量"></a>945题 <a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/" target="_blank" rel="noopener"> 使数组唯一的最小增量</a></h3><p><img src="945.png" alt="945"></p><h4 id="思路：-99"><a href="#思路：-99" class="headerlink" title="思路："></a>思路：</h4><p>我在一开始尝试了比较暴力的做法，很明显超时了。我们对每一个重复出现的数字，尝试将其不断加1直到其不在数组中，统计总加1的次数。时间复杂度应该是：$O(n^2)$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minIncrementForUnique</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dic <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        repeat <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> A<span class="token punctuation">:</span>            dic<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> dic<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>                repeat<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        count <span class="token operator">=</span> <span class="token number">0</span>        hs <span class="token operator">=</span> set<span class="token punctuation">(</span>dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> repeat<span class="token punctuation">:</span>            <span class="token keyword">while</span> i <span class="token keyword">in</span> hs<span class="token punctuation">:</span>                i <span class="token operator">+=</span> <span class="token number">1</span>                count <span class="token operator">+=</span> <span class="token number">1</span>            hs<span class="token punctuation">.</span>add<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后来，我想到了将时间复杂度降为$O(nlogn)$的办法。</p><ul><li>我们先对数组进行排序（$O(nlog)$）。</li><li>统计排序后的数组中的重复元素。</li><li>接着，我们从最小的元素值遍历到最大的元素值，即区间为[min（A），max（A）]。如果当前遍历到的值不在数组中且大于当前最小重复元素（因为只能加1），那么就可以从重复元素中选出一个最小的元素放再该位置上，需要移动的步数即为二者之差，省去了为每个数进行while循环找到插入位置的步骤。</li><li>如果还有重复元素没有合适的位置被插入，那么就在数组尾部进行插入。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minIncrementForUnique</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        A<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        B <span class="token operator">=</span> set<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        repeat <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> A<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                repeat<span class="token punctuation">.</span>append<span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>A<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> B <span class="token operator">and</span> i <span class="token operator">></span> repeat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                count <span class="token operator">+=</span> i <span class="token operator">-</span> repeat<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token operator">not</span><span class="token punctuation">(</span>repeat<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>        tail <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">while</span> repeat<span class="token punctuation">:</span>            count <span class="token operator">+=</span> tail <span class="token operator">-</span> repeat<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            tail <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这道题换句话说，就是需要把原数组映射到一个地址不冲突的区域，映射后的地址不小于原数组对应的元素。<br>比如 [3, 2, 1, 2, 1, 7] 就映射成了 [3, 2, 1, 4, 5, 7]。</p><p>我想了下，这道题目其实和解决 hash 冲突的线性探测法比较相似！<br>如果地址冲突了，会探测它的下一个位置，如果下一个位置还是冲突，继续向后看，直到第一个不冲突的位置为止。</p><p>关键点：因为直接线性探测可能会由于冲突导致反复探测耗时太长，因此我们可以考虑探测的过程中进行路径压缩。<br>怎么路径压缩呢？就是经过某条路径最终探测到一个空位置 x 后，将这条路径上的值都变成空位置所在的下标 x，那么假如下次探测的点又是这条路径上的点，则可以直接跳转到这次探测到的空位置 x，从 x 开始继续探测。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span> <span class="token punctuation">[</span><span class="token number">80000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minIncrementForUnique</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -1表示空位</span>        <span class="token keyword">int</span> move <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历每个数字a对其寻地址得到位置b, b比a的增量就是操作数。</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token operator">:</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token function">findPos</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>             move <span class="token operator">+=</span> b <span class="token operator">-</span> a<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> move<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 线性探测寻址（含路径压缩）</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findPos</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> b <span class="token operator">=</span> pos<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果a对应的位置pos[a]是空位，直接放入即可。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             pos<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>            <span class="token keyword">return</span> a<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 否则向后寻址</span>        <span class="token comment" spellcheck="true">// 因为pos[a]中标记了上次寻址得到的空位，因此从pos[a]+1开始寻址就行了（不需要从a+1开始）。</span>        b <span class="token operator">=</span> <span class="token function">findPos</span><span class="token punctuation">(</span>b <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         pos<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 寻址后的新空位要重新赋值给pos[a]哦，路径压缩就是体现在这里。</span>        <span class="token keyword">return</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="92题-反转链表-II"><a href="#92题-反转链表-II" class="headerlink" title="92题 反转链表 II"></a>92题 <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">反转链表 II</a></h3><p><img src="92.png" alt="92"></p><h4 id="思路：-100"><a href="#思路：-100" class="headerlink" title="思路："></a>思路：</h4><p>可以使用头插法解决反转链表问题。</p><p>我们先遍历找到链表的第m个位置，然后将第m+1到第n个节点插入至第m个节点之前即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseBetween</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        dummyhead <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token punctuation">)</span>        dummyhead<span class="token punctuation">.</span>next <span class="token operator">=</span> head        pre <span class="token operator">=</span> dummyhead        p <span class="token operator">=</span> head        count <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> p <span class="token operator">!=</span> None<span class="token punctuation">:</span>            <span class="token keyword">if</span> m <span class="token operator">&lt;=</span> count <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>                q <span class="token operator">=</span> p<span class="token punctuation">.</span>next                p<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next                q<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> q                q <span class="token operator">=</span> p<span class="token punctuation">.</span>next            <span class="token keyword">elif</span> count <span class="token operator">&lt;</span> m<span class="token punctuation">:</span>                pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>            count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以使用反转链边常用的快慢双指针法翻转第m到n个节点，使用两个指针存储一下第m-1个节点和第m个节点。翻转完成后，调整一下上述两个节点的next指针即可。 <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode/</a> </p><h3 id="820题-单词的压缩编码"><a href="#820题-单词的压缩编码" class="headerlink" title="820题 单词的压缩编码"></a>820题 <a href="https://leetcode-cn.com/problems/short-encoding-of-words/" target="_blank" rel="noopener">单词的压缩编码</a></h3><p><img src="820.png" alt="820"></p><h4 id="思路：-101"><a href="#思路：-101" class="headerlink" title="思路："></a>思路：</h4><p>这道题的本质是：如果一个单词出现在另一个单词的尾部，我们可以只需要存储另一个单词，而当前单词只需要截取另一个单词的尾部即可获取。所以，我们要删除所有出现在另一个单词尾部的单词，剩下单词长度加上<code>#</code>的个数即为结果。</p><p>我们可以使用反转所有单词+排序的方式，按序进行比较。因为这样做，前缀相同的单词必然位于相邻的位置（字典序）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minimumLengthEncoding</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> words<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            words<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        words <span class="token operator">=</span> sorted<span class="token punctuation">(</span>words<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> words<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>startswith<span class="token punctuation">(</span>words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            res <span class="token operator">+=</span> len<span class="token punctuation">(</span>words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>        res <span class="token operator">+=</span> len<span class="token punctuation">(</span>words<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这道题还可以用字典树，和求前缀子串类似，只不过本题是后缀。</p><h2 id="2020-5-6-（3-medium，2-easy）"><a href="#2020-5-6-（3-medium，2-easy）" class="headerlink" title="2020.5.6 （3 medium，2 easy）"></a>2020.5.6 （3 medium，2 easy）</h2><h3 id="111题-二叉树的最小深度"><a href="#111题-二叉树的最小深度" class="headerlink" title="111题 二叉树的最小深度"></a>111题 <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最小深度</a></h3><p><img src="111.png" alt="111"></p><h4 id="思路：-102"><a href="#思路：-102" class="headerlink" title="思路："></a>思路：</h4><p>这道题可以递归来做：</p><ul><li>如果当前子树为空，直接返回0</li><li>如果左子树为空，右子树不为空，那么左子树必不存在叶子节点，所以只能在右子树递归计算。加上当前节点高度1，进入右子树计算最小深度</li><li>如果右子树为空，左子树不为空，那么右子树必不存在叶子节点，所以只能在左子树递归计算。加上当前节点高度1，进入左子树计算最小深度</li><li>如果左右子树都为空，那么当前节点是叶子节点，不需要再递归了，直接返回当前节点高度1即可</li></ul><p>有点类似于求二叉树的高度，但是要讨论是否抵达叶子节点，而不是一味地求最小值。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 当只有左子树为空或者右子树为空时，不符合要求。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token operator">!=</span> None <span class="token operator">and</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>minDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>right <span class="token operator">!=</span> None <span class="token operator">and</span> root<span class="token punctuation">.</span>left <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>minDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token operator">and</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> min<span class="token punctuation">(</span>self<span class="token punctuation">.</span>minDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>minDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token operator">==</span> None <span class="token operator">and</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="167题-两数之和-II-输入有序数组两数之和-II-输入有序数组"><a href="#167题-两数之和-II-输入有序数组两数之和-II-输入有序数组" class="headerlink" title="167题 两数之和 II - 输入有序数组两数之和 II - 输入有序数组"></a>167题 <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">两数之和 II - 输入有序数组</a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">两数之和 II - 输入有序数组</a></h3><p><img src="167.png" alt="167"></p><h4 id="思路：-103"><a href="#思路：-103" class="headerlink" title="思路："></a>思路：</h4><p>三数之和问题的简化版本，两数之和。本质上，n数之和问题，都可以先n-2层循环模拟确定n-2个数的位置，再转化为双指针法解决两数之和问题。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> numbers<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>numbers<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            res <span class="token operator">=</span> numbers<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>right<span class="token punctuation">]</span>            <span class="token keyword">if</span> res <span class="token operator">==</span> target<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">elif</span> res <span class="token operator">></span> target<span class="token punctuation">:</span>                <span class="token keyword">while</span> numbers<span class="token punctuation">[</span>right<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> numbers<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                    right <span class="token operator">-=</span> <span class="token number">1</span>                right <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> numbers<span class="token punctuation">[</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> numbers<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">:</span>                    left <span class="token operator">+=</span> <span class="token number">1</span>                left <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="103题-二叉树的锯齿形层次遍历"><a href="#103题-二叉树的锯齿形层次遍历" class="headerlink" title="103题 二叉树的锯齿形层次遍历"></a>103题 <a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">二叉树的锯齿形层次遍历</a></h3><p><img src="103.png" alt="103"></p><h4 id="思路：-104"><a href="#思路：-104" class="headerlink" title="思路："></a>思路：</h4><p>BFS实现层次遍历，然后使用一个变量记录一下层数。奇数层不翻转，偶数层翻转，使用双端队列来模拟。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">zigzagLevelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root<span class="token punctuation">:</span>            queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>            level <span class="token operator">=</span> <span class="token number">1</span>            <span class="token keyword">while</span> queue<span class="token punctuation">:</span>                l <span class="token operator">=</span> len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>                now <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                <span class="token keyword">if</span> level <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                        node <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                        now<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                        <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                        <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                <span class="token keyword">elif</span> level <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                        node <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                        now<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                        <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                        <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                level <span class="token operator">+=</span> <span class="token number">1</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>now<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="912题-排序数组"><a href="#912题-排序数组" class="headerlink" title="912题 排序数组"></a>912题 <a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener">排序数组</a></h3><p><img src="912.png" alt="912"></p><h4 id="思路：-105"><a href="#思路：-105" class="headerlink" title="思路："></a>思路：</h4><p>这题是给人写一下各种排序练习，我写了个快排热身一下。更多排序内容参考我的第一篇博客。</p><p>快排的时间复杂度为$O(nlogn)$（使用了分治思想），空间复杂度为$O(1)$。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>            p <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span>            q <span class="token operator">=</span> right            <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> left<span class="token operator">&lt;</span>p<span class="token operator">&lt;=</span>right <span class="token operator">and</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">:</span>                    p <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">while</span> left<span class="token operator">&lt;</span>q<span class="token operator">&lt;=</span>right <span class="token operator">and</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">:</span>                    q <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">if</span> p <span class="token operator">&lt;</span> q<span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                    <span class="token keyword">break</span>            <span class="token keyword">return</span> q        <span class="token keyword">def</span> <span class="token function">quicksort</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> left <span class="token operator">>=</span> right<span class="token punctuation">:</span>                <span class="token keyword">return</span>            pivot <span class="token operator">=</span> partition<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>            quicksort<span class="token punctuation">(</span>left<span class="token punctuation">,</span> pivot<span class="token number">-1</span><span class="token punctuation">)</span>            quicksort<span class="token punctuation">(</span>pivot<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span>        quicksort<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实可以写得简洁一些：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>                p <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span>                q <span class="token operator">=</span> right                <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>                    <span class="token keyword">while</span> left<span class="token operator">&lt;</span>p<span class="token operator">&lt;=</span>right <span class="token operator">and</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">:</span>                        p <span class="token operator">+=</span> <span class="token number">1</span>                    <span class="token keyword">while</span> left<span class="token operator">&lt;</span>q<span class="token operator">&lt;=</span>right <span class="token operator">and</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">:</span>                        q <span class="token operator">-=</span> <span class="token number">1</span>                    <span class="token keyword">if</span> p <span class="token operator">&lt;</span> q<span class="token punctuation">:</span>                        nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                        <span class="token keyword">break</span>                partition<span class="token punctuation">(</span>left<span class="token punctuation">,</span> q<span class="token number">-1</span><span class="token punctuation">)</span>                partition<span class="token punctuation">(</span>q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span>        partition<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="82题-删除排序链表中的重复元素-II"><a href="#82题-删除排序链表中的重复元素-II" class="headerlink" title="82题 删除排序链表中的重复元素 II"></a>82题 <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">删除排序链表中的重复元素 II</a></h3><p><img src="82.png" alt="82"></p><h4 id="思路：-106"><a href="#思路：-106" class="headerlink" title="思路："></a>思路：</h4><p>使用一个哈希集合存放重复的元素即可。如果某个元素与下一个元素重复，或者它在哈希集合中，那么将它加入哈希集合并从链表中删去。只需一次遍历即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        hs <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        dummyhead <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token punctuation">)</span>        dummyhead<span class="token punctuation">.</span>next <span class="token operator">=</span> head        p <span class="token operator">=</span> dummyhead        <span class="token keyword">while</span> p<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token keyword">in</span> hs <span class="token operator">or</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">and</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>                hs<span class="token punctuation">.</span>add<span class="token punctuation">(</span>p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-7-（3-medium-2-easy）"><a href="#2020-5-7-（3-medium-2-easy）" class="headerlink" title="2020.5.7 （3 medium 2 easy）"></a>2020.5.7 （3 medium 2 easy）</h2><h3 id="120题-三角形最小路径和"><a href="#120题-三角形最小路径和" class="headerlink" title="120题 三角形最小路径和"></a>120题 <a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">三角形最小路径和</a></h3><p><img src="120.png" alt="120"></p><h4 id="思路：-107"><a href="#思路：-107" class="headerlink" title="思路："></a>思路：</h4><p>这题是被包装过了的动态规划问题，像这种类似的走迷宫或者选择路径问题，我们首选动态规划方法，如果不行，再考虑递归回溯的方法。</p><p>这道题有些像之前的机器人走迷宫问题，三角形每个结点都可以由左上方或者右上方的结点走到。所以动态规划状态矩阵dp[i] [j] 为第 i 行第 j 列的结点的最小路径和。</p><p>转移方程为：dp[i] [j] = trangle[i] [j] + min（dp[i-1] [j-1], dp[i-1] [j]），特别地，要考虑第一个结点和最后一个结点的下标溢出问题。</p><p>由于本题只需用到上一行的状态，我们可以对dp矩阵进行压缩，从而达到题目要求的空间复杂度。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minimumTotal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> triangle<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>triangle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> triangle<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>triangle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>triangle<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> triangle<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token keyword">elif</span> <span class="token number">0</span> <span class="token operator">&lt;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>triangle<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> triangle<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> triangle<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> min<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="365题-水壶问题"><a href="#365题-水壶问题" class="headerlink" title="365题 水壶问题"></a>365题 <a href="https://leetcode-cn.com/problems/water-and-jug-problem/" target="_blank" rel="noopener">水壶问题</a></h3><p><img src="365.png" alt="365"></p><h4 id="思路：-108"><a href="#思路：-108" class="headerlink" title="思路："></a>思路：</h4><p>这题可以使用深度优先搜索的方式来求解。因为每一时刻的动作只有六种可能：</p><ul><li>把 X 壶的水灌进 Y 壶，直至灌满或倒空；</li><li>把 Y 壶的水灌进 X 壶，直至灌满或倒空；</li><li>把 X 壶灌满；</li><li>把 Y 壶灌满；</li><li>把 X 壶倒空；</li><li>把 Y 壶倒空。</li></ul><p>所以我们使用DFS来进行路径搜索。直到某一个壶或者两个壶中的水量达到要求。</p><p>因为这道题的递归深度可能很深，可能超过系统的递归栈最大深度，所以我们应使用栈来模拟，并使用一个哈希集合来进行剪枝，防止重复搜索。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canMeasureWater</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">,</span> y<span class="token punctuation">:</span> int<span class="token punctuation">,</span> z<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>seen <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>            remain_x<span class="token punctuation">,</span> remain_y <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> remain_x <span class="token operator">==</span> z <span class="token operator">or</span> remain_y <span class="token operator">==</span> z <span class="token operator">or</span> remain_x <span class="token operator">+</span> remain_y <span class="token operator">==</span> z<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>remain_x<span class="token punctuation">,</span> remain_y<span class="token punctuation">)</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>seen<span class="token punctuation">:</span>                <span class="token keyword">continue</span>            self<span class="token punctuation">.</span>seen<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token punctuation">(</span>remain_x<span class="token punctuation">,</span> remain_y<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 把 X 壶灌满。</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> remain_y<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 把 Y 壶灌满。</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>remain_x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 把 X 壶倒空。</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> remain_y<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 把 Y 壶倒空。</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>remain_x<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 把 X 壶的水灌进 Y 壶，直至灌满或倒空。</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>remain_x <span class="token operator">-</span> min<span class="token punctuation">(</span>remain_x<span class="token punctuation">,</span> y <span class="token operator">-</span> remain_y<span class="token punctuation">)</span><span class="token punctuation">,</span> remain_y <span class="token operator">+</span> min<span class="token punctuation">(</span>remain_x<span class="token punctuation">,</span> y <span class="token operator">-</span> remain_y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#这里的min函数，是看先把x壶倒空还是先把y壶倒满</span>            <span class="token comment" spellcheck="true"># 把 Y 壶的水灌进 X 壶，直至灌满或倒空。</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>remain_x <span class="token operator">+</span> min<span class="token punctuation">(</span>remain_y<span class="token punctuation">,</span> x <span class="token operator">-</span> remain_x<span class="token punctuation">)</span><span class="token punctuation">,</span> remain_y <span class="token operator">-</span> min<span class="token punctuation">(</span>remain_y<span class="token punctuation">,</span> x <span class="token operator">-</span> remain_x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这道题还可以使用数学解法。我们通过推导可知，每次操作只会让两个水壶中的水发生如下变化：</p><ul><li>增加或减少x</li><li>增加或减少y</li></ul><p>所以，我们得到 ax+by = z，只要 存在 a 和 b 使这个方程成立即可，且 x+y&lt;z，也就是 z 不能超过两个水壶的最大容量。</p><p>同时，我们知道贝祖定理提出： ax+by = z 有解的条件是 z 是 x 和 y 的最大公因数的倍数。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canMeasureWater</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">,</span> y<span class="token punctuation">:</span> int<span class="token punctuation">,</span> z<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> x <span class="token operator">+</span> y <span class="token operator">&lt;</span> z<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> y <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> z <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> x <span class="token operator">+</span> y <span class="token operator">==</span> z        <span class="token keyword">return</span> z <span class="token operator">%</span> math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="189题-旋转数组"><a href="#189题-旋转数组" class="headerlink" title="189题  旋转数组"></a>189题 <a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener"> 旋转数组</a></h3><p><img src="189.png" alt="189"></p><h4 id="思路：-109"><a href="#思路：-109" class="headerlink" title="思路："></a>思路：</h4><p>最简单的做法是让每个元素向后挪一个位置，挪 k 次即可。时间复杂度$O(nk)$，空间复杂度$O(1)$。</p><p>我们也可以直接让前 n-k 元素向后挪 k 个位置，但这样我们就需要 k 个额外空间来存放被暂时覆盖的数字，最后还需要把这 k 个数字重新放到头部。时间复杂度$O(n)$，空间复杂度$O(k)$。</p><p>我们可以直接使用三次反转的方法，时间复杂度$O(n)$，空间复杂度$O(1)$。</p><blockquote><p>原始数组                  : 1 2 3 4 5 6 7<br>反转所有数字后             : 7 6 5 4 3 2 1<br>反转前 k 个数字后          : 5 6 7 4 3 2 1<br>反转后 n-k 个数字后        : 5 6 7 1 2 3 4 –&gt; 结果</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify nums in-place instead.        """</span>        <span class="token keyword">def</span> <span class="token function">reverse</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> right<span class="token operator">-</span>left<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>left<span class="token punctuation">,</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>right<span class="token operator">+</span>left<span class="token operator">-</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token operator">+</span>left<span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        k <span class="token operator">=</span> k <span class="token operator">%</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        reverse<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        reverse<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> k<span class="token number">-1</span><span class="token punctuation">)</span>        reverse<span class="token punctuation">(</span>k<span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="242题-有效的字母异位词"><a href="#242题-有效的字母异位词" class="headerlink" title="242题 有效的字母异位词"></a>242题 <a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">有效的字母异位词</a></h3><p><img src="242.png" alt="242"></p><h4 id="思路：-110"><a href="#思路：-110" class="headerlink" title="思路："></a>思路：</h4><p>最简单的方法是对两个单词的字母按照ascii码进行字典序排序，比较排序后的结果。时间复杂度$O(nlogn)$。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">return</span> sorted<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> sorted<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>考虑到存在unicode字符，我们可以使用哈希表存储两个单词中各字符出现的次数，要求二者每个字符出现的次数相等即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">!=</span>len<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        dic <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dic<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            dic<span class="token punctuation">[</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">for</span> key <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1162题-地图分析"><a href="#1162题-地图分析" class="headerlink" title="1162题 地图分析"></a>1162题 <a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener">地图分析</a></h3><p><img src="1162.png" alt="1162"></p><h4 id="思路：-111"><a href="#思路：-111" class="headerlink" title="思路："></a>思路：</h4><p>这是一道非常经典的题目，本质上是一个多源搜索问题：我们可以把陆地看成是起点，从每一块陆地开始进行搜索，搜索过程中修改海洋到当前陆地起点的距离。这题和994题腐烂的橘子也很像，我们可以把陆地看成是腐烂的橘子，而海洋是好的橘子。</p><p>搜索有两种：DFS和BFS。这道题很明显BFS更加合适，因为我们要求的是海洋区域到离它最近的陆地区域的距离 。DFS以某个陆地为起点，修改全部与它连通的海洋的距离，可能会导致一个问题：某块海洋距离当前陆地很远，而距离另一块陆地很近。这种情况下，当前的修改其实是多余的，也就是产生了重叠子问题，需要使用动态规划来优化，后面再说。</p><p>如果我们同时从所有陆地起点开始BFS，这样如果遇到了已经有距离的海洋区域，就不需要再修改了。你可以想象成你从每个陆地上派了很多船去踏上伟大航道，踏遍所有的海洋。每当船到了新的海洋，就会分裂成4条新的船，向新的未知海洋前进（访问过的海洋就不去了）。如果船到达了某个未访问过的海洋，那他们是第一个到这片海洋的。很明显，这么多船最后访问到的海洋，肯定是离陆地最远的海洋。</p><ul><li><p>时间复杂度：该算法最多执行 $n^2$ 次 BFS，即我们考虑最坏情况所有的区域都是海洋，那么每一个区域都会进行 BFS。对于每一次 BFS，最坏的情况是找不到陆地区域，我们只能遍历完剩下的 $n^2 - 1$个海洋区域，由于 vis 数组确保每个区域只被访问一次，所以单次 BFS 的渐进时间复杂度是 $O(n^2)$，程序的总的渐进时间复杂度是 $O(n^4)$。</p></li><li><p>空间复杂度：该算法使用了 vis 数组，渐进空间复杂度为 $O(n^2)$。</p></li></ul><p><img src="1162-1.png" alt="BFS"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxDistance</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        offsets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        level <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">if</span> queue<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">or</span> len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token operator">==</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token operator">*</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#特判，全为海洋或者全为陆地</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            L <span class="token operator">=</span> len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#按层进行多源BFS</span>                now <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> offset <span class="token keyword">in</span> offsets<span class="token punctuation">:</span>                    new_i <span class="token operator">=</span> now<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> offset<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                    new_j <span class="token operator">=</span> now<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> offset<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                    <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>new_i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>new_j<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> grid<span class="token punctuation">[</span>new_i<span class="token punctuation">]</span><span class="token punctuation">[</span>new_j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                        grid<span class="token punctuation">[</span>new_i<span class="token punctuation">]</span><span class="token punctuation">[</span>new_j<span class="token punctuation">]</span> <span class="token operator">=</span> level                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>new_i<span class="token punctuation">,</span>new_j<span class="token punctuation">]</span><span class="token punctuation">)</span>            level <span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> grid<span class="token punctuation">[</span>now<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>now<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#最后一个访问到的海洋，必然是最远的距离</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>求解<strong>在树或者图上的最短路径</strong>，都可以尝试BFS。</p><p>本题的多源BFS本质上是从一个超级源点开始的单源BFS，而原先的多个源点只不过是超级源点的下一层节点而已。我们也可以把本题看作是一个从超级源点开始的最优路径问题，使用dijkstra或者spfa等算法来做，这在路径带权时更好做。（本题的边不带权，都是1）</p><p><img src="1162-2.png" alt="超级源点"></p><p>而如果我们想要尝试DFS，重叠的子问题会大大降低我们程序的效率，这种情况下只能使用动态规划来进行优化。本题的动态规划比较难想，因为乍看上去，当前状态由上下左右四个方向的状态转移，无论是从哪个方向做一次递推，都无法满足动态规划的无后效性要求。</p><p>所以，本题我们可以使用两次动态规划，第一次计算从上方和左方而来的转移，第二次计算从右方和下方而来的转移。两次动态规划使用相同的转移矩阵。</p><p>dp[i] [j] 表示第 i 行第 j 列区域的距离陆地的最短距离，第一阶段转移方程为：</p><ul><li>如果是陆地：dp[i] [j] = 0</li><li>如果是海洋：dp[i] [j] = min（dp[i] [j-1] , dp[i-1] [j]）+ 1</li></ul><p>第二阶段转移方程为：</p><ul><li>如果是陆地：dp[i] [j] = 0</li><li>如果是海洋：dp[i] [j] = min（dp[i] [j]，min（dp[i] [j+1] , dp[i+1] [j]）+ 1）</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxDistance</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        count_land <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    count_land <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">elif</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    pre1 <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">></span><span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span><span class="token comment" spellcheck="true">#如果边界溢出，我们设其为一个极大值，表示从这个方向上，海洋无法到达陆地</span>                    pre2 <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>pre1<span class="token punctuation">,</span> pre2<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">if</span> count_land <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> count_land <span class="token operator">==</span> len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token operator">*</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    pre1 <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span>                    pre2 <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">if</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> min<span class="token punctuation">(</span>pre1<span class="token punctuation">,</span> pre2<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span><span class="token punctuation">[</span>max<span class="token punctuation">(</span>row<span class="token punctuation">)</span> <span class="token keyword">for</span> row <span class="token keyword">in</span> dp<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#求最大距离即可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n^2)$</li></ul><h2 id="2020-5-8-（4-easy-1-medium）"><a href="#2020-5-8-（4-easy-1-medium）" class="headerlink" title="2020.5.8 （4 easy 1 medium）"></a>2020.5.8 （4 easy 1 medium）</h2><h3 id="572题-另一个树的子树"><a href="#572题-另一个树的子树" class="headerlink" title="572题  另一个树的子树"></a>572题 <a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener"> 另一个树的子树</a></h3><p><img src="572.png" alt="572"></p><h4 id="思路：-112"><a href="#思路：-112" class="headerlink" title="思路："></a>思路：</h4><p>这道题我们可以先写一个函数递归判断两棵树是否具有相同结构和节点值（根节点值相等，且左右子树具有相同结构和节点值）</p><p>然后，我们使用任意一种遍历方式遍历 s 树的所有子树，判断其是否与 t 树具有相同结构和节点值.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSubtree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> t<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">isTreeEquals</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token operator">not</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> s <span class="token operator">and</span> t <span class="token operator">and</span> s<span class="token punctuation">.</span>val <span class="token operator">==</span> t<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> isTreeEquals<span class="token punctuation">(</span>s<span class="token punctuation">.</span>left<span class="token punctuation">,</span> t<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> isTreeEquals<span class="token punctuation">(</span>s<span class="token punctuation">.</span>right<span class="token punctuation">,</span> t<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> <span class="token operator">not</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token operator">not</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        queue <span class="token operator">=</span> <span class="token punctuation">[</span>s<span class="token punctuation">]</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            node <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> isTreeEquals<span class="token punctuation">(</span>node<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但实际上，这样做类似于串匹配中的BF暴力算法，如果要进行优化，可以使用类似于KMP思想。我们对于 s 树，求它的先序遍历序列，再将 t 的先序遍历序列作为模式串，使用KMP算法看 t 的序列是否是 s 的序列的子串。</p><p>需要注意，这样做的话，可以遇到特殊情况，比如 s 树由两个节点组成，2 是 1 的左孩子，而t 树也由两节点组成，2 是 1 的右孩子，这样尽管二者匹配，但其实不是我们要求的结果。</p><p>为了解决这个问题，我们可以引入两个空值 lNull 和 rNull，当一个节点的左孩子或者右孩子为空的时候，就插入这两个空值，这样 DFS 序列就唯一对应一棵树。</p><p><img src="572-1.png" alt="KMP"></p><h3 id="112题-路径总和"><a href="#112题-路径总和" class="headerlink" title="112题 路径总和"></a>112题 <a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">路径总和</a></h3><p><img src="112.png" alt="112"></p><h4 id="思路：-113"><a href="#思路：-113" class="headerlink" title="思路："></a>思路：</h4><p>递归判断，使用一个值存放当前路径上的值总和，先序遍历所有节点，如果遍历到了叶子节点，看路径和是否等于目标值，如果等于，返回True，且跳出之后所有递归，不等于则继续遍历。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>now_sum<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">:</span>                now_sum <span class="token operator">+=</span> root<span class="token punctuation">.</span>val<span class="token comment" spellcheck="true">#各函数内的now_sum独立，所以不需要显式回溯</span>                <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>left <span class="token operator">and</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                    <span class="token keyword">return</span> now_sum <span class="token operator">==</span> sum                <span class="token keyword">if</span> preorder<span class="token punctuation">(</span>now_sum<span class="token punctuation">,</span> root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>                <span class="token keyword">if</span> preorder<span class="token punctuation">(</span>now_sum<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> preorder<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="91题-解码方法"><a href="#91题-解码方法" class="headerlink" title="91题 解码方法"></a>91题 <a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">解码方法</a></h3><p><img src="91.png" alt="91"></p><h4 id="思路：-114"><a href="#思路：-114" class="headerlink" title="思路："></a>思路：</h4><p>这道题在剑指Offer上有原题，本质上是一个动态规划问题。状态矩阵dp[i] 为 s 串的前 i 个字符的解码方法数，它可以由dp[i-2] 和 dp[i-1] 转移而来（因为1个或2个数字可以解码为一个字符）</p><p>特别地，这题和剑指Offer的那题有一些细微的区别，因为单个数字’0’无法被解码成字母，所以要分类讨论一下。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numDecodings</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span> <span class="token keyword">if</span> s<span class="token operator">!=</span><span class="token string">'0'</span> <span class="token keyword">else</span> <span class="token number">0</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#第一个字符为0，无法被解码</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">if</span> s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'0'</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#第二个字符为0，则前两个字符的解码数目最大为1，如10</span>            dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">if</span> <span class="token number">10</span><span class="token operator">&lt;=</span>int<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">26</span> <span class="token keyword">else</span> <span class="token number">0</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">if</span> <span class="token number">10</span><span class="token operator">&lt;=</span>int<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">26</span> <span class="token keyword">else</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            a <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'0'</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token comment" spellcheck="true">#如果第i个数字为0，那么它无法被解码为字母加到前i-1个数字的解码组合后</span>            b <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span> <span class="token keyword">if</span> <span class="token number">10</span><span class="token operator">&lt;=</span>int<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">26</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token comment" spellcheck="true">#如果第i-1个和第i个数字不在10到26之间，那么它无法被解码为字母加到前i-2个数字的解码组合后</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a <span class="token operator">+</span> b            <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="203题-移除链表元素"><a href="#203题-移除链表元素" class="headerlink" title="203题 移除链表元素"></a>203题 <a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">移除链表元素</a></h3><p><img src="203.png" alt="203"></p><h4 id="思路：-115"><a href="#思路：-115" class="headerlink" title="思路："></a>思路：</h4><p>基础题，使用伪头结点+双指针求解。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> val<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        dummyhead <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token punctuation">)</span>        dummyhead<span class="token punctuation">.</span>next <span class="token operator">=</span> head        p <span class="token operator">=</span> dummyhead        q <span class="token operator">=</span> head        <span class="token keyword">while</span> q<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">if</span> q<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">:</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next                q <span class="token operator">=</span> p<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next                q <span class="token operator">=</span> q<span class="token punctuation">.</span>next        <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="110题-平衡二叉树"><a href="#110题-平衡二叉树" class="headerlink" title="110题 平衡二叉树"></a>110题 <a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">平衡二叉树</a></h3><p><img src="110.png" alt="110"></p><h4 id="思路：-116"><a href="#思路：-116" class="headerlink" title="思路："></a>思路：</h4><p>平衡二叉树的条件是：左子树和右子树均平衡，且左右子树高度差不大于1.</p><p>最简单的方法是递归判断左右子树是否平衡，然后调用求树的高度的函数判断左右子树高度差是否不大于1，但这样做很明显不好，因为判断左右子树是否平衡时，已经可以求出树的高度了，不需要重复递归两次。</p><p>我们可以这样做：</p><ul><li>当前子树为空树，返回0</li><li>当前子树为平衡二叉树，返回其高度</li><li>当前子树为非平衡二叉树，返回-1</li></ul><p>这样，我们在判断左右子树是否平衡的同时，还可以知道它们的高度，减少了重复遍历。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root <span class="token operator">==</span> None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            leftHeight <span class="token operator">=</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            rightHeight <span class="token operator">=</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> leftHeight <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">or</span> rightHeight <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">if</span> abs<span class="token punctuation">(</span>leftHeight<span class="token operator">-</span>rightHeight<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> max<span class="token punctuation">(</span>leftHeight<span class="token punctuation">,</span> rightHeight<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token boolean">False</span> <span class="token keyword">if</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">else</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-9-（2-medium-1-easy）"><a href="#2020-5-9-（2-medium-1-easy）" class="headerlink" title="2020.5.9 （2 medium 1 easy）"></a>2020.5.9 （2 medium 1 easy）</h2><h3 id="771题-宝石与石头"><a href="#771题-宝石与石头" class="headerlink" title="771题  宝石与石头"></a>771题 <a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener"> 宝石与石头</a></h3><p><img src="771.png" alt="771"></p><h4 id="思路：-117"><a href="#思路：-117" class="headerlink" title="思路："></a>思路：</h4><p>简单题，哈希表即可。遍历一遍石头，使用哈希表记录一下每种石头个数，再遍历一遍宝石，看宝石共有多少个。需要注意的是可以用defaultdict简化一下代码。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numJewelsInStones</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> J<span class="token punctuation">:</span> str<span class="token punctuation">,</span> S<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dic <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> S<span class="token punctuation">:</span>            dic<span class="token punctuation">[</span>ch<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> J<span class="token punctuation">:</span>            res <span class="token operator">+=</span> dic<span class="token punctuation">[</span>ch<span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1248题-统计「优美子数组」"><a href="#1248题-统计「优美子数组」" class="headerlink" title="1248题 统计「优美子数组」"></a>1248题 <a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">统计「优美子数组」</a></h3><p><img src="1248.png" alt="1248"></p><h4 id="思路：-118"><a href="#思路：-118" class="headerlink" title="思路："></a>思路：</h4><p>可以使用两种方法求解，一是滑动窗口法，二是前缀和。</p><p>这题的滑动窗口思路很难想。</p><ul><li><p>不断右移 right 指针来扩大滑动窗口，使其包含 k 个奇数；</p></li><li><p>若当前滑动窗口包含了 k 个奇数，则如下「计算当前窗口的优美子数组个数」：</p><ul><li>统计第 1 个奇数左边的偶数个数 leftEvenCnt。 这 leftEvenCnt 个偶数都可以作为「优美子数组」的起点，因此起点的选择有 leftEvenCnt + 1 种（因为可以一个偶数都不取，因此别忘了 +1 喔）。</li><li>统计第 k 个奇数右边的偶数个数 rightEvenCnt 。 这 rightEvenCnt 个偶数都可以作为「优美子数组」的终点，因此终点的选择有 rightEvenCnt + 1 种（因为可以一个偶数都不取，因此别忘了 +1 喔）。<br>因此「优美子数组」左右起点的选择组合数为 (leftEvenCnt + 1) * (rightEvenCnt + 1)。</li></ul></li><li><p>我们通过不断右移左右指针来统计上述 leftEvenCnt 和 rightEvenCnt，这样统计完成后，左指针指向下一个包含 k 个奇数的区间的开头，右指针指向下一个包含 k 个奇数的区间的最后一个奇数。继续循环统计即可。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numberOfSubarrays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> <span class="token number">0</span>        count <span class="token operator">=</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                count <span class="token operator">+=</span> <span class="token number">1</span>            right <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> count <span class="token operator">==</span> k<span class="token punctuation">:</span>                rightCount <span class="token operator">=</span> <span class="token number">0</span>                <span class="token keyword">while</span> right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    rightCount <span class="token operator">+=</span> <span class="token number">1</span>                    right <span class="token operator">+=</span> <span class="token number">1</span>                leftCount <span class="token operator">=</span> <span class="token number">0</span>                <span class="token keyword">while</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    leftCount <span class="token operator">+=</span> <span class="token number">1</span>                    left <span class="token operator">+=</span> <span class="token number">1</span>                res <span class="token operator">+=</span> <span class="token punctuation">(</span>leftCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>rightCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                left <span class="token operator">+=</span> <span class="token number">1</span>                count <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种好理解一些的方法是使用前缀和来求解。前缀和可以用于求解数组或者树甚至图上的一段路径和。这种题目我们之前也做过一些，例如560题和为k的子数组。这道题我们只要稍微修改前缀和的定义，将prefixSum[i]定义为前 i 个元素中共有几个奇数，那么从第 i 个元素到第 j 个元素之间的奇数个数为：prefixSum[j] - prefixSum[i]。我们还可以使用560题中的哈希表方法进行优化。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numberOfSubarrays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        prefixSum <span class="token operator">=</span> <span class="token number">0</span>        dic <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        dic<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> num<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">:</span>                prefixSum <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> prefixSum<span class="token operator">-</span>k <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                res <span class="token operator">+=</span> dic<span class="token punctuation">[</span>prefixSum<span class="token operator">-</span>k<span class="token punctuation">]</span>            dic<span class="token punctuation">[</span>prefixSum<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1111题-有效括号的嵌套深度"><a href="#1111题-有效括号的嵌套深度" class="headerlink" title="1111题 有效括号的嵌套深度"></a>1111题 <a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/" target="_blank" rel="noopener">有效括号的嵌套深度</a></h3><p><img src="1111.png" alt="1111"></p><h4 id="思路：-119"><a href="#思路：-119" class="headerlink" title="思路："></a>思路：</h4><p>这道题的本质思想就是让A、B两个字符串的括号深度尽可能小，也就是让二者的括号深度尽可能平均。所谓括号深度，就是括号生成中辅助栈的最大深度（参考20题），按照以往的方法，我们可以用数字来代替。所以我们可以遍历seq串并进行如下划分：</p><ul><li>如果当前为左括号：<ul><li>如果当前A串的括号深度大于B串，那么就将当前的左括号分配给B串，B串括号深度加1</li><li>否则，将当前左括号分配给A串，A串括号深度加1</li></ul></li><li>如果当前为右括号：<ul><li>如果当前A串括号深度大于B串，那么优先降A串的深度，将当前右括号分配给A，A串括号深度减1</li><li>否则，将当前右括号分配给B串，B串括号深度减1</li></ul></li></ul><p>这样做，尽可能保证了二者深度的平均。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxDepthAfterSplit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> seq<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        a <span class="token operator">=</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">#这是深度，初始都是0</span>        <span class="token keyword">for</span> s <span class="token keyword">in</span> seq<span class="token punctuation">:</span>            <span class="token keyword">if</span> s <span class="token operator">==</span> <span class="token string">"("</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> a<span class="token operator">></span>b<span class="token punctuation">:</span>                    ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                    b <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                    a <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> a<span class="token operator">></span>b<span class="token punctuation">:</span>                    ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                    a <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                    b <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> ans<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-10-（2-medium-3-easy）"><a href="#2020-5-10-（2-medium-3-easy）" class="headerlink" title="2020.5.10 （2 medium 3 easy）"></a>2020.5.10 （2 medium 3 easy）</h2><h3 id="542题-01-矩阵"><a href="#542题-01-矩阵" class="headerlink" title="542题  01 矩阵"></a>542题 <a href="https://leetcode-cn.com/problems/01-matrix/" target="_blank" rel="noopener"> 01 矩阵</a></h3><p><img src="542.png" alt="542"></p><h4 id="思路：-120"><a href="#思路：-120" class="headerlink" title="思路："></a>思路：</h4><p>这道题，本质上是之前做过的1162题地图分析的翻版。我们可以把0看作是陆地，1看作是海洋，那么求解每个1到0的最短距离，就等于求解海洋到陆地的最短距离。我们可以用BFS或者动态规划求解。</p><p>这里我们选择动态规划，与1162题一样，依然是两次遍历，因为状态转移来自四个方向上，无法一次遍历得到。</p><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n^2)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">updateMatrix</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                    pre1 <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span>                    pre2 <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">></span><span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>pre1<span class="token punctuation">,</span> pre2<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                    pre1 <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">if</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span>                    pre2 <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>pre1<span class="token punctuation">,</span> pre2<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> dp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DFS的应用场景：求最长的路径。</p><p>BFS的应用场景：求最短的路径。</p><h3 id="509题-斐波那契数"><a href="#509题-斐波那契数" class="headerlink" title="509题  斐波那契数"></a>509题 <a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener"> 斐波那契数</a></h3><p><img src="542.png" alt="542"></p><h4 id="思路：-121"><a href="#思路：-121" class="headerlink" title="思路："></a>思路：</h4><p>算法题中的经典题。没什么好说的，和跳台阶问题类似，动态规划即可，因为递归的话会带来许多重复的子问题。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> N<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> N <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> N <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="983题-最低票价"><a href="#983题-最低票价" class="headerlink" title="983题 最低票价"></a>983题 <a href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/" target="_blank" rel="noopener">最低票价</a></h3><p><img src="983.png" alt="983"></p><h4 id="思路：-122"><a href="#思路：-122" class="headerlink" title="思路："></a>思路：</h4><p>这道题，我首先想到的是DFS，因为这个最好想，递归来做。但这样做时间复杂度很高，因为会有重叠的子问题。我使用了带备忘录的递归进行剪枝，依然只能通过60%的测试用例。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mincostTickets</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> days<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> costs<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>min_price <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span>        dic <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>paths<span class="token punctuation">,</span> days<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> days <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>min_price <span class="token operator">=</span> min<span class="token punctuation">(</span>self<span class="token punctuation">.</span>min_price<span class="token punctuation">,</span> sum<span class="token punctuation">(</span>paths<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">elif</span> tuple<span class="token punctuation">(</span>days<span class="token punctuation">)</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">and</span> sum<span class="token punctuation">(</span>paths<span class="token punctuation">)</span><span class="token operator">>=</span>dic<span class="token punctuation">[</span>tuple<span class="token punctuation">(</span>days<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span>             <span class="token keyword">else</span><span class="token punctuation">:</span>                dic<span class="token punctuation">[</span>tuple<span class="token punctuation">(</span>days<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">(</span>paths<span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>costs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                        dfs<span class="token punctuation">(</span>paths<span class="token operator">+</span><span class="token punctuation">[</span>costs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> days<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token keyword">elif</span> i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>days<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                            <span class="token keyword">if</span> j<span class="token operator">==</span>len<span class="token punctuation">(</span>days<span class="token punctuation">)</span> <span class="token operator">or</span> days<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> days<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">7</span><span class="token punctuation">:</span>                                <span class="token keyword">break</span>                        dfs<span class="token punctuation">(</span>paths<span class="token operator">+</span><span class="token punctuation">[</span>costs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> days<span class="token punctuation">[</span>j<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token keyword">elif</span> i <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>                        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>days<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                            <span class="token keyword">if</span> j<span class="token operator">==</span>len<span class="token punctuation">(</span>days<span class="token punctuation">)</span> <span class="token operator">or</span> days<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> days<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>=</span><span class="token number">30</span><span class="token punctuation">:</span>                                <span class="token keyword">break</span>                        dfs<span class="token punctuation">(</span>paths<span class="token operator">+</span><span class="token punctuation">[</span>costs<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> days<span class="token punctuation">[</span>j<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        dfs<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> days<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>min_price<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>于是，我们要开始考虑动态规划问题。我们这里设动态规划状态矩阵dp[i]为前 i 天旅行的最低消费，由于提前买票必然会导致通行证天数的浪费，所以我们只需要在旅行的那天买票即可。</p><p>如果我们在第一天付套票的钱，那么我们付钱时需要考虑后面几天的出行情况才好决定是否付款，所以只能逆推，很难理解。这里我们可以改为最后一天付钱，就可以通过之前的出现情况顺推了。</p><p>动态规划转移方程为：</p><ul><li>dp[i] = dp[i-1] ，如果第 i 天不需要出行，则花费保持不变；</li><li>dp[i] = min（dp[i-1]+cost[0]，dp[i-7]+cost[1]，dp[i-30]+cost[2]），如果当前需要出行，则需要考虑之前买的是三种套票的哪一种</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mincostTickets</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> days<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> costs<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>days<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> days<span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span><span class="token punctuation">[</span>dp<span class="token punctuation">[</span>max<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>max<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token number">-7</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>max<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token number">-30</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1108题-IP-地址无效化"><a href="#1108题-IP-地址无效化" class="headerlink" title="1108题 IP 地址无效化"></a>1108题 <a href="https://leetcode-cn.com/problems/defanging-an-ip-address/" target="_blank" rel="noopener">IP 地址无效化</a></h3><p><img src="1108.png" alt="1108"></p><h4 id="思路：-123"><a href="#思路：-123" class="headerlink" title="思路："></a>思路：</h4><p>没啥好讲的，用字符串模拟一个StringBuffer往里加就行了，遇到“.”修改一下。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">defangIPaddr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> address<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token string">""</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> address<span class="token punctuation">:</span>            <span class="token keyword">if</span> ch <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">:</span>                res<span class="token operator">+=</span><span class="token string">'[.]'</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res<span class="token operator">+=</span>ch        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="108题-将有序数组转换为二叉搜索树"><a href="#108题-将有序数组转换为二叉搜索树" class="headerlink" title="108题 将有序数组转换为二叉搜索树"></a>108题 <a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">将有序数组转换为二叉搜索树</a></h3><p><img src="108.png" alt="108"></p><h4 id="思路：-124"><a href="#思路：-124" class="headerlink" title="思路："></a>思路：</h4><p>因为我们要转化的是二叉搜索树，并且是平衡的，我们可以对有序数组进行二分处理，递归生成平衡二叉搜索树。</p><p>因为二分处理可以让左子树节点数目和右子树节点数目尽可能相等，也就保证了高度平衡。</p><p>我们让中位数作为平衡二叉树的根节点，利用左半数组递归构造左子树，利用右半数组递归构造右子树，保证了左子树中的元素均小于根节点，右子树中的元素均大于根节点。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> left<span class="token operator">></span>right<span class="token punctuation">:</span>                <span class="token keyword">return</span> None            mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>left <span class="token operator">=</span> build<span class="token punctuation">(</span>left<span class="token punctuation">,</span> mid<span class="token number">-1</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>right <span class="token operator">=</span> build<span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token keyword">return</span> build<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-11-（3-easy，2-medium）"><a href="#2020-5-11-（3-easy，2-medium）" class="headerlink" title="2020.5.11 （3 easy，2 medium）"></a>2020.5.11 （3 easy，2 medium）</h2><h3 id="392题-判断子序列"><a href="#392题-判断子序列" class="headerlink" title="392题 判断子序列"></a>392题 <a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">判断子序列</a></h3><p><img src="392.png" alt="392"></p><h4 id="思路：-125"><a href="#思路：-125" class="headerlink" title="思路："></a>思路：</h4><p>我首先尝试了动态规划的解法，发现超时了。但应该是可以优化的，但动态规划方法时间复杂度为$O(len(s)*len(t))$，很不好。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i <span class="token operator">&lt;=</span> j <span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>j<span class="token operator">></span>i <span class="token operator">and</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>t<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">and</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这题其实不需要使用动态规划，我们可以使用双指针法求解。我们使用一个指针p遍历s串，一个指针q遍历t串，当s[p]等于t[q]时，我们可以让两个指针同时后移一个单位，否则，我们只移动q指针进行搜索。</p><p>这样，时间复杂度被我们降到了$O(len(t))$，且不需要额外的空间。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        p<span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">while</span> p <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">and</span> q <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">:</span>                p <span class="token operator">+=</span> <span class="token number">1</span>                q <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                q <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> p <span class="token operator">==</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以使用python的find函数，因为可以动态规划find函数的起始位置，所以可以这么写：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> s <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        l <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>            l <span class="token operator">=</span> t<span class="token punctuation">.</span>find<span class="token punctuation">(</span>ch<span class="token punctuation">,</span> l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> l <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="113题-路径总和-II"><a href="#113题-路径总和-II" class="headerlink" title="113题 路径总和 II"></a>113题 <a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">路径总和 II</a></h3><p><img src="113.png" alt="113"></p><h4 id="思路：-126"><a href="#思路：-126" class="headerlink" title="思路："></a>思路：</h4><p>这道题和之前做过的路径总和1几乎没有区别，同样是使用DFS+回溯的思想来做，唯一的区别是递归时需要保存一下当前路径，如果路径和等于目标值，那么将当前路径加入到结果列表中。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> path<span class="token punctuation">,</span> now_sum<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">:</span>                <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token operator">==</span> None <span class="token operator">and</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> None<span class="token punctuation">:</span>                    <span class="token keyword">if</span> now_sum <span class="token operator">==</span> sum<span class="token punctuation">:</span>                        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">)</span>                <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                    dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> path<span class="token operator">+</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">,</span> now_sum<span class="token operator">+</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                    dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> path<span class="token operator">+</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">,</span> now_sum<span class="token operator">+</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token punctuation">:</span>            dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="349题-两个数组的交集"><a href="#349题-两个数组的交集" class="headerlink" title="349题 两个数组的交集"></a>349题 <a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">两个数组的交集</a></h3><p><img src="349.png" alt="349"></p><h4 id="思路：-127"><a href="#思路：-127" class="headerlink" title="思路："></a>思路：</h4><p>可以使用哈希集合来做。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">intersection</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> list<span class="token punctuation">(</span>set<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span> <span class="token operator">&amp;</span> set<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：由于哈希集合操作的时间复杂度都为$O(1)$，所以本题的时间复杂度仅需考虑列表与集合转化的时间复杂度，为$O(M+N)$</li></ul><p>也可先将两个数组排序，使用双指针进行遍历查找。时间复杂度略高，因为要排序。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">intersection</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        nums1<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        nums2<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        p<span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        res <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> p<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span> <span class="token operator">and</span> q<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">:</span>                p <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">==</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>add<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span>                p <span class="token operator">+=</span> <span class="token number">1</span>                q <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                q <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> list<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="350题-两个数组的交集-II"><a href="#350题-两个数组的交集-II" class="headerlink" title="350题 两个数组的交集 II"></a>350题 <a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">两个数组的交集 II</a></h3><p><img src="350.png" alt="350"></p><h4 id="思路：-128"><a href="#思路：-128" class="headerlink" title="思路："></a>思路：</h4><p>最简单的方式是两次循环遍历，时间复杂度很高，平均时间复杂度约为：$O(mn)$。代码如下所示：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">intersect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> idx1<span class="token punctuation">,</span> num1 <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> idx2<span class="token punctuation">,</span> num2 <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> num1 <span class="token operator">==</span> num2<span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num1<span class="token punctuation">)</span>                    nums2<span class="token punctuation">[</span>idx2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>                    <span class="token keyword">break</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了进行优化，我们可以使用哈希表。我们先遍历一遍nums1，记录下nums1中各数字及出现次数。然后再遍历nums2，如果nums2中的某个数字在nums1中出现了，且出现次数大于0，我们就将其加入到结果数组中，并将其出现次数减1。</p><p>由于哈希表的操作都为$O(1)$的时间复杂度，那么平均时间复杂度为：$O(m+n)$。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">intersect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        dic <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> num1 <span class="token keyword">in</span> nums1<span class="token punctuation">:</span>            dic<span class="token punctuation">[</span>num1<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> num2 <span class="token keyword">in</span> nums2<span class="token punctuation">:</span>            <span class="token keyword">if</span> num2 <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">and</span> dic<span class="token punctuation">[</span>num2<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num2<span class="token punctuation">)</span>                dic<span class="token punctuation">[</span>num2<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>如果两个数组没有排好序，那么我们可以使用上一问中的双指针法先排序再进行游走搜索，平均时间复杂度约为$O(nlogn+mlogm+m+n)$，即为$O(max(nlogn,mlogm,m+n))$。如果排好序，那么时间复杂度直接为$O(m+n)$。</p></li><li><p>如果nums1的大小远小于nums2，那么m可以忽略不记。即哈希表的方法时间复杂度为$O(n)$，而排序的方法为$O(nlogn)$，所以哈希表方法更省时间。但如果数组已提前排好序，那么排序的方法也将是$O(n)$。</p></li><li><p>如果nums2的元素存放在磁盘上，且容量很大，超过了内存大小。</p><ul><li>我们如果要使用哈希表，它需要$O(min(m,n))$的额外空间，那么可以先将nums1的元素及出现次数使用哈希表统计出来。然后，我们按顺序将nums2的元素分成多个小文件，并按序读入内存，与哈希表中的元素相比较，并将结果追加写入磁盘中的某个文件中。</li><li>我们如果要使用排序的做法，只能对nums2的元素进行多路归并排序，因为nums2位于外存，我们只能使用外部排序，而归并排序天然适用。然后再用双指针法遍历文件求解即可。（ <a href="https://blog.csdn.net/ailunlee/article/details/84548950" target="_blank" rel="noopener">https://blog.csdn.net/ailunlee/article/details/84548950</a> ）</li></ul></li></ul><h3 id="93题-复原IP地址"><a href="#93题-复原IP地址" class="headerlink" title="93题 复原IP地址"></a>93题 <a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">复原IP地址</a></h3><p><img src="93.png" alt="93"></p><h4 id="思路：-129"><a href="#思路：-129" class="headerlink" title="思路："></a>思路：</h4><p>这道题我们可以使用DFS+回溯的思想来做，递归的终止条件为当前组合了四个数字。如果这四个数字能够完全划分IP地址串，那么就可以将它们加入结果列表。</p><p>每次DFS，我们选择当前IP串的开头前1个到前3个数字分别尝试进行分解。特别地，对于需要回溯的函数变量，我们在传参时对它们进行修改即可，这样不需要显式地回溯，性能更好。（如果是全局变量，仍然需要显式回溯）</p><p>特别地，我们需要进行剪枝，判断当前分解的数字：（1）是否位于0-255之间（除了0以外，开头是0的数字不算）（2）分解后剩余的数字是否还可能被分解。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">restoreIpAddresses</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> s<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> num <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> s <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">)</span>            <span class="token keyword">elif</span> num <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> min<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>int<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">255</span> <span class="token operator">and</span> str<span class="token punctuation">(</span>int<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span>s<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">3</span><span class="token operator">-</span>num<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">3</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">-</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>                        dfs<span class="token punctuation">(</span>path<span class="token operator">+</span><span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        dfs<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">"."</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> res<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="93-1.png" alt="回溯"></p><h2 id="2020-5-12（3-easy，1-medium，1-hard）"><a href="#2020-5-12（3-easy，1-medium，1-hard）" class="headerlink" title="2020.5.12（3 easy，1 medium，1 hard）"></a>2020.5.12（3 easy，1 medium，1 hard）</h2><h3 id="119题-杨辉三角-II"><a href="#119题-杨辉三角-II" class="headerlink" title="119题 杨辉三角 II"></a>119题 <a href="https://leetcode-cn.com/problems/pascals-triangle-ii/" target="_blank" rel="noopener">杨辉三角 II</a></h3><p><img src="119.png" alt="119"></p><h4 id="思路：-130"><a href="#思路：-130" class="headerlink" title="思路："></a>思路：</h4><p>这道题本质上和之前的杨辉三角问题没有任何区别，都是动态规划思想。特别注意的是空间复杂度要求，我们要使用滚动数组的方式来进行状态压缩。</p><p>需要注意的是：状态压缩时，由于动态规划需要用到子问题的状态，为了防止对状态矩阵的修改覆盖掉仍需要使用的状态，我们应从后向前进行状态转移。</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">getRow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> rowIndex<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> rowIndex <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> rowIndex <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>rowIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> rowIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">return</span> dp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="268题-缺失数字"><a href="#268题-缺失数字" class="headerlink" title="268题  缺失数字"></a>268题 <a href="https://leetcode-cn.com/problems/missing-number/" target="_blank" rel="noopener"> 缺失数字</a></h3><p><img src="268.png" alt="268"></p><h4 id="思路：-131"><a href="#思路：-131" class="headerlink" title="思路："></a>思路：</h4><p>这道题和之前的一道题“第一个缺失的数字”有着类似之处。本题中，我们可以直接进行原地哈希，空间复杂度仅需$O(1)$，空间复杂度为$O(n)$。</p><p>需要注意的是，这里的交换必须使用tmp变量来辅助。如果直接用python的a,b=b,a来做，由于涉及下标运算，会出错。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>                nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">!=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> i        <span class="token keyword">return</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，一个更为巧妙的方法是：我们可以让0到n的数字累加起来，减去当前数组中的数，所得结果即为缺失的值。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> i            res <span class="token operator">-=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span class="token operator">+</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，使用和相减的方法在其它语言中可能存在数据溢出的问题。我们可以通过位运算异或求解。假设我们有一个数组，包含0-n和nums中所有的数，那么除了缺失的那个数字出现了一次外，其余所有数字都出现了两次。那么问题转变为位运算的经典问题：只出现一次的数字。只要全部异或即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">^</span><span class="token operator">=</span> i            res <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span class="token operator">^</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="LCP01-猜数字"><a href="#LCP01-猜数字" class="headerlink" title="LCP01 猜数字"></a>LCP01 <a href="https://leetcode-cn.com/problems/guess-numbers/" target="_blank" rel="noopener">猜数字</a></h3><p><img src="LCP-01.png" alt="LCP01"></p><h4 id="思路：-132"><a href="#思路：-132" class="headerlink" title="思路："></a>思路：</h4><p>太简单了，不应该做的</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">game</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> guess<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> answer<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> answer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> guess<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                res <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1095题-山脉数组中查找目标值"><a href="#1095题-山脉数组中查找目标值" class="headerlink" title="1095题 山脉数组中查找目标值"></a>1095题 <a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">山脉数组中查找目标值</a></h3><p><img src="1095.png" alt="1095"></p><h4 id="思路：-133"><a href="#思路：-133" class="headerlink" title="思路："></a>思路：</h4><p>查找问题，想要降低时间复杂度，通常是利用二分查找。</p><p>本题我起初尝试了使用特殊的判断加上一次二分查找，发现无法通过全部的数据，必须要先找到山峰的位置。</p><p>所以，我们这道题这么做：</p><ul><li><p>一次二分查找，找到山峰：</p><ul><li><p>对于一个范围 [i, j]，我们可以先找到范围 [i, j] 中间连续的两个点 mid 与 mid + 1。如果 mountainArr.get(mid + 1) &gt; mountainArr.get(mid)，那么可以知道峰值在范围 [mid + 1, j] 内；如果 mountainArr.get(mid + 1) &lt; mountainArr.get(mid)，那么可以知道峰值在范围 [i, mid] 内。通过这样的方法，我们可以在 O(logn) 的时间内找到峰值所处的下标。</p></li><li><p><img src="1095-1.png" alt="找山峰"></p></li></ul></li><li><p>当我们找到了山峰，即可将山脉数组划分为两个有序的数组，我们只要进行两次二分查找就行了。特别地，二分查找内部要进行一点修改，分类讨论升序和降序的情况。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># </span><span class="token triple-quoted-string string">"""# This is MountainArray's API interface.# You should not implement it, or speculate about its implementation# """</span><span class="token comment" spellcheck="true">#class MountainArray:</span><span class="token comment" spellcheck="true">#    def get(self, index: int) -> int:</span><span class="token comment" spellcheck="true">#    def length(self) -> int:</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findInMountainArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">,</span> mountain_arr<span class="token punctuation">:</span> <span class="token string">'MountainArray'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">binarysearch</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> flag<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#二分查找</span>            <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>                mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>                midVal <span class="token operator">=</span> mountain_arr<span class="token punctuation">.</span>get<span class="token punctuation">(</span>mid<span class="token punctuation">)</span>                <span class="token keyword">if</span> midVal <span class="token operator">==</span> target<span class="token punctuation">:</span>                    <span class="token keyword">return</span> mid                <span class="token keyword">elif</span> midVal <span class="token operator">></span> target<span class="token punctuation">:</span>                    <span class="token keyword">if</span> flag<span class="token punctuation">:</span>                        right <span class="token operator">=</span> mid <span class="token operator">-</span><span class="token number">1</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> flag<span class="token punctuation">:</span>                        left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        right <span class="token operator">=</span> mid <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">def</span> <span class="token function">findPeak</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#找山峰</span>            <span class="token keyword">while</span> left<span class="token operator">&lt;</span>right<span class="token punctuation">:</span>                mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>                d <span class="token operator">=</span> mountain_arr<span class="token punctuation">.</span>get<span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> mountain_arr<span class="token punctuation">.</span>get<span class="token punctuation">(</span>mid<span class="token punctuation">)</span>                <span class="token keyword">if</span> d <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>                    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    right <span class="token operator">=</span> mid            <span class="token keyword">return</span> left        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> mountain_arr<span class="token punctuation">.</span>length<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        peak <span class="token operator">=</span> findPeak<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>        res <span class="token operator">=</span> binarysearch<span class="token punctuation">(</span>left<span class="token punctuation">,</span> peak<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> res<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> res        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> binarysearch<span class="token punctuation">(</span>peak<span class="token punctuation">,</span> right<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="80题-删除排序数组中的重复项-II"><a href="#80题-删除排序数组中的重复项-II" class="headerlink" title="80题 删除排序数组中的重复项 II"></a>80题 <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">删除排序数组中的重复项 II</a></h3><p> <img src="80.png" alt="80"></p><h4 id="思路：-134"><a href="#思路：-134" class="headerlink" title="思路："></a>思路：</h4><p>这题和之前的第1题1的区别仅仅在于：本题允许保留一个重复数字。我们依然可以使用之前所用的快慢双指针法，但需要额外添加一个标志位。快指针每次遇到新的数字，都要将标志位置True，表示允许新数字重复一次。如果遇到重复的数字后，当前标志位为True，那么将该数字插入慢指针维护的子序列，之后将标志位置False。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        flag <span class="token operator">=</span> <span class="token boolean">True</span>        slow <span class="token operator">=</span> <span class="token number">0</span>        fast <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> fast<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token operator">!=</span>nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token punctuation">:</span>                slow <span class="token operator">+=</span> <span class="token number">1</span>                nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span>                flag <span class="token operator">=</span> <span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> flag<span class="token punctuation">:</span>                    slow <span class="token operator">+=</span> <span class="token number">1</span>                    nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span>                    flag <span class="token operator">=</span> <span class="token boolean">False</span>            fast <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> slow <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-13（1-hard-3-easy）"><a href="#2020-5-13（1-hard-3-easy）" class="headerlink" title="2020.5.13（1 hard 3 easy）"></a>2020.5.13（1 hard 3 easy）</h2><h3 id="140题-单词拆分-II"><a href="#140题-单词拆分-II" class="headerlink" title="140题 单词拆分 II"></a>140题 <a href="https://leetcode-cn.com/problems/word-break-ii/" target="_blank" rel="noopener">单词拆分 II</a></h3><p><img src="140.png" alt="140"></p><h4 id="思路：-135"><a href="#思路：-135" class="headerlink" title="思路："></a>思路：</h4><p>这道题和139题类似，如果直接使用DFS必然超时，因为存在着许多重叠的子问题，可以使用带备忘录的DFS，但也并不是很好。</p><p>较好的方法依然是使用动态规划。不过为了方便起见，dp[i]被设置为一个列表，存放的是截止到第 i 个字符的拆分结果。状态转移方程为：</p><ul><li>从之前的某个字符 start 到当前字符 i 的一个字符串在词典中，我们就让s[start:i+1]与dp[start-1]中的拆分结果进行组合，生成新的字符串。需要特判一下start等于0的情况。</li></ul><p>特别地，如果词典使用列表，查询时间复杂度是线性的，我们需要改为哈希表，从而降为常数级别。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> wordDict<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>minLen<span class="token punctuation">,</span> maxLen<span class="token punctuation">,</span> wordSet<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>minLen<span class="token punctuation">,</span> maxLen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    start<span class="token operator">=</span>i<span class="token operator">-</span>j                    <span class="token keyword">if</span>  start<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> dp<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>start<span class="token punctuation">:</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> wordSet<span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                        <span class="token keyword">break</span>            <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> wordDict<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        tmp <span class="token operator">=</span> <span class="token punctuation">[</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token keyword">for</span> word <span class="token keyword">in</span> wordDict<span class="token punctuation">]</span>        minLen <span class="token operator">=</span> min<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>        maxLen <span class="token operator">=</span> max<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>        wordSet <span class="token operator">=</span> set<span class="token punctuation">(</span>wordDict<span class="token punctuation">)</span>        <span class="token keyword">if</span> isValid<span class="token punctuation">(</span>minLen<span class="token punctuation">,</span> maxLen<span class="token punctuation">,</span> wordSet<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>minLen<span class="token punctuation">,</span> maxLen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    start <span class="token operator">=</span> i <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">1</span>                    <span class="token keyword">if</span> start<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> s<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">in</span> wordSet<span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token keyword">if</span> start<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> dp<span class="token punctuation">[</span>start<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>start<span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">in</span> wordSet<span class="token punctuation">:</span>                        <span class="token keyword">for</span> st <span class="token keyword">in</span> dp<span class="token punctuation">[</span>start<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>st<span class="token operator">+</span><span class="token string">' '</span><span class="token operator">+</span>s<span class="token punctuation">[</span>start<span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，我们需要调用139题的函数，提前预判一下字符串是否可拆分，否则会超时。</p><h3 id="1365题-有多少小于当前数字的数字"><a href="#1365题-有多少小于当前数字的数字" class="headerlink" title="1365题 有多少小于当前数字的数字"></a>1365题 <a href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/" target="_blank" rel="noopener">有多少小于当前数字的数字</a></h3><p><img src="1365.png" alt="1365"></p><h4 id="思路：-136"><a href="#思路：-136" class="headerlink" title="思路："></a>思路：</h4><p>这道题我们很容易想到$O(n^2)$的暴力解法，但是很费时间。</p><p>较好的做法是使用计数排序的思想，因为0&lt;=nums[i]&lt;=100，所以可以只开一个长度为101的数组，存放下标对应数字在nums中出现的次数。然后通过一次累加遍历即可求出每个数字在数组中比它小的所有数字的数目。接着修改原nums的值为对应数目即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">smallerNumbersThanCurrent</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            arr<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> count            count <span class="token operator">+=</span> tmp        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$</li></ul><h3 id="1281题-整数的各位积和之差"><a href="#1281题-整数的各位积和之差" class="headerlink" title="1281题  整数的各位积和之差"></a>1281题 <a href="https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/" target="_blank" rel="noopener"> 整数的各位积和之差</a></h3><p><img src="1281.png" alt="1281"></p><h4 id="思路：-137"><a href="#思路：-137" class="headerlink" title="思路："></a>思路：</h4><p>没啥好说的，最基础的题目，</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">subtractProductAndSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        sum<span class="token punctuation">,</span> time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> str<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            now <span class="token operator">=</span> int<span class="token punctuation">(</span>ch<span class="token punctuation">)</span>            sum <span class="token operator">+=</span> now            time <span class="token operator">*=</span> now        <span class="token keyword">return</span> time <span class="token operator">-</span> sum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="232题-用栈实现队列"><a href="#232题-用栈实现队列" class="headerlink" title="232题 用栈实现队列"></a>232题 <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">用栈实现队列</a></h3><p><img src="232.png" alt="232"></p><h4 id="思路：-138"><a href="#思路：-138" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，辅助栈实现倒序，从而取出栈底也就是队尾元素。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>stack1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>stack2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Push element x to the back of queue.        """</span>        self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Removes the element from in front of queue and returns that element.        """</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack2 <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">:</span>                <span class="token keyword">while</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">peek</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Get the front element.        """</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack2 <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">:</span>                <span class="token keyword">while</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Returns whether the queue is empty.        """</span>        <span class="token keyword">return</span> <span class="token operator">not</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack1<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">or</span> self<span class="token punctuation">.</span>stack2<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Your MyQueue object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MyQueue()</span><span class="token comment" spellcheck="true"># obj.push(x)</span><span class="token comment" spellcheck="true"># param_2 = obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.peek()</span><span class="token comment" spellcheck="true"># param_4 = obj.empty()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-14（3-easy，2-medium）"><a href="#2020-5-14（3-easy，2-medium）" class="headerlink" title="2020.5.14（3 easy，2 medium）"></a>2020.5.14（3 easy，2 medium）</h2><h3 id="86题-分隔链表"><a href="#86题-分隔链表" class="headerlink" title="86题 分隔链表"></a>86题 <a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">分隔链表</a></h3><p><img src="86.png" alt="86"></p><h4 id="思路：-139"><a href="#思路：-139" class="headerlink" title="思路："></a>思路：</h4><p>这道题我一开始以为和数组的快排partition类似，要用双指针进行swap。后来发现其实不需要。链表的快排更加方便，因为只要修改指针，不需要新建节点，所以不用考虑新建数组所带来的空间占用问题。</p><p>我们只需新建两个虚头节点，用来新建两个队列，一个用于存放小于x的节点，一个用于存放大于等于x的节点。再次强调我们只需要修改对应节点的指针即可放入对应的队列，所以不占用额外空间。类似于链表的mergesort。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        dummyhead1 <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token punctuation">)</span>        dummyhead2 <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token punctuation">)</span>        p<span class="token punctuation">,</span> q <span class="token operator">=</span>dummyhead1<span class="token punctuation">,</span> dummyhead2        r <span class="token operator">=</span> head        <span class="token keyword">while</span> r <span class="token punctuation">:</span>            <span class="token keyword">if</span> r<span class="token punctuation">.</span>val <span class="token operator">>=</span> x<span class="token punctuation">:</span>                q<span class="token punctuation">.</span>next <span class="token operator">=</span> r                q <span class="token operator">=</span> q<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> r                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next            r <span class="token operator">=</span> r<span class="token punctuation">.</span>next        q<span class="token punctuation">.</span>next <span class="token operator">=</span> None        p<span class="token punctuation">.</span>next <span class="token operator">=</span> dummyhead2<span class="token punctuation">.</span>next        <span class="token keyword">return</span> dummyhead1<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别注意，两个队列最后一个节点的尾指针必须置None，否则可能出现环。最后将二者合并即可。</p><h3 id="355题-设计推特"><a href="#355题-设计推特" class="headerlink" title="355题 设计推特"></a>355题 <a href="https://leetcode-cn.com/problems/design-twitter/" target="_blank" rel="noopener">设计推特</a></h3><p> <img src="355.png" alt="355"></p><h4 id="思路：-140"><a href="#思路：-140" class="headerlink" title="思路："></a>思路：</h4><p>这道题挺有意思的，以实际场景来进行数据结构的设计，虽然不难，但也可以思考许多东西。</p><p>其实在这道题里，设计数据结构有些类似于我们实际开发过程中设计的数据库表。首先，我们必须有一张表存放着所有推特记录，这里我们使用一个栈来模拟，因为推特是有时间顺序的，且是先进后出（优先获取最新的推特）。其次，我们必须有一张表存放着所有用户相互关注的信息，这里我们使用一个哈希集合列表来模拟，因为哈希集合的查找时间在$O(1)$，我们可以快速知道某条推特的用户是否为当前用户的关注对象，并且不会重复关注人。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">Twitter</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>twitters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>users <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>set<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">postTweet</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> userId<span class="token punctuation">:</span> int<span class="token punctuation">,</span> tweetId<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Compose a new tweet.        """</span>        self<span class="token punctuation">.</span>twitters<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>userId<span class="token punctuation">,</span>tweetId<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">getNewsFeed</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> userId<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.        """</span>        newsList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> userId <span class="token operator">not</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>users<span class="token punctuation">[</span>userId<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#自己也关注自己</span>            self<span class="token punctuation">.</span>users<span class="token punctuation">[</span>userId<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>userId<span class="token punctuation">)</span>        followees <span class="token operator">=</span> self<span class="token punctuation">.</span>users<span class="token punctuation">[</span>userId<span class="token punctuation">]</span>        count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> news <span class="token keyword">in</span> self<span class="token punctuation">.</span>twitters<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#倒序遍历推特列表，取出10个自己关注的人的推特返回</span>            <span class="token keyword">if</span> news<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">in</span> followees <span class="token operator">and</span> count<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">:</span>                newsList<span class="token punctuation">.</span>append<span class="token punctuation">(</span>news<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> newsList    <span class="token keyword">def</span> <span class="token function">follow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> followerId<span class="token punctuation">:</span> int<span class="token punctuation">,</span> followeeId<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Follower follows a followee. If the operation is invalid, it should be a no-op.        """</span>        self<span class="token punctuation">.</span>users<span class="token punctuation">[</span>followerId<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>followeeId<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">unfollow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> followerId<span class="token punctuation">:</span> int<span class="token punctuation">,</span> followeeId<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Follower unfollows a followee. If the operation is invalid, it should be a no-op.        """</span>        <span class="token keyword">if</span> followeeId <span class="token operator">!=</span> followerId <span class="token operator">and</span> followeeId <span class="token keyword">in</span> self<span class="token punctuation">.</span>users<span class="token punctuation">[</span>followerId<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#自己不能取关自己或者不关注的人</span>            self<span class="token punctuation">.</span>users<span class="token punctuation">[</span>followerId<span class="token punctuation">]</span><span class="token punctuation">.</span>remove<span class="token punctuation">(</span>followeeId<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Your Twitter object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = Twitter()</span><span class="token comment" spellcheck="true"># obj.postTweet(userId,tweetId)</span><span class="token comment" spellcheck="true"># param_2 = obj.getNewsFeed(userId)</span><span class="token comment" spellcheck="true"># obj.follow(followerId,followeeId)</span><span class="token comment" spellcheck="true"># obj.unfollow(followerId,followeeId)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我的这种做法省空间但不是很省时间，省时间的做法是开一张哈希表为每个人单独存放可能关注的人的最新推特。</p><h3 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345 反转字符串中的元音字母"></a>345 <a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">反转字符串中的元音字母</a></h3><p><img src="345.png" alt="345"></p><h4 id="思路：-141"><a href="#思路：-141" class="headerlink" title="思路："></a>思路：</h4><p>我们这道题可以用双指针法，思路和快排的partition有些类似。事实上所有的类似题目都可以考虑n路快排，例如把奇数放在偶数前面，三色队列，分割链表等。</p><p>本题中，我们只需要让左指针顺序找一个元音字母，右指针倒序找一个元音字母，二者交换，继续让左右指针向内寻找交换，直到两个指针相交。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseVowels</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        yuanyin <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'u'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'I'</span><span class="token punctuation">,</span> <span class="token string">'O'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">}</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        s <span class="token operator">=</span> list<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token number">0</span><span class="token operator">&lt;=</span>left<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> yuanyin<span class="token punctuation">:</span>                left <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">while</span> <span class="token number">0</span><span class="token operator">&lt;=</span>right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> yuanyin<span class="token punctuation">:</span>                right <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>                s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                left <span class="token operator">+=</span> <span class="token number">1</span>                right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="213题-打家劫舍-II"><a href="#213题-打家劫舍-II" class="headerlink" title="213题 打家劫舍 II"></a>213题 <a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">打家劫舍 II</a></h3><p><img src="213.png" alt="213"></p><h4 id="思路：-142"><a href="#思路：-142" class="headerlink" title="思路："></a>思路：</h4><p>这道题和之前的打家劫舍1类似，我们只需要将圆环切分为两个队列，即第0家到倒数第2家和第1家到倒数第1家，分别进行动态规划，求两个队列的最大值即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp <span class="token operator">=</span> a            a <span class="token operator">=</span> b <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            b <span class="token operator">=</span> max<span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> b<span class="token punctuation">)</span>        res <span class="token operator">=</span> max<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>        a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp <span class="token operator">=</span> a            a <span class="token operator">=</span> b <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            b <span class="token operator">=</span> max<span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> b<span class="token punctuation">)</span>        res <span class="token operator">=</span> max<span class="token punctuation">(</span><span class="token punctuation">[</span>res<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="387题-字符串中的第一个唯一字符"><a href="#387题-字符串中的第一个唯一字符" class="headerlink" title="387题 字符串中的第一个唯一字符"></a>387题 <a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">字符串中的第一个唯一字符</a></h3><p><img src="387.png" alt="387"></p><h4 id="思路：-143"><a href="#思路：-143" class="headerlink" title="思路："></a>思路：</h4><p>两次遍历字符串，第一次用哈希表统计每个字符的出现次数。第二次找到第一个出现次数为1的字符。</p><p>也可以用两个哈希集合，一个用于存放出现过的字符，一个用来存放重复的字符。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        repeat <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> ch <span class="token keyword">in</span> res<span class="token punctuation">:</span>                repeat<span class="token punctuation">.</span>add<span class="token punctuation">(</span>ch<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>add<span class="token punctuation">(</span>ch<span class="token punctuation">)</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>repeat<span class="token punctuation">)</span><span class="token operator">!=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> idx<span class="token punctuation">,</span>ch <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> ch <span class="token operator">not</span> <span class="token keyword">in</span> repeat<span class="token punctuation">:</span>                    <span class="token keyword">return</span> idx        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-15（5-easy）"><a href="#2020-5-15（5-easy）" class="headerlink" title="2020.5.15（5 easy）"></a>2020.5.15（5 easy）</h2><h3 id="1342-将数字变成-0-的操作次数"><a href="#1342-将数字变成-0-的操作次数" class="headerlink" title="1342 将数字变成 0 的操作次数"></a>1342 <a href="https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/" target="_blank" rel="noopener">将数字变成 0 的操作次数</a></h3><p><img src="1342.png" alt="1342"></p><h4 id="思路：-144"><a href="#思路：-144" class="headerlink" title="思路："></a>思路：</h4><p>没什么好说的，后悔做了，太简单。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> numberOfSteps <span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> num<span class="token punctuation">:</span>            <span class="token keyword">if</span> num <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">:</span>                num <span class="token operator">=</span> num <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                num <span class="token operator">-=</span> <span class="token number">1</span>            count<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1295题-统计位数为偶数的数字"><a href="#1295题-统计位数为偶数的数字" class="headerlink" title="1295题  统计位数为偶数的数字"></a>1295题 <a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/" target="_blank" rel="noopener"> 统计位数为偶数的数字</a></h3><p><img src="1295.png" alt="1295"></p><h4 id="思路：-145"><a href="#思路：-145" class="headerlink" title="思路："></a>思路：</h4><p>直接转字符串判断长度即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> len<span class="token punctuation">(</span>str<span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> count<span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">:</span>                res <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="219题-存在重复元素-II"><a href="#219题-存在重复元素-II" class="headerlink" title="219题  存在重复元素 II"></a>219题 <a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener"> 存在重复元素 II</a></h3><p><img src="219.png" alt="219"></p><h4 id="思路：-146"><a href="#思路：-146" class="headerlink" title="思路："></a>思路：</h4><p>由于线性搜索的时间复杂度很高，所以无法使用。</p><p>这里我们用一个哈希表进行搜索。遍历当前数组，哈希表中存放的是截止到当前，已经遍历的数字和最大下标（因为要求下标最小差值，所以直接用最大下标即可）。如果当前数字已经在哈希表中，且之前出现的最近位置和当前位置差值小于 k ，即可返回True。否则，更新哈希表中对应数字的值为当前下标（也就是更新为当前最大下标）</p><p>时间复杂度为$O(n)$，空间复杂度为$O(n)$。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">containsNearbyDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dic <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dic<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i <span class="token operator">-</span> dic<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> k<span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dic<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="905题-按奇偶排序数组"><a href="#905题-按奇偶排序数组" class="headerlink" title="905题 按奇偶排序数组"></a>905题 <a href="https://leetcode-cn.com/problems/sort-array-by-parity/" target="_blank" rel="noopener">按奇偶排序数组</a></h3><p><img src="905.png" alt="905"></p><h4 id="思路：-147"><a href="#思路：-147" class="headerlink" title="思路："></a>思路：</h4><p>和之前得有一题很像，不过那题是奇数在偶数前面。使用快排思想即可，用双指针交换不符合题目条件的数字位置。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortArrayByParity</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token number">0</span><span class="token operator">&lt;=</span>left<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">and</span> A<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                left <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">while</span> <span class="token number">0</span><span class="token operator">&lt;=</span>right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">and</span> A<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                right <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> left<span class="token operator">&lt;</span>right<span class="token punctuation">:</span>                A<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>left<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>        <span class="token keyword">return</span> A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="746题-使用最小花费爬楼梯"><a href="#746题-使用最小花费爬楼梯" class="headerlink" title="746题 使用最小花费爬楼梯"></a>746题 <a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">使用最小花费爬楼梯</a></h3><p><img src="746.png" alt="746"></p><h4 id="思路：-148"><a href="#思路：-148" class="headerlink" title="思路："></a>思路：</h4><p>动态规划最基础的题目，爬楼梯类型。</p><p>状态矩阵dp[i]表示的是截止到第i个阶梯的最小花费。由于每次只能爬1或2个阶梯，则dp[i]只能由dp[i-1]和dp[i-2]转移而来：</p><p>dp[i] = min（dp[i-1]，dp[i-2]）+cost[i]</p><p>输出的结果是我们爬到最后两个阶梯所要的花费中的较小值。</p><p>由于只依赖前两个状态，我们可以使用滚动数组的方式压缩dp矩阵：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minCostClimbingStairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> cost<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        a <span class="token operator">=</span> cost<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        b <span class="token operator">=</span> cost<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>cost<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> min<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> min<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="415题-字符串相加"><a href="#415题-字符串相加" class="headerlink" title="415题 字符串相加"></a>415题 <a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">字符串相加</a></h3><p><img src="415.png" alt="415"></p><h4 id="思路：-149"><a href="#思路：-149" class="headerlink" title="思路："></a>思路：</h4><p>经典大数相加，使用三个指针p、q、c分别存放num1中的下标、num2中的下标和进位。当p或者q未越界，或者c不为0时，加到StringBuilder中去（python用字符列表模拟）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">addStrings</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num1<span class="token punctuation">:</span> str<span class="token punctuation">,</span> num2<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        num1 <span class="token operator">=</span> num1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        num2 <span class="token operator">=</span> num2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        p<span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        c <span class="token operator">=</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> p<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>num1<span class="token punctuation">)</span> <span class="token operator">or</span> q<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>num2<span class="token punctuation">)</span> <span class="token operator">or</span> c<span class="token punctuation">:</span>            a <span class="token operator">=</span> int<span class="token punctuation">(</span>num1<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">if</span> p<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>num1<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">0</span>            b <span class="token operator">=</span> int<span class="token punctuation">(</span>num2<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">if</span> q<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>num2<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">0</span>            s <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c            c <span class="token operator">=</span> s <span class="token operator">//</span> <span class="token number">10</span>            s <span class="token operator">=</span> s <span class="token operator">%</span> <span class="token number">10</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>            p <span class="token operator">+=</span> <span class="token number">1</span>            q <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>res<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-16-3-easy，1-medium"><a href="#2020-5-16-3-easy，1-medium" class="headerlink" title="2020.5.16 (3 easy，1 medium)"></a>2020.5.16 (3 easy，1 medium)</h2><h3 id="130题-被围绕的区域"><a href="#130题-被围绕的区域" class="headerlink" title="130题 被围绕的区域"></a>130题 <a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">被围绕的区域</a></h3><p><img src="130.png" alt="130"></p><h4 id="思路：-150"><a href="#思路：-150" class="headerlink" title="思路："></a>思路：</h4><p>这道题我的思路是：先找到边界上的所有“O”，然后以这些“O”作为起点进行多源BFS，将相邻的“O”全部存入一个哈希集合中。最后遍历一次棋盘，如果某个“O“不在上述哈希集合中，说明它必然被围绕，将其修改为”X“。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">solve</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify board in-place instead.        """</span>        queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> board<span class="token punctuation">:</span>            rowLen <span class="token operator">=</span> len<span class="token punctuation">(</span>board<span class="token punctuation">)</span>            colLen <span class="token operator">=</span> len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            offsets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>rowLen<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'O'</span> <span class="token punctuation">:</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>colLen<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'O'</span><span class="token punctuation">:</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>colLen<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>colLen<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'O'</span><span class="token punctuation">:</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>rowLen<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'O'</span><span class="token punctuation">:</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>rowLen<span class="token number">-1</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>            hs <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">while</span> queue<span class="token punctuation">:</span>                l <span class="token operator">=</span> len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                    now <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                    hs<span class="token punctuation">.</span>add<span class="token punctuation">(</span>now<span class="token punctuation">)</span>                    nowRow<span class="token punctuation">,</span> nowCol <span class="token operator">=</span> now<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> now<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                    <span class="token keyword">for</span> offset <span class="token keyword">in</span> offsets<span class="token punctuation">:</span>                        newRow <span class="token operator">=</span> nowRow <span class="token operator">+</span> offset<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                        newCol <span class="token operator">=</span> nowCol <span class="token operator">+</span> offset<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                        <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>newRow<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>newCol<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> board<span class="token punctuation">[</span>newRow<span class="token punctuation">]</span><span class="token punctuation">[</span>newCol<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'O'</span> <span class="token operator">and</span> <span class="token punctuation">(</span>newRow<span class="token punctuation">,</span>newCol<span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token keyword">in</span> hs<span class="token punctuation">:</span>                            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>newRow<span class="token punctuation">,</span>newCol<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>rowLen<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>colLen<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'O'</span> <span class="token operator">and</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token keyword">in</span> hs<span class="token punctuation">:</span>                        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'X'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="257题-二叉树的所有路径"><a href="#257题-二叉树的所有路径" class="headerlink" title="257题 二叉树的所有路径"></a>257题 <a href="https://leetcode-cn.com/problems/binary-tree-paths/" target="_blank" rel="noopener">二叉树的所有路径</a></h3><p><img src="257.png" alt="257"></p><h4 id="思路：-151"><a href="#思路：-151" class="headerlink" title="思路："></a>思路：</h4><p>带备忘录的DFS搜索即可，基础题。备忘录用来存放当前路径，需要回溯。</p><p>结果需要修改为题目要求的格式。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">binaryTreePaths</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">:</span>                <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                    dfs<span class="token punctuation">(</span>path<span class="token operator">+</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">,</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                    dfs<span class="token punctuation">(</span>path<span class="token operator">+</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token operator">not</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token operator">not</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token punctuation">:</span>            dfs<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">,</span>root<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">"->"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> li <span class="token keyword">in</span> res<span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1021题-删除最外层的括号"><a href="#1021题-删除最外层的括号" class="headerlink" title="1021题 删除最外层的括号"></a>1021题 <a href="https://leetcode-cn.com/problems/remove-outermost-parentheses/" target="_blank" rel="noopener">删除最外层的括号</a></h3><p><img src="1021.png" alt="1021"></p><h4 id="思路：-152"><a href="#思路：-152" class="headerlink" title="思路："></a>思路：</h4><p>使用一个计数变量count，遍历S串，如果遇到了左括号，count++，遇到了右括号，count–。</p><p>如果count等于0，那么就将当前遍历到的所有字符串去除最外层括号加到结果串中，清空当前字符串，继续遍历。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeOuterParentheses</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> S<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        count <span class="token operator">=</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token string">""</span>        s <span class="token operator">=</span> <span class="token string">""</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> S<span class="token punctuation">:</span>            <span class="token keyword">if</span> ch <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">:</span>                count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                count <span class="token operator">-=</span> <span class="token number">1</span>            s <span class="token operator">+=</span> ch            <span class="token keyword">if</span> count <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">:</span>                res <span class="token operator">+=</span> s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>                s <span class="token operator">=</span> <span class="token string">""</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1221题-分割平衡字符串"><a href="#1221题-分割平衡字符串" class="headerlink" title="1221题 分割平衡字符串"></a>1221题 <a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/" target="_blank" rel="noopener">分割平衡字符串</a></h3><p><img src="1221.png" alt="1221"></p><h4 id="思路：-153"><a href="#思路：-153" class="headerlink" title="思路："></a>思路：</h4><p>和1021题几乎相同，只不过1021题是原语括号串，本题是平衡字符串罢了。同时，本题不要求L和R的先后顺序，和括号串不同，所以一旦count为0就可以将结果数加1.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">balancedStringSplit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        count <span class="token operator">=</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> ch<span class="token operator">==</span><span class="token string">"R"</span><span class="token punctuation">:</span>                count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                count <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> count <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">:</span>                res <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-17-（3-easy-2-medium）"><a href="#2020-5-17-（3-easy-2-medium）" class="headerlink" title="2020.5.17 （3 easy 2 medium）"></a>2020.5.17 （3 easy 2 medium）</h2><h3 id="1441题-用栈操作构建数组"><a href="#1441题-用栈操作构建数组" class="headerlink" title="1441题 用栈操作构建数组"></a>1441题 <a href="https://leetcode-cn.com/problems/build-an-array-with-stack-operations/" target="_blank" rel="noopener">用栈操作构建数组</a></h3><p><img src="1441.png" alt="1441"></p><h4 id="思路：-154"><a href="#思路：-154" class="headerlink" title="思路："></a>思路：</h4><p>这题并不难想，我们只需要从1到n依次读取一个数字，看其是否与target数组中的数字匹配即可。如果不匹配，那么就是先入栈再出栈，否则直接入栈。由于target数组严格递增，我们可以将时间复杂度从$O(n^2)$降到$O(n)$，只需设置一个指针，指向target中的首个元素，一旦遍历到数字等于该元素，那么就将指针后移一位。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> target<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        p <span class="token operator">=</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">==</span> target<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"Push"</span><span class="token punctuation">)</span>                p <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">if</span> p <span class="token operator">==</span> len<span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> res            <span class="token keyword">else</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"Push"</span><span class="token punctuation">)</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"Pop"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1442题-形成两个异或相等数组的三元组数目"><a href="#1442题-形成两个异或相等数组的三元组数目" class="headerlink" title="1442题 形成两个异或相等数组的三元组数目"></a>1442题 <a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/" target="_blank" rel="noopener">形成两个异或相等数组的三元组数目</a></h3><p><img src="1442.png" alt="1442"></p><h4 id="思路：-155"><a href="#思路：-155" class="headerlink" title="思路："></a>思路：</h4><p>这题的暴力算法很好想，直接三层循环遍历找到合适的i，j，k即可。但我们要考虑的是如何降低时间复杂度。</p><p>首先，我们可以考虑前缀和的方法，来简化求解某一个区间数组的异或的过程。由于异或运算符合结合律和分配律，且a ^ a = 0，a ^ 0 = a。所以 a = arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1] = prefixXor[j - 1] ^ prefixXor[i - 1]。类似于求解区间和的前缀和做法，我们只需要统计截止到每个元素的前缀和，即可快速求出每个区间的异或结果。</p><p>其次，我们可以通过数学运算，简化搜索 j 的过程。我们知道，最终的目的是找到使 a == b的三元组。由于异或的性质：</p><ul><li>a = arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1]</li><li>b = arr[j] ^ arr[j + 1] ^ … ^ arr[k]</li><li>a == b</li></ul><p>所以：</p><ul><li>a ^  b == 0，即从arr[i] 异或到 arr[k]结果等于0。</li></ul><p>我们只需要找到异或结果等于0的区间[i,k]，该区间内可选的 j 的数目为（k - i），即能组成（k - i）个不同的三元组。</p><p>最终的时间复杂度为$O(n^2)$，n为arr数组长度。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countTriplets</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        prefixXor <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        now <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            now <span class="token operator">^</span><span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            prefixXor<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> now        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">:</span>                    <span class="token keyword">if</span> prefixXor<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                        res <span class="token operator">+=</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> i<span class="token punctuation">)</span>                <span class="token keyword">elif</span> prefixXor<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span> prefixXor<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> i<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1443题-收集树上所有苹果的最少时间"><a href="#1443题-收集树上所有苹果的最少时间" class="headerlink" title="1443题 收集树上所有苹果的最少时间"></a>1443题 <a href="https://leetcode-cn.com/problems/minimum-time-to-collect-all-apples-in-a-tree/" target="_blank" rel="noopener">收集树上所有苹果的最少时间</a></h3><p><img src="1443.png" alt="1443"></p><h4 id="思路：-156"><a href="#思路：-156" class="headerlink" title="思路："></a>思路：</h4><p>先序遍历DFS求解。</p><p>首先根据题目给出的条件建树（本质上其实就是一个限定了起点的无向无环图）</p><p>从根节点开始搜索当前树中获得苹果的路程总和：</p><ul><li>如果当前树的子树中搜索不到苹果，且根节点没有苹果，直接返回-1</li><li>如果当前树的子树中搜索不到苹果，但根节点有苹果，返回0，表示在当前树中搜索苹果的总路程为0</li><li>如果当前树的子树中可以搜索到苹果，则使用一个变量记录下总路程，一旦搜索到一个返回值大于等于0的子树，那么总路程加上该返回值再加2（因为从根节点前往子树来回需要2的距离）</li></ul><p>同时，无向边是双向的，这点需要注意，还要防止重复遍历节点。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minTime</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> edges<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> hasApple<span class="token punctuation">:</span> List<span class="token punctuation">[</span>bool<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        graph <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span>        <span class="token keyword">for</span> e <span class="token keyword">in</span> edges<span class="token punctuation">:</span>            graph<span class="token punctuation">[</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>e<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            graph<span class="token punctuation">[</span>e<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        visited <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root <span class="token keyword">in</span> graph<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                s <span class="token operator">=</span> <span class="token number">0</span>                visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>root<span class="token punctuation">)</span>                <span class="token keyword">for</span> child <span class="token keyword">in</span> graph<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> child <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>                        dist <span class="token operator">=</span> dfs<span class="token punctuation">(</span>child<span class="token punctuation">)</span>                        <span class="token keyword">if</span> dist<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">:</span>                            dist <span class="token operator">+=</span> <span class="token number">2</span>                            s <span class="token operator">+=</span> dist                visited<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>root<span class="token punctuation">)</span>                <span class="token keyword">if</span> s<span class="token punctuation">:</span>                    <span class="token keyword">return</span> s                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> hasApple<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token number">0</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> hasApple<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token number">0</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>dfs<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="404题-左叶子之和"><a href="#404题-左叶子之和" class="headerlink" title="404题 左叶子之和"></a>404题 <a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">左叶子之和</a></h3><p><img src="404.png" alt="404"></p><h4 id="思路：-157"><a href="#思路：-157" class="headerlink" title="思路："></a>思路：</h4><p>先序遍历，每访问到一个节点，看它的左孩子是否是叶节点，如果是，那么累加进结果中。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>s <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">:</span>                <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token operator">and</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right <span class="token operator">and</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>s <span class="token operator">+=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val                inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="414题-第三大的数"><a href="#414题-第三大的数" class="headerlink" title="414题  第三大的数"></a>414题 <a href="https://leetcode-cn.com/problems/third-maximum-number/" target="_blank" rel="noopener"> 第三大的数</a></h3><p><img src="414.png" alt="414"></p><h4 id="思路：-158"><a href="#思路：-158" class="headerlink" title="思路："></a>思路：</h4><p>这题本质上是一般的topK问题的简化版本。考虑到TOPK问题的常规解法：（1）堆（2）快速选择（3）计数排序，综合考虑时间复杂度和空间复杂度，我们选用堆来求解。堆解法的时间复杂度为$O(n)$，空间复杂度为$O(1)$，因为本题的k是一个常数。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> heapq<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">thirdMax</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        nums <span class="token operator">=</span> list<span class="token punctuation">(</span>set<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> max<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        heap <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>heap<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>heap<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-18-（3-easy-2-medium）"><a href="#2020-5-18-（3-easy-2-medium）" class="headerlink" title="2020.5.18 （3 easy 2 medium）"></a>2020.5.18 （3 easy 2 medium）</h2><h3 id="1450题-在既定时间做作业的学生人数"><a href="#1450题-在既定时间做作业的学生人数" class="headerlink" title="1450题 在既定时间做作业的学生人数"></a>1450题 <a href="https://leetcode-cn.com/problems/number-of-students-doing-homework-at-a-given-time/" target="_blank" rel="noopener">在既定时间做作业的学生人数</a></h3><p><img src="1450%E9%A2%98" alt="1450"></p><h4 id="思路：-159"><a href="#思路：-159" class="headerlink" title="思路："></a>思路：</h4><p>简单题，只要遍历一下时间段，看目标时间在几个时间段内即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">busyStudent</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> startTime<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> endTime<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> queryTime<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>startTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> startTime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>queryTime<span class="token operator">&lt;=</span>endTime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1451题-重新排列句子中的单词"><a href="#1451题-重新排列句子中的单词" class="headerlink" title="1451题 重新排列句子中的单词"></a>1451题 <a href="https://leetcode-cn.com/problems/rearrange-words-in-a-sentence/" target="_blank" rel="noopener">重新排列句子中的单词</a></h3><p><img src="1451%E9%A2%98" alt="1451"></p><h4 id="思路：-160"><a href="#思路：-160" class="headerlink" title="思路："></a>思路：</h4><p>虽然是中等题，但由于我使用的是python，还是挺容易的。</p><p>我们重写排序方法，使用匿名函数获得单词长度作为排序的关键字，由于python默认升序排序，且使用的排序方法默认会保证相等元素的相对位置，所以直接排序即可。</p><p>最后，要将结果组合成新的字符串，同时保证开头字母大写，其余字母小写。先调用lower方法全部转小写，再调用upper方法将开头字符转大写即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">arrangeWords</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        wordList <span class="token operator">=</span> text<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>        wordList<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token keyword">lambda</span> x <span class="token punctuation">:</span> len<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>wordList<span class="token punctuation">)</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1452题-收藏清单"><a href="#1452题-收藏清单" class="headerlink" title="1452题 收藏清单"></a>1452题 <a href="https://leetcode-cn.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/" target="_blank" rel="noopener">收藏清单</a></h3><p><img src="1452%E9%A2%98" alt="1452"></p><h4 id="思路：-161"><a href="#思路：-161" class="headerlink" title="思路："></a>思路：</h4><p>由于列表比较是否为子集的时间复杂度很高（貌似是$O(n^2)$），所以我们要先转为hashset的形式。使用集合自带的差集操作求解。</p><p>我们遍历favoriteCompanies列表，每次转化当前子列表为集合。搜索之前已有的集合列表，并设置一个状态变量flag。如果当前集合是之前某个集合的子集，并跳出搜索，继续遍历下一个列表。如果之前某个集合是当前集合的子集，那么就将之前的这个集合及其序号从集合列表和结果列表中去除。如果不是上述两种情况，那么将当前列表集合放入集合列表，序号放入结果列表。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">peopleIndexes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> favoriteCompanies<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        hsList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>favoriteCompanies<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                hsList<span class="token punctuation">.</span>append<span class="token punctuation">(</span>set<span class="token punctuation">(</span>favoriteCompanies<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                hs <span class="token operator">=</span> set<span class="token punctuation">(</span>favoriteCompanies<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                flag <span class="token operator">=</span> <span class="token number">0</span>                tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                tmp2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>hsList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> len<span class="token punctuation">(</span>hs <span class="token operator">-</span> hsList<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                        flag <span class="token operator">=</span> <span class="token number">1</span>                        <span class="token keyword">break</span>                    <span class="token keyword">elif</span> len<span class="token punctuation">(</span>hsList<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> hs<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                        flag <span class="token operator">=</span> <span class="token number">2</span>                        tmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>hsList<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                        tmp2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>j<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token operator">not</span> flag<span class="token punctuation">:</span>                    hsList<span class="token punctuation">.</span>append<span class="token punctuation">(</span>hs<span class="token punctuation">)</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>                <span class="token keyword">elif</span> flag <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>                    hsList<span class="token punctuation">.</span>append<span class="token punctuation">(</span>hs<span class="token punctuation">)</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>                    <span class="token keyword">for</span> hs <span class="token keyword">in</span> tmp<span class="token punctuation">:</span>                        hsList<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>hs<span class="token punctuation">)</span>                    <span class="token keyword">for</span> j <span class="token keyword">in</span> tmp2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                        res<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>j<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，删除之前的子集时，要先用临时列表存起来，等到遍历完成以后再操作。因为不可以在循环时改变循环变量的值。</p><h3 id="1290题-二进制链表转整数"><a href="#1290题-二进制链表转整数" class="headerlink" title="1290题 二进制链表转整数"></a>1290题 <a href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/" target="_blank" rel="noopener">二进制链表转整数</a></h3><p><img src="1290.png" alt="1290"></p><h4 id="思路：-162"><a href="#思路：-162" class="headerlink" title="思路："></a>思路：</h4><p>起初我遍历了两次，进行模拟，时间复杂度较高。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getDecimalValue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        p <span class="token operator">=</span> head        n <span class="token operator">=</span> <span class="token string">""</span>        <span class="token keyword">while</span> p<span class="token punctuation">:</span>            n <span class="token operator">+=</span> str<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> idx<span class="token punctuation">,</span>i <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>n<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> int<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">**</span> idx<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>较好的方法是遍历的同时使用位运算，每次遍历到链表中的一个元素，将之前得到的结果向左移一位，并将当前元素加到结果中去。并且，python的位运算默认以10进制表示，不需要先转成2进制。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getDecimalValue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        p <span class="token operator">=</span> head        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> p<span class="token punctuation">:</span>            res <span class="token operator">&lt;&lt;</span><span class="token operator">=</span> <span class="token number">1</span>            res <span class="token operator">+=</span> p<span class="token punctuation">.</span>val            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="171题-Excel表列序号"><a href="#171题-Excel表列序号" class="headerlink" title="171题 Excel表列序号"></a>171题 <a href="https://leetcode-cn.com/problems/excel-sheet-column-number/" target="_blank" rel="noopener">Excel表列序号</a></h3><p><img src="171.png" alt="171"></p><h4 id="思路：-163"><a href="#思路：-163" class="headerlink" title="思路："></a>思路：</h4><p>简单题，你可以把它想象成一种二十六进制数字。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">titleToNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> idx<span class="token punctuation">,</span>ch <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> <span class="token punctuation">(</span>ord<span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">26</span> <span class="token operator">**</span> idx<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-19-（2-medium-3-easy）"><a href="#2020-5-19-（2-medium-3-easy）" class="headerlink" title="2020.5.19 （2 medium 3 easy）"></a>2020.5.19 （2 medium 3 easy）</h2><h3 id="210题-课程表-II"><a href="#210题-课程表-II" class="headerlink" title="210题 课程表 II"></a>210题 <a href="https://leetcode-cn.com/problems/course-schedule-ii/" target="_blank" rel="noopener">课程表 II</a></h3><p><img src="210.png" alt="210"></p><h4 id="思路：-164"><a href="#思路：-164" class="headerlink" title="思路："></a>思路：</h4><p>我的方法：数据结构经典图论题目——有向图的拓扑排序，基于BFS的流程如下：</p><ul><li>先建图的邻接表，表示该图，统计图上每个节点（即课程）的入度（即先修课程数目）</li><li>进行拓扑排序，每次从图上删去任意一个入读为0的节点，注意要将所有以它为起点的边指向的节点入度减1。如果一次遍历无法找到入度为0的节点，那么当前图必然存在环路，无法找到符合条件的学习顺序，返回空列表即可。否则，每次将删掉的结果加入到结果列表尾部，直到图上不存在节点。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> numCourses<span class="token punctuation">:</span> int<span class="token punctuation">,</span> prerequisites<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        graph <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        inDegree <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>numCourses<span class="token punctuation">)</span><span class="token punctuation">:</span>            inDegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> e <span class="token keyword">in</span> prerequisites<span class="token punctuation">:</span>            graph<span class="token punctuation">[</span>e<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            inDegree<span class="token punctuation">[</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> graph<span class="token punctuation">:</span>            flag <span class="token operator">=</span> <span class="token boolean">False</span>            <span class="token keyword">for</span> v <span class="token keyword">in</span> inDegree<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> inDegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    inDegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>                    <span class="token keyword">for</span> nextNode <span class="token keyword">in</span> graph<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span>                        inDegree<span class="token punctuation">[</span>nextNode<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                    <span class="token keyword">del</span> graph<span class="token punctuation">[</span>v<span class="token punctuation">]</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">)</span>                    flag <span class="token operator">=</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token operator">not</span> flag<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事实上，一种更好的办法是使用队列。</p><ul><li>queue 队列中始终是【入度为 0 的课】在里面流动</li><li>选择一门课，就让它 出列，同时 查看哈希表，看它 对应哪些后续课</li><li>将这些后续课的 入度 - 1，如果有 减至 0 的，就将它 推入 queue</li><li>不再有新的入度 0 的课入列 时，此时 queue 为空，退出循环</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> numCourses<span class="token punctuation">:</span> int<span class="token punctuation">,</span> prerequisites<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        graph <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        inDegree <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>numCourses<span class="token punctuation">)</span><span class="token punctuation">:</span>            inDegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> e <span class="token keyword">in</span> prerequisites<span class="token punctuation">:</span>            graph<span class="token punctuation">[</span>e<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            inDegree<span class="token punctuation">[</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> v <span class="token keyword">in</span> graph<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> inDegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">)</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            now <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> nextV <span class="token keyword">in</span> graph<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">:</span>                inDegree<span class="token punctuation">[</span>nextV<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">if</span> inDegree<span class="token punctuation">[</span>nextV<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nextV<span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>now<span class="token punctuation">)</span>        <span class="token keyword">return</span> res <span class="token keyword">if</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">==</span> numCourses <span class="token keyword">else</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="153题-寻找旋转排序数组中的最小值"><a href="#153题-寻找旋转排序数组中的最小值" class="headerlink" title="153题 寻找旋转排序数组中的最小值"></a>153题 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a></h3><p><img src="153.png" alt="153"></p><h4 id="思路：-165"><a href="#思路：-165" class="headerlink" title="思路："></a>思路：</h4><p>之前的搜索旋转排序数组的衍生题，更加简单一些，我们只需要找到旋转点即可。</p><p>搜索题最先考虑的就是能不能按照某种规则分治搜索，例如我们最常使用的二分查找。这道题，我们可以按照如下的规则进行二分：</p><ul><li>计算左边界left和右边界right的中间点mid</li><li>如果nums[left] &lt; nums[right]，则当前区间未旋转，最小值点在left处。</li><li>如果nums[left] &lt;= nums[mid]，则旋转点必然在[mid+1,right]之间，我们让left = mid + 1</li><li>如果nums[left] &gt; nums[mid]，则旋转点必然在[left,mid]之间，我们让right = mid</li><li>直到left&gt;=right，跳出循环。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findMin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">:</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                right <span class="token operator">=</span> mid        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="389题-找不同"><a href="#389题-找不同" class="headerlink" title="389题 找不同"></a>389题 <a href="https://leetcode-cn.com/problems/find-the-difference/" target="_blank" rel="noopener">找不同</a></h3><p><img src="389.png" alt="389"></p><h4 id="思路：-166"><a href="#思路：-166" class="headerlink" title="思路："></a>思路：</h4><p>位运算，因为除了新添的字母外，每个字母都出现了偶数次。我们使用ascii码进行异或，最后的结果即为新添数字的ascii码，返回字母即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findTheDifference</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        s <span class="token operator">=</span> s <span class="token operator">+</span> t         n <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>            n <span class="token operator">^</span><span class="token operator">=</span> ord<span class="token punctuation">(</span>ch<span class="token punctuation">)</span>        <span class="token keyword">return</span> chr<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="258题-各位相加"><a href="#258题-各位相加" class="headerlink" title="258题 各位相加"></a>258题 <a href="https://leetcode-cn.com/problems/add-digits/" target="_blank" rel="noopener">各位相加</a></h3><p><img src="258.png" alt="258"></p><h4 id="思路：-167"><a href="#思路：-167" class="headerlink" title="思路："></a>思路：</h4><p>递归和循环的思路很简单，难就难在如何用数学方法推导出$O(1)$的时间复杂度。</p><p>具体证明可看这里:</p><p><img src="258-1.png" alt="证明"></p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">addDigits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">9</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> num <span class="token operator">></span> <span class="token number">9</span> <span class="token keyword">else</span> num<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1122题-数组的相对排序"><a href="#1122题-数组的相对排序" class="headerlink" title="1122题 数组的相对排序"></a>1122题 <a href="https://leetcode-cn.com/problems/relative-sort-array/" target="_blank" rel="noopener">数组的相对排序</a></h3><p><img src="1122.png" alt="1122"></p><h4 id="思路：-168"><a href="#思路：-168" class="headerlink" title="思路："></a>思路：</h4><p>使用哈希表将时间复杂度从暴力的$O(n^2)$降到$O(n)$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">relativeSortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> arr2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        ht <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        hs <span class="token operator">=</span> set<span class="token punctuation">(</span>arr1<span class="token punctuation">)</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> arr1<span class="token punctuation">:</span>            ht<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> arr2<span class="token punctuation">:</span>            res <span class="token operator">+=</span> <span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">*</span> ht<span class="token punctuation">[</span>num<span class="token punctuation">]</span>            hs<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>num<span class="token punctuation">)</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> sorted<span class="token punctuation">(</span>list<span class="token punctuation">(</span>hs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> <span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">*</span> ht<span class="token punctuation">[</span>num<span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-20-（4-medium）"><a href="#2020-5-20-（4-medium）" class="headerlink" title="2020.5.20 （4 medium）"></a>2020.5.20 （4 medium）</h2><h3 id="90题-子集-II"><a href="#90题-子集-II" class="headerlink" title="90题 子集 II"></a>90题 <a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">子集 II</a></h3><p><img src="90.png" alt="90"></p><h3 id="思路：-169"><a href="#思路：-169" class="headerlink" title="思路："></a>思路：</h3><p>依然是DFS回溯的思路，但是考虑到出现重复的情况，我们需要先排序，再剪枝。</p><p>如果当前路径已经出现在子集集合中，那么就进行剪枝，不再向下继续遍历。考虑到判断是否存在于列表中需要$O(n)$的时间复杂度，这里我们使用哈希集合，降到$O(1)$.</p><p>需要注意的是，可变类型不可哈希，所以我们要使用元组代替列表，最后将其转成列表类型。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">subsetsWithDup</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>add<span class="token punctuation">(</span>path<span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                next <span class="token operator">=</span> path<span class="token operator">+</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> next <span class="token operator">not</span> <span class="token keyword">in</span> res<span class="token punctuation">:</span>                    dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span> next<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span>list<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> res<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="547题-朋友圈"><a href="#547题-朋友圈" class="headerlink" title="547题 朋友圈"></a>547题 <a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">朋友圈</a></h3><p><img src="547.png" alt="547"></p><h4 id="思路：-170"><a href="#思路：-170" class="headerlink" title="思路："></a>思路：</h4><p>这道题，本质上是求一个非完全连通图上的子图数目，数据结构课上的经典题目。类似于“小岛数目”的题。这种题，我们解决的方案有：BFS、DFS、并查集等。</p><p>由于BFS和DFS的思路基本类似，只是搜索的方式不同，我们只讨论DFS。DFS就是每次任意选一个用户作为起点，深度优先搜索所有与他连通的用户（即互为好友），并将相关节点全部标记为已访问。每次开始遍历一个子图时，将结果数目加1。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findCircleNum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> M<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        visited <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> v <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>                visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>v<span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>M<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> M<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">and</span> i <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>                    dfs<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>                res <span class="token operator">+=</span> <span class="token number">1</span>                dfs<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外还有一种算法是并查集。并查集使用父亲节点数组来模拟一个森林，任意在一个连同子图中选取一个节点作为根节点，图中其余所有节点都是它的孩子。判断两个节点是否连通，只需要判断他们有没有共同的祖先。</p><p>主要分为两个操作：</p><ul><li>Union并操作，负责连通两个节点。如果两个节点不在同一树内，即根节点不同，那么合并两个树。只需要将一个树的根节点的父亲修改为另一个树的根节点即可。如果合并了两个不在同一个子图中的节点，那么就将当前并查集的连通分量减1.</li><li>Find查操作，负责查询某个节点的所在树的根节点。特别地，如果查询时发现到根节点的路径不为1，那么就将路径上所有的节点的父亲节点修改为根节点，从而优化查操作的时间复杂度，这叫做“路径压缩”。</li></ul><p>我讲的比较简略，一个比较好的网站是： <a href="https://blog.csdn.net/qq_41593380/article/details/81146850" target="_blank" rel="noopener">https://blog.csdn.net/qq_41593380/article/details/81146850</a> </p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">UnionFindSet</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>num <span class="token operator">=</span> n    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span>        root <span class="token operator">=</span> a        <span class="token keyword">while</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token operator">!=</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            root <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>root<span class="token punctuation">]</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">!=</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span>            a<span class="token punctuation">,</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> root        <span class="token keyword">return</span> root    <span class="token keyword">def</span> <span class="token function">union</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>        rootA <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>a<span class="token punctuation">)</span>        rootB <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>b<span class="token punctuation">)</span>        <span class="token keyword">if</span> rootA<span class="token operator">!=</span>rootB<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>rootA<span class="token punctuation">]</span> <span class="token operator">=</span> rootB            self<span class="token punctuation">.</span>num <span class="token operator">-=</span> <span class="token number">1</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findCircleNum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> M<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        UF <span class="token operator">=</span> UnionFindSet<span class="token punctuation">(</span>len<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>M<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">!=</span>j <span class="token operator">and</span> M<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    UF<span class="token punctuation">.</span>union<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span>        <span class="token keyword">return</span> UF<span class="token punctuation">.</span>num<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="77题-组合"><a href="#77题-组合" class="headerlink" title="77题  组合"></a>77题 <a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener"> 组合</a></h3><p><img src="77.png" alt="77"></p><h4 id="思路：-171"><a href="#思路：-171" class="headerlink" title="思路："></a>思路：</h4><p>这种组合题依然是考虑递归回溯来做。同时需要考虑是否可以剪枝：本题如果从当前选择的数字index的下一个数字index+1到n之间还剩下的可选数字个数小于剩余还需要选择的数字，那么必然无法再选择出长度为k的组合，不需要继续递归，直接剪枝即可。</p><p>我们只需要让每次递归选择的下一个数的区间为：[index+1,n-（k-len(path)）+1]，即可完成剪枝。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">combine</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token punctuation">(</span>k<span class="token operator">-</span>len<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span> path<span class="token operator">+</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="209题-长度最小的子数组"><a href="#209题-长度最小的子数组" class="headerlink" title="209题 长度最小的子数组"></a>209题 <a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">长度最小的子数组</a></h3><p><img src="209.png" alt="209"></p><h4 id="思路：-172"><a href="#思路：-172" class="headerlink" title="思路："></a>思路：</h4><p>双指针的常规题，我们只需要维护一个区间，其区间和大于等于s，一旦小于s，我们就让右指针向前遍历扩大区间。一旦大于s，我们就让左指针向前遍历，收缩区间，直到区间即将小于s，记录下当前区间长度，与最小区间长度比较。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minSubArrayLen</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> int<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> <span class="token number">0</span>        sum <span class="token operator">=</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span>        <span class="token keyword">while</span> right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span>            <span class="token keyword">if</span> sum<span class="token operator">&lt;</span>s<span class="token punctuation">:</span>                right <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> sum <span class="token operator">==</span> s<span class="token punctuation">:</span>                right <span class="token operator">+=</span> <span class="token number">1</span>                res <span class="token operator">=</span> min<span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> left<span class="token operator">&lt;</span>right <span class="token operator">and</span> sum<span class="token operator">-</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">>=</span>s<span class="token punctuation">:</span>                    sum <span class="token operator">-=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                    left <span class="token operator">+=</span> <span class="token number">1</span>                right <span class="token operator">+=</span> <span class="token number">1</span>                res <span class="token operator">=</span> min<span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span>        <span class="token keyword">return</span> res <span class="token keyword">if</span> res<span class="token operator">!=</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span> <span class="token keyword">else</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>双指针的时间复杂度为$O(n)$，事实上，我们还可以使用二分查找+前缀和的方法，时间复杂度略高，为$O(nlogn)$。</p><h2 id="2020-5-21-（4easy-1medium）"><a href="#2020-5-21-（4easy-1medium）" class="headerlink" title="2020.5.21 （4easy 1medium）"></a>2020.5.21 （4easy 1medium）</h2><h3 id="1313题-解压缩编码列表"><a href="#1313题-解压缩编码列表" class="headerlink" title="1313题 解压缩编码列表"></a>1313题 <a href="https://leetcode-cn.com/problems/decompress-run-length-encoded-list/" target="_blank" rel="noopener">解压缩编码列表</a></h3><p><img src="1313.png" alt="1313"></p><h4 id="思路：-173"><a href="#思路：-173" class="headerlink" title="思路："></a>思路：</h4><p>简单题，模拟一遍即可，偶数位为出现次数，奇数位为数字。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">decompressRLElist</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            freq <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            val <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>freq<span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="520题-检测大写字母"><a href="#520题-检测大写字母" class="headerlink" title="520题 检测大写字母"></a>520题 <a href="https://leetcode-cn.com/problems/detect-capital/" target="_blank" rel="noopener">检测大写字母</a></h3><p><img src="520.png" alt="520"></p><h4 id="思路：-174"><a href="#思路：-174" class="headerlink" title="思路："></a>思路：</h4><p>只要检测（1）是否全部为大写字母（2）除首字母外全部为小写字母。此两种情况下是合法的。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">detectCapitalUse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        tmp <span class="token operator">=</span> word<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> word<span class="token operator">==</span>word<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">or</span> tmp<span class="token operator">==</span>tmp<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="290题-单词规律"><a href="#290题-单词规律" class="headerlink" title="290题 单词规律"></a>290题 <a href="https://leetcode-cn.com/problems/word-pattern/" target="_blank" rel="noopener">单词规律</a></h3><p><img src="290.png" alt="290"></p><h3 id="思路：-175"><a href="#思路：-175" class="headerlink" title="思路："></a>思路：</h3><p>这道题的核心思想是找到单词和模式字符的一一对应关系，很明显，这种可以用哈希映射来实现键值对的关系，我们可以使用哈希表（字典）。</p><p>同步遍历二者，如果模式字符已经出现过，而当前单词没有出现过，必然不匹配；否则，比较模式字符的对应单词和当前单词是否相等。如果当前单词已经出现过，而当前模式字符没有出现过，必然不匹配。如果二者都没有出现过，那么建立映射关系。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wordPattern</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pattern<span class="token punctuation">:</span> str<span class="token punctuation">,</span> str<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dic <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        words <span class="token operator">=</span> str<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token operator">!=</span>len<span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>                dic<span class="token punctuation">[</span>pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> dic<span class="token punctuation">[</span>pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328 奇偶链表"></a>328 <a href="https://leetcode-cn.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">奇偶链表</a></h3><p><img src="328.png" alt="328"></p><h3 id="思路：-176"><a href="#思路：-176" class="headerlink" title="思路："></a>思路：</h3><p>和链表的快排类似（数组中也是使用二路快排的思想进行奇偶划分），我们新建两个伪头结点。遍历链表，将序号为奇数的插入到第一个伪头结点的链表中，将序号为偶数的插入到第二个伪头结点的链表中。最后合并即可。由于没有新建结点，只是修改了指针，所以不会占用额外的空间。</p><p>类似的题目是“分割链表”，那道题纯粹是快排，这道题只是借鉴了快排思想，原理都是类似的。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">oddEvenList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        dummyhead1 <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>None<span class="token punctuation">)</span>        dummyhead2 <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>None<span class="token punctuation">)</span>        p <span class="token operator">=</span> head        q <span class="token operator">=</span> dummyhead1        r <span class="token operator">=</span> dummyhead2        count <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> p<span class="token punctuation">:</span>            <span class="token keyword">if</span> count<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">:</span>                q<span class="token punctuation">.</span>next <span class="token operator">=</span> p                q <span class="token operator">=</span> q<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                r<span class="token punctuation">.</span>next <span class="token operator">=</span> p                r <span class="token operator">=</span> r<span class="token punctuation">.</span>next            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next            count <span class="token operator">+=</span> <span class="token number">1</span>        r<span class="token punctuation">.</span>next <span class="token operator">=</span> None        q<span class="token punctuation">.</span>next <span class="token operator">=</span> dummyhead2<span class="token punctuation">.</span>next        <span class="token keyword">return</span> dummyhead1<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1046题-最后一块石头的重量"><a href="#1046题-最后一块石头的重量" class="headerlink" title="1046题 最后一块石头的重量"></a>1046题 <a href="https://leetcode-cn.com/problems/last-stone-weight/" target="_blank" rel="noopener">最后一块石头的重量</a></h3><p><img src="1046.png" alt="1046"></p><h4 id="思路：-177"><a href="#思路：-177" class="headerlink" title="思路："></a>思路：</h4><p>如果我们频繁需要取出一个列表的最大值或者最小值，那么如果直接用列表，时间复杂度会是线性的。为了降低时间复杂度，我们可以用堆这个数据结构。</p><p>python提供heapq模块，但是只支持小顶堆。我们需要自行使用负数来模拟大顶堆。</p><p>时间复杂度：$O(NlogN)$,（粗略计算，忽略常数倍数和常数项）每个元素入队一次，出队和入队调整堆的复杂度是 $O(logN)$；<br>空间复杂度：$O(N)$，优先队列的大小。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> heapq<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lastStoneWeight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stones<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        heap <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> stones<span class="token punctuation">]</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>heap<span class="token punctuation">)</span>        <span class="token keyword">while</span> len<span class="token punctuation">(</span>heap<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>            x <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>heap<span class="token punctuation">)</span>            y <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>heap<span class="token punctuation">)</span>            <span class="token keyword">if</span> x<span class="token operator">!=</span>y<span class="token punctuation">:</span>                heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>heap<span class="token punctuation">,</span> x<span class="token operator">-</span>y<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>heap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>heap<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-22-（1easy-1hard-1medium）"><a href="#2020-5-22-（1easy-1hard-1medium）" class="headerlink" title="2020.5.22 （1easy 1hard 1medium）"></a>2020.5.22 （1easy 1hard 1medium）</h2><h3 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496 下一个更大元素 I"></a>496 <a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">下一个更大元素 I</a></h3><p><img src="496.png" alt="496"></p><h4 id="思路：-178"><a href="#思路：-178" class="headerlink" title="思路："></a>思路：</h4><p>简单题，和之前的一道气温上升的最小天数类似，唯一的区别是那道题要求出上升的间隔，而这道题之要求出下一个更大的值即可，更简单。</p><p>思路是使用一个单调递减栈。每次遇到一个值，就将它与栈顶元素比较，如果大于栈顶元素值，说明栈顶元素的下一个更大元素就是当前值，将该关系使用一个哈希表存储起来即可，然后，将栈顶元素出栈。重复上述操作，直到栈空或者栈顶元素大于当前元素，就将当前元素入栈，继续向前搜索。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        bigger <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums2<span class="token punctuation">:</span>            <span class="token keyword">while</span> stack <span class="token operator">and</span> num<span class="token operator">></span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                bigger<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> num                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums1<span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">if</span> num <span class="token operator">not</span> <span class="token keyword">in</span> bigger<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> bigger<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#如果不在哈希表中，说明不存在下一个更大的值</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="460题-LFU缓存"><a href="#460题-LFU缓存" class="headerlink" title="460题 LFU缓存"></a>460题 <a href="https://leetcode-cn.com/problems/lfu-cache/" target="_blank" rel="noopener">LFU缓存</a></h3><p><img src="496.png" alt="496"></p><h4 id="思路：-179"><a href="#思路：-179" class="headerlink" title="思路："></a>思路：</h4><p>我的思路借鉴了之前的LRU算法，略微修改，在它的基础上添加了一个计数器，用于记录每个键的使用频率。每次需要页面置换时，顺序遍历LRU的双向链表，找到第一个使用频率最小的键，将其删除。（原先的LRU双向队列是队首为最近使用的键，队尾为最远使用的键，我们修改成相反的含义，其实不改也可以，只是要反向搜索）</p><p>效率不是很好，页面置换的时间复杂度高达$O(n)$，其余操作均为$O(1)$，可以进一步优化。应该可以直接维护一个频次递减的双向队列，而不是维护一个使用距今时间递减的双向队列。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">BiListNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token comment" spellcheck="true">#需要存key，因为要根据链表的变化反过来动态修改哈希表</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> value        self<span class="token punctuation">.</span>pre <span class="token operator">=</span> None        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">BiLinkedList</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>head <span class="token operator">=</span> BiListNode<span class="token punctuation">(</span>None<span class="token punctuation">,</span>None<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>tail <span class="token operator">=</span> BiListNode<span class="token punctuation">(</span>None<span class="token punctuation">,</span>None<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>tail        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>pre <span class="token operator">=</span> self<span class="token punctuation">.</span>head<span class="token comment" spellcheck="true">#双向链表的话，既要有伪头节点，还要有伪尾节点，方便从尾部进行修改</span>    <span class="token keyword">def</span> <span class="token function">moveToBack</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#删除节点</span>        self<span class="token punctuation">.</span>addToBack<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#加到尾部 </span>    <span class="token keyword">def</span> <span class="token function">addToBack</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        node<span class="token punctuation">.</span>pre <span class="token operator">=</span> self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>pre        node<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>tail        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>pre <span class="token operator">=</span> node        node<span class="token punctuation">.</span>pre<span class="token punctuation">.</span>next <span class="token operator">=</span> node        <span class="token comment" spellcheck="true">#加到尾部</span>    <span class="token keyword">def</span> <span class="token function">remove</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        node<span class="token punctuation">.</span>pre<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>pre <span class="token operator">=</span> node<span class="token punctuation">.</span>pre        <span class="token comment" spellcheck="true">#删除节点</span><span class="token keyword">class</span> <span class="token class-name">LFUCache</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> capacity<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity        self<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>times <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>hashmap <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        self<span class="token punctuation">.</span>linkedlist <span class="token operator">=</span> BiLinkedList<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>hashmap<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            node <span class="token operator">=</span> self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span>            self<span class="token punctuation">.</span>times<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>moveToBack<span class="token punctuation">(</span>node<span class="token punctuation">)</span>            <span class="token keyword">return</span> node<span class="token punctuation">.</span>val        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">put</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">:</span> int<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>hashmap<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            node <span class="token operator">=</span> self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span>            node<span class="token punctuation">.</span>val <span class="token operator">=</span> value            self<span class="token punctuation">.</span>times<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>moveToBack<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token keyword">elif</span> self<span class="token punctuation">.</span>size <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>capacity<span class="token punctuation">:</span>            node <span class="token operator">=</span> BiListNode<span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> node            self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>addToBack<span class="token punctuation">(</span>node<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>times<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            self<span class="token punctuation">.</span>size <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#页面置换算法</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>capacity<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                min_times <span class="token operator">=</span> min<span class="token punctuation">(</span>self<span class="token punctuation">.</span>times<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                p <span class="token operator">=</span> self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next                <span class="token keyword">while</span> p<span class="token operator">!=</span>self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>tail<span class="token punctuation">:</span>                    <span class="token keyword">if</span> self<span class="token punctuation">.</span>times<span class="token punctuation">[</span>p<span class="token punctuation">.</span>key<span class="token punctuation">]</span><span class="token operator">==</span>min_times<span class="token punctuation">:</span>                        <span class="token keyword">break</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        p <span class="token operator">=</span> p<span class="token punctuation">.</span>next                self<span class="token punctuation">.</span>times<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>p<span class="token punctuation">.</span>key<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>p<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>hashmap<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>p<span class="token punctuation">.</span>key<span class="token punctuation">)</span>                node <span class="token operator">=</span> BiListNode<span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> node                self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>addToBack<span class="token punctuation">(</span>node<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>times<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token comment" spellcheck="true"># Your LFUCache object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = LFUCache(capacity)</span><span class="token comment" spellcheck="true"># param_1 = obj.get(key)</span><span class="token comment" spellcheck="true"># obj.put(key,value)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="208题-实现-Trie-前缀树"><a href="#208题-实现-Trie-前缀树" class="headerlink" title="208题 实现 Trie (前缀树)"></a>208题 <a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">实现 Trie (前缀树)</a></h3><p><img src="208.png" alt="208"></p><h4 id="思路：-180"><a href="#思路：-180" class="headerlink" title="思路："></a>思路：</h4><p>前缀树是求解字符串问题非常有效的方法，它可以方便地找到单词的前缀，判断单词是否存在。与哈希表判断单词是否存在相比，它可以解决哈希碰撞问题，在某些情况下优化时间复杂度。</p><p>前缀树，顾名思义，使用TreeNode进行存储。本题的所有方法都可以用递归和循环两种方式解决，通常情况下，循环方式占用的空间更小，所以我们选择循环方式。</p><ul><li>插入单词操作，我们每次选取单词的一个字符，将其插入到当前子树的孩子节点中，并进入该节点，继续插入字符，直到单词的字符被遍历完。这时，我们要插入一个结束符，表示截止到该节点的路径表示了一个完整的单词。</li><li>搜索单词和搜索前缀操作基本类似，都是在前缀树中向下搜索。只不过搜索单词必须要找到结束符，而搜索前缀不需要。</li></ul><p><img src="208-1.png" alt="208-1"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>childs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Trie</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>None<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Inserts a word into the trie.        """</span>        root <span class="token operator">=</span> self<span class="token punctuation">.</span>root        <span class="token keyword">for</span> ch <span class="token keyword">in</span> word<span class="token punctuation">:</span>            <span class="token keyword">if</span> ch <span class="token operator">not</span> <span class="token keyword">in</span> root<span class="token punctuation">.</span>childs<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                root<span class="token punctuation">.</span>childs<span class="token punctuation">[</span>ch<span class="token punctuation">]</span> <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>ch<span class="token punctuation">)</span>            root <span class="token operator">=</span> root<span class="token punctuation">.</span>childs<span class="token punctuation">[</span>ch<span class="token punctuation">]</span>        <span class="token keyword">if</span> <span class="token string">'#'</span> <span class="token operator">not</span> <span class="token keyword">in</span> root<span class="token punctuation">.</span>childs<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            root<span class="token punctuation">.</span>childs<span class="token punctuation">[</span><span class="token string">'#'</span><span class="token punctuation">]</span> <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token string">'#'</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Returns if the word is in the trie.        """</span>        root <span class="token operator">=</span> self<span class="token punctuation">.</span>root        <span class="token keyword">for</span> ch <span class="token keyword">in</span> word<span class="token punctuation">:</span>            <span class="token keyword">if</span> ch <span class="token operator">not</span> <span class="token keyword">in</span> root<span class="token punctuation">.</span>childs<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            root <span class="token operator">=</span> root<span class="token punctuation">.</span>childs<span class="token punctuation">[</span>ch<span class="token punctuation">]</span>        <span class="token keyword">if</span> <span class="token string">'#'</span> <span class="token operator">not</span> <span class="token keyword">in</span> root<span class="token punctuation">.</span>childs<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">def</span> <span class="token function">startsWith</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prefix<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Returns if there is any word in the trie that starts with the given prefix.        """</span>        root <span class="token operator">=</span> self<span class="token punctuation">.</span>root        <span class="token keyword">for</span> ch <span class="token keyword">in</span> prefix<span class="token punctuation">:</span>            <span class="token keyword">if</span> ch <span class="token operator">not</span> <span class="token keyword">in</span> root<span class="token punctuation">.</span>childs<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            root <span class="token operator">=</span> root<span class="token punctuation">.</span>childs<span class="token punctuation">[</span>ch<span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span class="token comment" spellcheck="true"># Your Trie object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = Trie()</span><span class="token comment" spellcheck="true"># obj.insert(word)</span><span class="token comment" spellcheck="true"># param_2 = obj.search(word)</span><span class="token comment" spellcheck="true"># param_3 = obj.startsWith(prefix)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，我们可以用一个嵌套的字典来模拟前缀树，而不需要建立完整的树节点，能够减少时间复杂度。</p><h3 id="495题-提莫攻击"><a href="#495题-提莫攻击" class="headerlink" title="495题 提莫攻击"></a>495题 <a href="https://leetcode-cn.com/problems/teemo-attacking/" target="_blank" rel="noopener">提莫攻击</a></h3><p><img src="495.png" alt="495"></p><h4 id="思路：-181"><a href="#思路：-181" class="headerlink" title="思路："></a>思路：</h4><p>每次在中毒状态持续范围内的攻击，让其延续中毒状态。否则，先统计一下上次中毒的时间，加到结果中，然后修改中毒开始时间和结束时间。</p><p>需要注意一点，就是最后会有一段中毒时间没有被统计，需要加入结果中。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findPoisonedDuration</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> timeSeries<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> duration<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        start_time <span class="token operator">=</span> <span class="token number">0</span>        end_time <span class="token operator">=</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>timeSeries<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> timeSeries<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> end_time<span class="token punctuation">:</span>                res <span class="token operator">+=</span> end_time <span class="token operator">-</span> start_time                start_time <span class="token operator">=</span> timeSeries<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                end_time <span class="token operator">=</span> start_time <span class="token operator">+</span> duration            <span class="token keyword">else</span><span class="token punctuation">:</span>                end_time <span class="token operator">=</span> timeSeries<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> duration        res <span class="token operator">+=</span> end_time <span class="token operator">-</span> start_time        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-23-（2easy-2medium）"><a href="#2020-5-23-（2easy-2medium）" class="headerlink" title="2020.5.23 （2easy 2medium）"></a>2020.5.23 （2easy 2medium）</h2><h3 id="455题-分发饼干"><a href="#455题-分发饼干" class="headerlink" title="455题 分发饼干"></a>455题 <a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">分发饼干</a></h3><p><img src="455.png" alt="455"></p><h4 id="思路：-182"><a href="#思路：-182" class="headerlink" title="思路："></a>思路：</h4><p>和之前的有一道判断子序列的题目挺像的，可以使用双指针法来求解。</p><p>前提是需要数组有序。我们每次让p指针指向g数组中的元素，q指针指向s数组中的元素，如果p指针只想的元素小于等于q指针指向的元素，表明这个小朋友的胃口必然能被这块饼干满足。由于数组都是有序的，所以本质上是一个贪心的解法，每次都选取满足小朋友需求的最小的饼干。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findContentChildren</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> g<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        g<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        s<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        p<span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">while</span> p<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>g<span class="token punctuation">)</span> <span class="token operator">and</span> q<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> g<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">&lt;=</span>s<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">:</span>                p <span class="token operator">+=</span> <span class="token number">1</span>            q <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="129题-求根到叶子节点数字之和"><a href="#129题-求根到叶子节点数字之和" class="headerlink" title="129题 求根到叶子节点数字之和"></a>129题 <a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">求根到叶子节点数字之和</a></h3><p><img src="129.png" alt="129"></p><h4 id="思路：-183"><a href="#思路：-183" class="headerlink" title="思路："></a>思路：</h4><p>DFS+回溯的基本题目，使用先序遍历搜索所有到达叶子节点的路径，使用一个num变量记录当前路径的值，搜素完当前子树需要将num变量的值回溯。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sumNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">:</span>                num <span class="token operator">=</span> num <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> root<span class="token punctuation">.</span>val                <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>left <span class="token operator">and</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>res <span class="token operator">+=</span> num                <span class="token keyword">else</span><span class="token punctuation">:</span>                    inorder<span class="token punctuation">(</span>num<span class="token punctuation">,</span> root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                    inorder<span class="token punctuation">(</span>num<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                num <span class="token operator">%=</span> <span class="token number">10</span> <span class="token comment" spellcheck="true">#回溯</span>        inorder<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1266题-访问所有点的最小时间"><a href="#1266题-访问所有点的最小时间" class="headerlink" title="1266题 访问所有点的最小时间"></a>1266题 <a href="https://leetcode-cn.com/problems/minimum-time-visiting-all-points/" target="_blank" rel="noopener">访问所有点的最小时间</a></h3><p><img src="1266.png" alt="1266"></p><h4 id="思路：-184"><a href="#思路：-184" class="headerlink" title="思路："></a>思路：</h4><p>起初，我使用了贪心的递归模拟，虽然能通过，但是时间复杂度很高。基本思想是如果目标点不在正方向上，那么就朝对应的对角线方向移动，如果目标点在正方向上，那么就向对应的正方向上移动。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minTimeToVisitAllPoints</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> points<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">move</span><span class="token punctuation">(</span>now_i<span class="token punctuation">,</span>now_j<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>points<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> now_i<span class="token operator">==</span>points<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">and</span> now_j<span class="token operator">==</span>points<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    move<span class="token punctuation">(</span>now_i<span class="token punctuation">,</span>now_j<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>res <span class="token operator">+=</span> <span class="token number">1</span>                    diff_x <span class="token operator">=</span> points<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> now_i                    diff_y <span class="token operator">=</span> points<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> now_j                    offset_x <span class="token operator">=</span> <span class="token number">0</span>                    offset_y <span class="token operator">=</span> <span class="token number">0</span>                    <span class="token keyword">if</span> diff_x<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                        offset_x <span class="token operator">=</span> <span class="token number">1</span>                    <span class="token keyword">elif</span> diff_x<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>                        offset_x <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>                    <span class="token keyword">if</span> diff_y<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                        offset_y <span class="token operator">=</span> <span class="token number">1</span>                    <span class="token keyword">elif</span> diff_y<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>                        offset_y <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>                    move<span class="token punctuation">(</span>offset_x<span class="token operator">+</span>now_i<span class="token punctuation">,</span> offset_y<span class="token operator">+</span>now_j<span class="token punctuation">,</span> index<span class="token punctuation">)</span>        move<span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码的问题是一步一步地移动，非常缓慢，我们应该尝试一次性移动多个位置。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minTimeToVisitAllPoints</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> points<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">move</span><span class="token punctuation">(</span>now_i<span class="token punctuation">,</span>now_j<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>points<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> now_i<span class="token operator">==</span>points<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">and</span> now_j<span class="token operator">==</span>points<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果当前已经到达目标点，更换目标点为下一个</span>                    move<span class="token punctuation">(</span>now_i<span class="token punctuation">,</span>now_j<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    diff_x <span class="token operator">=</span> points<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> now_i                    diff_y <span class="token operator">=</span> points<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> now_j                    offset_x <span class="token operator">=</span> <span class="token number">0</span>                    offset_y <span class="token operator">=</span> <span class="token number">0</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>diff_x<span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">and</span> diff_y<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>diff_y<span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">and</span> diff_x<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果在正方向上，直接移动到对应的目标点</span>                        offset_x <span class="token operator">=</span> diff_x <span class="token keyword">if</span> diff_x <span class="token keyword">else</span> <span class="token number">0</span>                        offset_y <span class="token operator">=</span> diff_y <span class="token keyword">if</span> diff_y <span class="token keyword">else</span> <span class="token number">0</span>                        self<span class="token punctuation">.</span>res <span class="token operator">+=</span> abs<span class="token punctuation">(</span>offset_x<span class="token punctuation">)</span> <span class="token keyword">if</span> offset_x <span class="token keyword">else</span> abs<span class="token punctuation">(</span>offset_y<span class="token punctuation">)</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果不在正方向上，朝对应方向的对角线移动，直到到达正方向</span>                        offset_x <span class="token operator">=</span> offset_y <span class="token operator">=</span> min<span class="token punctuation">(</span>abs<span class="token punctuation">(</span>diff_x<span class="token punctuation">)</span><span class="token punctuation">,</span> abs<span class="token punctuation">(</span>diff_y<span class="token punctuation">)</span><span class="token punctuation">)</span>                        offset_x <span class="token operator">*=</span> <span class="token number">1</span> <span class="token keyword">if</span> diff_x<span class="token operator">></span><span class="token number">0</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>                        offset_y <span class="token operator">*=</span> <span class="token number">1</span> <span class="token keyword">if</span> diff_y<span class="token operator">></span><span class="token number">0</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>                        self<span class="token punctuation">.</span>res <span class="token operator">+=</span> abs<span class="token punctuation">(</span>offset_x<span class="token punctuation">)</span>                    move<span class="token punctuation">(</span>offset_x<span class="token operator">+</span>now_i<span class="token punctuation">,</span> offset_y<span class="token operator">+</span>now_j<span class="token punctuation">,</span> index<span class="token punctuation">)</span>        move<span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，这道题是一个切比雪夫距离问题。可以直接用数学法求解。（如果有障碍物，还是要考虑模拟的方法）</p><p><img src="1266-1.png" alt="切比雪夫距离"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minTimeToVisitAllPoints</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> points<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>points<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> max<span class="token punctuation">(</span>abs<span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>points<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>abs<span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>points<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="150题-逆波兰表达式求值"><a href="#150题-逆波兰表达式求值" class="headerlink" title="150题 逆波兰表达式求值"></a>150题 <a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">逆波兰表达式求值</a></h3><p><img src="150.png" alt="150"></p><h4 id="思路：-185"><a href="#思路：-185" class="headerlink" title="思路："></a>思路：</h4><p>波兰表达式是学习栈过程中必须掌握的题目，我们使用一个栈进行模拟即可。</p><p>需要注意的是，python的整除在结果小于0时会向下取整，我们应该都是向上取整，所以使用int（a/b）代替a//b</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">evalRPN</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tokens<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> token <span class="token keyword">in</span> tokens<span class="token punctuation">:</span>            <span class="token keyword">if</span> token <span class="token operator">==</span> <span class="token string">'+'</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token keyword">elif</span> token <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">:</span>                a<span class="token punctuation">,</span> b <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>b <span class="token operator">-</span> a<span class="token punctuation">)</span>             <span class="token keyword">elif</span> token <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token keyword">elif</span> token <span class="token operator">==</span> <span class="token string">'/'</span><span class="token punctuation">:</span>                a<span class="token punctuation">,</span> b <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>int<span class="token punctuation">(</span>b<span class="token operator">/</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>int<span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> stack<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-24（3easy-2medium）"><a href="#2020-5-24（3easy-2medium）" class="headerlink" title="2020.5.24（3easy 2medium）"></a>2020.5.24（3easy 2medium）</h2><h3 id="205题-同构字符串"><a href="#205题-同构字符串" class="headerlink" title="205题  同构字符串"></a>205题 <a href="https://leetcode-cn.com/problems/isomorphic-strings/" target="_blank" rel="noopener"> 同构字符串</a></h3><p><img src="205.png" alt="205"></p><h4 id="思路：-186"><a href="#思路：-186" class="headerlink" title="思路："></a>思路：</h4><p>使用哈希表来建立s和t中的字母的一一映射关系，一旦发现了不符合映射关系的情况，就返回False，如果全部满足映射关系，那么就返回True。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isIsomorphic</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        hashmap <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">!=</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> hashmap<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> hashmap<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">!=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> hashmap<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>                hashmap<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="977题-有序数组的平方"><a href="#977题-有序数组的平方" class="headerlink" title="977题 有序数组的平方"></a>977题 <a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">有序数组的平方</a></h3><p><img src="977.png" alt="977"></p><h4 id="思路：-187"><a href="#思路：-187" class="headerlink" title="思路："></a>思路：</h4><p>这道题起初我只想到了先平方和再排序的暴力方法。</p><p>实际上，由于原数组升序排序，且可能含有负数，所以数字的平方和必定从两侧向中间减小（越接近0越小）。</p><p>我们可以使用双指针的方法求解。起初的最大平方数必然来自数组的两端，因为要么是最小负数的平方，要么是最大正数的平方。我们让两个指针分别指向数组的两端，每次从二者中选择一个较大平方的数加入到结果数组，然后收缩对应的指针。最后要将结果数组翻转。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortedSquares</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        p<span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> p<span class="token operator">&lt;=</span>q<span class="token punctuation">:</span>            <span class="token keyword">if</span> abs<span class="token punctuation">(</span>A<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span>abs<span class="token punctuation">(</span>A<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>A<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token operator">*</span>A<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span>                q <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>A<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">*</span>A<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span>                p <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="143题-重排链表"><a href="#143题-重排链表" class="headerlink" title="143题 重排链表"></a>143题 <a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">重排链表</a></h3><p><img src="143.png" alt="143"></p><h4 id="思路：-188"><a href="#思路：-188" class="headerlink" title="思路："></a>思路：</h4><p>我的思路是这样的：</p><ul><li>快慢双指针法找到链表中点，同时使用一个辅助栈存放中点之前的每个节点。</li><li>找到中点后，遍历后半部分的节点，每次从辅助栈中取出一个节点，将当前节点移动到该节点后面。</li><li>需要注意的是：链表长度为奇数和偶数两种情况下，需要分类讨论一下。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, next=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.next = next</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reorderList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify head in-place instead.        """</span>        <span class="token keyword">if</span> head<span class="token punctuation">:</span>            stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            p <span class="token operator">=</span> head            q <span class="token operator">=</span> head<span class="token punctuation">.</span>next            <span class="token keyword">while</span> q <span class="token operator">and</span> q<span class="token punctuation">.</span>next<span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next                q <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            <span class="token keyword">if</span> stack<span class="token punctuation">:</span>                <span class="token keyword">if</span> q<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#判断链表长度奇偶性</span>                    p <span class="token operator">=</span> p<span class="token punctuation">.</span>next                <span class="token keyword">while</span> p<span class="token punctuation">.</span>next<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#将后半链表插入到前半链表的缝隙中去</span>                    node1 <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                    node2 <span class="token operator">=</span> p<span class="token punctuation">.</span>next                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next                    node2<span class="token punctuation">.</span>next <span class="token operator">=</span> node1<span class="token punctuation">.</span>next                    node1<span class="token punctuation">.</span>next <span class="token operator">=</span> node2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="116题-填充每个节点的下一个右侧节点指针"><a href="#116题-填充每个节点的下一个右侧节点指针" class="headerlink" title="116题 填充每个节点的下一个右侧节点指针"></a>116题 <a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">填充每个节点的下一个右侧节点指针</a></h3><p><img src="116.png" alt="116"></p><h4 id="思路：-189"><a href="#思路：-189" class="headerlink" title="思路："></a>思路：</h4><p>这种需要在树的同一层进行修改的题目，优先考虑层次遍历。</p><p>我们对于这个完美二叉树，需要从右到左遍历每一层的节点，然后让每个节点的next指针指向上一个节点。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""# Definition for a Node.class Node:    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):        self.val = val        self.left = left        self.right = right        self.next = next"""</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">connect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Node'</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token punctuation">:</span>            queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>            <span class="token keyword">while</span> queue<span class="token punctuation">:</span>                next <span class="token operator">=</span> None                L <span class="token operator">=</span> len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">:</span>                    node <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                    node<span class="token punctuation">.</span>next <span class="token operator">=</span> next                    next <span class="token operator">=</span> node                    <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                    <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="605题-种花问题"><a href="#605题-种花问题" class="headerlink" title="605题 种花问题"></a>605题 <a href="https://leetcode-cn.com/problems/can-place-flowers/" target="_blank" rel="noopener">种花问题</a></h3><p><img src="605.png" alt="605"></p><h4 id="思路：-190"><a href="#思路：-190" class="headerlink" title="思路："></a>思路：</h4><p>本题显然是一个动态规划问题。如果我们使用回溯方法，将会产生大量重叠子问题。</p><p>和买卖股票、打家劫舍等问题类似，本题是一个二维动态规划问题，动态规划的状态矩阵dp[i] [j]表示第 i 个花盆的第 j 种选择后当前所能种入的花的总数，j = 0时，选择不种花，j=1时，选择种花。</p><p>这题的特别之处在于有的花盆已经被种上花了，所以对应的DP矩阵只能选择种花，而将不种花的情况修改为0.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canPlaceFlowers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> flowerbed<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>flowerbed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> flowerbed<span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token punctuation">:</span>                count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>flowerbed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> flowerbed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> flowerbed<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>count<span class="token operator">>=</span>n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上本题还可以简化成贪心问题，只要能够种花就选择种。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canPlaceFlowers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> flowerbed<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>flowerbed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            left <span class="token operator">=</span> flowerbed<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token keyword">if</span> i<span class="token number">-1</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">0</span>            right <span class="token operator">=</span> flowerbed<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">if</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>flowerbed<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">0</span>            <span class="token keyword">if</span> <span class="token operator">not</span> left <span class="token operator">and</span> <span class="token operator">not</span> right <span class="token operator">and</span> <span class="token operator">not</span> flowerbed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                count <span class="token operator">+=</span> <span class="token number">1</span>                flowerbed<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">return</span> count<span class="token operator">>=</span>n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-25（2easy-2medium）"><a href="#2020-5-25（2easy-2medium）" class="headerlink" title="2020.5.25（2easy 2medium）"></a>2020.5.25（2easy 2medium）</h2><h3 id="665题-非递减数列"><a href="#665题-非递减数列" class="headerlink" title="665题 非递减数列"></a>665题 <a href="https://leetcode-cn.com/problems/non-decreasing-array/" target="_blank" rel="noopener">非递减数列</a></h3><p><img src="655.png" alt="655"></p><h4 id="思路：-191"><a href="#思路：-191" class="headerlink" title="思路："></a>思路：</h4><p>这道题虽然标了easy，但我认为还是挺难的，主要是不太好推出变化的规律。</p><ul><li>首先，我们遍历数列，寻找到每一个递减的位置。</li><li>然后，我们需要尝试对该位置进行调整。如果我们不调整，仅仅统计出现了多少次递减，那么结果不一定是对的，比如[3,4,2,3]这种测试用例，虽然只有一次递减，但只通过一次调整是无法成为非递减序列的。</li><li>调整的方法如下：<ul><li>导致递减（nums[i]&gt;nums[i+1]）的情况无非有两个：nums[i]太大，或者nums[i+1]太小。我们先考虑缩小nums[i]。由于之前的序列必然非递减，那么nums[i]想要保持非递减，最小能够修改的值为nums[i-1]，特别地，当i==0时，我们只能让nums[i] = nums[i+1]</li><li>但是，让nums[i]缩小后，并不一定能保证nums[i]&lt;=nums[i+1]。此时，我们要将nums[i]还原，再尝试让nums[i+1]变大为nums[i]，这样能保证nums[i]&lt;=nums[i+1]（为什么从一开始不直接让nums[i+1]变大？考虑这样的一种情况[4,2,3]或者[1,2,5,3,4]等，缩小nums[i]的优先级更高）</li></ul></li><li>如果调整的次数超过1次，返回false。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">checkPossibility</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp                    nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                count <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="106题-从中序与后序遍历序列构造二叉树"><a href="#106题-从中序与后序遍历序列构造二叉树" class="headerlink" title="106题 从中序与后序遍历序列构造二叉树"></a>106题 <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">从中序与后序遍历序列构造二叉树</a></h3><p><img src="106.png" alt="106"></p><h4 id="思路：-192"><a href="#思路：-192" class="headerlink" title="思路："></a>思路：</h4><p>和根据前序后序序列重构二叉树类似，依然可以用后序序列找到当前子树的根节点，然后根据根节点，通过中序序列找到左右子树个数，截取左右子树的中序和后序序列，递归构造左右子树。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> postorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>inL<span class="token punctuation">,</span> inR<span class="token punctuation">,</span> postL<span class="token punctuation">,</span> postR<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> inL <span class="token operator">></span> inR<span class="token punctuation">:</span>                <span class="token keyword">return</span>            root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>postR<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>inL<span class="token punctuation">,</span> inR<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> postorder<span class="token punctuation">[</span>postR<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>            root<span class="token punctuation">.</span>left <span class="token operator">=</span> build<span class="token punctuation">(</span>inL<span class="token punctuation">,</span> i<span class="token number">-1</span><span class="token punctuation">,</span> postL<span class="token punctuation">,</span> postL<span class="token operator">+</span><span class="token punctuation">(</span>i<span class="token operator">-</span>inL<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>right <span class="token operator">=</span> build<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> inR<span class="token punctuation">,</span> postL<span class="token operator">+</span><span class="token punctuation">(</span>i<span class="token operator">-</span>inL<span class="token punctuation">)</span><span class="token punctuation">,</span> postR<span class="token number">-1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token keyword">return</span> build<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>inorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>postorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，这种题目由于要大量查找根节点在中序遍历中的位置，而列表的查询是线性的时间复杂度，所以我们可以尝试使用哈希表来优化。使用哈希表存储中序遍历序列中每一个值和其对应位置的映射关系。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> postorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>inL<span class="token punctuation">,</span> inR<span class="token punctuation">,</span> postL<span class="token punctuation">,</span> postR<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> inL <span class="token operator">></span> inR<span class="token punctuation">:</span>                <span class="token keyword">return</span>            root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>postR<span class="token punctuation">]</span><span class="token punctuation">)</span>            i <span class="token operator">=</span> self<span class="token punctuation">.</span>dic<span class="token punctuation">[</span>postorder<span class="token punctuation">[</span>postR<span class="token punctuation">]</span><span class="token punctuation">]</span>            root<span class="token punctuation">.</span>left <span class="token operator">=</span> build<span class="token punctuation">(</span>inL<span class="token punctuation">,</span> i<span class="token number">-1</span><span class="token punctuation">,</span> postL<span class="token punctuation">,</span> postL<span class="token operator">+</span><span class="token punctuation">(</span>i<span class="token operator">-</span>inL<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>right <span class="token operator">=</span> build<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> inR<span class="token punctuation">,</span> postL<span class="token operator">+</span><span class="token punctuation">(</span>i<span class="token operator">-</span>inL<span class="token punctuation">)</span><span class="token punctuation">,</span> postR<span class="token number">-1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> root        self<span class="token punctuation">.</span>dic <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>inorder<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>dic<span class="token punctuation">[</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token keyword">return</span> build<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>inorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>postorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="216题-组合总和-III"><a href="#216题-组合总和-III" class="headerlink" title="216题 组合总和 III"></a>216题 <a href="https://leetcode-cn.com/problems/combination-sum-iii/" target="_blank" rel="noopener">组合总和 III</a></h3><p><img src="216.png" alt="216"></p><h4 id="思路：-193"><a href="#思路：-193" class="headerlink" title="思路："></a>思路：</h4><p>组合总和问题：回溯法解决。</p><p>DFS的方法其性能往往不是很好，所以使用时能剪枝也一定要剪枝。本题如果当前选的数字无法让后续的最小递增序列与当前和相加小于等于n，那么需要进行剪枝操作。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">combinationSum3</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> path<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index <span class="token operator">==</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> path<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span> n <span class="token operator">-</span> s <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token operator">+</span><span class="token punctuation">[</span>n<span class="token operator">-</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                index <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>path<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">if</span> path <span class="token keyword">else</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    x <span class="token operator">=</span> <span class="token number">0</span>                    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token operator">+</span>k<span class="token operator">-</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>                        x <span class="token operator">+=</span> j                    <span class="token keyword">if</span> s<span class="token operator">+</span>x<span class="token operator">&lt;=</span>n<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#剪枝</span>                        dfs<span class="token punctuation">(</span>index<span class="token punctuation">,</span> path<span class="token operator">+</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token operator">+</span>i<span class="token punctuation">)</span>        dfs<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2020-5-26（3easy-1medium-1hard）"><a href="#2020-5-26（3easy-1medium-1hard）" class="headerlink" title="2020.5.26（3easy 1medium 1hard）"></a>2020.5.26（3easy 1medium 1hard）</h3><h3 id="1351题-统计有序矩阵中的负数"><a href="#1351题-统计有序矩阵中的负数" class="headerlink" title="1351题 统计有序矩阵中的负数"></a>1351题 <a href="https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/" target="_blank" rel="noopener">统计有序矩阵中的负数</a></h3><p><img src="1351.png" alt="1351"></p><h4 id="思路：-194"><a href="#思路：-194" class="headerlink" title="思路："></a>思路：</h4><p>简单题，可以画图看一下，由于按行和按列都非递增，一旦某个元素为负数，则行数大于它和列数大于它的元素都为负数，按照此规律可以优化时间复杂度。</p><p>（还可以使用二分查找第一个负数位置，进一步优化）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countNegatives</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token number">0</span>        n <span class="token operator">=</span> <span class="token number">101</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>min<span class="token punctuation">(</span>n<span class="token punctuation">,</span> len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> <span class="token punctuation">(</span>min<span class="token punctuation">(</span>n<span class="token punctuation">,</span> len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span>j<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token punctuation">)</span>                    n <span class="token operator">=</span> j                    <span class="token keyword">break</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="709题-转换成小写字母"><a href="#709题-转换成小写字母" class="headerlink" title="709题  转换成小写字母"></a>709题  <a href="https://leetcode-cn.com/problems/to-lower-case/" target="_blank" rel="noopener">转换成小写字母</a></h3><p><img src="709.png" alt="709"></p><h4 id="思路：-195"><a href="#思路：-195" class="headerlink" title="思路："></a>思路：</h4><p>简单题，直接修改ASCII码即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">toLowerCase</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> str<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        str <span class="token operator">=</span> list<span class="token punctuation">(</span>str<span class="token punctuation">)</span>        offset <span class="token operator">=</span> ord<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> idx<span class="token punctuation">,</span>ch <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> ord<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span>ord<span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token operator">&lt;=</span>ord<span class="token punctuation">(</span><span class="token string">'Z'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                str<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> chr<span class="token punctuation">(</span>ord<span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token operator">-</span>offset<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>str<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="922题-按奇偶排序数组-II"><a href="#922题-按奇偶排序数组-II" class="headerlink" title="922题 按奇偶排序数组 II"></a>922题 <a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/" target="_blank" rel="noopener">按奇偶排序数组 II</a></h3><p><img src="922.png" alt="922"></p><h4 id="思路：-196"><a href="#思路：-196" class="headerlink" title="思路："></a>思路：</h4><p>双指针法，一个指针从前向后遍历寻找所有的 当 <code>A[i]</code> 为奇数时，<code>i</code> 不是奇数的情况，一个指针从后向前遍历需按照所有的 当 <code>A[i]</code> 为偶数时， <code>i</code> 不是偶数的情况。</p><p>每次将二者交换，直到遍历完所有的元素，此时数组符合条件。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortArrayByParityII</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        p <span class="token operator">=</span> <span class="token number">0</span>        q <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token number">0</span><span class="token operator">&lt;=</span>p<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span> <span class="token operator">and</span> <span class="token operator">not</span> p<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>                p <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">while</span> <span class="token number">0</span><span class="token operator">&lt;=</span>q<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">not</span> A<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span> <span class="token operator">and</span> q<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>                q <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> p<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">and</span> q<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">:</span>                A<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>p<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>        <span class="token keyword">return</span> A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-08-11-硬币"><a href="#面试题-08-11-硬币" class="headerlink" title="面试题 08.11. 硬币"></a><a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">面试题 08.11. 硬币</a></h3><p><img src="8-11.png" alt="8-11"></p><h4 id="思路：-197"><a href="#思路：-197" class="headerlink" title="思路："></a>思路：</h4><p>类似于这种找组合题，最核心的做法无非就是搜索（BFS求最小组合，DFS求一个完整组合）或者动态规划（求所有组合）。</p><p>本题要找出所有组合，而搜索类方法不可避免地带来重叠子问题。例如，100元可以有多种方式拆分为90元，尽管剩余的金额一样，拆分的方法也类似，但DFS或BFS会将这几种方法看作不同的分支，继续从90元进行拆分，导致时间和空间的浪费。较好的解决方法是使用动态规划。</p><p>本题的动态规划矩阵为dp[i]，表示金额i共有几种表示法。</p><p>我们可能想当然地认为：</p><ul><li>dp[i] = dp[i-1] + dp[i-5] + dp[i-10] + dp[i-25]</li></ul><p>但其实这样做是不对的，假如i = 6，上述算法会求得dp[6] = 3，这是因为它将[1,5]和[5,1]看作是两种不同的组合，实际上它们是一种情况。</p><p>所有，我们要修改动态规划的方法。为了使硬币的组合情况升序，去除[5,1]这种情况，我们需要按照硬币金额逐轮分解。这样分解出来的组合都是升序的。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">waysToChange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        coins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> coin <span class="token keyword">in</span> coins<span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>coin<span class="token punctuation">]</span> <span class="token keyword">if</span> i<span class="token operator">-</span>coin<span class="token operator">>=</span><span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">0</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，这就是一个<strong>完全背包问题</strong>。我们可以将金额看作是背包容量，硬币看作是价值和重量相等的物品，我们不限定每种硬币选取的数目。</p><p>一定要先选物品，再选背包容量！否则会导致重复！</p><h3 id="1371题-每个元音包含偶数次的最长子字符串"><a href="#1371题-每个元音包含偶数次的最长子字符串" class="headerlink" title="1371题 每个元音包含偶数次的最长子字符串"></a>1371题 <a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener">每个元音包含偶数次的最长子字符串</a></h3><p><img src="1371.png" alt="1371"></p><h4 id="思路：-198"><a href="#思路：-198" class="headerlink" title="思路："></a>思路：</h4><p>这道题本质上是一个前缀和问题。和我们之前做过的最长优美子串类似。</p><p>子串问题，优先考虑以下三种方法：</p><ul><li>前缀和（求解某一区间的数值，包括区间和、区间内的奇数个数、区间内的元音个数等）</li><li>滑动窗口（最大无重复子串、最小覆盖子串、滑动窗口最大值等）</li><li>区间动态规划（前两种方法均不适用才考虑，时间复杂度较高，平方级别）</li></ul><p>这道题我们可以使用前缀和pre[i] [k]表示前 i 个字符中第 k 个元音出现的次数，从而很方便地求解某一段子字符串内各元音出现的次数，然后判断其是否全部为偶数即可。</p><p>但是这样做时间复杂度也很高，需要进行平方级别的时间复杂度。</p><p>实际上，我们还发现，如果某一区间[i, j]的元音个数全部为偶数，那么pre[j] [k] 的奇偶性必然和pre[i] [k]的奇偶性一致。所以，我们只需要使用一个哈希表存放五个元音不同奇偶性的情况出现在字符串中的最早位置，然后每次遍历获得当前前 i 个字符的五个元音奇偶性，与该奇偶性出现的最早位置相减，所得差值必然是一个元音全偶区间的长度，更新最大长度即可。</p><p>同时，我们发现，五个元音奇偶性可以用二进制数表示。第0位为0表示’a’出现次数为偶数，否则为奇数，依此类推。实际上，这种位示图方式在算法题和实际应用中都很常见（如操作系统的文件系统管理空闲磁盘块），可以压缩键的大小。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findTheLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token number">0</span>        status <span class="token operator">=</span> <span class="token number">0</span>        pos <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#五个二进制位，范围为0-31</span>        pos<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token comment" spellcheck="true">#前0个字符，即字符串为空时，必然出现次数全为0，即全偶</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'a'</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#每次元音出现次数加1，奇偶性都要反转，使用异或运算模拟</span>                status <span class="token operator">^</span><span class="token operator">=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'e'</span><span class="token punctuation">:</span>                status <span class="token operator">^</span><span class="token operator">=</span> <span class="token number">2</span>            <span class="token keyword">elif</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'i'</span><span class="token punctuation">:</span>                status <span class="token operator">^</span><span class="token operator">=</span> <span class="token number">4</span>            <span class="token keyword">elif</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'o'</span><span class="token punctuation">:</span>                status <span class="token operator">^</span><span class="token operator">=</span> <span class="token number">8</span>            <span class="token keyword">elif</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'u'</span><span class="token punctuation">:</span>                status <span class="token operator">^</span><span class="token operator">=</span> <span class="token number">16</span>            <span class="token keyword">if</span> pos<span class="token punctuation">[</span>status<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#与最早出现位置求差值</span>                res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> i<span class="token operator">-</span>pos<span class="token punctuation">[</span>status<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token comment" spellcheck="true">#记录最早位置</span>                pos<span class="token punctuation">[</span>status<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-27（3easy-1medium-1hard）"><a href="#2020-5-27（3easy-1medium-1hard）" class="headerlink" title="2020.5.27（3easy 1medium 1hard）"></a>2020.5.27（3easy 1medium 1hard）</h2><h3 id="832题-翻转图像"><a href="#832题-翻转图像" class="headerlink" title="832题 翻转图像"></a>832题 <a href="https://leetcode-cn.com/problems/flipping-an-image/" target="_blank" rel="noopener">翻转图像</a></h3><p><img src="832.png" alt="832"></p><h4 id="思路：-199"><a href="#思路：-199" class="headerlink" title="思路："></a>思路：</h4><p>看上去比较简单，常规的思路是遍历图像两遍。但实际上，我们可以使用一次遍历即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">flipAndInvertImage</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        rowLen <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        rowCol <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>rowLen<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token punctuation">(</span>rowCol<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>rowCol<span class="token operator">-</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#二者相异，翻转再反转没有意义</span>                    A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> <span class="token number">1</span>                    A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>rowCol<span class="token operator">-</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">return</span> A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1137题-第-N-个泰波那契数"><a href="#1137题-第-N-个泰波那契数" class="headerlink" title="1137题 第 N 个泰波那契数"></a>1137题 <a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/" target="_blank" rel="noopener">第 N 个泰波那契数</a></h3><p><img src="1137.png" alt="1137"></p><h4 id="思路：-200"><a href="#思路：-200" class="headerlink" title="思路："></a>思路：</h4><p>动态规划入门题，类似斐波那契数列。</p><p>注意特判！</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">tribonacci</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        T <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>        T<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        T<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            T<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> T<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> T<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span> <span class="token operator">+</span> T<span class="token punctuation">[</span>i<span class="token number">-3</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> T<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="168题-Excel表列名称"><a href="#168题-Excel表列名称" class="headerlink" title="168题 Excel表列名称"></a>168题 <a href="https://leetcode-cn.com/problems/excel-sheet-column-title/" target="_blank" rel="noopener">Excel表列名称</a></h3><p><img src="168.png" alt="168"></p><h4 id="思路：-201"><a href="#思路：-201" class="headerlink" title="思路："></a>思路：</h4><p>之前做过的入门题，每次需要先减1，再取余26，然后整除26。本质上是一个十进制转26进制的变形题。</p><p>减1是因为存在余数为0的情况，实际上余数为0时应该返回26，为了解决这个问题，将每次的结果向前移动1。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">convertToTitle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token string">""</span>        <span class="token keyword">while</span> n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>            n <span class="token operator">-=</span> <span class="token number">1</span>            res <span class="token operator">+=</span> chr<span class="token punctuation">(</span>ord<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token operator">+</span>n<span class="token operator">%</span><span class="token number">26</span><span class="token punctuation">)</span>            n <span class="token operator">//=</span> <span class="token number">26</span>        <span class="token keyword">return</span> res<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="134题-加油站"><a href="#134题-加油站" class="headerlink" title="134题 加油站"></a>134题 <a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">加油站</a></h3><p><img src="134.png" alt="134"></p><h4 id="思路：-202"><a href="#思路：-202" class="headerlink" title="思路："></a>思路：</h4><p>我使用了暴力模拟的方法，可以通过，但速度很慢（$O(n^2)$）。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canCompleteCircuit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> gas<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> cost<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>            g <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>gas<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                now <span class="token operator">=</span> <span class="token punctuation">(</span>index<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token operator">%</span>len<span class="token punctuation">(</span>gas<span class="token punctuation">)</span>                g <span class="token operator">+=</span> gas<span class="token punctuation">[</span>now<span class="token punctuation">]</span>                <span class="token keyword">if</span> g<span class="token operator">&lt;</span>cost<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>                g <span class="token operator">=</span> g <span class="token operator">-</span> cost<span class="token punctuation">[</span>now<span class="token punctuation">]</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>gas<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> isValid<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> i        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，可以只用一次遍历就解决。</p><p><img src="134-1.png" alt="134-1"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canCompleteCircuit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> gas<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> cost<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        rest <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">#剩余油量</span>        run <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">#当前油量</span>        start <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">#起始地址</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>gas<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            rest <span class="token operator">+=</span> gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            run <span class="token operator">+=</span> gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">if</span> run <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                run <span class="token operator">=</span> <span class="token number">0</span>                start <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> start <span class="token keyword">if</span> rest<span class="token operator">>=</span><span class="token number">0</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span><span class="token comment" spellcheck="true">#如果总耗油量小于等于总油量，那么必然可以选择一个加油站作为起点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="123题-买卖股票的最佳时机-III"><a href="#123题-买卖股票的最佳时机-III" class="headerlink" title="123题 买卖股票的最佳时机 III"></a>123题 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">买卖股票的最佳时机 III</a></h3><p><img src="123.png" alt="123"></p><h4 id="思路：-203"><a href="#思路：-203" class="headerlink" title="思路："></a>思路：</h4><p>买卖股票问题的核心在于定义好状态。相比以往的买卖股票问题，本题因为限制了买卖股票的次数，且次数大于1，所以必须要额外添加一个维度表示已经进行的交易次数这一状态。</p><p>我们定义：</p><ul><li>dp[i] [k] [0] 表示：第 i 天，进行了 k 次交易，且当前状态为不持有股票的最大收益</li><li>dp[i] [k] [1] 表示：第 i 天，进行了 k 次交易，且当前状态为持有股票的最大收益</li></ul><p>那么，k 一共有三种取值，分别为0，1，2，代表进行了0次交易、1次交易、2次交易</p><p>转移方程为：</p><ul><li>dp[i] [0] [0] = 0 （0次交易，且不持有股票，等于什么也没做，收益为0）</li><li>dp[i] [0] [1] = -∞ （0次交易，且持有股票，必然不可能，设为负无穷）</li><li>dp[i] [1] [0] = max（dp[i-1] [1] [0]，dp[i-1] [1] [1] + price[i]）（1次交易，且不持有股票，要么保持的是前一天不持有的状态，要么是从持有股票的状态卖出持有的股票得到，由于要求的是最大收益，所以取二者较大值）</li><li>dp[i] [1] [1] = max（dp[i-1] [1] [1]，dp[i-1] [0] [0] - price[i]）（1次交易，且持有股票，要么保持的是前一天持有的状态，要么是从不持有股票的状态买入股票得到，由于要求的是最大收益，所以取二者较大值）</li><li>dp[i] [2] [0] = max（dp[i-1] [2] [0]，dp[i-1] [2] [1] + price[i]）（2次交易，且不持有股票，要么保持的是前一天不持有的状态，要么是从持有股票的状态卖出持有的股票得到，由于要求的是最大收益，所以取二者较大值）</li><li>dp[i] [2] [1] = max（dp[i-1] [2] [1]，dp[i-1] [1] [0] - price[i]）（2次交易，且持有股票，要么保持的是前一天持有的状态，要么是从不持有股票的状态买入股票得到，由于要求的是最大收益，所以取二者较大值）</li></ul><p>接着，我们尝试定义初始状态，即第0天的状态：</p><ul><li>dp[0] [0] [0] = 0 （0次交易，且不持有股票，等于什么也没做，收益为0）</li><li>dp[0] [0] [1] = -∞ （0次交易，且持有股票，必然不可能，设为负无穷）</li><li>dp[0] [1] [0] = -∞ （第0天不可能即买入又卖出股票一次）</li><li>dp[0] [1] [1] = -∞ （第0天可能买入股票一次）</li><li>dp[0] [2] [0] = -∞ （第0天不可能即买入又卖出股票两次）</li><li>dp[0] [2] [1] = -∞ （第0天不可能买入股票两次） </li></ul><p>最后，我们只需要在最后处于不持仓的三种情况下（dp[i] [0] [0] 尽管不持仓，但相当于没有操作，不是卖出，所以收益一定为0，但炒股不一定会赚钱，而是可能亏损，所以也要将不操作的情况放入比较）选一个最大收益即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> prices<span class="token punctuation">:</span>            dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>float<span class="token punctuation">(</span><span class="token string">'INF'</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>float<span class="token punctuation">(</span><span class="token string">'INF'</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>float<span class="token punctuation">(</span><span class="token string">'INF'</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>float<span class="token punctuation">(</span><span class="token string">'INF'</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> max<span class="token punctuation">(</span><span class="token punctuation">[</span>dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果k值较大，我们可以额外添加一层循环。</p><p>同样的，我们可以使用滚动数组法对本题的状态矩阵进行压缩。因为只跟前一天的状态相关。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> prices<span class="token punctuation">:</span>            dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>float<span class="token punctuation">(</span><span class="token string">'INF'</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>float<span class="token punctuation">(</span><span class="token string">'INF'</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>float<span class="token punctuation">(</span><span class="token string">'INF'</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>float<span class="token punctuation">(</span><span class="token string">'INF'</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> max<span class="token punctuation">(</span><span class="token punctuation">[</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-5-28（3easy-2medium）"><a href="#2020-5-28（3easy-2medium）" class="headerlink" title="2020.5.28（3easy 2medium）"></a>2020.5.28（3easy 2medium）</h2><h3 id="190题-颠倒二进制位"><a href="#190题-颠倒二进制位" class="headerlink" title="190题 颠倒二进制位"></a>190题 <a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">颠倒二进制位</a></h3><p><img src="190.png" alt="190"></p><h4 id="思路：-204"><a href="#思路：-204" class="headerlink" title="思路："></a>思路：</h4><p>由于写题时忘记了python二进制的相关操作，我使用了最为朴素的底层算法进行二进制转换。这里，我使用了一个栈来模拟二进制位的颠倒。</p><p>需要注意，本题如果二进制位不满32位，需要补齐。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseBits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> n <span class="token punctuation">:</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span>            n <span class="token operator">//=</span> <span class="token number">2</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token number">0</span>        c <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>            res <span class="token operator">+=</span> c <span class="token operator">*</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            c <span class="token operator">*=</span> <span class="token number">2</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python二进制位的相关操作为：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token number">1.10</span>进制转换为其他进制方法一：函数  十进制转二进制：bin<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token string">'0b1010'</span> tpye<span class="token punctuation">:</span>是字符串类型 <span class="token number">0b</span>：表示<span class="token number">2</span>进制  十进制转八进制：oct<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token string">'0o12'</span>   tpye<span class="token punctuation">:</span>是字符串类型 0o：表示<span class="token number">8</span>进制十进制转十六进制：hex<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token string">'0xa'</span>    tpye<span class="token punctuation">:</span>是字符串类型 0x：表示<span class="token number">16</span>进制方法二：format<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:b}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token string">'1001'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:o}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token string">'11'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:x}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token string">'a'</span><span class="token number">2</span><span class="token punctuation">.</span>其他转换为<span class="token number">10</span>进制：方法一：int<span class="token punctuation">(</span><span class="token punctuation">)</span>函数int<span class="token punctuation">(</span><span class="token string">'0b1010'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token number">10</span> 或者 int<span class="token punctuation">(</span><span class="token string">'1010'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token number">10</span>int<span class="token punctuation">(</span><span class="token string">'0o12'</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token number">10</span> 或者 int<span class="token punctuation">(</span><span class="token string">'12'</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token number">10</span>int<span class="token punctuation">(</span><span class="token string">'0xa'</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token number">10</span> 或者 int<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token number">10</span>备注：int<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>括号中x是需要转换的数值type必须是字符串<span class="token punctuation">,</span>y是当前进制数方法二<span class="token punctuation">:</span> eval函数<span class="token operator">>></span><span class="token operator">></span> eval<span class="token punctuation">(</span><span class="token string">'1111'</span><span class="token punctuation">)</span><span class="token number">1111</span><span class="token operator">>></span><span class="token operator">></span> eval<span class="token punctuation">(</span><span class="token string">'0b1111'</span><span class="token punctuation">)</span><span class="token number">15</span><span class="token operator">>></span><span class="token operator">></span> eval<span class="token punctuation">(</span><span class="token string">'0o1111'</span><span class="token punctuation">)</span><span class="token number">585</span><span class="token operator">>></span><span class="token operator">></span> eval<span class="token punctuation">(</span><span class="token string">'0x1111'</span><span class="token punctuation">)</span><span class="token number">4369</span>备注：type必须是str且前面的进制标志<span class="token punctuation">(</span><span class="token number">0b</span><span class="token punctuation">,</span>0o<span class="token punctuation">,</span>0x<span class="token punctuation">)</span>不可少<span class="token number">3</span><span class="token punctuation">.</span>将十进制转换为固定长度的多进制类型：方法一<span class="token punctuation">:</span><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:08b}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token string">'00001001'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:06o}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token string">'000011'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:06x}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token string">'000009'</span>备注：<span class="token string">'{:08b}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># :b表示转换为二进制，08表示高位用0补够8位</span>方法二：<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span>bin<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token number">101</span><span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> str<span class="token punctuation">.</span>zfill<span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token number">00000101</span><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span>oct<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token number">11</span><span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> str<span class="token punctuation">.</span>zfill<span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token number">00000011</span><span class="token operator">>></span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span>hex<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#去掉前面0b</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token number">14</span><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span>hex<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token string">'0x14'</span><span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">.</span>zfill<span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token string">'00000x14'</span><span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述方法使用了两次循环，实际上，我们可以边分离二进制位，边翻转。这里，我们练习位运算符，使用和汉明距离类似的方法获取 n 的每一位二进制位，然后使用左移运算符移动到对应位置上。当 n 全为0时，我们可以提前跳出。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseBits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token number">0</span>        c <span class="token operator">=</span> <span class="token number">31</span>        <span class="token keyword">while</span> n <span class="token punctuation">:</span>            res <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> c<span class="token comment" spellcheck="true">#这里一定要加括号</span>            c <span class="token operator">-=</span> <span class="token number">1</span>            n <span class="token operator">>></span><span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="485题-最大连续1的个数"><a href="#485题-最大连续1的个数" class="headerlink" title="485题 最大连续1的个数"></a>485题 <a href="https://leetcode-cn.com/problems/max-consecutive-ones/" target="_blank" rel="noopener">最大连续1的个数</a></h3><p><img src="485.png" alt="485"></p><h4 id="思路：-205"><a href="#思路：-205" class="headerlink" title="思路："></a>思路：</h4><p>我的思路是是用一个简单的双指针构造滑动窗口进行统计：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findMaxConsecutiveOnes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        p<span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> q<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">:</span>                res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> q<span class="token operator">-</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                q <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                q <span class="token operator">+=</span> <span class="token number">1</span>                p <span class="token operator">=</span> q        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后来我发现，似乎不需要维护滑动窗口的左边界，直接统计即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findMaxConsecutiveOnes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        p <span class="token operator">=</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">0</span>        count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> p<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">:</span>                count <span class="token operator">+=</span> <span class="token number">1</span>                res <span class="token operator">=</span> max<span class="token punctuation">(</span>count<span class="token punctuation">,</span> res<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                count <span class="token operator">=</span> <span class="token number">0</span>            p <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="844题-比较含退格的字符串"><a href="#844题-比较含退格的字符串" class="headerlink" title="844题 比较含退格的字符串"></a>844题 <a href="https://leetcode-cn.com/problems/backspace-string-compare/" target="_blank" rel="noopener">比较含退格的字符串</a></h3><p><img src="844.png" alt="844"></p><h4 id="思路：-206"><a href="#思路：-206" class="headerlink" title="思路："></a>思路：</h4><p>使用一个栈来模拟退格操作即可。如果遇到退格符，就将栈顶元素出栈。比较运算后两个字符串是否相等即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">backspaceCompare</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> S<span class="token punctuation">:</span> str<span class="token punctuation">,</span> T<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">calculate</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">:</span>            stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> ch <span class="token keyword">in</span> st<span class="token punctuation">:</span>                <span class="token keyword">if</span> ch <span class="token operator">==</span> <span class="token string">'#'</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> stack<span class="token punctuation">:</span>                        stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>ch<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>stack<span class="token punctuation">)</span>        <span class="token keyword">return</span> calculate<span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token operator">==</span> calculate<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="147题-对链表进行插入排序"><a href="#147题-对链表进行插入排序" class="headerlink" title="147题 对链表进行插入排序"></a>147题 <a href="https://leetcode-cn.com/problems/insertion-sort-list/" target="_blank" rel="noopener">对链表进行插入排序</a></h3><p><img src="147.png" alt="147"></p><h4 id="思路：-207"><a href="#思路：-207" class="headerlink" title="思路："></a>思路：</h4><p>使用指针遍历的方式进行插入排序：</p><ul><li><p>p指针：用于遍历链表。</p></li><li><p>pre指针：p指针的上一个节点，即指向有序链表的最后一个节点。如果p指针的值大于等于pre指针，说明非递减，不必尝试插入。也可以用来删除p指针的节点。</p></li><li><p>插入过程：</p><ul><li>创建伪头节点dummyhead，防止需要在头部进行插入</li><li>使用q指针遍历之前的链表，寻找当前节点p的插入位置</li><li>插入分两步，先删除p节点，再插入p节点</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">insertionSortList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head<span class="token punctuation">:</span>            dummyhead <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span>float<span class="token punctuation">(</span><span class="token string">'INF'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#伪头结点，用于插入，由于寻找插入位置时需要进行比较前后两个节点的值，所以这里设为负无穷</span>            dummyhead<span class="token punctuation">.</span>next <span class="token operator">=</span> head            p <span class="token operator">=</span> head<span class="token punctuation">.</span>next            pre <span class="token operator">=</span> head            <span class="token keyword">while</span> p<span class="token punctuation">:</span>                <span class="token keyword">if</span> pre<span class="token punctuation">.</span>val <span class="token operator">></span> p<span class="token punctuation">.</span>val<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#需要尝试插入</span>                    q <span class="token operator">=</span> dummyhead                    <span class="token keyword">while</span> q <span class="token operator">!=</span> pre<span class="token punctuation">:</span>                        <span class="token keyword">if</span> q<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> p<span class="token punctuation">.</span>val <span class="token operator">and</span> q<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">></span> p<span class="token punctuation">.</span>val<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#寻找插入位置</span>                            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next                            p<span class="token punctuation">.</span>next <span class="token operator">=</span> q<span class="token punctuation">.</span>next                            q<span class="token punctuation">.</span>next <span class="token operator">=</span> p                            <span class="token keyword">break</span>                        q <span class="token operator">=</span> q<span class="token punctuation">.</span>next                    p <span class="token operator">=</span> pre<span class="token punctuation">.</span>next                <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#不需要插入，直接后移</span>                    p <span class="token operator">=</span> p<span class="token punctuation">.</span>next                    pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next            <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next        <span class="token keyword">return</span> None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="367题-有效的完全平方数"><a href="#367题-有效的完全平方数" class="headerlink" title="367题  有效的完全平方数"></a>367题 <a href="https://leetcode-cn.com/problems/valid-perfect-square/" target="_blank" rel="noopener"> 有效的完全平方数</a></h3><p><img src="367.png" alt="367"></p><h4 id="思路：-208"><a href="#思路：-208" class="headerlink" title="思路："></a>思路：</h4><p>我的思路是使用二分查找。这题本质上和求解平方根是一样的，之前求解sqrt的时候，我们尝试了两种方法：</p><ul><li>拟牛顿法</li><li>二分查找法</li></ul><p>这道题同样可以使用上述两种方法求解，只不过因为要求整数解，而非浮点数解，所以不用考虑阈值问题，直接让迭代过程保持整型即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPerfectSquare</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#1要特判，因为它整除2为0，是唯一一个平方根大于自身一半的数字</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> num<span class="token operator">//</span><span class="token number">2</span>        <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            tmp <span class="token operator">=</span> mid<span class="token operator">*</span>mid            <span class="token keyword">if</span> tmp <span class="token operator">==</span> num<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">elif</span> tmp <span class="token operator">></span> num<span class="token punctuation">:</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法整理汇总（附代码）</title>
      <link href="/2020/02/16/sort-algorithms/"/>
      <url>/2020/02/16/sort-algorithms/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。</p><p><strong>本文并不会详细讲解每种排序算法的原理</strong>，网上有很多很好的教程，大家可以自己去搜了看。</p><p>最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 <a href="https://leetcode-cn.com/problems/sort-an-array/" title="LeetCode 912. 排序数组" target="_blank" rel="noopener">LeetCode 912. 排序数组</a> 这道题。</p><h2 id="性质汇总"><a href="#性质汇总" class="headerlink" title="性质汇总"></a>性质汇总</h2><blockquote><p>如果发现表中有错误，请留言告知。</p></blockquote><table><thead><tr><th>算法</th><th>最好</th><th>最坏</th><th>平均</th><th>空间</th><th align="center">稳定性</th><th align="center">是否基于比较</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>插入排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>快速排序</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(n\log n)$</td><td>$O(\log n)$~$O(n)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>归并排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>希尔排序</td><td>$O(n^{1.3})$</td><td>$O(n^2)$</td><td>$O(n\log n)$~$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>基数排序</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>桶排序</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n+m)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>堆排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr></tbody></table><blockquote><p>如果表格显示有问题的话，还可以直接看下面的汇总图：</p></blockquote><p><img src="1.png" alt="十大经典排序算法性质汇总"></p><h3 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h3><p>我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。</p><p><strong>冒泡排序</strong><br><a href="https://en.wikipedia.org/wiki/Bubble_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bubble_sort</a></p><p><strong>选择排序</strong><br><a href="https://en.wikipedia.org/wiki/Selection_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Selection_sort</a></p><p><strong>插入排序</strong><br><a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Insertion_sort</a></p><p><strong>快速排序</strong><br><a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Quicksort</a></p><p><strong>归并排序</strong><br><a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Merge_sort</a></p><p><strong>希尔排序</strong><br><a href="https://en.wikipedia.org/wiki/Shellsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Shellsort</a></p><p><strong>计数排序</strong><br><a href="https://en.wikipedia.org/wiki/Counting_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Counting_sort</a></p><p><strong>基数排序</strong><br><a href="https://en.wikipedia.org/wiki/Radix_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Radix_sort</a></p><p><strong>桶排序</strong><br><a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bucket_sort</a></p><p><strong>堆排序</strong><br><a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heapsort</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>所有的排序算法接口都是相同的，也就是 <code>vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums)</code> 。只需要你传入一个 <code>vector&lt;int&gt;</code> 类型的数组，就能返回排序后的结果。</p><p>运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sortArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 冒泡排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> i<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 选择排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">selectSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    idx <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 插入排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">insertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 快速排序（24 ms）</span>    <span class="token keyword">void</span> <span class="token function">qSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序（192 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rnums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序 + 非递归（80 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSortNR</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> len <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> n<span class="token operator">-</span>len<span class="token punctuation">;</span> l <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span>len<span class="token number">-1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> l<span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>len<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token operator">-</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 希尔排序（40 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">shellSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j<span class="token operator">-</span>gap <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">-</span><span class="token operator">=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计数排序（32 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">countSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> maxv<span class="token operator">-</span>minv<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token operator">+</span>minv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 基数排序（不适用于负数）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">radixSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxv <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxv <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>            maxd<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rank</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxd <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> count<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rank<span class="token punctuation">[</span><span class="token operator">--</span>count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            maxd<span class="token operator">--</span><span class="token punctuation">;</span>            base <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 桶排序 (20 ms)</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> bs <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>maxv<span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">bucket</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bucket<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sz <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 堆排序（32 ms）</span>    <span class="token keyword">void</span> <span class="token function">adjust</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> c1 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c2 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>c2<span class="token operator">&lt;</span>s <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>c2<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> c2 <span class="token operator">:</span> c1<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
