<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NLP自学笔记：Word2Vec、Glove和ELMO</title>
      <link href="/2020/04/08/nlp-zi-xue-bi-ji-word2vec-glove-he-elmo/"/>
      <url>/2020/04/08/nlp-zi-xue-bi-ji-word2vec-glove-he-elmo/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>词汇表示（Word Representation）一直是自然语言处理中最基础也是最重要的任务之一。 深度学习已经给这一领域带来了革命性的变革。其中一个很关键的概念就是词嵌入（<strong>word embeddings</strong>），这是语言表示的一种方式，可以让算法自动的理解一些类似的词，比如男人对女人，比如国王对王后，还有其他很多的例子。 </p><p>本文是我在学习吴恩达深度学习课程中的词汇表示一章的总结与思考，同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己的理解，如有错误欢迎在评论区指出，非常感谢！</p><h2 id="one-hot表示法"><a href="#one-hot表示法" class="headerlink" title="one-hot表示法"></a>one-hot表示法</h2><p>one-hot表示法是机器学习中表示<strong>离散化特征</strong>的一种重要方法，在NLP任务中，我们同样可以使用它来表示词。在神经网络序列模型的博客中，我已经介绍了使用one-hot向量表示单词的步骤，这里我再简单说明一下：</p><ul><li>建立一个向量，包含常用的词汇，形成一个<strong>词汇表（vocabulary）</strong> 。词汇表的大小是人为设定的，这里，我们使用10,000个单词来构建我们的词汇表。 对于一般规模的商业应用来说30,000到50,000词大小的词典比较常见，但是100,000词的也不是没有，而且有些大型互联网公司会用百万词，甚至更大的词典。</li><li>接下来，我们为单词建立one-hot向量，假如一个词在词汇表中的序号为1234，那么它的one-hot向量就是在1234行为1，其余行均为0的10000维列向量。</li><li>特别地，我们需要考虑<strong>未登录词、开始标记、结尾标记</strong>等情况。未登录词指的是不在词汇表中的单词，我们需要在词汇表添加标记\UNK来表示它们。此外，在构建语言模型、进行机器翻译等过程中，我们还需要使用到开始标记、结尾标记，它们表示的是句子的开始、结尾位置。例如，一旦语言模型生成了结尾标记，我们就可以认为句子生成完毕。我们在词汇表中添加\BOS和\EOS来表示他们。</li></ul><p><img src="1.png" alt="one-hot表示法"></p><p> 这种表示方法的一大缺点就是它把每个词孤立起来，这样使得算法对相关词的泛化能力不强。  <strong>每个one-hot只是为了表示单词自己而已，无法让算法很容易的跨单词泛化，即它无法表示任何两个单词之间的关系</strong>，因为任何两个单词one-hot向量的内积为都是0。 </p><p>例如，我们需要建立一个语言模型来生成句子，假设我们已经学习了下面这个句子：</p><blockquote><p>I want a glass of orange juice.  </p></blockquote><p>在另一个任务中，我们已经预测了如下的句子：</p><blockquote><p>I want a glass of apple <em>__</em>. </p></blockquote><p><strong>由于在one-hot表示法中，单词orange和单词apple间没有任何关联，所以即使模型知道了orange juice是比较常见的搭配，也无法学习到apple juice也是一种常见的情况。所以，空格处无法正确填入单词juice。</strong></p><p>此外，one-hot向量通常维度很高（与词汇表的大小一致），同时它又是非常稀疏的（只在一个位置为1），所以使用one-hot向量表示词将会使模型的参数变多，难以训练。</p><h2 id="词嵌入表示法"><a href="#词嵌入表示法" class="headerlink" title="词嵌入表示法"></a>词嵌入表示法</h2><p>有没有方法可以更好的表示词，能够捕捉词义以及词间的关联呢？答案是有的，我们可以使用<strong>特征化</strong>的方法来表示一个单词。</p><p>比如下图所示，一共有4个属性（实际应用会更多）：性别、是否为皇室、年龄、是否为食品。每个单词分别从这4个属性给出与这些属性的相关度。<strong>那么任何一个单词就可以用一个4维的特征向量表示</strong>，比如Man表示为(-1, 0.01, 0.03, 0.09)。 </p><p><img src="2.png" alt="词嵌入表示法"></p><p>此时，可以清晰的看到Apple和Orange极为相似，上面的例子就很容易使得算法在第二句话也填入单词juice。 </p><p>当我们将单词使用这种高维特征表示时，就叫做<strong>词嵌入（word embedding）</strong>。之所以叫做embedding，可以想象成每个单词被嵌入（embed）到了一个高维空间内。词嵌入是NLP最重要的思想之一。 </p><p>需要说明的是，上面的特征只是直观的举例，实际上的特征并不是手工设计的，而是算法（即word embedding）学习而来；而且这些学习的特征，<strong>可能并不具有良好的解释性</strong>，但不管怎样，算法都可以快速哪些单词是相似的。 </p><p>我们可以使用<strong>t-SNE</strong>算法进行高维词向量的可视化，可以看到，词义相近的单词在经过词嵌入后被聚在了一起：</p><p><img src="3.png" alt="词嵌入可视化"></p><h2 id="词嵌入的作用"><a href="#词嵌入的作用" class="headerlink" title="词嵌入的作用"></a>词嵌入的作用</h2><h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><p>我们以一个命名实体识别（NER）的任务为例，假设训练集中存在着这么一句话：</p><blockquote><p> Sally Johnson is an orange farmer. </p></blockquote><p>我们在这里使用一个BRNN模型，并使用词嵌入向量来表示单词，作为BRNN的输入。BRNN可以根据orange farmer判断出Sally Johnson是一个人名。</p><p>当我们遇到了新的输入，如：</p><blockquote><p> Robert Lin is an apple farmer. </p></blockquote><p>由于apple的词嵌入和orange的词嵌入是相似的，所以模型也可以容易的识别Robert Lin是一个人名 。 </p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 预训练模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：从Transformer到Bert</title>
      <link href="/2020/04/07/nlp-zi-xue-bi-ji-cong-transformer-dao-bert/"/>
      <url>/2020/04/07/nlp-zi-xue-bi-ji-cong-transformer-dao-bert/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：注意力机制</title>
      <link href="/2020/04/07/nlp-zi-xue-bi-ji-zhu-yi-li-ji-zhi/"/>
      <url>/2020/04/07/nlp-zi-xue-bi-ji-zhu-yi-li-ji-zhi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：神经网络序列模型</title>
      <link href="/2020/04/05/nlp-zi-xue-bi-ji-shen-jing-wang-luo-xu-lie-mo-xing/"/>
      <url>/2020/04/05/nlp-zi-xue-bi-ji-shen-jing-wang-luo-xu-lie-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>序列模型（Sequence Model）是深度学习最令人激动的领域之一。循环神经网络（Recurrent Neural Network, RNN）也已变革了语音识别（Speech Recognition）、自然语言处理（Natural Language Process, NLP）等领域。</p><p>本文是我在学习吴恩达深度学习课程中的序列模型一章的总结与思考，同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己对于该模型的理解，如有错误欢迎在评论区指出，非常感谢！</p><h2 id="从问题出发"><a href="#从问题出发" class="headerlink" title="从问题出发"></a>从问题出发</h2><p>与之前的讲解类似，我们在这里依旧围绕自然语言处理中的经典问题<strong>词性标注问题</strong>进行讨论和解释。</p><ul><li>给定一个句子X，输出句子中每一个单词对应的词性。</li></ul><p><img src="1.png" alt="词性标注任务"></p><h2 id="什么是序列模型"><a href="#什么是序列模型" class="headerlink" title="什么是序列模型"></a>什么是序列模型</h2><p>序列模型（Sequence Model）的相关知识我已经在之前的博客中有所介绍，常规机器学习方法中的隐马尔可夫模型和条件随机场模型都可以用来解决序列标注问题，它们其实就是一类序列模型。<strong>深度学习的序列模型近年来已经成为自然语言处理的最重要模型之一，主要包括循环神经网络（RNN）以及它的一些变体（LSTM、GRU等）。</strong></p><p>序列模型指的是<strong>模型的输入X或者输出Y是一个序列</strong>，例如：词性标注任务中，输入可以是连续的单词组成的句子，而输出可以是句子各单词的词性序列。</p><p>下面是一些序列模型适用的例子，可以看到，它不仅适用于自然语言处理的相关任务，还在计算机视觉、语音识别等领域应用广泛。</p><p><img src="1.jpg" alt="常用序列模型"></p><p>这些问题都可以通过有监督的学习（Supervised Learning），通过给定样本的特征向量X和标签Y进行训练。<strong>这几个例子的区别是，有些是X和Y都是序列数据，有些只有X或Y是序列数据，另外有些X和Y虽然都是序列数据，但序列的长度并不相等</strong>。 </p><p><img src="2.jpg" alt="序列模型的分类"></p><p>可以看到：</p><ul><li>语音识别、DNA序列分析和命名实体识别任务的输入X和输出Y都是序列数据，且序列长度相等。</li><li>机器翻译的输入X和输出Y都是序列数据，但序列长度不一定相等。因为一句英文文本经过翻译后，所得到的中文文本所含单词数不一定是一样的。</li><li>情感分析和视频行为识别的输入X是序列数据，而输出Y只有一个维度，即情感的类别或者行为的类别。</li><li>音乐生成任务的输出Y是序列数据（一段音乐），而输入X 可以是空集，也可以是个单一的整数，这个数可能指代你想要生成的音乐风格，也可能是你想要生成的那首曲子的头几个音符。 </li></ul><p>后面我们将知道，<strong>这些不同类别的序列模型都可以使用同一个深度学习模型来解决，那就是循环神经网络模型（RNN），我们只需要对它进行一些结构上的调整即可。</strong></p><h2 id="什么是循环神经网络"><a href="#什么是循环神经网络" class="headerlink" title="什么是循环神经网络"></a>什么是循环神经网络</h2><h3 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h3><p>首先，我们定义一些接下来的讲解中需要使用到的符号：</p><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">$x^{(i)\langle t \rangle}$</td><td align="center">第$i$个输入序列的第$t$个序列元素，即第$i$个输入句子的第$t$个单词</td></tr><tr><td align="center">$y^{(i)\langle t \rangle}$</td><td align="center">第$i$个输出序列的第$t$个序列元素，即第$i$个句子的词性标注结果的第$t$个词性</td></tr><tr><td align="center">$T_x^{(i)}$</td><td align="center">第$i$个输入序列的长度 ，即第$i$个句子的单词数目（每条数据的序列长度可以不一样）</td></tr><tr><td align="center">$T_y^{(i)}$</td><td align="center">第$i$个输出序列的长度 ，即第$i$个句子的词性数目（词性标注任务中：$T_x^{(i)}=T_y^{(i)}$）</td></tr></tbody></table><p>以词性标注任务为例，上述符号的含义如下图所示：</p><p><img src="2.png" alt="符号示意"></p><h3 id="如何表示词"><a href="#如何表示词" class="headerlink" title="如何表示词"></a>如何表示词</h3><p>接下来，我们需要考虑的问题是<strong>怎么表示输入序列（也就是句子）中的词</strong>。在这里，我们先使用一种最为简单的方法，也就是<strong>one-hot表示法</strong>，来表示句子中的词。这个方法无法捕捉词语本身丰富的语义信息。日后，我将介绍一些预训练的语言模型，如<strong>Word2Vec和Bert</strong>等，<strong>它们通过词嵌入（Word Embedding）的方法使用词嵌入向量表示词，捕捉了词语的含义和词间的关系，替换one-hot向量作为深度学习模型的输入，刷新了NLP中许多任务的最佳表现。</strong></p><p>one-hot表示法在我的对数线性模型博客中有所介绍，它是表示离散特征的一种方法。使用它来表示单词，我们需要进行以下几步：</p><ol><li>建立一个向量，包含常用的词汇，形成一个<strong>词汇表（vocabulary）</strong> 。词汇表的大小是人为设定的，这里，我们使用10,000个单词来构建我们的词汇表。 对于一般规模的商业应用来说30,000到50,000词大小的词典比较常见，但是100,000词的也不是没有，而且有些大型互联网公司会用百万词，甚至更大的词典。 </li><li>接下来，我们为单词建立one-hot向量，假如一个词在词汇表中的序号为1234，那么它的one-hot向量就是在1234行为1，其余行均为0的10000维列向量。</li><li>特别地，我们需要考虑<strong>未登录词、开始标记、结尾标记</strong>等情况。未登录词指的是不在词汇表中的单词，我们需要在词汇表添加标记\UNK来表示它们。此外，在构建语言模型、进行机器翻译等过程中，我们还需要使用到开始标记、结尾标记，它们表示的是句子的开始、结尾位置。例如，一旦语言模型生成了结尾标记，我们就可以认为句子生成完毕。我们在词汇表中添加\Start和\End来表示他们。</li></ol><p>下图是吴恩达老师课件中的例子：</p><p><img src="3.png" alt="词的one-hot表示"></p><h3 id="循环神经网络模型的基本结构"><a href="#循环神经网络模型的基本结构" class="headerlink" title="循环神经网络模型的基本结构"></a>循环神经网络模型的基本结构</h3><p>在介绍循环神经网络之前，我们尝试利用最简单的标准神经网络——反向传播神经网络（BPNN）来进行序列标注。我们可以将句子中的所有词的one-hot向量拼接作为标准神经网络的输入，经过若干隐藏层后输出词性标注结果，如下图所示：</p><p><img src="4.png" alt="标准神经网络"></p><p>但这个神经网络只适用于单个词的词性标注（分类问题），而不适用于整个句子的词性标注（序列标注，结构化分类问题），主要原因有以下几种：</p><ul><li>不同的句子的长度不一样，意味着<strong>BPNN的输入层和输出层维度需要不断地改变。</strong></li><li>更重要的是，<strong>BPNN无法共享从文本的不同位置上学到的特征。</strong> 比如网络学习到Harry在第一个位置可能是名词，但在其他位置却无法识别了。我们希望模型能够像卷积神经网络一样，在图像上某一个位置检测到的边缘特征能够应用到其他位置上。 </li><li>还有一点是<strong>模型的参数过于庞大，计算量太大</strong>。因为每个单词都是10000维的one-hot向量，输入层和输出层的单元太多。</li></ul><p><strong>为了解决BPNN在序列化标注问题中的缺陷，科学家们提出了一种神经网络的序列模型：循环神经网络模型（Recurrent Neural Network Model）</strong>。</p><p><img src="5.png" alt="循环神经网络"></p><p>其中，每个时间步（time step，也就是序列的每个状态）的RNN单元如下图所示：</p><p><img src="6.png" alt="基本的RNN单元"></p><p>可以看到：<strong>每个时间步的RNN单元，其实都是一个简单的单隐藏层BPNN。为了增强模型的表示能力，隐藏层使用tanh激活函数（Activation Function）增加非线性（这里有个疑问：为什么RNN中tanh比ReLU更常用呢）；为了计算当前时间步各词性的概率进行分类预测，输出层使用softmax激活函数进行概率归一化。</strong>上图右侧的公式即为RNN的前向传播公式（ Forward Propagation）。 </p><p>RNN的特别之处在于：当$x^{\langle t \rangle}$输入到当前时间步对应的RNN单元时，同时会将上一个时间步RNN单元的隐藏层的激活值$a^{\langle t-1 \rangle}$加入计算。特别的，第一层的激活值输入$a^{\langle 0 \rangle}$一般是定义为0向量。 也就是说，<strong>对于每一个时间步的预测，其输入信息不仅来自于当前序列元素$x^{\langle t \rangle}$，还间接来自于之前的所有序列元素（因为输入了$a^{\langle t-1 \rangle}$）</strong>。</p><p>上述RNN解决了BPNN用于序列标注的缺陷：</p><ul><li><strong>每个时间步的RNN单元，其输入、输出的维度都是一致的。</strong>例如我们使用单隐藏层RNN单元，隐藏层的神经元数目设为100，则$a^{\langle t-1 \rangle}$为100维列向量，$x^{\langle t \rangle}$为10000维的one-hot向量，每个RNN单元的输入固定为10100维，输出的维度与训练集中的词性数目相等。对于不同长度的输入序列，我们只需要修改RNN单元的个数即可。</li><li><strong>每一个时间步的RNN单元共享参数，即可以共享从文本的不同位置上学到的特征</strong>，也就是上面循环神经网络示意图中的三个参数矩阵$W_{aa}$,$W_{ax}$,$W_{ya}$和对应的偏差项（bias）。</li><li><strong>模型的参数量减少了。</strong>RNN中我们只有三组固定大小的参数，而原先的BPNN光是输入层和第一个隐藏层之间的全连接都需要大量参数，因为BPNN输入的每个词的one-hot向量之间不共享参数矩阵。</li></ul><p>需要注意的是，这里只是画了一个最基本的RNN，只有一个隐藏层，实际上，我们可以加大隐藏层数量，形成深度RNN（Deep RNN）。 对于标准CNN来说，可以有很多层，比如100个隐藏层，<strong>但对RNN来说3层就已经很深了</strong>，因为RNN还有很长的时间维度（temporal dimension），即便3层RNN的训练难度也很大。  </p><p><img src="7.png" alt="深度RNN"></p><h3 id="循环神经网络模型的反向传播"><a href="#循环神经网络模型的反向传播" class="headerlink" title="循环神经网络模型的反向传播"></a>循环神经网络模型的反向传播</h3><p>在上一节，我们已经介绍了RNN前向传播的基本流程。<strong>每一个时间步的RNN单元使用上一个时间步传来的激活值和当前序列元素的输入进行一次或多次全连接层运算，最后所得的激活值，一方面继续传给下一个时间步，另一方面输入softmax层计算当前序列元素的标注输出。</strong>具体过程如下图所示：</p><p><img src="8.png" alt="RNN前向传播示意图"></p><p>接下来，我们需要定义模型的损失函数，以便进行梯度下降优化，拟合出特征权重参数。</p><p>与常规的Softmax输出层的BPNN类似，我们在这里定义第$t$个时间步的损失函数为<strong>交叉熵损失函数</strong>（Cross Entropy Loss）：<br>$$<br>Loss^{\langle t \rangle}(\hat y^{(i)\langle t \rangle},y^{(i)\langle t \rangle})=- y^{(i)\langle t \rangle}log (\hat y^{(i)\langle t \rangle})<br>$$<br>整个序列的损失函数定义为<strong>各时间步损失函数之和</strong>：<br>$$<br>Loss(\hat y^{(i)},y^{(i)})=\sum_{t=1}^{T_x^{(i)}}Loss^{\langle t \rangle}(\hat y^{(i)\langle t \rangle},y^{(i)\langle t \rangle})<br>$$<br>接下来，便可以使用各种凸优化方法进行迭代计算，求解最优参数。假设我们使用梯度下降算法进行参数拟合，那么各参数的梯度反向传播计算如下所示：</p><p><img src="9.png" alt="RNN反向传播示意图"></p><p>上述反向传播可以自己推导一遍，加深印象。<strong>反向传播的推导并不复杂，它其实就是一种动态规划算法，状态转移方程中使用了求导的链式法则而已。</strong></p><p>具体的梯度计算公式<strong>（我推的不是最简形式，最简形式可以参考前向传播公式自己化简）</strong>如下：<br>$$<br>\frac{dLoss^{(i)}}{dW_{ya}}=\sum_{t=1}^{T_x^{(i)}}\frac{dLoss^{(i)\langle t \rangle}}{d \hat y^{(i)\langle t \rangle}}\frac{d \hat y^{(i)\langle t \rangle}}{dW_{ya}}……(1)<br>$$</p><p>$$<br>\frac{dLoss^{(i)}}{dW_{aa}}=\sum_{t=1}^{T_x^{(i)}}\sum_{k=1}^{t}\frac{dLoss^{(i)\langle t \rangle}}{d \hat y^{(i)\langle t \rangle}}\frac{d \hat y^{(i)\langle t \rangle}}{da^{\langle t \rangle}}(\prod_{j=k+1}^t\frac{da^{\langle j \rangle}}{da^{\langle j-1 \rangle}})\frac{da^{\langle k \rangle}}{dW_{aa}}……(2)<br>$$</p><p>$$<br>\frac{dLoss^{(i)}}{dW_{ax}}=\sum_{t=1}^{T_x^{(i)}}\sum_{k=1}^{t}\frac{dLoss^{(i)\langle t \rangle}}{d \hat y^{(i)\langle t \rangle}}\frac{d \hat y^{(i)\langle t \rangle}}{da^{\langle t \rangle}}(\prod_{j=k+1}^t\frac{da^{\langle j \rangle}}{da^{\langle j-1 \rangle}})\frac{da^{\langle k \rangle}}{dW_{aa}}……(2)<br>$$</p><h2 id="循环神经网络的不同架构"><a href="#循环神经网络的不同架构" class="headerlink" title="循环神经网络的不同架构"></a>循环神经网络的不同架构</h2><p>我们在之前提到了许多不同的序列任务都可以使用RNN来完成，我们只需要调整RNN的结构。自然语言处理中，主要的序列任务可以分为以下几类：</p><ol><li>One to many：一对多，如语言模型（Language Model），主要用于文本生成，如AI写诗等，我们通常只给出一个开头的字或词，让语言模型帮我们生成完整的句子序列。</li><li>Many to one：多对一，如文本分类，我们通常给出一个句子序列，让语言模型输出其类别。</li><li>Many to Many（$T_x=T_y$）：输入输出序列长度相等的多对多，如词性标注任务。</li><li>Many to Many（$T_x!=T_y$）：输入输出序列长度不相等的多对多，如机器翻译。</li></ol><p>在前面的几节，我们以词性标注为例，给出了输入输出序列长度相等的多对多RNN模型的基本结构，更多的结构如下图所示：</p><p><img src="10.png" alt="不同类型的RNN"></p><ul><li>左下角就是之前接触的最基本的RNN，Many to many并且$T_x=T_y$。</li><li>Many to one结构，与标准结构相比，<strong>将每个时间步的输出都去除，只保留最后一步的输出。</strong></li><li>One to one结构，就是标准神经网络。</li><li>One to many结构，<strong>仅在第一个时间步输入唯一的序列数据，接下来每一个时间步的输入都来自上一步的输出（Ngram语言模型）。</strong></li><li>Many to many并且$T_x!=T_y$。则将输入时间步和输出时间步完全拆分。前半部分称之为<strong>编码器（encoder）</strong>，后半部分称之为<strong>解码器（decoder）</strong>。例如，机器翻译任务中，前半部分将源文本进行编码，并将编码所得结果输入后半部分的解码器。后半部分的解码器其实就是一个语言模型，采用集束搜索（Beam Search）等方式选择出生成的最大概率序列作为翻译的结果。</li></ul><h2 id="双向循环神经网络"><a href="#双向循环神经网络" class="headerlink" title="双向循环神经网络"></a>双向循环神经网络</h2><p>在实际预测中，我们可能<strong>不仅需要当前时间步之前的信息，也需要当前时间步之后的信息。</strong>例如，一个单词被预测为名词，可能不仅与前一个单词是什么有关，也与后一个单词是什么有关。我们在之前提出的RNN架构，只能使用到之前时间步的信息，为了解决这个缺陷，我们可以使用双向循环神经网络（BRNN）。</p><p>我在这里借用吴恩达的PPT：</p><p><img src="11.png" alt="BRNN"></p><p>如上图所示，BRNN首先包含了前向RNN的基本架构，接着为每个时间步添加反向循环单元。最后，每个时间步的预测输出，需要同时考虑前向激活函数和反向激活函数。</p><p>BRNN中，每个时间步的预测输出要等所有序列扫描结束后才能输出。但这也造成了一个弱点，比如语音识别，需要等用户说完一整句才开始识别，所以真正的实时语音识别，会使用更为复杂的模块，而不是仅使用BRNN。 </p><h2 id="循环神经网络中的梯度消失和梯度爆炸"><a href="#循环神经网络中的梯度消失和梯度爆炸" class="headerlink" title="循环神经网络中的梯度消失和梯度爆炸"></a>循环神经网络中的梯度消失和梯度爆炸</h2><p>我们在之前已经介绍了RNN中的梯度反向传播计算，与其他深度学习的神经网络一样， <strong>RNN也面临梯度消失（vanishing gradients）和梯度爆炸（exploding gradients）</strong> 的问题，尤其是梯度消失的问题，更难解决。 </p><p>首先，我们来看RNN单元隐藏层中最为常用的激活函数tanh的函数曲线以及它的导数曲线：</p><p><img src="12.png" alt="tanh函数曲线和导数曲线"></p><p>可以看到，<strong>tanh的导数值取值范围位于闭区间[0,1]上</strong>。</p><p>在一个最基本的BPNN中，反向传播计算各参数的梯度时，需要使用到权重值、激活函数的导数以及预测值和真实值的误差。 如果我们使用正态分布初始化权重w，那么w都是0-1之间的小数，而tanh激活函数的导数也是0-1之间的数，<strong>经过反向传播的连乘后，随着相距的层数增加，连乘的次数也将被多，结果会变的很小，导致梯度消失</strong>。若我们初始化的w是很大的数，大到乘以激活函数的导数都大于1，那么经过多次连乘后，可能会导致求偏导的结果很大，形成<strong>梯度爆炸</strong>。 </p><p>事实上，tanh激活函数已经算比较好了，如果你使用sigmoid激活函数，那么它的导数值取值范围为[0,0.25]，更容易造成<strong>梯度消失问题</strong>。事实上，比较好的一种激活函数为ReLu激活函数（修正线性单元），它的导数值永远只有0或者1，所以可以很好地解决梯度消失问题。（疑问： RNN 中一个经典的问题是如何避免梯度消失。造成这个问题的一个很重要原因是采用了 tanh 作为激活函数，很容易造成梯度消失问题。所以为什么不换成ReLU呢？）</p><p>我们再回头看一看RNN的反向传播公式：</p><p><img src="9.png" alt="RNN反向传播示意图"></p><p>RNN 中的梯度消失/梯度爆炸和普通的 MLP 或者深层 CNN 中梯度消失/梯度爆炸的含义不一样。MLP/CNN 中不同的层有不同的参数，各是各的梯度；而 RNN 中同样的权重在各个时间步共享，最终的梯度为各个时间步的梯度的和。 所以，<strong>RNN 中总的梯度是不会消失的。即便因为连乘的原因梯度越传越弱，那也只是远距离的梯度消失，由于近距离的梯度不会消失，所有梯度之和便不会消失。RNN 所谓梯度消失的真正含义是，梯度被近距离梯度主导，导致模型难以学到远距离的依赖关系。（可以参考反向传播那一节的式（2）和式（3）理解，当k和t距离越远时，连乘的次数将越多）</strong> </p><p>梯度爆炸比较容易解决，我们可以使<strong>用梯度剪切（gradient clipping）</strong>，即梯度如果超过一定阈值，则缩放梯度。 </p><p><img src="13.png" alt="梯度剪切"></p><p><strong>相对而言，梯度消失问题很难解决，这导致后面的时间步的输出很难通过反向传播影响到前面的参数计算，从而使RNN难以捕捉长距离的依赖。而在自然语言处理任务中，长距离依赖通常是比较重要的，能够很大地影响模型的性能。</strong></p><p>为了解决梯度消失问题，科学家们在基本RNN的基础上提出了改进，<strong>将基本的RNN单元修改为使用了门（Gate)来控制记忆的长短期记忆单元（LSTM）和门控循环单元（GRU）</strong>。</p><h2 id="门控循环单元"><a href="#门控循环单元" class="headerlink" title="门控循环单元"></a>门控循环单元</h2><p>门控循环单元（Gated Recurrent Unit，GRU），<strong>是在基本RNN单元的基础上改进，帮助RNN缓解（无法解决）梯度消失问题，从而更好的捕捉长距离依赖</strong>。 它其实是长短期记忆单元的简化版，这里我们先介绍简单的版本。</p><p>我们以一个语言模型为例，假设我们需要构建一个语言模型根据训练文本自动生成句子，有如下两个句子：</p><blockquote><p>The ==cat==, which already ate …., ==was== full. The ==cats==, which already ate …., ==were== full. </p></blockquote><p> 中间是一个很长的从句，结尾处谓语（be）的形式要根据最开始的主语（cat）的单复数决定。这说明语言中经常会有<strong>长距离的依赖</strong>。但基本的RNN对这种问题的处理效果并不好，它无法捕捉到这种长距离依赖。 </p><p>首先，我们给出吴恩达老师画出的基本RNN单元（这里的$W_a$和$b_a$由原先的$W_{ax}$、$W_{aa}$和$b_{ax}$、$b_{aa}$堆叠而成，方便表述）： </p><p><img src="14.png" alt="基本RNN单元"></p><p>GRU经引入一个新的变量$c$，作为<strong>记忆细胞（Memory Cell）</strong>，其作用是提供一定比特的记忆，比如上例中记忆cat是单数还是负数。在时间$t$，记忆细胞的值记为$c^{\langle t \rangle}$。在GRU中，虽然输出的激活函数$a^{\langle t \rangle}$总是和$c^{\langle t \rangle}$相等，但我们还是提供两个标记区别，主要是为了和后面LSTM保持标记的统一性。 </p><p>接下来是GRU的公式：</p><p>首先是$\widetilde{c}$，代表将用于替换$c^{\langle t \rangle}$的候选（candidate）值：<br>$$<br>\widetilde{c}^{\langle t \rangle}=tanh(W_c[c^{\langle t-1 \rangle},x^{\langle t \rangle}]+b_c)<br>$$<br>接着，我们引入GRU的重要思想——门（Gate），我们用$Γ_u$表示 ：<br>$$<br>Γ_u=\sigma(W_u[c^{\langle t-1 \rangle},x^{\langle t \rangle}]+b_u)<br>$$<br>这里的$Γ_u$代表的是<strong>更新门（update Gate），激活函数$\sigma$使用sigmoid函数，从而使更新门的取值缩放到[0,1]，它表示的是当前时间步更新记忆细胞$c^{\langle t \rangle}$的程度</strong>，越接近1，表示更新的程度越大，具体公式如下：<br>$$<br>c^{\langle t \rangle}=Γ_u \times \widetilde{c}+(1-Γ_u) \times c^{\langle t-1 \rangle}<br>$$<br>上述公式究竟有什么用呢？ 前面说$\widetilde{c}$只是候选，是因为决定权在于$Γ_u$，$Γ_u$决定了什么时候去更新$c^{\langle t \rangle}$。对应上面的例子，<em><em>这个机制可能就是，从读取到cat开始，就一直在$c^{\langle t \rangle}$记录着主语是单数，直到遇到谓语was，$c^{\langle t \rangle}$认为就没必要再记录下去了，即开始更新$c^{\langle t \rangle}$。 </em></em></p><p><img src="15.png" alt="更新门的作用"></p><p> 把上述GRU单元的公式，它的结构用图表示如下： </p><p><img src="16.png" alt="基本GRU"></p><p>可以看到，<strong>GRU仅仅使用了一个门就实现了更新记忆细胞和遗忘记忆细胞，也就是让$(1-Γ_u)$控制遗忘的程度。而LSTM中使用了独立的遗忘门（forget gate）来控制遗忘，所以参数更多一些，训练起来也更慢。</strong></p><p>通过使用更新门，我们可以<strong>选择性的更新记忆细胞</strong>（在GRU中就是上一个时间步的隐藏层激活值输出，包含了前面所有时间步内的信息）。<em><em>当更新门$Γ_u$的值总为0时，相当于保持了记忆，在我们的例子中，就是在谓语was的时间步和主语cat的时间步之间开辟了一条直达的远距离路径。 梯度在这条路径上可以无损地传递，从而不会消失。这有些类似于CNN的 ResNet 中的跳跃连接（short cut）。 </em></em></p><p>此外，完整的GRU单元还设置了一个相关门 （Relevance Gate，也叫重置门Reset Gate） $Γ_r$，用于表示$\widetilde{c}$和$c^{\langle t -1 \rangle}$的相关性：<br>$$<br>Γ_r=\sigma(W_r[c^{\langle t-1 \rangle},x^{\langle t \rangle}]+b_r)<br>$$<br>候选值$\widetilde{c}$的计算公式修改为：<br>$$<br>\widetilde{c}^{\langle t \rangle}=tanh(W_c[Γ_r \times c^{\langle t-1 \rangle},x^{\langle t \rangle}]+b_c)<br>$$<br> 完整的GRU内部结构如下图所示：</p><p><img src="17.png" alt="完整GRU"></p><h2 id="长短期记忆单元"><a href="#长短期记忆单元" class="headerlink" title="长短期记忆单元"></a>长短期记忆单元</h2><p><strong>长短期记忆单元（Long Short Term Memory）可以看作是门控循环单元GRU的复杂版</strong>。事实上， 在深度学习的历史上，<strong>LSTM</strong>也是更早出现的，而<strong>GRU</strong>是最近才发明出来的，它可能源于<strong>Pavia</strong>在更加复杂的<strong>LSTM</strong>模型中做出的简化。 </p><p>以下为GRU和LSTM二者的公式对比：</p><p><img src="18.png" alt="GRU和LSTM"></p><p>可以看到，GRU的主要特点在于：</p><ul><li><p>$a^{\langle t \rangle}$总是和$c^{\langle t \rangle}$相等。</p></li><li><p>使用了两个门，即更新门$Γ_u$和相关门$Γ_r$。</p></li></ul><p>而LSTM相对于GRU的变化在于：</p><ul><li>$a^{\langle t \rangle}$和$c^{\langle t \rangle}$不相等。</li><li>使用了三个门：<ul><li>去掉了用于计算候选值$\widetilde{c}$的相关门$Γ_r$。</li><li>增加了用于控制遗忘的遗忘门（Forget Gate）$Γ_f$，替换了GRU中的$1-Γ_r$。</li><li>增加了用于计算$a^{\langle t \rangle}$的输出门$Γ_o$。</li></ul></li></ul><p>完整的LSTM单元如下图所示：</p><p><img src="19.png" alt="完整LSTM单元"></p><p>完整的LSTM网络如下图所示：</p><p><img src="20.png" alt="完整LSTM网络"></p><p>可以看到，LSTM网络中，梯度的传播相较于基本RNN多了许多路径。其中，<strong>有一条贯穿$c^{\langle t \rangle}$的”高速公路“</strong>。与CNN的 ResNet 中的跳跃连接（short cut）类似，在这条路径上，<strong>假设遗忘门$Γ_f$保持等于1，那么梯度将无损地在需要进行远距离依赖的时间步间传输</strong>。 由于总的远距离梯度 = 各条路径的远距离梯度之和，即便其他远距离路径梯度消失了，只要保证有一条远距离路径梯度不消失，总的远距离梯度就不会消失（正常梯度 + 消失梯度 = 正常梯度）。因此 LSTM 通过改善<strong>一条路径</strong>上的梯度问题拯救了<strong>总体的远距离梯度</strong>。 </p><p><strong>另外需要强调的是</strong>，LSTM除了在结构上天然地克服了梯度消失的问题，更重要的是具有更多的参数来控制模型；通过四倍于RNN的参数量，可以更加精细地预测时间序列变量。 </p><h2 id="GRU与LSTM的比较"><a href="#GRU与LSTM的比较" class="headerlink" title="GRU与LSTM的比较"></a>GRU与LSTM的比较</h2><p>吴恩达老师的原话：</p><blockquote><p><strong>GRU</strong>的优点是这是个更加简单的模型，所以更容易创建一个更大的网络，而且它只有两个门，在计算性上也运行得更快，然后它可以扩大模型的规模。</p></blockquote><blockquote><p>但是<strong>LSTM</strong>更加强大和灵活，因为它有三个门而不是两个。如果你想选一个使用，我认为<strong>LSTM</strong>在历史进程上是个更优先的选择，所以如果你必须选一个，我感觉今天大部分的人还是会把<strong>LSTM</strong>作为默认的选择来尝试。虽然我认为最近几年<strong>GRU</strong>获得了很多支持，而且我感觉越来越多的团队也正在使用<strong>GRU</strong>，因为它更加简单，而且还效果还不错，它更容易适应规模更加大的问题。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我对循环神经网络（RNN）进行学习时的总结了。RNN是NLP深度学习最重要的模型之一，许多开创性的工作就是在它的基础上完成的，包括我的大创课题上下位网络构建的SOTA目前也是由LSTM保持着。接下来，我将介绍常见的预训练模型的基本原理（word2vec，bert等），未来还将介绍NLP深度学习中的Attention机制以及常用的优化、调参算法。</p><h2 id="参考文献（部分）"><a href="#参考文献（部分）" class="headerlink" title="参考文献（部分）"></a>参考文献（部分）</h2><ul><li><p><a href="http://www.ai-start.com/dl2017/html/lesson5-week1.html" target="_blank" rel="noopener">吴恩达深度学习课件</a></p></li><li><p><a href="http://dl-notes.imshuai.com/#/c5w1?id=_110-long-short-term-memory-lstm" target="_blank" rel="noopener">吴恩达深度学习笔记</a></p></li><li><p>台大李宏毅教授的深度学习视频 </p></li><li><p><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks</a> </p></li><li><p><a href="https://www.researchgate.net/publication/13853244_Long_Short-term_Memory" target="_blank" rel="noopener">Hochreiter &amp; Schmidhuber 1997. Long short-term memory</a> </p></li><li><p><a href="https://arxiv.org/pdf/1409.1259.pdf" target="_blank" rel="noopener">Cho et al., 2014. On the properties of neural machine translation: Encoder-decoder approaches</a></p></li><li><p><a href="https://arxiv.org/pdf/1412.3555.pdf" target="_blank" rel="noopener">Chung et al., 2014. Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling</a> </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：条件随机场模型</title>
      <link href="/2020/04/04/nlp-zi-xue-bi-ji-tiao-jian-sui-ji-chang-mo-xing/"/>
      <url>/2020/04/04/nlp-zi-xue-bi-ji-tiao-jian-sui-ji-chang-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是我在学习苏州大学李正华老师的中文信息处理课程（<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">中文信息处理（Chinese Information Processing）Course Resources</a>）时，对于条件随机场模型（Condition Random Field Model）的一些个人见解和思考，同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己对于该模型的理解，如有错误欢迎在评论区指出，非常感谢！</p><h2 id="从问题出发"><a href="#从问题出发" class="headerlink" title="从问题出发"></a>从问题出发</h2><p>与之前的讲解类似，我们在这里依旧围绕自然语言处理中的经典问题<strong>词性标注问题</strong>进行讨论和解释。</p><ul><li>给定一个句子X，输出句子中每一个单词对应的词性。</li></ul><p><img src="1.png" alt="词性标注任务"></p><h2 id="条件随机场模型的由来"><a href="#条件随机场模型的由来" class="headerlink" title="条件随机场模型的由来"></a>条件随机场模型的由来</h2><p>我在之前已经讨论过了隐马尔可夫模型（HMM）和对数线性模型（Log-Linear Model），我觉得，有了之前的过程基础，我们接下来对于条件随机场模型的学习将变得非常轻松，因为<strong>实际上条件随机场模型只是隐马尔可夫模型和对数线性模型的结合。</strong>当我们打好了基础，剩下来的只有细微的调整和修补。</p><p>首先，我们来看下面这张图，它阐述了我们要学习的条件随机场模型和之前的两个模型的关系。<strong>顺便说一下，本文讨论的条件随机场模型都是线性链条件随机场（ Linear-chain CRF），这是NLP中常用的CRF形式，此外还有全连接条件随机场（Generl Graph CRF），一般用在CV中，这里就不多叙述。</strong></p><p><img src="2.png" alt="HMM、Log-Linear Model、LC-CRF的关系"></p><p>这张图将三者的关系描述的很清楚。你可以这样去理解LC-CRF的由来：</p><ul><li>LC-CRF可以看作是<strong>分类模型Log-Linear Model加入了HMM中的转移特征（齐次马尔可夫假设）从而转变成为的结构化分类模型</strong>，从而可以进行Seq2Seq的标注。也就是说，对于样本的预测不再是相互独立的，对于某个样本的预测需要考虑前面（Forward）或者后面（Backward）样本预测的结果。</li><li>LC-CRF也可以看作是<strong>生成模型HMM中引入了Log-Linear Model中的自定义特征函数，把它变成了一个判别模型，解决了HMM的输出独立性假设问题和有限元马尔可夫假设问题</strong>， 不仅可以表达观测之间的依赖，还可表示当前观测与前后多个状态之间的复杂依赖。 </li></ul><p>LC-CRF本质上结合了HMM和Log-Linear Model的优点，从而效果更好，更加强大。也就是说，<strong>LC-CRF是Log-Linear Model的序列扩展，是Global Log-Linear Model！</strong></p><p>其实介绍到这里，我觉得CRF已经没有多少要说得了，如果你深入地理解了对数线性模型和隐马尔可夫模型，那么CRF的训练和预测过程你一定能够轻松学会。</p><h2 id="LC-CRF的训练"><a href="#LC-CRF的训练" class="headerlink" title="LC-CRF的训练"></a>LC-CRF的训练</h2><p><strong>LC-CRF是一个判别模型</strong>，所以它的训练过程和Log-Linear Model非常类似。</p><h3 id="构建特征空间"><a href="#构建特征空间" class="headerlink" title="构建特征空间"></a>构建特征空间</h3><p>与Log-Linear Model类似，首先，我们需要为LC-CRF构建<strong>特征空间（Feature Space）</strong>。构建特征空间的方法也与之前类似，<strong>我们采用预先定义好的特征模板（Feature Template）对训练集中的每一个词进行特征抽取</strong>。这里，我们使用如下的特征模板：</p><p><img src="3.png" alt="LC-CRF的特征模板"></p><p>你可能会发现：02-15号特征和我们之前在Log-Linear Model中定义的特征模板是一致。这些特征我们称之为<strong>Unigram特征</strong>，也就是一元特征，包含了词特征、字特征，例如当前词是什么，上一个词是什么，当前词的前缀后缀等。它考虑的是当前词的特征信息，也就是说只考虑了一元隐状态。</p><p>需要特别注意，<strong>我们新加入了01号特征，考虑了当前词性和上一个词性的关系（二元隐状态），这称为Bigram特征，也就是二元特征。</strong>正是因为有了二元特征，我们才可以考虑不同时间步输出之间的关系，将Log-Linear Model序列化，并且使用Viterbi算法进行全局动态规划解码。<strong>二元特征的定义符合了HMM中的一阶马尔可夫假设，其实就是HMM模型中的状态转移矩阵</strong>。下面这张图简单地描述了Unigram特征和Bigram特征。</p><p><img src="4.png" alt="Unigram特征和Bigram特征"></p><p>与Log-Linear Model类似，这里的特征使用One-hot表示，特征抽取可以进行“段+偏移”优化。具体细节可以参考我的对数线性模型博客。</p><h3 id="定义假设函数"><a href="#定义假设函数" class="headerlink" title="定义假设函数"></a>定义假设函数</h3><p>LC-CRF与Log-Linear Model的假设函数并不相同，<strong>因为它是序列模型，所以输出的是预测的整个序列的概率。</strong></p><p>我们先定义一个长度为$n$的句子$S$标注为词性序列$Y$的分值为：<br>$$<br>Score(S,Y)=\sum_{i=1}^{n}w_i^T x_i<br>$$<br>其中，$w_i$是这个句子第$i$个词的特征权重向量，$x_i$是它的特征向量。这里它们都是列向量，需要对$w_i$进行转置处理，然后进行矩阵相乘。将所有词的分值进行相加，得到的是整个句子的总分。</p><p>如果我们对这个句子的所有可能的词性序列求解最大分值，并将最大分值的词性序列作为当前句子的标注结果，你会发现这种做法其实也是Work的。<strong>这其实就是将我们之前提到的Linear Model的全局化，也就是Global Linear Model。</strong>有关线性模型的更多知识可以参考我的上一篇博客，训练的方法依然可以使用我们在Linear Model的在线学习法。</p><p><strong>为了将Global Linear Model转化为Global Log-Linear Model，也就是我们的LC-CRF模型，我们还需要对所得的分值Score进行Softmax函数运算，从而将所得的分值归一化为概率Probability</strong>。从线性模型到对数线性模型的转化也可以看我的上一篇博客。这里，我们使用Softmax函数，得到长度为$n$的句子$S$标注为词性序列$Y$的条件概率，也就是我们模型的假设函数为：<br>$$<br>P(Y|S)=\frac{e^{Score(S,Y)}}{\sum_{Y^{‘}\in{T^n}}e^{Score(S,Y^{‘})}}<br>$$<br>其中，$T^n$为当前句子所有可能的词性标注序列集合。<strong>可以看到，我们使用一个Softmax指数模型来表示整个标签序列的联合概率, 这个概率条件依赖于给定的完整观察序列。 这是一种全局归一化的方式。</strong></p><p>特别地，HMM模型和Log-Linear Model的结合其实还有另外一种方式，即<strong>最大熵隐马尔可夫模型（MEMM）</strong>，这个模型和LC-CRF非常类似，唯一的区别在于，<strong>它的概率归一化的时刻在于每一个时间步（Local归一化），而LC-CRF的概率归一化时刻在整个序列计算完成后（全局归一化）。</strong>虽然MEMM也是Work的，但它存在着<strong>标注偏置</strong>的缺陷，导致其无法在维特比算法的解码过程中确保全局最优。具体为什么会这样，可以看<a href="https://blog.csdn.net/yzxnuaa/article/details/79626265" target="_blank" rel="noopener">这篇博客</a>，我就不过多的进行说明。</p><h3 id="参数训练"><a href="#参数训练" class="headerlink" title="参数训练"></a>参数训练</h3><p>与Log-Linear Model一样，我们对于LC-CRF的参数拟合依然是可以通过<strong>梯度下降法</strong>进行的。这里，我们选用<strong>交叉熵损失函数</strong>作为优化的目标函数，从最大熵模型和极大似然估计法推导出交叉熵损失函数的过程可以参考我的上一篇博客。</p><p>各权重梯度的求解需要使用到前向后向算法的合作，具体计算过程的推导大家可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/12-crf/main.pdf" target="_blank" rel="noopener">李老师的讲义</a>，这里就不进行叙述了，可以自己动手推导一遍。<strong>特别注意的是，当你对Softmax的交叉熵损失函数求$w_i$的梯度时，条件概率$P(Y|S)$的分母上也含有$w_i$，不能忘记求偏导，这导致我一开始怎么也无法推导出正确的梯度。</strong></p><p>至于梯度下降过程中的细节，如正则化、学习率下降等，均在我的上一篇博客中有说明。大家可以动手自己实践一下，仅需要在Log-Linear Model的基础上进行一些修改即可。</p><h2 id="LC-CRF的预测"><a href="#LC-CRF的预测" class="headerlink" title="LC-CRF的预测"></a>LC-CRF的预测</h2><p>LC-CRF跟HMM一样，一般预测用的都是<strong>维特比（Viterbi）算法</strong>。这个算法是一个简单的动态规划，在我的HMM博客有详细的说明。</p><p><strong>需要注意的是，LC-CRF是全局归一化，即分值和概率的转化放在最后一步进行，所以在维特比算法的动态规划状态矩阵中计算的是当前词性序列的累计得分，使用的是累加。而在HMM中，状态矩阵中计算的是概率，使用的是发射概率和转移概率的累乘。</strong></p><p><img src="5.png" alt="维特比算法示意图"></p><h2 id="HMM和CRF的关系"><a href="#HMM和CRF的关系" class="headerlink" title="HMM和CRF的关系"></a>HMM和CRF的关系</h2><p><strong>与HMM相比，CRF其实是它的泛化，添加了不受限制的特征模板，从而可以不仅仅局限在HMM的观测独立性假设和齐次马尔可夫假设上。</strong>如果你对HMM的核心概率公式，即已知观测序列$s$，求解生成观测序列$l$的概率的概率公式（HMM是生成模型，这里是联合概率），求对数后，将得到：<br>$$<br>logP(l,s)=log(P(l_0)\prod_{i=1}^nP(l_i|l_{i-1})P(s_i|l_i))<br>\\\\=logP(l_0)+\sum_{i=1}^nlogP(l_i|l_{i-1})+\sum_{i=1}^nlogP(s_i|l_i)<br>$$<br> 我们可以将HMM的这个式子和我们的CRF的分值计算公式进行对比：<br>$$<br>Score(l,s)=\sum_{i=1}^{n}\sum_{j=1}^{m}\lambda_jf_j(s,i,l_i,l_{i-1})<br>$$</p><p>其中，$f_j$表示第$j$个特征，$\lambda_j$表示它的特征权重。</p><p>由于CRF需要使用Bigram特征，这里的特征还需要考虑前面一个隐状态$l_{i-1}$是什么。</p><p>由于$f_j$的取值总为0或1，我们可以发现： <strong>如果我们把第一个HMM式子中的log形式的概率看做是第二个CRF式子中的特征函数的权重的话，其实，CRF和HMM具有相同的形式。换句话说，我们可以构造一个CRF，使它与HMM的对数形式相同 ，只需要将特征模板限定为初始特征、转移特征和发射特征。也就是说 ，每一个HMM模型其实都等价于某个CRF！</strong></p><p> 但是，CRF要比HMM更加强大，原因主要有两点： </p><ul><li><strong>CRF可以定义数量更多，种类更丰富的特征函数</strong>。  HMM模型具有天然具有局部性，就是说，在HMM模型中，当前的单词只依赖于当前的标签，当前的标签只依赖于前一个标签。这样的局部性限制了HMM只能定义相应类型的特征函数，而CRF的特征模板不受限制，可以考虑各种类型的特征。</li><li><strong>CRF可以使用任意的特征权重</strong> 。HMM的特征权重是对数概率，也就是说它必须取负值，也只能取负值。而且既然是概率那么它一定要满足概率完备性条件才可以，但是CRF的特征权重你是可以随意取值的。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我对NLP中的CRF模型的学习笔记，由于很多知识在前面的两篇博客——HMM模型和Log-Linear模型中已经讲解过，所以本文写的比较简略。但只要认真的学习了前面两个模型，其实CRF已经迎刃而解了。</p><p>接下来，我将继续学习NLP的相关知识，并尝试练习使用深度学习模型。</p><h2 id="参考资料（部分）"><a href="#参考资料（部分）" class="headerlink" title="参考资料（部分）"></a>参考资料（部分）</h2><p><a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">苏州大学李正华老师的课件</a></p><p><a href="https://www.jianshu.com/p/55755fc649b1" target="_blank" rel="noopener">如何轻松愉快地理解条件随机场（CRF）？</a></p><p><a href="https://www.zhihu.com/question/35866596" target="_blank" rel="noopener">如何用简单易懂的例子解释条件随机场（CRF）模型？它和HMM有什么区别？</a></p><p><a href="https://www.cnblogs.com/kerwins-AC/p/9584862.html" target="_blank" rel="noopener">条件随机场</a></p><p>李航老师《统计学习方法》</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer题解</title>
      <link href="/2020/03/21/jian-zhi-offer-ti-jie/"/>
      <url>/2020/03/21/jian-zhi-offer-ti-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近随便投了字节跳动的暑期实习生，没想到简历过关了，4.12日先去笔试。考虑到Leetcode上面的题目比较多，决定先把《剑指Offer》上的所有题目都刷一遍。</p><h2 id="1-数组中重复的数字"><a href="#1-数组中重复的数字" class="headerlink" title="1. 数组中重复的数字"></a>1. <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中重复的数字</a></h2><p>思路：使用<strong>哈希表或者集合</strong>等数据结构，遍历数组中的数字，当数字没有出现在集合中时，将其加入集合，当数字已经出现在集合中时，说明其重复了，直接返回。</p><p>时间复杂度：$O(n)$，n为数组大小。</p><p>空间复杂度:  $O(n)$</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dic<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-二维数组中的查找"><a href="#2-二维数组中的查找" class="headerlink" title="2.  二维数组中的查找"></a>2. <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener"> 二维数组中的查找</a></h2><p>思路：有些类似于<strong>二叉查找树</strong>的思路，从右上角开始搜索，左侧的数字都比当前数小，下方的数字都比当前数大。如果当前数小于目标，则向下移动一格，大于目标，则向左移动一格，等于目标返回True，超出边界时需要返回False。</p><p>时间复杂度：$O(m+n)$，这是从右上角搜索到左下角的最坏情况，m为行数，n为列数。</p><p>空间复杂度:  $O(1)$</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findNumberIn2DArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> matrix<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            row<span class="token operator">=</span><span class="token number">0</span>            col<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>                    col<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">elif</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>                    row<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-替换空格"><a href="#3-替换空格" class="headerlink" title="3.替换空格"></a>3.<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">替换空格</a></h2><p>思路：将字符串转换为字符列表进行遍历替换即可。（也可以直接调用字符串的replace函数）</p><p><strong>注意：Python中常见的不可变类型有数字、字符串和元组，可变类型有列表和字典。区别主要是： 当不可变数据类型的对应变量的值发生了改变，那么它对应的内存地址也会发生改变。 而可变数据类型可以在不改变内存地址的前提下修改对应内存的值。所以，如果我们要原地修改字符串的内容，需要将其转换为列表。</strong></p><p>时间复杂度：$O(n)$，n为原字符串长度。</p><p>空间复杂度:  $O(m)$，m为替换空格后字符串长度。</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">replaceSpace</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        stLi<span class="token operator">=</span>list<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>stLi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> stLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">' '</span><span class="token punctuation">:</span>                stLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'%20'</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>stLi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-从尾到头打印链表"><a href="#4-从尾到头打印链表" class="headerlink" title="4.从尾到头打印链表"></a>4.<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">从尾到头打印链表</a></h2><p>思路1：递归法，递归结束条件为当前指针为None，利用递归的机制进行求解。<strong>（非尾递归，会先将当前层递归函数保存在栈空间中，等待下层递归函数执行完返回）</strong></p><p>时间复杂度：$O(n)$，n为链表长度。</p><p>空间复杂度:  $O(n)$。</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reversePrint</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>reversePrint<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">[</span>head<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token keyword">if</span> head<span class="token operator">!=</span>None <span class="token keyword">else</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：值 A if 条件语句 else 值B，如果条件满足则值A，否则值B。</p><p>思路2：<strong>辅助栈</strong>，利用栈的性质（先进后出）求解。</p><p>时间复杂度：$O(n)$，n为链表长度。</p><p>空间复杂度:  $O(n)$。</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reversePrint</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        p<span class="token operator">=</span>head        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> result<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-重建二叉树"><a href="#5-重建二叉树" class="headerlink" title="5. 重建二叉树"></a>5. <a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">重建二叉树</a></h2><p>思路：我们生成二叉树主要有两种做法，一是利用标记了空节点的层次遍历序列，二是利用前序（后序）遍历加上中序遍历。后者的具体做法是<strong>分治法</strong>：</p><ul><li><strong>前序遍历的第 1 个结点一定是二叉树的根结点</strong>；</li><li>在中序遍历中，根结点把中序遍历序列分成了两个部分，左边部分构成了二叉树的根结点的左子树，右边部分构成了二叉树的根结点的右子树。</li><li>查找根结点在中序遍历序列中的位置，可以遍历，也可以在一开始就记录下来。</li></ul><p><img src="5.png" alt="分治法"></p><p>通过分治，我们可以递归求解。</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>preL<span class="token punctuation">,</span>preR<span class="token punctuation">,</span>inL<span class="token punctuation">,</span>inR<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> preL<span class="token operator">></span>preR <span class="token operator">or</span> inL<span class="token operator">></span>inR<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当前子树为空</span>                <span class="token keyword">return</span> None            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preL<span class="token punctuation">]</span><span class="token punctuation">)</span>            inPos<span class="token operator">=</span>inorder<span class="token punctuation">.</span>index<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            leftLen<span class="token operator">=</span>inPos<span class="token operator">-</span>inL            root<span class="token punctuation">.</span>left<span class="token operator">=</span>build<span class="token punctuation">(</span>preL<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>preL<span class="token operator">+</span>leftLen<span class="token punctuation">,</span>inL<span class="token punctuation">,</span>inPos<span class="token number">-1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#分治，划分左子树和右子树的序列</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>build<span class="token punctuation">(</span>preL<span class="token operator">+</span>leftLen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>preR<span class="token punctuation">,</span>inPos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>inR<span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token keyword">if</span> preorder<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> build<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>preorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>inorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-用两个栈实现队列"><a href="#6-用两个栈实现队列" class="headerlink" title="6. 用两个栈实现队列"></a>6. <a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">用两个栈实现队列</a></h2><p>思路： 我们可以设计栈A用于入队操作，栈B用于将元素倒序，从而实现出队操作。 </p><ul><li><p><strong>加入队尾 <code>appendTail()</code>函数：</strong> 将数字 <code>val</code> 加入栈 <code>A</code> 即可。</p></li><li><p>删除队首<code>deleteHead()</code>函数：</p><p>有以下三种情况。</p><ol><li><strong>当栈 <code>B</code> 不为空：</strong> <code>B</code>中仍有已完成倒序的元素，因此直接返回 <code>B</code> 的栈顶元素。</li><li><strong>否则，当 <code>A</code> 为空：</strong> 即两个栈都为空，无元素，因此返回 -1 。</li><li><strong>否则：</strong> 将栈 <code>A</code> 元素全部转移至栈 <code>B</code> 中，实现元素倒序，并返回栈 <code>B</code> 的栈顶元素。</li></ol></li></ul><p>时间复杂度：入队$O(1)$，出队$O(n)$</p><p>空间复杂度：$O(n)$</p><p>这个思路只需要保证入队、出队操作的正确返回即可，不需要维护一个真正的用栈模拟的队列。还可以用栈A模拟队列，辅助栈B用于模拟队列的入队或者出队操作，不过那样会比较慢，因为每一次使用辅助栈B都会涉及倒序操作。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">CQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>A<span class="token punctuation">,</span> self<span class="token punctuation">.</span>B <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">appendTail</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>A<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">deleteHead</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>B<span class="token punctuation">:</span>             <span class="token keyword">return</span> self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>A<span class="token punctuation">:</span>             <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>A<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>A<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7.斐波那契数列"></a>7.<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">斐波那契数列</a></h2><p>思路：经典题，<strong>动态规划</strong>求解，相较于递归节约时间和空间。</p><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        fib<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            fib<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>fib<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>fib<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">1000000007</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#实际上python只需要在return时取余即可，这里是向java等语言看齐，防止越界</span>        <span class="token keyword">return</span> fib<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事实上，这道题的DP状态矩阵还可以进一步优化，仅<strong>使用两个变量存储</strong>，降为$O(1)$。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a <span class="token operator">+</span> b        <span class="token keyword">return</span> a <span class="token operator">%</span> <span class="token number">1000000007</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-青蛙跳台阶问题"><a href="#8-青蛙跳台阶问题" class="headerlink" title="8.青蛙跳台阶问题"></a>8.<a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">青蛙跳台阶问题</a></h2><p>思路：依然是<strong>动态规划</strong>问题，青蛙跳到第1级台阶只有一个路径，第2级台阶只有两个路径，第n级台阶的路径为跳到第n-2级台阶的路径数加上跳到第n-1级台阶的路径数之和。    </p><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numWays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        a<span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span>        <span class="token keyword">if</span> n<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> a        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            a<span class="token punctuation">,</span>b<span class="token operator">=</span>b<span class="token punctuation">,</span>a<span class="token operator">+</span>b        <span class="token keyword">return</span> b<span class="token operator">%</span><span class="token number">1000000007</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-旋转数组的最小数字"><a href="#9-旋转数组的最小数字" class="headerlink" title="9.旋转数组的最小数字"></a>9.<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">旋转数组的最小数字</a></h2><p>思路：这种类型的题目，如果我们直接使用线性级别的时间复杂度肯定能做，但没啥意思。查找、排序的题目如果想达到对数级别的时间复杂度，一定要尝试<strong>二分法（减治思想）</strong>。</p><ul><li>本题的思路是通过二分法减治<strong>排除必不可能是最小值的元素</strong>。<ul><li>首先，与常规二分法一样，我们设置两个指针left和right指向数组的左右边界。mid=（left+right）//2</li><li>我们比较numbers[mid]与numbers[right]的值，分为以下三种情况:<ul><li>numbers[mid]&lt;numbers[right]：根据旋转数组的性质，说明从numbers[mid]到numbers[right]必然是升序序列，所以mid+1到right的数字必然大于mid位置的数字，所以它们都不可能是最小值，可以排除，进入[left，mid]闭区间查找最小值。</li><li>numbers[mid]&gt;numbers[right]：根据旋转数组的性质，说明旋转点必然在numbers[mid+1]到numbers[right]之间，进入[mid+1，right]闭区间查找最小值。</li><li>numbers[mid]==numbers[right]：此时，我们不知道最小值在[left，mid]闭区间还是[mid+1，right]闭区间中， 例 [1, 0, 1, 1, 1]中，最小值在[left，mid]，例[1, 1, 1, 0, 1]中，最小值在[mid+1，right]中。虽然我们无法进行二分减治，但是此时我们确定了两个相等的数，并且我们知道删除其中一个不影响最终寻找最小值，我们可以将right减1，缩小区间，再次尝试二分。</li><li>迭代二分后，最终left将超过right，此时left的位置即为最小值的位置。</li></ul></li></ul></li><li>为什么不比较numbers[mid]与numbers[left]的值？<ul><li>例子[1,2,3,4,5]中，numbers[mid]&gt;numbers[left]，最小值在[left，mid]中，但在例子[3,4,5,1,2]中，numbers[mid]&gt;numbers[left]，最小值却在[mid+1，right]中，考虑到未旋转的特殊情况，我们不能使用中间数与首个数比较。</li></ul></li></ul><p>时间复杂度：$O(logn)$</p><p>空间复杂度：$O(1)$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> numbers<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#二分查找这里是小于等于，因为二分查找需要比较最后一个长度为1的区间的值与目标是否相等，这里仅需找到最后一个长度为1的区间即可</span>            mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">if</span> numbers<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>numbers<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">elif</span> numbers<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>numbers<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                right<span class="token operator">=</span>mid            <span class="token keyword">else</span><span class="token punctuation">:</span>                right<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> numbers<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-矩阵中的路径"><a href="#10-矩阵中的路径" class="headerlink" title="10.矩阵中的路径"></a>10.<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">矩阵中的路径</a></h2><p>思路：这类走迷宫问题，我们首先很容易想到的就是<strong>DFS+回溯算法</strong>。类似的题目还有解数独、全排列、皇后问题等。基本的思路就是尝试从矩阵中的每个位置出发，如果当前位置的字符等于目标字符串的首字符，那么继续向左、右、上、下四个方向尝试匹配，目前字符串的指针加1。如果目标字符串的指针到达其长度，说明已经完成匹配，可以返回True。特别地，在这里，同一位置的字符不能重复选择，我们需要设置一个visited矩阵。</p><p><img src="10.png" alt="复杂度分析"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exist</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> board<span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index<span class="token operator">==</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span>word<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">and</span> visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">:</span>                    visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                    res<span class="token operator">=</span>backtrack<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token number">-1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token number">-1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#这里不能直接return，否则无法回溯</span>                    visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">False</span><span class="token comment" spellcheck="true">#回溯已访问矩阵</span>                    <span class="token keyword">return</span> res        <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">##尝试每个位置出发</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PS：这里的visited矩阵可以不用开，直接原地修改board矩阵的元素为False即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exist</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index<span class="token operator">==</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span>word<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>                    tmp<span class="token punctuation">,</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token boolean">False</span>                    res<span class="token operator">=</span>backtrack<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token number">-1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token number">-1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                    board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span>tmp                    <span class="token keyword">return</span> res        <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-机器人的运动范围"><a href="#11-机器人的运动范围" class="headerlink" title="11. 机器人的运动范围"></a>11.<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener"> 机器人的运动范围</a></h2><p>思路：DFS，有点类似于二叉树的节点数统计。判断当前位置是否可以到达的条件是：</p><ol><li>没有越界；</li><li>数位和小于k；</li><li>未访问过。</li></ol><p>一旦该位置不可到达，立刻返回0；如果该位置可达，那么返回1+dfs(row+1,col)+dfs(row,col+1)，表示当前节点可达且继续向右、下方遍历。</p><p>注意，此处机器人虽然可以向上、下、左、右进行遍历，但是我们发现一个地图上所有的格子都可以通过向右走和向下走到达，那么为了防止重复的判断，我们只向下和向右走。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">movingCount</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;</span>m <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;</span>n <span class="token operator">and</span> <span class="token punctuation">(</span>row<span class="token operator">//</span><span class="token number">10</span><span class="token operator">+</span>row<span class="token operator">%</span><span class="token number">10</span><span class="token operator">+</span>col<span class="token operator">//</span><span class="token number">10</span><span class="token operator">+</span>col<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span>k <span class="token operator">and</span> visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">:</span>                visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>dfs<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token operator">+</span>dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：$O(mn)$</p><p>空间复杂度：$O(mn)$</p><h2 id="12-剪绳子"><a href="#12-剪绳子" class="headerlink" title="12.剪绳子"></a>12.<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">剪绳子</a></h2><p>思路：动态规划，dp[i]为整数i可以拆分得到的最大乘积。转移方程为：从1到i-1遍历分解因子j，选择分解后乘积最大的结果，作为当前的状态值。需要注意的是max(dp[i-j],i-j)这一步，因为整数i拆分后的最大乘积不一定大于i，所以要进行比较，例如dp[2]=1&lt;2，所以2并不需要拆分。</p><ul><li>时间复杂度：$O(N^2)$，两侧 <code>for</code> 循环。</li><li>空间复杂度：$O(N)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">integerBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token operator">-</span>j<span class="token punctuation">)</span><span class="token operator">*</span>j<span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，我们通过<a href="https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-shu-xue-fang-fa-han-wan-zheng-t/" target="_blank" rel="noopener">数学证明</a>可以得知，只要尽量把整数i分解为更多的3或2即可，省去了许多分解因子的比较。</p><p>同时，我们还可以使用滚动数组的方法减少状态矩阵的空间占用。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">integerBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            <span class="token number">3</span> <span class="token operator">*</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><h2 id="13-剪绳子-II"><a href="#13-剪绳子-II" class="headerlink" title="13.剪绳子 II"></a>13.<a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/" target="_blank" rel="noopener">剪绳子 II</a></h2><p>思路：和上一题一样，由于我们求导得到的极大值点为e，所以我们要尽量把整数分解为更多的3或者2。最后结果取余1000000007即可（python没有溢出的问题），否则要用快速幂取余法求余数。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">integerBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            <span class="token number">3</span> <span class="token operator">*</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">1000000007</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-二进制中1的个数"><a href="#14-二进制中1的个数" class="headerlink" title="14.二进制中1的个数"></a>14.<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">二进制中1的个数</a></h2><p>思路：根据十进制数与二进制数进行转换的方法，按位判断。</p><ul><li>时间复杂度：$O(logN)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hammingWeight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        count<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                count<span class="token operator">+=</span><span class="token number">1</span>            n<span class="token operator">//=</span><span class="token number">2</span>        <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化的思路：根据以下事实：</p><ul><li>一个数 n与一个比它小 1 的数（n - 1）进行与运算（&amp;）之后，得到的结果会消除 n中最低位的 1.</li></ul><pre><code>示例1: 7 &amp; 600111      &amp;   =》 0011000110示例2: 8 &amp; 701000      &amp;   =》 0000000111</code></pre><p>可以看到，通过与运算不断地消去1，直到 n==0 即可。统计消去的次数，即为n中1的个数。</p><ul><li>时间复杂度：$O(M)$。M为1的个数。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hammingWeight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        count<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            n<span class="token operator">&amp;</span><span class="token operator">=</span>n<span class="token number">-1</span>            count<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="15-数值的整数次方"><a href="#15-数值的整数次方" class="headerlink" title="15.数值的整数次方"></a>15.<a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">数值的整数次方</a></h2><p>思路：快速幂算法，曾经在我的另一篇博客中有提到，第50题。基本思想是二分递归。</p><ul><li>时间复杂度：$O(logN)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">myPow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> float<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">fastpow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">1</span>            half<span class="token operator">=</span>fastpow<span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> half<span class="token operator">*</span>half            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> x<span class="token operator">*</span>half<span class="token operator">*</span>half        <span class="token keyword">if</span> n<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>            n<span class="token operator">=</span><span class="token operator">-</span>n            x<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span>x        <span class="token keyword">return</span> fastpow<span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="16-打印从1到最大的n位数"><a href="#16-打印从1到最大的n位数" class="headerlink" title="16.打印从1到最大的n位数"></a>16.<a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">打印从1到最大的n位数</a></h2><p>思路：这道题没什么好说的，如果用python的列表很好做。但如果是其他语言的话，数字可能在后期会溢出。当可能溢出时，需要把问题转化为大数加法，应考虑进位和最高位是否进位的问题。此外，还可以将其转化为0-9在n个位置上的全排列问题。后两种解法都需要考虑怎么去除最前面的0。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">printNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>pow<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="17-删除链表的节点"><a href="#17-删除链表的节点" class="headerlink" title="17.删除链表的节点"></a>17.<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">删除链表的节点</a></h2><p>思路：数据结构中单链表的最基础操作，使用一个指针，当其next节点的值为需要删除的值时，通过移动next指针指向next节点的next指针，完成删除操作。</p><p>特别地，为了不讨论在链表头部删除节点的特殊情况，我们额外添加一个空的头节点。</p><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def deleteNode(self, head: ListNode, val: int) -&gt; ListNode:        dummyhead=ListNode(0)        dummyhead.next=head        p=dummyhead        while (p.next!=None):            if p.next.val==val:                p.next=p.next.next                break            p=p.next        return dummyhead.next</code></pre><h2 id="18-正则表达式匹配"><a href="#18-正则表达式匹配" class="headerlink" title="18.正则表达式匹配"></a>18.<a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">正则表达式匹配</a></h2><p>思路：动态规划求解，这道题我在我的另一篇博客里有提及。</p><ul><li>时间复杂度：$O(MN)$。</li><li>空间复杂度：$O(MN)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> p<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                first_match<span class="token operator">=</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">or</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'.'</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">and</span> p<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'*'</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">or</span> <span class="token punctuation">(</span>first_match <span class="token operator">and</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>first_match <span class="token operator">and</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="19-表示数值的字符串"><a href="#19-表示数值的字符串" class="headerlink" title="19. 表示数值的字符串"></a>19.<a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener"> 表示数值的字符串</a></h2><p>这道题个人感觉纯靠耐心，利用判断慢慢做，暂时先不做了</p><h2 id="20-调整数组顺序使奇数位于偶数前面"><a href="#20-调整数组顺序使奇数位于偶数前面" class="headerlink" title="20. 调整数组顺序使奇数位于偶数前面"></a>20. <a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">调整数组顺序使奇数位于偶数前面</a></h2><p>思路：双指针法，我的思路来自于快速排序。指针left指向数组最左侧，指针right指向数组最右侧，如果left处的数字是一个奇数，说明该位置上的数字没问题，我们将left加1；如果是一个偶数，则将其与right处的数字交换，此时right处的数字必为偶数，我们可以将right减1。接着，我们看right处的数字，如果它是一个偶数，说明right处数字没问题，可以将right减1，否则，我们将其与left处的数字交换，此时left处必是奇数，我们可以将left+1.</p><p>由于数组中必然一半是奇数，一半是偶数，上述算法当left==right时跳出即可，说明所有数字已成功移动。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exchange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp<span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>tmp        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                swap<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>                right<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                left<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                right<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                swap<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>                left<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="21-链表中倒数第k个节点"><a href="#21-链表中倒数第k个节点" class="headerlink" title="21.链表中倒数第k个节点"></a>21.<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">链表中倒数第k个节点</a></h2><p>思路：快慢指针法，构建一前一后间隔为k的两个指针，当前方的指针指向None时，返回后方指针。特别地，要讨论一下当快指针到达正数第k个节点之前，慢指针将不会出发。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getKthFromEnd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        p<span class="token operator">=</span>head        q<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>k<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>next                q<span class="token operator">=</span>q<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                k<span class="token operator">-=</span><span class="token number">1</span>                q<span class="token operator">=</span>q<span class="token punctuation">.</span>next        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="22-反转链表"><a href="#22-反转链表" class="headerlink" title="22.反转链表"></a>22.<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">反转链表</a></h2><p>思路：有点类似于主站的k个一组反转链表，简化版，可以用头插法或者尾插法实现翻转。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        p<span class="token operator">=</span>head        q<span class="token operator">=</span>head<span class="token punctuation">.</span>next        <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            p<span class="token punctuation">.</span>next<span class="token operator">=</span>q<span class="token punctuation">.</span>next            q<span class="token punctuation">.</span>next<span class="token operator">=</span>head            head<span class="token operator">=</span>q            q<span class="token operator">=</span>p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这道题由于所有插入均在头部，所以不需要使用dummy head。</p><p>另一种方案是使用双指针进行翻转。通过两个间隔为1节点的快慢指针，不断修改快指针的节点的next指针为慢指针的节点，并使他们不断向前移动即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        p<span class="token operator">=</span>None        q<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp<span class="token punctuation">,</span>q<span class="token punctuation">.</span>next<span class="token operator">=</span>q<span class="token punctuation">.</span>next<span class="token punctuation">,</span>p            p<span class="token punctuation">,</span>q<span class="token operator">=</span>q<span class="token punctuation">,</span>tmp        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="23-合并两个排序的链表"><a href="#23-合并两个排序的链表" class="headerlink" title="23. 合并两个排序的链表"></a>23. <a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">合并两个排序的链表</a></h2><p>思路：这题类似于主站的第21题，我曾在另一篇博客里详细说过，主要的思路是用两个指针比较两个链表中的元素，并选取较小的放入新链表。</p><ul><li>时间复杂度：$O(M+N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> l2<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        dummyhead<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        p<span class="token punctuation">,</span>q<span class="token operator">=</span>l1<span class="token punctuation">,</span>l2        r<span class="token operator">=</span>dummyhead        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None <span class="token operator">and</span> q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>                r<span class="token punctuation">.</span>next<span class="token operator">=</span>p                p<span class="token operator">=</span>p<span class="token punctuation">.</span>next                r<span class="token operator">=</span>r<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                r<span class="token punctuation">.</span>next<span class="token operator">=</span>q                q<span class="token operator">=</span>q<span class="token punctuation">.</span>next                r<span class="token operator">=</span>r<span class="token punctuation">.</span>next        <span class="token keyword">if</span> p<span class="token operator">==</span>None<span class="token punctuation">:</span>            r<span class="token punctuation">.</span>next<span class="token operator">=</span>q        <span class="token keyword">else</span><span class="token punctuation">:</span>            r<span class="token punctuation">.</span>next<span class="token operator">=</span>p        <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>归并排序中合并相邻链表的常规做法，需要注意的是当插入空链表时需要分类讨论，为了减少判断，我们可以使用一个伪头结点。</p><h2 id="24-树的子结构"><a href="#24-树的子结构" class="headerlink" title="24.树的子结构"></a>24.<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">树的子结构</a></h2><p>思路：我们先使用先序遍历，遍历树A。然后调用另一个函数，判断A的当前子树是否与B匹配。如果当前子树与B匹配，返回True，否则继续尝试遍历A当前子树的左子树和右子树，看它们与B是否匹配。</p><p>匹配的函数：</p><ol><li>如果当前节点B为空，说明树B已经匹配至越过叶子节点，返回True</li><li>如果当前节点A为空，说明树A已经匹配至越过叶子节点，但树B还没有匹配完，失配了，返回False</li><li>如果当前节点A和节点B均非空，且A的值与B的值相等，则继续尝试匹配A、B节点的左节点和右节点。</li><li>如果A的值与B的值不等，说明失配，返回False。</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSubStructure</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> B<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>B<span class="token operator">==</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token operator">==</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">.</span>val<span class="token operator">==</span>B<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> match<span class="token punctuation">(</span>A<span class="token punctuation">.</span>left<span class="token punctuation">,</span>B<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> match<span class="token punctuation">(</span>A<span class="token punctuation">.</span>right<span class="token punctuation">,</span>B<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> A<span class="token operator">==</span>None <span class="token operator">or</span> B<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> match<span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>isSubStructure<span class="token punctuation">(</span>A<span class="token punctuation">.</span>left<span class="token punctuation">,</span>B<span class="token punctuation">)</span> <span class="token operator">or</span> self<span class="token punctuation">.</span>isSubStructure<span class="token punctuation">(</span>A<span class="token punctuation">.</span>right<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="25-二叉树的镜像"><a href="#25-二叉树的镜像" class="headerlink" title="25.二叉树的镜像"></a>25.<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">二叉树的镜像</a></h2><p>思路：观察镜像翻转后的二叉树可知，我们可以从上向下进行递归翻转。对于每一个节点，我们将其左子树和右子树交换，然后递归进入左子树和右子树的根节点，继续交换它们的左右子树。你会发现，如果你将当前层调整至镜像后，下一层节点其实已经被两个一组翻转了，只需要交换两个一组内部的节点即可完成翻转。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(N)$。递归要占用栈空间。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token operator">=</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>root<span class="token punctuation">.</span>left            self<span class="token punctuation">.</span>mirrorTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>mirrorTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="26-对称的二叉树"><a href="#26-对称的二叉树" class="headerlink" title="26.对称的二叉树"></a>26.<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">对称的二叉树</a></h2><p>思路：</p><ul><li>对称二叉树规律：<ul><li>对于树中任意两个对称节点A和B，一定有：<ul><li>A.val = B.val：即此两对称节点值相等。</li><li>A 的 左子节点 和 B的 右子节点 对称；</li><li>A 的 右子节点 和 B的 左子节点 对称。</li><li>如果A、B均为空，我们认为它们是对称的。</li><li>如果A、B中一个空一个非空，则必然不对称。</li></ul></li></ul></li><li>根据以上规律，考虑从顶至底递归判断每对节点是否对称，从而判断树是否为对称二叉树。</li></ul><p><img src="26.png" alt="规律"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> A<span class="token operator">==</span>None <span class="token operator">and</span> B<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> A<span class="token operator">==</span>None <span class="token operator">or</span> B<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> A<span class="token punctuation">.</span>val<span class="token operator">==</span>B<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> match<span class="token punctuation">(</span>A<span class="token punctuation">.</span>left<span class="token punctuation">,</span>B<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token operator">and</span> match<span class="token punctuation">(</span>A<span class="token punctuation">.</span>right<span class="token punctuation">,</span>B<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> match<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">if</span> root <span class="token keyword">else</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(N)$。递归要占用栈空间。</li></ul><h2 id="27-顺时针打印矩阵"><a href="#27-顺时针打印矩阵" class="headerlink" title="27.顺时针打印矩阵"></a>27.<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">顺时针打印矩阵</a></h2><p>思路：螺旋矩阵，模拟题，做过很多次了。主站第54题，可以看我的另一篇博客。</p><ul><li>时间复杂度：$O(MN)$。</li><li>空间复杂度：$O(N)$。递归要占用栈空间。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        level<span class="token operator">=</span><span class="token number">0</span>        row<span class="token operator">=</span><span class="token number">0</span>        col<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">if</span> matrix<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        result<span class="token operator">=</span><span class="token punctuation">[</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">]</span>        count<span class="token operator">=</span><span class="token number">1</span>        row_nums<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span>        col_nums<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        size<span class="token operator">=</span>row_nums<span class="token operator">*</span>col_nums        <span class="token keyword">while</span> count<span class="token operator">&lt;</span>size<span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col_nums<span class="token operator">-</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>                col<span class="token operator">+=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>row_nums<span class="token operator">-</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>                row<span class="token operator">+=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col_nums<span class="token operator">-</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>                col<span class="token operator">-=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>row_nums<span class="token operator">-</span>level<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                row<span class="token operator">-=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            level<span class="token operator">+=</span><span class="token number">1</span>            col<span class="token operator">+=</span><span class="token number">1</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>            count<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="28-包含min函数的栈"><a href="#28-包含min函数的栈" class="headerlink" title="28.包含min函数的栈"></a>28.<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">包含min函数的栈</a></h2><p>思路：入栈、出栈、取栈顶元素的操作都很简单，Java中可以用数组或者链表来模拟，而python中可以直接用列表来模拟。唯一的难点在于如何找到当前最小值。如果取最小值的时候遍历整个栈，时间复杂度会是线性的，比较高。我们可以以空间换时间，通过建立一个辅助栈，记录当前栈中的某个元素及其之前的所有元素中的最小值。</p><ul><li>时间复杂度：$O(1)$。</li><li>空间复杂度：$O(N)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MinStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>A<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>B<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>A<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> x<span class="token operator">&lt;</span>self<span class="token punctuation">.</span>B<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">else</span> self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>B<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>A<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>A<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>B<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your MinStack object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MinStack()</span><span class="token comment" spellcheck="true"># obj.push(x)</span><span class="token comment" spellcheck="true"># obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.top()</span><span class="token comment" spellcheck="true"># param_4 = obj.min()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="29-栈的压入、弹出序列"><a href="#29-栈的压入、弹出序列" class="headerlink" title="29.栈的压入、弹出序列"></a>29.<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">栈的压入、弹出序列</a></h2><p>思路：辅助栈模拟法。通过采用一个辅助栈模拟压入、弹出的过程。按照压入序列，每次往辅助栈中压入一个数字，同时查看弹出序列中的第 i 个元素是否为辅助栈的栈顶元素（i初始为0），是则从辅助栈中弹出该元素，并将 i 加1，尝试弹出下一个元素，否则继续压入数字。如果最终辅助栈为空，说明弹出序列在当前压入序列下合法。</p><ul><li>时间复杂度：$O(N)$。将所有元素一遍入栈，一遍出栈，需要 $O(2N)$。</li><li>空间复杂度：$O(N)$。使用了辅助栈 <code>st</code>。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">validateStackSequences</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pushed<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> popped<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        i<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> pushed<span class="token punctuation">:</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>popped<span class="token punctuation">)</span> <span class="token operator">and</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>popped<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                i<span class="token operator">+=</span><span class="token number">1</span>         <span class="token keyword">return</span> <span class="token boolean">True</span> <span class="token keyword">if</span> stack<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="30-I-从上到下打印二叉树"><a href="#30-I-从上到下打印二叉树" class="headerlink" title="30. I. 从上到下打印二叉树"></a>30.<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener"> I. 从上到下打印二叉树</a></h2><p>思路：基本的BFS，队列实现。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            i<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">while</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>None<span class="token punctuation">:</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span>                i<span class="token operator">+=</span><span class="token number">1</span>            queue<span class="token operator">=</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">]</span>        <span class="token keyword">return</span> queue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="31-II-从上到下打印二叉树-II"><a href="#31-II-从上到下打印二叉树-II" class="headerlink" title="31.II. 从上到下打印二叉树 II"></a>31.<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">II. 从上到下打印二叉树 II</a></h2><p>思路：依然是BFS的基本题，采用队列的方式。每一层开始时记录下当前队列中的节点数目 L，并开始让父节点出队，左右子节点非空入队，共重复L次，即完成了一层的遍历，将当前队列中的节点添加至结果数组中。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">]</span><span class="token punctuation">)</span>                l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span>                    queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="32-III-从上到下打印二叉树-III"><a href="#32-III-从上到下打印二叉树-III" class="headerlink" title="32. III. 从上到下打印二叉树 III"></a>32.<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener"> III. 从上到下打印二叉树 III</a></h2><p>思路：依然是BFS的基本题，使用一个level变量记录一下当前的层数即可。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        level<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> level<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span>                    queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                level<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> result   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33.二叉搜索树的后序遍历序列"></a>33.<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">二叉搜索树的后序遍历序列</a></h2><p>思路：这道题就是看数组是否满足某一个二叉搜索树的后序遍历。我们知道：</p><ul><li>后序遍历的最后一个节点都是根节点。数组顺序为： [ 左子树 | 右子树 | 根节点 ] 。</li><li>对于二叉搜索树的任意一个节点，左子树的所有节点必然小于它，右子树的所有节点必然大于它。</li></ul><p>根据上述两个性质，我们可以进行递归分治判断，我们先判断根节点的的左子树是否均比他小，右子树是否均比他大，若成立，则继续判断左子树和右子树是否符合二叉搜索树的定义。至于如何划分子树，可以根据根节点来划分，如果出现了比根节点大的值，则该节点及其后在根节点之前的所有节点均为右子树的节点。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">verifyPostorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> postorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> left<span class="token operator">>=</span>right<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            p<span class="token operator">=</span>left            <span class="token keyword">while</span> <span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">&lt;</span>postorder<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                p<span class="token operator">+=</span><span class="token number">1</span>            pos<span class="token operator">=</span>p            <span class="token keyword">while</span> <span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">></span>postorder<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                p<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> p<span class="token operator">==</span>right<span class="token punctuation">:</span>                <span class="token keyword">return</span> match<span class="token punctuation">(</span>left<span class="token punctuation">,</span>pos<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">and</span> match<span class="token punctuation">(</span>pos<span class="token punctuation">,</span>right<span class="token number">-1</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> match<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>postorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>时间复杂度：$O(N^2)$。最坏情况下是当二叉树退化为链表。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><h2 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34.二叉树中和为某一值的路径"></a>34.<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">二叉树中和为某一值的路径</a></h2><p>思路：递归搜索+回溯。类似于组合数的问题，我在另一篇博客中有提到过，基本做法是从根节点向下递归搜索，如果当前节点为空，则直接返回，如果当前节点不为空，则将当前节点加入至当前路径列表，并将它的值加入至当前路径和中。接着讨论两种情况：（1）当前节点为叶子节点且当前路径和为0，那么将当前路径加入至结果列表中；（2）否则，继续搜索左孩子节点和右孩子节点。讨论完成后，回溯至最初的状态。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>re<span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            re<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            sum<span class="token operator">-=</span>root<span class="token punctuation">.</span>val            <span class="token keyword">if</span> sum<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> root<span class="token punctuation">.</span>left<span class="token operator">==</span>None <span class="token operator">and</span> root<span class="token punctuation">.</span>right<span class="token operator">==</span>None<span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>re<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>re<span class="token punctuation">,</span>sum<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>re<span class="token punctuation">,</span>sum<span class="token punctuation">)</span>            re<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            sum<span class="token operator">+=</span>root<span class="token punctuation">.</span>val        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> re<span class="token punctuation">]</span> <span class="token keyword">for</span> re <span class="token keyword">in</span> result<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>时间复杂度：$O(N)$。本质上就是一次先序遍历加上判断的过程。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35.复杂链表的复制"></a>35.<a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">复杂链表的复制</a></h2><p>思路：这题本质上是模拟复杂链表的深拷贝。既然是深拷贝，我们就不能直接引用，而是应该使用新建值相同的节点类的方式进行拷贝。但是这道题有一个问题，就是存在random指针指向链表中的任意节点或者 <code>null</code>。 所以如何保证拷贝random指针的节点和拷贝next指针的节点的一致性，是我们需要解决的问题。也就是说，如果我们按照next指针顺序进行拷贝节点的话，如果需要拷贝的节点已经因为之前被某个节点的random指针指向，而已经被拷贝过了，如何知道它已经拷贝且正确指向他呢？</p><p>我的思路是使用一个哈希表，哈希表的key是原链表中的节点，哈希表的value是新拷贝得到的节点。当我们进行拷贝时，如果需要拷贝的节点尚且不在哈希表的key中，则我们可以进行拷贝，并将原节点-新节点的键值对保存进哈希表中，当我们再次拷贝某节点，会发现它已被拷贝过，直接将next或random指针指向它即可。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。哈希表使用了额外的空间。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""# Definition for a Node.class Node:    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):        self.val = int(x)        self.next = next        self.random = random"""</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">copyRandomList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Node'</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> head<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        copyhead<span class="token operator">=</span>Node<span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token operator">=</span>copyhead        q<span class="token operator">=</span>head        visited<span class="token operator">=</span><span class="token punctuation">{</span>head<span class="token punctuation">:</span>copyhead<span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> q<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span>                <span class="token keyword">if</span> q<span class="token punctuation">.</span>next <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    visited<span class="token punctuation">[</span>q<span class="token punctuation">.</span>next<span class="token punctuation">]</span><span class="token operator">=</span>Node<span class="token punctuation">(</span>q<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                p<span class="token punctuation">.</span>next<span class="token operator">=</span>visited<span class="token punctuation">[</span>q<span class="token punctuation">.</span>next<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                p<span class="token punctuation">.</span>next<span class="token operator">=</span>None            <span class="token keyword">if</span> q<span class="token punctuation">.</span>random<span class="token operator">!=</span>None<span class="token punctuation">:</span>                <span class="token keyword">if</span> q<span class="token punctuation">.</span>random <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    visited<span class="token punctuation">[</span>q<span class="token punctuation">.</span>random<span class="token punctuation">]</span><span class="token operator">=</span>Node<span class="token punctuation">(</span>q<span class="token punctuation">.</span>random<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                p<span class="token punctuation">.</span>random<span class="token operator">=</span>visited<span class="token punctuation">[</span>q<span class="token punctuation">.</span>random<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                p<span class="token punctuation">.</span>random<span class="token operator">=</span>None            p<span class="token punctuation">,</span>q<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">,</span>q<span class="token punctuation">.</span>next        <span class="token keyword">return</span> copyhead<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他思路：</p><p><img src="35.png" alt></p><ul><li>我们可以将链表看成是graph，利用BFS或者DFS+哈希表进行求解。本质思想和直接迭代按照单链表的next指针顺序复制是一样的。</li></ul><h2 id="35-二叉搜索树与双向链表"><a href="#35-二叉搜索树与双向链表" class="headerlink" title="35.二叉搜索树与双向链表"></a>35.<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">二叉搜索树与双向链表</a></h2><p>思路：首先，我们知道，二叉搜索树的性质有一条是中序遍历所得到的结果是升序排序的序列。恰好，我们要构造的双向链表也是升序排序的，所以我们会想到使用中序遍历来进行原地转换。</p><p>具体算法如下：</p><ul><li><p>设置全局变量head，tail指针，指向当前链表的头尾节点，初始均为None。（为什么一定要全局节点，因为这里的指针是不可变类型，所以在内部函数中对其修改不会改变外层的值，如果是可变类型则会产生改变）</p></li><li><p>开始中序遍历，如果当前节点为空，那么什么也不做，直接返回。如果当前节点非空，先递归遍历左子树。如果当前head指针非空，说明当前节点是二叉搜索树的第一个节点，即最小值，自然也就是双向链表的head节点，那么让head指向他。如果当前tail非空，说明左子树的遍历已经为双向链表加入了节点，且tail指向的是当前双向链表的尾部节点，那么进行如下修改：（1）让当前节点的left指针指向当前tail（2）让当前tail的right指针指向当前节点。接下来，无论tail是否为空，让它指向当前节点。上述三个操作相当于把当前节点加入至双向链表尾部，并让tail指向他。接下来，递归遍历右子树。简而言之，上述过程就是按照中序遍历的顺序不断原地修改二叉搜索树，tail指针始终指向当前节点的前一个节点。</p></li><li><p>完成中序遍历后，我们获得了一个头尾尚未连接的双向链表，此时我们将头节点和尾节点连接即可。</p></li><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(1)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""# Definition for a Node.class Node:    def __init__(self, val, left=None, right=None):        self.val = val        self.left = left        self.right = right"""</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>head<span class="token operator">=</span>None        self<span class="token punctuation">.</span>tail<span class="token operator">=</span>None    <span class="token keyword">def</span> <span class="token function">treeToDoublyList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Node'</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>             inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>head<span class="token operator">==</span>None<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>head<span class="token operator">=</span>root            <span class="token keyword">if</span> self<span class="token punctuation">.</span>tail<span class="token operator">!=</span>None<span class="token punctuation">:</span>                root<span class="token punctuation">.</span>left<span class="token operator">=</span>self<span class="token punctuation">.</span>tail                self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>right<span class="token operator">=</span>root            self<span class="token punctuation">.</span>tail<span class="token operator">=</span>root            inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>left<span class="token operator">=</span>self<span class="token punctuation">.</span>tail        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>head        <span class="token keyword">return</span> self<span class="token punctuation">.</span>head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="36-序列化二叉树"><a href="#36-序列化二叉树" class="headerlink" title="36.序列化二叉树"></a>36.<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">序列化二叉树</a></h2><p>思路：这道题我曾经在大二的数据结构课上做过，可以用两种方式来解决。这里我们先说层次遍历的解法。</p><p>BFS的解法：</p><ul><li>序列化：BFS的序列化按照常规做法，依然是使用队列来完成。先将根节点加入队列。每次从队首取出一个节点，如果当前节点为空，那么向序列化的字符串中添加一个”*”作为占位符，否则将它的value添加进字符串，中间用“，”隔开。然后，将其左右孩子节点均加入队列中。重复上述过程直到队列为空。</li></ul><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Encodes a tree to a single string.        :type root: TreeNode        :rtype: str        """</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span>        data<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token operator">==</span>None<span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>node<span class="token punctuation">.</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">","</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>反序列化：BFS的反序列化较为复杂，由于不是完全二叉树，不可以直接用下标运算求解子节点位置，需要使用一个辅助队列来存放当前剩余的需要处理的节点，并使用一个指针来遍历序列化字符串中逗号隔开的每个元素。</li></ul><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Decodes your encoded data to tree.        :type data: str        :rtype: TreeNode        """</span>        data<span class="token operator">=</span>data<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"*"</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None        root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span>        i<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">"*"</span><span class="token punctuation">:</span>                leftNode<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                node<span class="token punctuation">.</span>left<span class="token operator">=</span>leftNode                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>leftNode<span class="token punctuation">)</span>            i<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">"*"</span><span class="token punctuation">:</span>                rightNode<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                node<span class="token punctuation">.</span>right<span class="token operator">=</span>rightNode                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>rightNode<span class="token punctuation">)</span>            i<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一种更为简单直观的方式是DFS的做法，直接使用先序遍历求解。</p><ul><li>序列化：先序遍历，每次将当前节点加入至序列化字符串中，如果当前节点为空，则加入“*”占位符，否则加入value，然后递归遍历左子树和右子树。</li></ul><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Encodes a tree to a single string.        :type root: TreeNode        :rtype: str        """</span>        data<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        preorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">","</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>反序列化：依然是先序遍历的方式递归重建二叉树。</li></ul><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Decodes your encoded data to tree.        :type data: str        :rtype: TreeNode        """</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">:</span>            now<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> now<span class="token operator">==</span><span class="token string">"*"</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> None            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>left<span class="token operator">=</span>build<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>build<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            <span class="token keyword">return</span> root        queue<span class="token operator">=</span>data<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> build<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="37-字符串的排列"><a href="#37-字符串的排列" class="headerlink" title="37.字符串的排列"></a>37.<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">字符串的排列</a></h2><p>思路：全排列问题，采用DFS+递归的方式解决。需要注意的是这里应该进行去重，去重的思路有两种：</p><ul><li>哈希表或者集合的方式去重。</li><li>先对字符串进行字典序排序（字符串没有sort函数，必须调用全局函数sorted（）），如果当前序号的字符等于前一个字符，且前一个字符尚未被访问，则可以跳过对他的搜索。因为它的所有组合已经被前一个字符的搜索所覆盖了。具体可以参考主站的第47题<a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">全排列 II</a>。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">permutation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        s<span class="token operator">=</span>sorted<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">DFS</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token operator">==</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token boolean">True</span> <span class="token operator">and</span> <span class="token operator">not</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">and</span> visited<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                        DFS<span class="token punctuation">(</span>st<span class="token operator">+</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">False</span>        DFS<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(N*N!)$。N为字符串长度</li><li>空间复杂度：$O(N*N!)$。</li></ul><h2 id="38-数组中出现次数超过一半的数字"><a href="#38-数组中出现次数超过一半的数字" class="headerlink" title="38.数组中出现次数超过一半的数字"></a>38.<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中出现次数超过一半的数字</a></h2><p>思路：排序然后取中位数即可。因为假如某个数字出现次数超过一半，则排序后必然出现在中间位置上。</p><ul><li>时间复杂度：$O(NlogN)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="39-最小的k个数"><a href="#39-最小的k个数" class="headerlink" title="39.最小的k个数"></a>39.<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">最小的k个数</a></h2><p>思路：经典的TOP K问题！常规的做法是直接排序一下，用快排的话是$O(NlogN)$。为了能更快，主要思路有有两种，分别是使用堆（优先队列）或者快速选择。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li>基本思路：使用一个大顶堆来存储数组中前k小的元素。一开始，先使用数组中前K个元素建大顶堆，此时，堆顶的元素为前K个元素中的最大值。然后从K+1个元素向后依次遍历，如果当前元素小于大顶堆的堆顶元素，说明堆顶元素不仅大于堆中的K-1个元素，且大于当前元素，必不可能是前K小的元素。所以，我们将当前元素加入至堆中，并调整堆至继续符合大顶堆。继续向后遍历，维护大顶堆，直到遍历到数组末尾，此时堆中的元素即为数组的前K小的值。</li><li>时间复杂度：$O(nlogk)$，因为元素出堆和入队平均都需要$O(logk)$的时间复杂度，与此同时，最坏的情况下（降序排列），需要对所有的元素进行插入操作，所以时间复杂度为$O(nlogk)$。</li><li>空间复杂度：$O(k)$，使用了一个大小为k的堆。</li><li>Python中提供了高级数据结构heapq，详情可以看这篇博客<a href="https://blog.csdn.net/jamfiy/article/details/88185512" target="_blank" rel="noopener">python高级（堆heapq模块）</a>，它以列表为基础提供了小顶堆的操作。为了使用大顶堆，我们对堆中所有的元素进行取反操作，并再返回结果时恢复符号。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getLeastNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        heap<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>heap<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#将列表转换为堆</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token operator">-</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#前K个数字入堆</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token operator">-</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#这个函数的意思是，如果当前数比堆顶元素大，那么入堆并将堆顶元素出堆，否则不变</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> heap<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><ul><li><p>基本思路：在数组中找第K小（大）的元素，或者前K小（大）的元素，可以使用快速排序变形的算法，我们称之为快速选择（quick select），都是分治法。</p></li><li><p>让我们回顾快速排序的思路。快速排序中有一步很重要的操作是 partition（划分），从数组中随机选取一个枢纽元素 v，然后原地移动数组中的元素，使得比 v 小的元素在 v 的左边，比 v 大的元素在 v 的右边，如下图所示：</p><p><img src="39.jpg" alt="快速排序"></p><p>这个 partition 操作是原地进行的，需要 $O(n)$ 的时间，接下来，快速排序会递归地排序左右两侧的数组。而快速选择（quick select）算法的不同之处在于，接下来只需要递归地选择一侧的数组。快速选择算法想当于一个“不完全”的快速排序，因为我们只需要知道最小的 k 个数是哪些，并不需要知道它们的顺序。</p><p>我们的目的是寻找最小的 k 个数。假设经过一次 partition 操作，枢纽元素位于下标 m，也就是说，左侧的数组有 m 个元素，是原数组中最小的 m 个数。那么：</p><ul><li>若 k = m，我们就找到了最小的 k 个数，就是左侧的数组；</li><li>若 k&lt;m ，则最小的 k 个数一定都在左侧数组中，我们只需要对左侧数组递归地 parition 即可；</li><li>若 k&gt;m，则左侧数组中的 m 个数都属于最小的 k 个数，我们还需要在右侧数组中寻找最小的 k-m个数，对右侧数组递归地 partition 即可。</li></ul></li><li><p>复杂度分析比较麻烦：</p><p><img src="39.png" alt="快速选择的复杂度分析"></p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getLeastNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#和快速排序中的分治一样，将当前区间首部的枢纽元素调整至正确的位置</span>            i<span class="token operator">=</span>left<span class="token operator">+</span><span class="token number">1</span>            j<span class="token operator">=</span>right            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>right <span class="token operator">and</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    i<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j<span class="token operator">></span>left <span class="token operator">and</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">>=</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    j<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">if</span> i<span class="token operator">&lt;</span>j<span class="token punctuation">:</span>                    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                    <span class="token keyword">break</span>            <span class="token keyword">return</span> j        <span class="token keyword">def</span> <span class="token function">quickSelect</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#快速选择算法</span>            m<span class="token operator">=</span>partition<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> m<span class="token operator">==</span>k<span class="token punctuation">:</span>                <span class="token keyword">return</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">elif</span> m<span class="token operator">></span>k<span class="token punctuation">:</span>                <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span>left<span class="token punctuation">,</span>m<span class="token number">-1</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span>        <span class="token keyword">if</span> k<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> k<span class="token operator">></span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> arr        <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="40-数据流中的中位数"><a href="#40-数据流中的中位数" class="headerlink" title="40.数据流中的中位数"></a>40.<a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">数据流中的中位数</a></h2><p>思路：这道题我们可以将插入的数字保存在一个数组中，然后排序数组输出中位数。很明显，这样做很低效。较好的一种思路是使用二分法查找插入的位置，保证每次插入后数组是有序的。但是这样做还不够好，我们可以通过使用两个堆来解决这一问题。</p><ul><li>我们使用一个大顶堆用于存放当前所有数据中的前一半数据（下标由0到len//2），使用一个小顶堆存放当前数组的后一半数据（下标由len//2+1到len-1）。当总长度为奇数时，我们取大顶堆中的堆顶元素作为中位数，否则取两个堆堆顶元素求平均。</li><li>由于中位数在大顶堆中，所以当前数据总数为奇数时，大顶堆规模比小顶堆大1，当数据总数为偶数时，大顶堆规模和小顶堆相等。所以插入后数据总数为奇数时，新的数先插入小顶堆，再从小顶堆堆顶取出元素插入大顶堆，使小顶堆规模不变，大顶堆规模加1，从而保证了前述的性质。插入后数据总数为偶数时，新的数先插入大顶堆，再从大顶堆堆顶取出元素插入小顶堆，使大顶堆规模不变，小顶堆规模加1。</li><li>时间复杂度：插入元素：$O(logk)$，求中位数：$O(log1)$。</li><li>Python中只有小顶堆，所以大顶堆需要用负数来模拟。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MedianFinder</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>largeHeap<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>smallHeap<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>count<span class="token operator">=</span><span class="token number">0</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>self<span class="token punctuation">.</span>largeHeap<span class="token punctuation">)</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>self<span class="token punctuation">.</span>smallHeap<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">addNum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>count<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>self<span class="token punctuation">.</span>largeHeap<span class="token punctuation">,</span><span class="token operator">-</span>heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>self<span class="token punctuation">.</span>smallHeap<span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>self<span class="token punctuation">.</span>smallHeap<span class="token punctuation">,</span><span class="token operator">-</span>heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>self<span class="token punctuation">.</span>largeHeap<span class="token punctuation">,</span><span class="token operator">-</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>count<span class="token operator">+=</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">findMedian</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None        <span class="token keyword">if</span> self<span class="token punctuation">.</span>count<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">-</span>self<span class="token punctuation">.</span>largeHeap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>self<span class="token punctuation">.</span>smallHeap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span>self<span class="token punctuation">.</span>largeHeap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your MedianFinder object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MedianFinder()</span><span class="token comment" spellcheck="true"># obj.addNum(num)</span><span class="token comment" spellcheck="true"># param_2 = obj.findMedian()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="41-连续子数组的最大和"><a href="#41-连续子数组的最大和" class="headerlink" title="41.连续子数组的最大和"></a>41.<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">连续子数组的最大和</a></h2><p>思路：动态规划，与主站53题相同。状态矩阵DP[i]表示以第i个数结尾的连续子数组的最大和。转移方程为：DP[i]=（1）nums[i]（if DP[i-1]&lt;=0） （2）DP[i-1]+nums[i]（else），转移过程中记录最大值。特别地，我们可以原地修改Nums矩阵作为DP矩阵。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> nums<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None        maxSum<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>            maxSum<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>maxSum<span class="token punctuation">)</span>        <span class="token keyword">return</span> maxSum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="42-数字-1-的个数"><a href="#42-数字-1-的个数" class="headerlink" title="42.数字 1 的个数"></a>42.<a href="https://leetcode-cn.com/problems/number-of-digit-one/" target="_blank" rel="noopener">数字 1 的个数</a></h2><p>思路：数学规律题，需要慢慢分析。个人认为面试题的可能性不大，以后再做。</p><h2 id="43-数字序列中某一位的数字"><a href="#43-数字序列中某一位的数字" class="headerlink" title="43.数字序列中某一位的数字"></a>43.<a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">数字序列中某一位的数字</a></h2><p>思路：依然是数学规律题，一位数从0到9，共10个，总占位数10位，两位数从10到99，共90个，总占位数180位…..以此类推，m位数所占位数为$(10^m-10^{m-1})*m$。从而可以推出某一位的数字是哪个数字的哪一位。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findNthDigit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">cal</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> m<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">10</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">**</span>m<span class="token number">-10</span><span class="token operator">**</span><span class="token punctuation">(</span>m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span>m        m<span class="token operator">=</span><span class="token number">0</span>        s<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> n<span class="token operator">>=</span>s<span class="token punctuation">:</span>            m<span class="token operator">+=</span><span class="token number">1</span>            s<span class="token operator">+=</span>cal<span class="token punctuation">(</span>m<span class="token punctuation">)</span>        s<span class="token operator">-=</span>cal<span class="token punctuation">(</span>m<span class="token punctuation">)</span>        <span class="token keyword">if</span> m<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>n<span class="token operator">-</span>s<span class="token punctuation">)</span><span class="token operator">//</span>m        <span class="token keyword">else</span><span class="token punctuation">:</span>            num<span class="token operator">=</span> str<span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">**</span><span class="token punctuation">(</span>m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>n<span class="token operator">-</span>s<span class="token punctuation">)</span><span class="token operator">//</span>m<span class="token punctuation">)</span>            offset<span class="token operator">=</span><span class="token punctuation">(</span>n<span class="token operator">-</span>s<span class="token punctuation">)</span><span class="token operator">%</span>m            <span class="token keyword">return</span> int<span class="token punctuation">(</span>num<span class="token punctuation">[</span>offset<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="44-把数组排成最小的数"><a href="#44-把数组排成最小的数" class="headerlink" title="44.把数组排成最小的数"></a>44.<a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">把数组排成最小的数</a></h2><p>思路：这道题主要的思路是这样的，我们需要对当前数组进行排序，排序的规则需要我们重新定义。我们比较两个字符串，如果A+B的字典序小于B+A，那么A一定在B之前。重写排序规则的方法，在Java中可以重写Comparator，Python中新建一个类，重写它的lt方法，并将其传入sorted函数的key中。</p><ul><li>时间复杂度：$O(NlogN)$。排序的时间复杂度。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">cmpSmaller</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__lt__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self <span class="token operator">+</span> y <span class="token operator">&lt;</span> y <span class="token operator">+</span> self  <span class="token comment" spellcheck="true"># 字符串拼接比较(两两比较)</span>    <span class="token comment" spellcheck="true"># 按由小到大来排列</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        res<span class="token operator">=</span>sorted<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">,</span>key<span class="token operator">=</span>cmpSmaller<span class="token punctuation">)</span>        smallest <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>res<span class="token punctuation">)</span>        <span class="token keyword">return</span> smallest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="45-把数字翻译成字符串"><a href="#45-把数字翻译成字符串" class="headerlink" title="45.把数字翻译成字符串"></a>45.<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">把数字翻译成字符串</a></h2><p>思路：先将数字转字符串便于直接获取某一位，再动态规划，状态矩阵dp[i]为前i个字符的翻译方法数目。转移时，要注意：由于单个数字必然可以转为字母，如果前一个数字字符和当前数字字符组成的新数字在[10，25]间，说明它们可以组成一个英文字母（此处，含有前缀0的数字不可以被翻译成字母，如“01”等），那么dp[i]=dp[i-1]+dp[i-2]，否则dp[i]=dp[i-1]。特别地，对于i==1时要特殊判断一下，因为涉及到字符串的初始化。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(N)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">translateNum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        num<span class="token operator">=</span>str<span class="token punctuation">(</span>num<span class="token punctuation">)</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp<span class="token operator">=</span>int<span class="token punctuation">(</span>num<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>tmp<span class="token operator">&lt;=</span><span class="token number">25</span> <span class="token operator">and</span> num<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'0'</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，像这种只用到前两个状态的动态规划，还可以使用滚动数组的方式降低空间复杂度。</p><h2 id="46-礼物的最大价值"><a href="#46-礼物的最大价值" class="headerlink" title="46.礼物的最大价值"></a>46.<a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">礼物的最大价值</a></h2><p>思路：有些类似于主站的机器人走迷宫问题，一开始这种题目我们很容易想到DFS，但是我们发现会超时，因为对许多路径进行了重复的遍历，产生了重叠子问题。很明显，这里我们要使用动态规划，dp[i] [j]为走到（i，j）格子时的最大礼物数目，转移方程见程序，选取上方或者左侧的状态中的最大值加上当前格子礼物价值作为当前状态。特别地，我们还可以原地修改grid作为我们的状态矩阵dp，不使用额外空间。</p><ul><li>时间复杂度：$O(MN)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxValue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> row<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> col<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">+=</span>grid<span class="token punctuation">[</span>row<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span>                <span class="token keyword">elif</span> row<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> col<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                    grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">+=</span>grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token keyword">elif</span> row<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> col<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                    grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">+=</span>max<span class="token punctuation">(</span>grid<span class="token punctuation">[</span>row<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">,</span>grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> grid<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="47-最长不含重复字符的子字符串"><a href="#47-最长不含重复字符的子字符串" class="headerlink" title="47.最长不含重复字符的子字符串"></a>47.<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">最长不含重复字符的子字符串</a></h2><p>思路：与主站第3题类似，采用双指针维护一个不含重复字符的滑动窗口。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span><span class="token number">1</span>        max_len<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token keyword">in</span> s<span class="token punctuation">[</span>left<span class="token punctuation">:</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                left<span class="token operator">+=</span><span class="token number">1</span>            now_len<span class="token operator">=</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">if</span> now_len<span class="token operator">></span>max_len<span class="token punctuation">:</span>                max_len<span class="token operator">=</span>now_len            right<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> max_len<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="48-丑数"><a href="#48-丑数" class="headerlink" title="48.丑数"></a>48.<a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">丑数</a></h2><p>思路：这道题我曾经在蓝桥杯上做过，基本思路就是动态规划，dp[i]为第i个丑数。具体做法是使用三个指针，分别指向2、3、5所要乘以的丑数因子，每次从三个指针指向的丑数分别乘以2、3、5所得乘积中选取最小值添加到当前丑数数组中，并将最小值对应的指针加1，继续比较。（需要注意的是，这里的最小值可能不止一个）</p><p>当然，这道题还可以用一个小顶堆来做，基本的思路是小顶堆堆顶存放当前最小丑数，每次取出最小丑数，并将它乘2、3、5的积加入堆中，继续取最小丑数，取n次。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">nthUglyNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>      dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>      p2<span class="token punctuation">,</span>p3<span class="token punctuation">,</span>p5<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>          dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>p3<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>p5<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>dp<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">:</span>              p2<span class="token operator">+=</span><span class="token number">1</span>          <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>dp<span class="token punctuation">[</span>p3<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">:</span>              p3<span class="token operator">+=</span><span class="token number">1</span>          <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>dp<span class="token punctuation">[</span>p5<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">:</span>              p5<span class="token operator">+=</span><span class="token number">1</span>      <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="49-第一个只出现一次的字符"><a href="#49-第一个只出现一次的字符" class="headerlink" title="49.第一个只出现一次的字符"></a>49.<a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/" target="_blank" rel="noopener">第一个只出现一次的字符</a></h2><p>思路：简单题，使用哈希表来存放每个字符出现的次数，输出第一个出现次数为1的字符。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">if</span> s<span class="token punctuation">:</span>            dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>            <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>                <span class="token keyword">if</span> ch <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    dic<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dic<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">for</span> key <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> key        <span class="token keyword">return</span> <span class="token string">" "</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="50-数组中的逆序对"><a href="#50-数组中的逆序对" class="headerlink" title="50.数组中的逆序对"></a>50.<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">数组中的逆序对</a></h2><p>思路：这道题的思路很难想到，需要慢慢分析。最简单的做法是暴力遍历，时间复杂度为$O(N^2)$。但很明显，时间复杂度过高，会很慢。在这里，我们使用一种归并排序的思想进行优化。</p><ul><li>正常进行归并排序。</li><li>只用添加一行代码，就是使用双指针归并两个有序数组时，如果前一个数组的指针p指向的数大于后一个数组的指针q指向的数，说明前面的数组中，自p到最后一个下标的数都大于q下标的数，都为逆序对，所以需要在全局变量count中加上len（nums1）-p。（相较于直接暴力破解，这样做可以一次确定多个逆序对）</li><li>时间复杂度：$O(NlogN)$。本质上还是归并排序</li><li>空间复杂度：$O(N)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>sum<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">mergeTwoList</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span>nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>            p<span class="token operator">=</span><span class="token number">0</span>            q<span class="token operator">=</span><span class="token number">0</span>            result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span> <span class="token operator">and</span> q<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">:</span>                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span>                    p<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>sum<span class="token operator">+=</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">-</span>p                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span>                    q<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> p<span class="token operator">==</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">:</span>                result<span class="token operator">+=</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">:</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                result<span class="token operator">+=</span>nums1<span class="token punctuation">[</span>p<span class="token punctuation">:</span><span class="token punctuation">]</span>            <span class="token keyword">return</span> result        <span class="token keyword">def</span> <span class="token function">mergesort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> nums            mid<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">return</span> mergeTwoList<span class="token punctuation">(</span>mergesort<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token punctuation">:</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>mergesort<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        mergesort<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>sum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="51-两个链表的第一个公共节点"><a href="#51-两个链表的第一个公共节点" class="headerlink" title="51.两个链表的第一个公共节点"></a>51.<a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">两个链表的第一个公共节点</a></h2><p>思路：最简单的方法是暴力比较，时间复杂度较高。可以考虑哈希表辅助比较，但是空间复杂度较高。最好的办法是双指针法，指针P指向headA，指针Q指向headB，二者同时向后遍历，如果P到达终点，那么让他重新从headB开始；如果Q到达终点，那么让他重新从headA开始，最终二者必然相遇。</p><p>双指针法原理是： 若相交，链表A： a+c, 链表B : b+c。 a+c+b+c = b+c+a+c ，则会在公共处c起点相遇。若不相交，a +b = b+a 。因此相遇处是NULL 。</p><ul><li>时间复杂度：$O(m+n)$。</li><li>空间复杂度：$O(1)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> headA<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> headB<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        p<span class="token operator">=</span>headA        q<span class="token operator">=</span>headB        <span class="token keyword">while</span> p<span class="token operator">!=</span>q<span class="token punctuation">:</span>            p<span class="token operator">=</span>headB <span class="token keyword">if</span> p<span class="token operator">==</span>None <span class="token keyword">else</span> p<span class="token punctuation">.</span>next            q<span class="token operator">=</span>headA <span class="token keyword">if</span> q<span class="token operator">==</span>None <span class="token keyword">else</span> q<span class="token punctuation">.</span>next        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="52-I-在排序数组中查找数字-I"><a href="#52-I-在排序数组中查找数字-I" class="headerlink" title="52.I. 在排序数组中查找数字 I"></a>52.<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">I. 在排序数组中查找数字 I</a></h2><p>思路：我们首先肯定想到的是顺序遍历数组，但那样无法获取log级别的时间复杂度。为了优化，我们使用二分的思想，与主站34题类似，先二分查找该数字第一次出现的位置，再二分查找其最后一次出现的位置，最后返回差值即可。</p><ul><li>时间复杂度：$O(logN)$。</li><li>空间复杂度：$O(1)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">searchLeftBound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            left<span class="token operator">=</span><span class="token number">0</span>            right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>                mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">>=</span>target<span class="token punctuation">:</span>                    right<span class="token operator">=</span>mid<span class="token number">-1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>left<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> left            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">def</span> <span class="token function">searchRightBound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            left<span class="token operator">=</span><span class="token number">0</span>            right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>                mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token punctuation">:</span>                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    right<span class="token operator">=</span>mid<span class="token number">-1</span>            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> right            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        leftBound<span class="token operator">=</span>searchLeftBound<span class="token punctuation">(</span><span class="token punctuation">)</span>        rightBound<span class="token operator">=</span>searchRightBound<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> leftBound<span class="token operator">></span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> rightBound<span class="token operator">-</span>leftBound<span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="53-II-0～n-1中缺失的数字"><a href="#53-II-0～n-1中缺失的数字" class="headerlink" title="53.II. 0～n-1中缺失的数字"></a>53.<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">II. 0～n-1中缺失的数字</a></h2><p>思路：首先我们想到的是顺序遍历检查下标，但这样依然是线性的时间复杂度。为了优化至对数级别的时间复杂度，我们还是使用二分的方法，如果中位数与下标相等，说明它及它之前的所有数都不缺失，进入右区间查找缺失的数字，否则进入左区间查找。最后返回Left，为什么是left可以自己模拟一下。当最后的left等于len（nums）时，说明当前数组所有的数字均不缺失。</p><ul><li>时间复杂度：$O(logN)$。</li><li>空间复杂度：$O(1)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>mid<span class="token punctuation">:</span>                left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                right<span class="token operator">=</span>mid<span class="token number">-1</span>        <span class="token keyword">return</span> left<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54.二叉搜索树的第k大节点"></a>54.<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">二叉搜索树的第k大节点</a></h2><p>思路：与数组中求第（前）k大（小）是一样的，两种思路：（1）堆，（2）快速选择。这里我们由于事先没有完整的数据，需要进行二叉树的遍历，所以使用堆更好。在这里我们使用大小为k的小顶堆存放前k大的数。</p><ul><li>时间复杂度：$O(NlogK)$。</li><li>空间复杂度：$O(K)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">kthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>k<span class="token operator">=</span>k        heap<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>heap<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>k<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>k<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            preOrder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            preOrder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        preOrder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> heap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，我们发现这棵树是二叉查找树，即每个节点的左子树都小于它，右子树都大于它，中序遍历得到的序列为所有元素的升序排列。我们可以稍加修改，中序遍历从左-根-右修改成右-根-左，即把遍历的结果变为所有元素的降序排列。然后我们使用一个计数变量，当遍历k次时，输出结果即可。</p><ul><li>时间复杂度：$O(K)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">kthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>k<span class="token operator">=</span>k        self<span class="token punctuation">.</span>res<span class="token operator">=</span>None        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None <span class="token operator">and</span> self<span class="token punctuation">.</span>res<span class="token operator">==</span>None<span class="token punctuation">:</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>k<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>k<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>res<span class="token operator">=</span>root<span class="token punctuation">.</span>val                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="55-I-二叉树的深度"><a href="#55-I-二叉树的深度" class="headerlink" title="55.I. 二叉树的深度"></a>55.<a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">I. 二叉树的深度</a></h2><p>思路：二叉树操作中的基本题目，递归求解，如果当前节点为空，那么当前深度为0，否则当前深度为1加上左右子树的深度的最大值。层层返回深度，根节点的深度即为二叉树的深度。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(N)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="56-II-平衡二叉树"><a href="#56-II-平衡二叉树" class="headerlink" title="56.II. 平衡二叉树"></a>56.<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">II. 平衡二叉树</a></h2><p>思路：DFS，同时使用辅助函数计算当前深度，如果当前左右子树均平衡，且他们的深度之差小于等于1，则说明当前二叉树平衡。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> match<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> match<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">and</span> abs<span class="token punctuation">(</span>depth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token operator">-</span>depth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">1</span>        <span class="token keyword">def</span> <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>max<span class="token punctuation">(</span>depth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span>depth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> match<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化：上述算法求解子树深度时会出现很多重复的计算，可以进行优化。</p><ul><li>当前节点为空：当前树满足平衡二叉树的要求，且深度为0，返回0。</li><li>当前节点左子树或右子树不是平衡二叉树：返回-1。</li><li>否则：如果左子树和右子树深度差小于等于1，说明当前树是平衡二叉树，返回当前树的深度，否则，返回-1。</li></ul><p>减少了对树深度的重复求解，使子树可以返回深度信息，不用重新遍历整个树求深度了。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>            left <span class="token operator">=</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> left <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            right <span class="token operator">=</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> right <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">return</span> max<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> abs<span class="token punctuation">(</span>left <span class="token operator">-</span> right<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="57-I-数组中数字出现的次数"><a href="#57-I-数组中数字出现的次数" class="headerlink" title="57.I. 数组中数字出现的次数"></a>57.<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">I. 数组中数字出现的次数</a></h2><p>思路：如果想要获得线性的时间复杂度和常数级的空间复杂度，这一类题我们只能使用位运算。</p><p>python的位运算：</p><blockquote><p>&amp;：按位与操作，只有 1 &amp;1 为1，其他情况为0。可用于进位运算。</p><p>|：按位或操作，只有 0|0为0，其他情况为1。</p><p>~：逐位取反。</p><p>^：异或，相同为0，相异为1。可用于加操作（不包括进位项）。</p><p>&lt;&lt;：左移操作，2的幂相关</p><p>&gt;&gt;：右移操作，2的幂相关</p></blockquote><ul><li>假如本题简化为： 除了一个数字出现一次，其他都出现了两次，让我们找到出现一次的数。 </li><li>解决方案：使用按位异或运算，由于任何数异或自己本身得到的是0，任何数异或0得到的是自己本身，所以我们可以对数组中全部的数字执行全员异或。假设全部数字两两出现，那么每一个二进制位上的1和0出现的个数必然是偶数，异或的结果必然是0，最后再异或上出现一次的数字的该二进制位的值，会保留这个值。最终全员异或的结果必是出现了一次的数。</li><li>补充：异或满足交换律，17 xor 19 xor 17 相当于 17 xor 17 xor 19 = 0 xor 19 = 19 。</li><li>这里把其他出现了两次修改为任何的偶数次，都可以全员异或求解。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        single_number <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            single_number <span class="token operator">^</span><span class="token operator">=</span> num        <span class="token keyword">return</span> single_number<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>那么假如我们将偶数次再扩展为任意次，那么对于奇数次如何求解呢？即问题变为： 除了一个数字出现一次，其他都出现了三次，让我们找到出现一次的数。 </li><li>解决方案：依然可以使用位运算。统计二进制编码每一位上1出现的次数，假设所有数字都出现了3次，那么每一位上的1必然出现了3的倍数次（包括0）。考虑到出现了一次的数，如果某一位上1出现的次数不是3的倍数，那么出现了一次的数的二进制编码在这一位上必然是1。根据上述性质，便可求解出现了一次的数的二进制编码，转回十进制即可。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            cnt <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 记录当前 bit 有多少个1</span>            bit <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i  <span class="token comment" spellcheck="true"># 记录当前要操作的 bit</span>            <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>                <span class="token keyword">if</span> num <span class="token operator">&amp;</span> bit <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                    cnt <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> cnt <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 不等于0说明唯一出现的数字在这个 bit 上是1</span>                res <span class="token operator">|</span><span class="token operator">=</span> bit        <span class="token keyword">return</span> res <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token number">32</span> <span class="token keyword">if</span> res <span class="token operator">></span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token number">31</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">else</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>注：这里的返回值是因为python的机制问题，补码上表示符号的位会被解释为数值位。要手动将其变为正确的结果。</p></li><li><p>了解完上述两道题，我们大致知道了使用位运算求解数组中出现次数特殊的数字。回到本题，本题的思路看上去和上面举的第一个例子十分类似。我们已经知道了如何求解一个数组中一个数字出现一次，其他都出现了两次的解法。为了解决当前问题，我们可以把数组划分为两个数组，每个数组中一个数字出现一次，其他都出现了两次。</p></li><li><p>如何划分：同样将整个数组异或，异或之后，得到一个数字，这个数字从二进制数的角度看，一定有位数为1。这个1是怎么来的？就是那两个只出现一次的数字，异或得到的，他们对应的位不一样，肯定是一个数对应位数出现的是0，另一个数字对应位置上出现的数字是1.据此，将这个数组分成两个部分。一部分是，对应位置出现的数是0的数组，一部分是，对应位置出现的数是1的数组，此时，这两个数组满足我们第一个例题提到的要求，我们对其分别进行全局异或，即可得到两个数字。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        result1<span class="token punctuation">,</span>result2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        tmp<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            tmp<span class="token operator">^</span><span class="token operator">=</span>num        n<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>tmp<span class="token operator">&amp;</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            n<span class="token operator">=</span>n<span class="token operator">&lt;&lt;</span><span class="token number">1</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> num<span class="token operator">&amp;</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#注意：这里不能判断其是否等于1，否则会出错。要判断其是否与运算后还是n或0。</span>                result1<span class="token operator">^</span><span class="token operator">=</span>num            <span class="token keyword">else</span><span class="token punctuation">:</span>                result2<span class="token operator">^</span><span class="token operator">=</span>num        <span class="token keyword">return</span> <span class="token punctuation">[</span>result1<span class="token punctuation">,</span>result2<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="58-II-数组中数字出现的次数-II"><a href="#58-II-数组中数字出现的次数-II" class="headerlink" title="58.II. 数组中数字出现的次数 II"></a>58.<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">II. 数组中数字出现的次数 II</a></h2><p>思路：上一题思路中的第二个例子，给出了解法。基本思路就是使用移位+与运算，统计所有数字每一位上1出现的总次数，假如某一位上1出现的总次数不为3的倍数，说明多出来的数字在这一位上取1。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            count<span class="token operator">=</span><span class="token number">0</span>            n<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i            <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>                <span class="token keyword">if</span> num<span class="token operator">&amp;</span>n<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                    count<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> count<span class="token operator">%</span><span class="token number">3</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                result<span class="token operator">|</span><span class="token operator">=</span>n        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="59-和为s的两个数字"><a href="#59-和为s的两个数字" class="headerlink" title="59.和为s的两个数字"></a>59.<a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">和为s的两个数字</a></h2><p>思路：主站n数之和的简化版，使用双指针法从两侧逼近结果，同时逼近时可以注意跳过重复的数字，减少计算量。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token operator">==</span>left<span class="token punctuation">)</span><span class="token punctuation">:</span>                    left<span class="token operator">+=</span><span class="token number">1</span>                left<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token number">-1</span><span class="token operator">==</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>                    right<span class="token operator">-=</span><span class="token number">1</span>                right<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="60-II-和为s的连续正数序列"><a href="#60-II-和为s的连续正数序列" class="headerlink" title="60.II. 和为s的连续正数序列"></a>60.<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">II. 和为s的连续正数序列</a></h2><p>思路：这道题，我们一开始可能会想到数学解法或者暴力解法，事实上并不需要那么做。我们可以使用滑动窗口法来求解。</p><p>我们使用两个指针left和right维护一个在[1，n]的连续整数区间上滑动的窗口。特别地，我们发现，由于题目要求的正数序列连续且至少含两个数，那么滑动窗口中最大的数不能超过（n+1）//2，所以我们滑动的区间可以缩小为[1，（n+1）//2]。开始时，left=1，right=2，然后right顺序向左滑动，如果当前区间和等于s，则可以将当前区间加入到结果中，如果当前区间和大于s，那么我们要收缩左边界至区间和小于等于s，特别地，如果此时区间和等于s，我们也要把当前区间加入到结果中。如果当前区间和小于s，那么继续右边界向右滑动。当右边界到达终点时，结束滑动。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findContinuousSequence</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        left<span class="token operator">=</span><span class="token number">1</span>        sum<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> right <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">(</span>target<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            sum<span class="token operator">+=</span>right            <span class="token keyword">if</span> sum<span class="token operator">==</span>target<span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">elif</span> sum<span class="token operator">></span>target<span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>sum<span class="token operator">></span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>                    sum<span class="token operator">-=</span>left                    left<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> sum<span class="token operator">==</span>target<span class="token punctuation">:</span>                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="61-I-翻转单词顺序"><a href="#61-I-翻转单词顺序" class="headerlink" title="61. I. 翻转单词顺序"></a>61.<a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/" target="_blank" rel="noopener"> I. 翻转单词顺序</a></h2><p>思路：如果用python的字符串方法split（）+join（）来做的话很简单。自己实现的话主要就是先判断一下每个单词的边界：（1）每个单词的首字符不为空格，且要么是句子的第一个字符，要么前一个字符为空格（2）每个单词的尾字符不为空格，且要么是句子的最后一个字符，要么后一个字符为空格。每找到一对边界后，将字符串切片得到的单词加入单词列表，并调用join函数拼接他们。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseWords</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        start<span class="token operator">=</span><span class="token number">0</span>        end<span class="token operator">=</span><span class="token number">0</span>        words<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">' '</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> <span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    start<span class="token operator">=</span>i                <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">or</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    end<span class="token operator">=</span>i                    words<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">[</span>start<span class="token punctuation">:</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>words<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，还可以进行两次翻转。先将整个字符串进行翻转，再对每个单词进行翻转。</p><h2 id="62-II-左旋转字符串"><a href="#62-II-左旋转字符串" class="headerlink" title="62. II. 左旋转字符串"></a>62.<a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank" rel="noopener"> II. 左旋转字符串</a></h2><p>思路：python如果使用字符串的切片将非常简单，更复杂的解法有两种：</p><ul><li>三次翻转。先将s[:k]翻转，再将s[k:]翻转，最后将整个字符串翻转。</li><li>空间换时间。直接拼接两个s为ss，取ss[k:k+(len(s))]即可。</li><li>模运算。类似于动态规划中滚动数组和顺序表队列插入的思想。设i从k到k+len（s），i对len（s）求模。节约了空间。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseLeftWords</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        res<span class="token operator">=</span><span class="token string">""</span>        l<span class="token operator">=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">,</span>n<span class="token operator">+</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token operator">+=</span>s<span class="token punctuation">[</span>i<span class="token operator">%</span>l<span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="63-I-滑动窗口的最大值"><a href="#63-I-滑动窗口的最大值" class="headerlink" title="63. I. 滑动窗口的最大值"></a>63.<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener"> I. 滑动窗口的最大值</a></h2><p>思路：这题表面看可以移动窗口并遍历寻找最大值，但实际上时间复杂度太高，为$O(NK)$，不符合要求。为了将时间复杂度降到$O(N)$，我们需要使用一个辅助双向单调队列来做。双向队列中的元素满足：（1）在当前滑动窗口内（2）单调递减。（为什么使用双向队列：因为我们希望在两端都可以取出元素）。每次添加一个新的元素，调整队列的方法为：</p><ul><li>如果当前队尾元素小于新元素，那么新元素入队后，双向队列将不符合单调递减的性质，所以将队尾元素出队，移除队尾所有比当前元素小的元素。（即辅助队列为当前窗口可能的最大值的降序排列）</li><li>如果当前队首元素下标不在窗口内，将其出队。</li></ul><p>我们先用数组的前k个元素建立该队列，然后每次滑动窗口时添加一个元素并调整队列，当前队列的首元素即为当前窗口中的最大值。在这里，我们在队列中存放下标而非实际的值，这样方便我们判断元素是否在窗口内。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(K)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> nums<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">or</span> k<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">change_queue</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span>nums<span class="token punctuation">[</span>queue<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>i<span class="token operator">-</span>k<span class="token punctuation">:</span>                queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>            change_queue<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        result<span class="token operator">=</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            change_queue<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，我使用了python的列表来模拟一个双向队列，实际上python的collections库提供了许多封装的数据结构，双向队列为deque。</p><h2 id="64-II-队列的最大值"><a href="#64-II-队列的最大值" class="headerlink" title="64. II. 队列的最大值"></a>64. <a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">II. 队列的最大值</a></h2><p>思路：和63题思路基本一致，使用一个辅助双向单调递减队列存放可能的最大值，每次有新元素入队时，调整队列；每次有元素出队时，如果该元素是当前队列最大元素，那么辅助队列也要进行pop，调整为下一个最大的元素。其实这道题本质上和上一道题是一样的，上一题你可以看作是本题的一种特殊情况：先不断让元素入队，达到窗口大小K之后，每次让新元素入队，队首元素出队。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MaxQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>dequeue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">max_value</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>dequeue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">if</span> self<span class="token punctuation">.</span>dequeue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">push_back</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>dequeue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>dequeue<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>value<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#这里与63题不一样，是小于，因为无法用下标来判断是否出队，索性保留重复的。</span>            self<span class="token punctuation">.</span>dequeue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dequeue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop_front</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>queue<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        res<span class="token operator">=</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> res<span class="token operator">==</span>self<span class="token punctuation">.</span>dequeue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>dequeue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token comment" spellcheck="true"># Your MaxQueue object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MaxQueue()</span><span class="token comment" spellcheck="true"># param_1 = obj.max_value()</span><span class="token comment" spellcheck="true"># obj.push_back(value)</span><span class="token comment" spellcheck="true"># param_3 = obj.pop_front()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="65-n个骰子的点数"><a href="#65-n个骰子的点数" class="headerlink" title="65.n个骰子的点数"></a>65.<a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">n个骰子的点数</a></h2><p>我的最初思路：DFS寻找n个骰子的点数全排列，哈希表记录每种点数和对应的排列数目，最后计算每种点数和的概率即可。时间复杂度为$O(6^n)$。</p><p>编写后，发现时间复杂度太高。再次观察，发现DFS出现了重叠子问题，就像机器人走迷宫的那道题一样。</p><p>解决的方法是采用动态规划。状态矩阵DP[i] [j]为i个骰子掷出j的点数和时的点数排列组合的数目。</p><blockquote><p>转移方程（注意越界）：</p><p>for k in range(1,7):    </p><p>dp[i] [j]=dp[i-1] [j-k]</p></blockquote><ul><li>时间复杂度：$O(N^2)$。</li><li>空间复杂度：$O(N^2)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>float<span class="token punctuation">]</span><span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">6</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> j<span class="token operator">-</span>k<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>k<span class="token punctuation">]</span>        s<span class="token operator">=</span>sum<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> num<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token operator">/</span>s<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，像这种每一个状态的转移仅依赖于之前有限个状态的动态规划，还可以使用滚动数组的方法进行空间上的优化，不必保存完整的状态。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>float<span class="token punctuation">]</span><span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">*</span>i<span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token comment" spellcheck="true">#这里一定要清零！</span>                <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> j<span class="token operator">-</span>k<span class="token operator">>=</span>i<span class="token number">-1</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+=</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>k<span class="token punctuation">]</span>        s<span class="token operator">=</span>pow<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">,</span>n<span class="token operator">*</span><span class="token number">6</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>s<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="66-扑克牌中的顺子"><a href="#66-扑克牌中的顺子" class="headerlink" title="66.扑克牌中的顺子"></a>66.<a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">扑克牌中的顺子</a></h2><p>思路：有两种思路，分别是排序和不排序的思路。</p><ul><li>不排序：遍历扑克牌，如果出现了0，那么跳过；如果当前数字重复，那么返回False；如果当前数字不重复，更新最大值和最小值。最后，如果数组中的最大值减去最小值小于5，那么说明可以组成一个顺子。</li><li>时间复杂度：$O(N)$。遍历一次数组。</li><li>空间复杂度：$O(N)$。哈希表。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isStraight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        max_value<span class="token operator">=</span><span class="token number">0</span>        min_value<span class="token operator">=</span><span class="token number">14</span>        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dic<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>            max_value<span class="token operator">=</span>max<span class="token punctuation">(</span>max_value<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            min_value<span class="token operator">=</span>min<span class="token punctuation">(</span>min_value<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> max_value<span class="token operator">-</span>min_value<span class="token operator">&lt;</span><span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>排序：对扑克牌数组进行升序排序，同时统计0的个数。对于非0的相邻数字，先看它们是否重复，再看它们之间缺失的数是否可以被0代替。例如 [0,0,1,2,5]，2和5间缺失了2个数，此时数组中有两个0，可以填补。填补后记得更新0的数量。</li><li>时间复杂度：$O(NlogN)$。排序。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isStraight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        num_zero<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                num_zero<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>                num_zero<span class="token operator">-=</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span>                <span class="token keyword">if</span> num_zero<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="67-圆圈中最后剩下的数字"><a href="#67-圆圈中最后剩下的数字" class="headerlink" title="67.圆圈中最后剩下的数字"></a>67.<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">圆圈中最后剩下的数字</a></h2><p>思路：这道题我们首先想到的是模拟，但是模拟时间复杂度很高，会超时。我尝试了一些优化的方案，都不行。实际上，这道题是数学问题，经典的约瑟夫环问题。具体推导可见<a href="https://blog.csdn.net/u011500062/article/details/72855826" target="_blank" rel="noopener">https://blog.csdn.net/u011500062/article/details/72855826 </a></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lastRemaining</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">or</span> m <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None        last <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            last <span class="token operator">=</span> <span class="token punctuation">(</span>last <span class="token operator">+</span> m<span class="token punctuation">)</span><span class="token operator">%</span>i        <span class="token keyword">return</span> last<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="68-股票的最大利润"><a href="#68-股票的最大利润" class="headerlink" title="68.股票的最大利润"></a>68.<a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">股票的最大利润</a></h2><p> 思路：买卖股票问题，遍历每一天的股票价格。如果当前价格小于当前历史最低价格时，更新当前历史最低价格。如果当前价格大于当前历史最低价格时，计算当前收益，并更新当前最大收益。即贪心算法。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        min_prices<span class="token operator">=</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        max_profit<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> price <span class="token keyword">in</span> prices<span class="token punctuation">:</span>            min_prices<span class="token operator">=</span>min<span class="token punctuation">(</span>price<span class="token punctuation">,</span>min_prices<span class="token punctuation">)</span>            <span class="token keyword">if</span> price<span class="token operator">></span>min_prices<span class="token punctuation">:</span>                max_profit<span class="token operator">=</span>max<span class="token punctuation">(</span>price<span class="token operator">-</span>min_prices<span class="token punctuation">,</span>max_profit<span class="token punctuation">)</span>        <span class="token keyword">return</span> max_profit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，上述思路其实是动态规划算法的优化版本。我们可以维护一个动态规划状态矩阵DP[i]来记录第i天时，股票的最大利润。DP[i]=max（DP[i-1]，price-min_prices）,有点类似于01背包问题。由于我们仅需要前一天的最大收益，我们之前说过，动态规划的转移仅与之前有限个状态有关时，可以优化空间复杂度。所以我们用一个变量max_profit来存放当前最大收益。</p><h2 id="69-求1-2-…-n"><a href="#69-求1-2-…-n" class="headerlink" title="69.求1+2+…+n"></a>69.<a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">求1+2+…+n</a></h2><p>思路：利用python中的and机制。</p><ul><li>如果多个变量均非0（包括None、False等），那么返回最后一个变量的值。如3 and 2 and ‘a’的返回值为’a’； </li><li>如果多个变量中存在0值，则返回第一个0值。如1 and ‘a’ and 0 and None的返回值为0。 </li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sumNums</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> n <span class="token operator">and</span> n<span class="token operator">+</span>self<span class="token punctuation">.</span>sumNums<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="70-不用加减乘除做加法"><a href="#70-不用加减乘除做加法" class="headerlink" title="70.不用加减乘除做加法"></a>70.<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">不用加减乘除做加法</a></h2><p>思路：位运算</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">:</span> int<span class="token punctuation">,</span> b<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        a <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token number">0xFFFFFFFF</span>        b <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token number">0xFFFFFFFF</span>        <span class="token keyword">while</span> b<span class="token punctuation">:</span>            carry <span class="token operator">=</span> a <span class="token operator">&amp;</span> b            a <span class="token operator">^</span><span class="token operator">=</span> b            b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>carry<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFFFFFFFF</span>        <span class="token keyword">return</span> a <span class="token keyword">if</span> a <span class="token operator">&lt;</span> <span class="token number">0x80000000</span> <span class="token keyword">else</span> <span class="token operator">~</span><span class="token punctuation">(</span>a<span class="token operator">^</span><span class="token number">0xFFFFFFFF</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="71-构建乘积数组"><a href="#71-构建乘积数组" class="headerlink" title="71. 构建乘积数组"></a>71.<a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/" target="_blank" rel="noopener"> 构建乘积数组</a></h2><p>思路：对称运算，由于 <code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code>。且不能使用除法。 那么我们先可以正向累乘，计算nums1[i]=A[0]×A[1]×…×A[i-1]。计算完成后，再反向累乘计算nums2[i]=A[i+1]×…×A[n-1]。最后，将nums1[i]和nums2[i]按位相乘即可得到最终的结果。</p><p>为了减少时空复杂度，我们反向计算A[i+1]×…×A[n-1]时，不需要再开一个数组nums2[i]，直接设置一个临时变量存放A[i+1]×…×A[n-1]，并让他与当前nums1[i]相乘即可得到最终的结果。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(N)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">constructArr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> a<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        tmp<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>res<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>a<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp<span class="token operator">*=</span>a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*=</span>tmp        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="72-把字符串转换成整数"><a href="#72-把字符串转换成整数" class="headerlink" title="72.把字符串转换成整数"></a>72.<a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/" target="_blank" rel="noopener">把字符串转换成整数</a></h2><p>思路：这种规则匹配题，没有捷径，需要细心地把每种情况都列出来加以判断。这里我贴出我一年多以前用JAVA写的代码，写的很臃肿。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    public int myAtoi<span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String newS<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">;</span>        int flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        char c<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span>str<span class="token punctuation">.</span>toCharArray<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>c<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">' '</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'+'</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token operator">|</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        newS<span class="token operator">=</span>newS<span class="token punctuation">.</span>concat<span class="token punctuation">(</span>String<span class="token punctuation">.</span>valueOf<span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">48</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">57</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        newS<span class="token operator">=</span>newS<span class="token punctuation">.</span>concat<span class="token punctuation">(</span>String<span class="token punctuation">.</span>valueOf<span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        flag<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">48</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">57</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    newS<span class="token operator">=</span>newS<span class="token punctuation">.</span>concat<span class="token punctuation">(</span>String<span class="token punctuation">.</span>valueOf<span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    flag<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">57</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    newS<span class="token operator">=</span>newS<span class="token punctuation">.</span>concat<span class="token punctuation">(</span>String<span class="token punctuation">.</span>valueOf<span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newS<span class="token punctuation">.</span>equals<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token operator">|</span><span class="token punctuation">(</span>newS<span class="token punctuation">.</span>equals<span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token operator">|</span><span class="token punctuation">(</span>newS<span class="token punctuation">.</span>equals<span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            long result<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>newS<span class="token punctuation">.</span>length<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>newS<span class="token punctuation">.</span>charAt<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result<span class="token operator">=</span><span class="token operator">-</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>Math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                    result<span class="token operator">=</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>Math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                result<span class="token operator">=</span>Long<span class="token punctuation">.</span>parseLong<span class="token punctuation">(</span>newS<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token operator">&lt;</span><span class="token operator">-</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>Math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result<span class="token operator">=</span><span class="token operator">-</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>Math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token operator">>=</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>Math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result<span class="token operator">=</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>Math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>int<span class="token punctuation">)</span>result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正则表达式解法：</p><blockquote><ul><li><code>^</code>：匹配字符串开头</li><li><code>[\+\-]</code>：代表一个+字符或-字符</li><li><code>?</code>：前面一个字符可有可无</li><li><code>\d</code>：一个数字</li><li><code>+</code>：前面一个字符的一个或多个</li></ul></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">strToInt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> str<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        INT_MAX <span class="token operator">=</span> <span class="token number">2147483647</span>        INT_MIN <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2147483648</span>        s<span class="token operator">=</span> str<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#清除两端空格</span>        res <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>r<span class="token string">'^[\+\-]?\d+'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#正则表达式：匹配位于字符串开头且接下来是一个正号或负号或没有且接下来是1到多个数字</span>        num <span class="token operator">=</span> res<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        nums <span class="token operator">=</span> int<span class="token punctuation">(</span><span class="token operator">*</span>num<span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>min<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">,</span> INT_MIN<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="74-I-二叉搜索树的最近公共祖先"><a href="#74-I-二叉搜索树的最近公共祖先" class="headerlink" title="74.I. 二叉搜索树的最近公共祖先"></a>74.<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">I. 二叉搜索树的最近公共祖先</a></h2><p>思路：递归求解，根据二叉搜索树的性质（每个节点的左子树都小于它，右子树都大于它），当当前节点不为None时：</p><ul><li>如果p、q节点的值均比当前节点的值小，那么它们的祖先必然在当前节点的左子树中。</li><li>如果p、q节点的值均比当前节点的值大，那么它们的祖先必然在当前节点的右子树中。</li><li>否则，它们的祖先必是当前节点。（这里有两种情况，一是当前节点的值位于p、q节点的值中间，说明它们两个节点必然分布在当前节点的左右子树中，当前节点必然是他们的最近祖先。二是当前节点的值等于p或者q节点的值，由于一个节点也可以是它自身的祖先，所以当前节点必然是他们的最近祖先。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">DFS</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> None            <span class="token keyword">if</span> p<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val <span class="token operator">and</span> q<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> DFS<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">elif</span> p<span class="token punctuation">.</span>val<span class="token operator">></span>root<span class="token punctuation">.</span>val <span class="token operator">and</span> q<span class="token punctuation">.</span>val<span class="token operator">></span>root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> DFS<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> root        <span class="token keyword">return</span> DFS<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非递归写法：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val <span class="token operator">and</span> q<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                root<span class="token operator">=</span>root<span class="token punctuation">.</span>left            <span class="token keyword">elif</span> p<span class="token punctuation">.</span>val<span class="token operator">></span>root<span class="token punctuation">.</span>val <span class="token operator">and</span> q<span class="token punctuation">.</span>val<span class="token operator">></span>root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                root<span class="token operator">=</span>root<span class="token punctuation">.</span>right            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> root        <span class="token keyword">return</span> None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="75-II-二叉树的最近公共祖先"><a href="#75-II-二叉树的最近公共祖先" class="headerlink" title="75.II. 二叉树的最近公共祖先"></a>75.<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">II. 二叉树的最近公共祖先</a></h2><p>思路：上一道题的复杂版，我们无法直接通过节点值的大小比较来确定公共祖先的位置，只能通过递归搜索的方法求解。</p><p>这里我们使用后序遍历。</p><ul><li>如果当前节点为空，返回None。</li><li>如果当前节点等于p或者q，返回当前节点。 （一个节点的祖先可以是自身）</li><li>递归遍历左、右子树。</li><li>如果左子树返回的节点为空，说明p、q均不在左子树中，返回右子树找到的节点。</li><li>如果右子树返回的节点为空，说明p、q均不在右子树中，返回左子树找到的节点。</li><li>如果左右子树返回的节点都不为空，说明p、q分布在左右子树中，则当前节点必然是最近的公共祖先。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> q<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None <span class="token operator">or</span> root<span class="token operator">==</span>p <span class="token operator">or</span> root<span class="token operator">==</span>q<span class="token punctuation">:</span>                <span class="token keyword">return</span> root            leftNode<span class="token operator">=</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            rightNode<span class="token operator">=</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> leftNode<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> rightNode            <span class="token keyword">if</span> rightNode<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> leftNode            <span class="token keyword">return</span> root        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：线性模型和对数线性模型</title>
      <link href="/2020/03/17/nlp-zi-xue-bi-ji-xian-xing-mo-xing-he-dui-shu-xian-xing-mo-xing/"/>
      <url>/2020/03/17/nlp-zi-xue-bi-ji-xian-xing-mo-xing-he-dui-shu-xian-xing-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是我在学习苏州大学李正华老师的中文信息处理课程（<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">中文信息处理（Chinese Information Processing）Course Resources</a>）时，对于线性模型和对数线性模型的一些个人见解和思考，同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己对于该模型的理解，如有错误欢迎在评论区指出，非常感谢！</p><h2 id="从问题出发"><a href="#从问题出发" class="headerlink" title="从问题出发"></a>从问题出发</h2><p>与隐马尔可夫模型的讲解类似，我们在这里依旧围绕自然语言处理中的经典问题<strong>词性标注问题</strong>进行讨论和解释。</p><ul><li>给定一个句子X，输出句子中每一个单词对应的词性。</li></ul><p><img src="1.png" alt="词性标注任务"></p><p>与隐马尔可夫模型不同的是，线性模型与对数线性模型将词性标注转化为了一个<strong>多元分类</strong>问题，它们将不再以整个句子序列作为模型的输入，整个句子的词性序列作为模型的输出，而是假设<strong>词语之间的预测相互独立</strong>，将问题转化为<strong>从所有可能的词性类别中选取某个词语最有可能的类别进行输出</strong>。</p><h2 id="什么是线性模型"><a href="#什么是线性模型" class="headerlink" title="什么是线性模型"></a>什么是线性模型</h2><p>线性模型（Linear Model)，又称为<strong>线性回归模型</strong>，是一种<strong>有监督学习模型</strong>。我们曾经在高中的时候学习过一种回归方法——线性回归。将这个方法泛化，就可以得到我们的线性模型。</p><p>我们以吴恩达老师在coursera上的机器学习课程中的房价预测例子进行说明。</p><p><img src="2.png" alt="房价预测"></p><p>如上图所示，假设我们得到了一个当地的房价数据集，其中包括了房子的面积、卧室数、层数、房龄等信息，同时给出了对应的房价。我们需要解决的问题就是如何<strong>利用房子的信息预测出它的价格</strong>。在机器学习中，我们把类似于面积、卧室数等这些样本的信息叫做<strong>样本的特征（Feature）</strong>，它们是我们进行预测的依据。我们把需要预测的值叫做<strong>样本的标签（Label)</strong>。训练集中的每一个样本是一个<strong>（特征，标签)二元组</strong>。</p><p>在机器学习中，样本的特征往往是人工选择的，例如上述的面积、卧室数、层数等房屋信息。如何选择合适的特征是一门高深的学问，我们称其为<strong>特征工程</strong>。特征往往不止一个，所以使用<strong>向量</strong>的形式对其进行表示。在这里，我使用列向量$\vec x=(x_1,x_2…x_n)$来表示特征向量，由于书写列向量不是很方便，所以只能这么书写，但你需要记住$\vec x$是一个列向量。</p><p>当给定某个房子的面积、卧室数、层数、房龄等特征，在线性模型中，我们会使用一个线性方程来计算房子的价格。我们使用$h$表示这个线性方程，$h$代表<strong>hypothesis</strong>(<strong>假设</strong>) ，具体公式如下：<br>$$<br>h_{w}(x)=w_0+w_1x_1+w_2x_2+…+w_nx_n<br>$$<br>我们为每个特征给定一个特征权重$w$，这个权重可以是正数也可以是负数。其中，$w_0$为<strong>偏置项</strong>（bias），专门用来表示方程中的常数项。通过训练样本学习权重$w$，我们便可使用上述方程进行预测。</p><p>为了使公式简洁一些，引入$x_0=1$，使用列向量$\vec w=(w_0,w_1…w_n)$来表示权重向量，则公式转化为：<br>$$<br>h_{w}(x)=w_0x_0+w_1x_1+w_2x_2+…+w_nx_n\<br>=w^Tx<br>$$</p><h2 id="线性模型的泛化"><a href="#线性模型的泛化" class="headerlink" title="线性模型的泛化"></a>线性模型的泛化</h2><p>看到上述的线性方程，你可能会疑惑：上述方程得到的仅仅是一条直线方程，而需要拟合的数据点往往不能通过简单的直线来拟合。换句话说， 如果仅仅使用在此之前的单元和多元线性回归，<strong>我们只能得到多维空间的高维平面</strong>。为了进一步增强泛化能力，我们可以引入<strong>幂次项特征和多项式特征</strong>。 </p><p>例如，我们的模型原先只是一个线性方程：<br>$$<br>h_{w}(x)=w_1x_1+w_2x_2<br>$$<br>为了增强拟合能力，我们可以令$x_3=x_1^2$，$x_4=x_2^2$，$x_5=x_1x_2$。于是，我们的模型将变为：<br>$$<br>h_{w}(x)=w_1x_1+w_2x_2+w_3x_3+w_4x_4+w_5x_5\<br>=w_1x_1+w_2x_2+w_3x_1^2+w_4x_2^2+w_5x_1x_2<br>$$<br>可以看到，此时我们的模型将可以拟合复杂的非线性函数。<strong>也就是说，很多复杂的模型都可以转化为线性模型进行建模。</strong></p><p>但需要注意的是：<strong>过多地使用幂次项特征和多项式特征会使模型的拟合能力太强，从而导致过拟合的问题</strong>。我将专门 写一篇blog来讲解机器学习中的过拟合问题，并介绍一些解决过拟合的办法，如正则化和dropout等。</p><h2 id="线性模型的特征提取"><a href="#线性模型的特征提取" class="headerlink" title="线性模型的特征提取"></a>线性模型的特征提取</h2><h3 id="连续型特征"><a href="#连续型特征" class="headerlink" title="连续型特征"></a>连续型特征</h3><p>特征分为连续型特征和离散型特征。<strong>连续型特征顾名思义就是取值是连续的特征，例如上述例子中的房子面积。</strong>在实际的机器学习过程中， 很少直接将连续值作为线性回归模型和逻辑回归模型的特征输入，而是将连续特征离散化为一系列0、1特征交给模型，这样做的优势有以下几点： </p><ol><li>离散特征的增加和减少都很容易，易于模型的<strong>快速迭代</strong>。</li><li>稀疏向量内积乘法运算<strong>速度快</strong>，计算结果<strong>方便存储，容易扩展</strong>。</li><li>离散化后的特征对异常数据有很强的<strong>鲁棒性</strong>：比如一个特征是年龄&gt;30是1，否则0。如果特征没有离散化，一个异常数据“年龄300岁”会给模型造成很大的干扰。</li><li>线性回归模型和逻辑回归模型属于广义线性模型，表达能力受限；单变量离散化为N个后，每个变量有单独的权重，相当于为模型引入了非线性，<strong>能够提升模型表达能力，加大拟合</strong>。</li><li>离散化后可以<strong>进行特征交叉</strong>，由M+N个变量变为M*N个变量，进一步引入非线性，提升表达能力。</li><li>特征离散化后，模型会更<strong>稳定</strong>，比如如果对用户年龄离散化，20-30作为一个区间，不会因为一个用户年龄长了一岁就变成一个完全不同的人。当然处于区间相邻处的样本会刚好相反，所以怎么划分区间是门学问。</li><li>特征离散化以后，起到了简化模型的作用，降低了模型<strong>过拟合</strong>的风险。</li></ol><h3 id="离散性特征"><a href="#离散性特征" class="headerlink" title="离散性特征"></a>离散性特征</h3><p><strong>离散型特征顾名思义就是取值是离散的特征，例如上述例子中的房龄、卧室数和层数。</strong>对于离散型特征，我们使用一种叫做<strong>one-hot</strong>的方法进行编码。</p><p>one-hot的基本思想：<strong>将离散型特征的每一种取值都看成一种状态</strong>，若你的这一特征中有N个不相同的取值，那么我们就可以将该特征抽象成N种不同的状态，one-hot编码保证了每一个取值只会使得一种状态处于“激活态”，也就是说这N种状态中只有一个状态位值为1，其他状态位都是0。举个例子，假设我们以学历为例，我们想要研究的类别为小学、中学、大学、硕士、博士五种类别，我们使用one-hot对其编码就会得到：</p><blockquote><p>小学-&gt;[1,0,0,0,0]</p><p>中学-&gt;[0,1,0,0,0]</p><p>大学-&gt;[0,0,1,0,0]</p><p>硕士-&gt;[0,0,0,1,0]</p><p>博士-&gt;[0,0,0,0,1]</p></blockquote><p><strong>特别地，如果该离散型特征只有True或False两种取值，那么我们通常用1表示True，0表示False</strong>。</p><h2 id="线性模型的训练过程"><a href="#线性模型的训练过程" class="headerlink" title="线性模型的训练过程"></a>线性模型的训练过程</h2><h3 id="定义优化目标"><a href="#定义优化目标" class="headerlink" title="定义优化目标"></a>定义优化目标</h3><p>当我们写出了假设函数$h$后，接下来我们要做的就是通过已有的训练集得到合适的模型权重$\vec w=(w_0,w_1…w_n)$。</p><p>为了进行权重的训练，首先，我们要定义三个函数：</p><ol><li><strong>损失函数（Loss Function ）</strong>：<strong>单个样本</strong>的预测值和真实值（标签）的误差。</li><li><strong>代价函数（Cost Function ）</strong>：<strong>整个训练集所有样本</strong>的预测值和真实值（标签）的误差，也就是损失函数的平均。</li><li><strong>目标函数（Object Function）</strong>：<strong>最终需要优化的函数</strong>。等于经验风险+结构风险（也就是代价函数 + 正则化项）。</li></ol><p><strong>这里，我们先不讲解正则化的知识，假设我们的目标函数即为代价函数</strong>。那么线性模型的优化问题即为最小化所有样本的误差的平均值。线性模型的误差可以用许多函数来表示，其中比较常用的一种是<strong>均方误差</strong>(Mean squared error) ，这里我们使用均方误差来描述我们的模型误差（PS：更多损失函数可以参考<a href="https://www.jiqizhixin.com/articles/091202" target="_blank" rel="noopener">机器学习中常用的损失函数你知多少？</a>）</p><p>假设训练集中样本的标签为$y$，样本的数量为$m$，预测值为假设函数的输出$h_{w}(x)$，则需要优化的目标函数为：<br>$$<br>J(w)=\frac{1}{2m}\sum_{i=1}^{m}(h_w(x^{(i)})-y^{(i)})^2<br>$$<br>我们的目标便是<strong>选择出可以使得建模误差的平方和能够最小的模型参数</strong>，即<strong>找到合适的模型权重$\vec w$，使$J(w)$取得最小值</strong>。需要注意的是，目标函数中的1/2仅仅是为了方便求导。</p><h3 id="从极大似然估计到损失函数"><a href="#从极大似然估计到损失函数" class="headerlink" title="从极大似然估计到损失函数"></a>从极大似然估计到损失函数</h3><p>在隐马尔可夫模型的讲解中，我曾经说过损失函数和极大似然估计有着紧密的联系，例如<strong>我们在逻辑回归模型里使用的交叉熵损失函数其实就是似然函数加上负号</strong>。也就是说，<strong>最优化问题既可以理解为最大化模型的似然估计，也可以理解为最小化模型的损失函数</strong>。</p><p>为什么会出现这样的现象呢？其实这并不是巧合，是可以通过数学公式进行推导的。具体推导内容可以参考这篇讲义<a href="https://wenku.baidu.com/view/78d16462c9d376eeaeaad1f34693daef5ff713d2.html" target="_blank" rel="noopener">各损失函数与最大似然</a>。</p><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><h4 id="正规方程法"><a href="#正规方程法" class="headerlink" title="正规方程法"></a>正规方程法</h4><p>正规方程法可以用于求解线性模型的目标函数取得最小值时，权重$w$的准确值。但在机器学习中，我们很少使用这种方法求解模型的权重，我在这里简单提一下它的弊端：</p><ol><li>对于一个由$n$个训练样本的特征向量$x$组成的训练集矩阵$X$，计算极值点的时间复杂度为$O(n^3)$，<strong>当训练集规模很大时，正规方程法将变得十分缓慢。</strong></li><li>正规方程法需要使用训练集矩阵$X$的逆矩阵$X^{(-1)}$，但是<strong>我们无法保证$X$一定可逆。</strong></li><li><strong>只适用于线性模型</strong>，不适合逻辑回归模型等其他模型 。</li></ol><h4 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h4><p>我们已经说过，当训练集规模很大时，例如有上百万、上千万的数据时，正规方程法将会非常缓慢，那么有没有办法能够降低时间复杂度呢？答案是有的，我们在这里可以使用<strong>梯度下降法</strong>进行求解。</p><p>为了将问题简化，我们假设模型现在只存在两个特征，对应的权重为$\theta_0$和$\theta_1$。 我们绘制一个等高线图，三个坐标分别为$\theta_0$和$\theta_1$和$J(\theta_0,\theta_1)$： </p><p><img src="3.png" alt="等高线图"></p><p>则可以看出在三维空间中存在一个使得$J(\theta_0,\theta_1)$最小的点，我们可以发现均方差损失函数的图像很明显是一个<strong>凸函数</strong>，即不存在局部最优解的问题。 </p><p>梯度下降法的相当于<strong>我们下山的过程</strong>，每次我们要走一步下山，寻找最低的地方，那么最可靠的方法便是环顾四周，寻找下山速度最快的方向前进，持续该过程，最后便能无限接近最低点。</p><p>对于函数而言，<strong>便是求得该函数对所有参数的偏导（梯度），每次根据梯度更新这些参数，直到参数收敛为止，注意这些参数必须同步进行更新</strong>。 从数学上的角度来看，梯度的方向是函数增长速度最快的方向，那么梯度的反方向就是函数减少最快的方向。那么，如果想计算一个函数的最小值，就可以使用梯度下降法的思想来做。 </p><p>假设模型共有$n$个特征，加上偏置项的特征$x_0=1$，共有$n+1$个特征。则对于某个权重参数$w_j$进行梯度下降的公式可以表示为：<br>$$<br>w_j=w_j-\alpha\frac{dJ(w)}{dw_j}=w_j-\alpha\frac{1}{m}\sum^{m}_{i=1}(h_w(x^{(i)})-y^{(i)})x_j^{(i)}<br>$$<br>其中，<strong>$\alpha$是一个由我们自己设置的超参数（hyper parameter）——学习率</strong> （<strong>learning rate</strong>），它决定了我们沿着能让目标函数下降程度最大的方向向下迈出的步子有多大。 </p><p>梯度下降的过程形象表示便是如下图所示，一步一步下降达到最低点。</p><p> <img src="3.jpg" alt="梯度下降的直观表示"></p><p>需要说明以下几点：</p><ul><li><p>$\alpha$为学习率，学习率决定了学习的速度，<strong>我们需要选择合适的学习率</strong>。</p><ul><li><p>如果$\alpha$过小，那么学习的时间就会很长，导致算法的低效。</p></li><li><p>如果$\alpha$过大，那么由于每一步更新过大，可能无法收敛到最低点。由于越偏离最低点函数的导数越大，如果$\alpha$过大，某一次更新直接跨越了最低点，来到了比更新之前<strong>更高</strong>的地方。那么下一步更新步会更大，如此反复震荡，离最低点越来越远。</p></li><li><p>以上两种情况如下图所示 ：</p><p><img src="2.jpg" alt></p></li></ul></li><li><p><strong>我们的算法不一定能达到最优解</strong>。 但是由于线性回归模型中的函数都是<strong>凸函数</strong>,所以利用梯度下降法，是可以找到全局最优解的，在这里不详细阐述。 </p></li><li><p>我们这里得到的是<strong>数值解</strong>而非解析解，存在着一定误差。</p></li></ul><p>顺便说一下，我这里举例的是<strong>批量梯度下降（batch gradient descent,BGD）</strong>，即尝试将<strong>所有样本</strong>的误差优化到最小。这种方法的优点是每次下降都是朝着全局最优的方向前进。但是，我们发现它每次都要计算所有样本的损失，这在大批量数据的情况下会非常缓慢。</p><p>还有一种梯度下降的方法叫做<strong>随机梯度下降法（ Stochastic gradient descent）</strong>，它每次选取<strong>一个随机样本</strong>，尝试优化它的损失函数。虽然随机梯度下降法每次下降是朝着局部最优的方向前进，无法保证全局的优化，但整体而言，它的下降方向还是朝着全局最优点前进的。与此同时，它的计算量相较于批量梯度下降大大减少了。</p><p>此外，还有一种方法叫做<strong>小批量梯度下降法（mini-batch gradient descent）</strong>，这是现在最为常用的一种梯度下降学习法，它是BGD和SGD的折中。它每次尝试优化一个mini-batch-size数量的样本，即减少了运算量，又降低了梯度下降方向出错的可能性。</p><h3 id="过拟合与正则化"><a href="#过拟合与正则化" class="headerlink" title="过拟合与正则化"></a>过拟合与正则化</h3><p>在前面我们提到了可以通过引入<strong>幂次项特征和多项式特征</strong>来增加模型的拟合能力。但是，模型的拟合能力过强有时候并不是一件好事。下面，我将介绍线性回归模型中的<strong>过拟合 (over-fitting) 问题</strong>。</p><p>首先，我们给出过拟合的定义：</p><blockquote><p>在统计学中，过拟合（英语：overfitting，或称过度拟合）现象是指在拟合一个统计模型时，使用过多参数。对比于可获取的数据总量来说，一个荒谬的模型只要足够复杂，是可以完美地适应数据。过拟合一般可以视为违反奥卡姆剃刀原则。当可选择的参数的自由度超过数据所包含信息内容时，这会导致最后（拟合后）模型使用任意的参数，这会减少或破坏模型一般化的能力更甚于适应数据。过拟合的可能性不只取决于参数个数和数据，也跟模型架构与数据的一致性有关。此外对比于数据中预期的噪声或错误数量，跟模型错误的数量也有关。 </p></blockquote><p>通俗的说，过拟合问题的本质是<strong>我们模型的学习能力太强，导致过于强调拟合训练集的样本，从而丢失了泛化的能力</strong>。当模型出现了过拟合的问题，它虽然能非常好地适应我们的训练集，但在新输入变量进行预测时可能会效果不好 。</p><p>我们借用吴恩达老师coursera课程中的PPT来描述过拟合、欠拟合、好的拟合三种情况。</p><p><img src="4.png" alt="拟合的情况"></p><p>在这里，我尝试用一个易于理解的例子来解释上述三种情况：</p><blockquote><p>我们可以把学生做练习题的过程看成是模型的训练过程，学生在做了很多练习题后，可以参加考试了，我们可以把考试看作为模型的预测过程。欠拟合很简单，就是平时不认真学习，做练习题和参加考试的分数自然都很低，也就是训练集和测试集的准确率都很低。那么过拟合是什么呢？过拟合就是平时只知道死记硬背，仅仅记住了练习题，却不知道举一反三，虽然平时作业分数很高，但是考试成绩却并不好，也就是训练集准确率很高，但测试集准确率很低。最佳的情况就是既认真做练习，又不局限于练习题，这种就是我们虽说的拟合较好的情况。</p></blockquote><p>为了解决过拟合的问题，我们应该引入一个<strong>参数项</strong>，<strong>在进行梯度下降的时候尽可能使得参数变小</strong>，这样可以使得很多额外的特征的权重接近于0。 这个方法也叫做<strong>正则化</strong>（regularization）。此外，还有一些防止过拟合的办法，例如神经网络中的dropout等，我会在接下来的博客中继续为大家介绍。</p><p>正则化中的参数项一般也叫做正则项，常用的正则项有以下两种：</p><ul><li>L1正则项：各个权重的<strong>绝对值之和</strong>，可以产生稀疏权值矩阵，即产生一个稀疏模型，可以用于<strong>特征选择</strong> 。同时，一定程度上 也可以防止过拟合 。</li><li>L2正则项：各个权重的<strong>平方和</strong>，可以防止模型过拟合（overfitting）。</li></ul><p>线性模型和对数线性模型中，我们通常采用的是L2正则项。加入正则项后，模型的代价函数变为：<br>$$<br>J(w)=\frac{1}{2m}[\sum_{i=1}^{m}(h_w(x^{(i)})-y^{(i)})^2+\lambda\sum_{j=1}^{n}w^2]<br>$$<br>梯度下降的公式变为：<br>$$<br>w_j=w_j-\alpha\frac{dJ(w)}{dw_j}=w_j-\alpha\frac{1}{m}\sum^{m}_{i=1}[(h_w(x^{(i)})-y^{(i)})x_j^{(i)}+\lambda w_j]<br>$$<br>我们可以发现，通过引入正则化项，可以使模型的所有参数在梯度下降时多下降一些，从而尽可能地减小。上式中，$\lambda$是一个用于控制正则化程度的超参数，我们一般称其为<strong>正则化系数</strong>，如果$\lambda$过大，则所有权重将趋近于0， 这样我们所得到的只能是一条平行于x轴的直线 。 所以对于正则化，我们要取一个合理的$\lambda$的值 。超参数的选择是机器学习中最为常见的问题，我们一般使用<strong>开发集</strong>进行调参。</p><p>顺便提一下，过拟合的情况下，增加训练集的样本数量将会使模型的性能得到提升。在当今这个海量数据的时代，数据是容易获得的，所以深度学习的常见做法是训练出一个拟合能力很强（层数深、神经元多）的神经网络，加上大规模的训练样本，再加上一些正则化的方法，所得出的模型通常性能最好。</p><h2 id="回到词性标注问题上来"><a href="#回到词性标注问题上来" class="headerlink" title="回到词性标注问题上来"></a>回到词性标注问题上来</h2><p>相信通过前面的介绍，你已经对线性模型有了基本的认识，下面我们回到词性标注任务上，简单地介绍一下如何基于多元分类的思想使用线性回归模型进行词性标注。</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>在我们之前的介绍中，你可能会发现，线性模型主要是用于解决机器学习中的<strong>回归（regression）问题</strong>。也就是说，它预测的最终结果通常是连续值。虽然与对数线性模型相比，线性模型不常用于<strong>分类（classification）</strong>，但在介绍对数线性模型之前，我们仍可以通过一些方法使其运用在分类标注词性上。</p><p>最基本的思想就是，<strong>我们通过选取词语的一些特征，训练出一个线性模型，模型的输出为该词语标注为各词性的分值（score），然后我们选取分值最大的词性作为预测的结果。</strong>通过这一转化，我们将线性回归模型运用在了分类问题上。</p><h3 id="特征获取"><a href="#特征获取" class="headerlink" title="特征获取"></a>特征获取</h3><p>与之前预测房价的例子不同，词性标注模型的特征不是事先定义好的，而是通过<strong>特征模板（feature template）</strong>在训练集中抽取而来的。特征模板需要专家进行手工的定义。目前，学术界常用的用于词性标注的特征模板如下表所示。</p><p><img src="5.png" alt="特征模板"></p><p>可以看到，我们一共使用了14种特征模板，其中包含了许多有用的信息，例如词信息，字信息，词缀信息等等。</p><p>在实际训练过程中，我们需要先构建<strong>特征空间（feature space）</strong>。它是训练集中所有特征的集合。<strong>构建的方式是：我们每次选取一个词，根据特征模板抽取相应的14种特征，并将其加入到特征空间内。需要注意的是特征空间中不能出现重复的特征。</strong></p><p>在这里，我们还可以对特征抽取进行优化。我们观察特征模板可以发现，<strong>对于每个样本，每一种特征的模板都需要抽取每一种词性的特征，而对于所有不同的词性，其特征模板的后缀都是相同的</strong>。通过计算机中经常使用的<strong>段加偏移</strong>的思想，我们可以大大减少构建特征空间所耗费的时间，将时间复杂度由$O(MN)$降为$O(M+N)$。具体的优化操作不再赘述，大家可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/9-linear-model/main2.pdf" target="_blank" rel="noopener">李老师的讲义</a>。</p><p>我在这里画出了这个线性模型的示意图，你应该就能理解为什么它的特征空间可以用二维矩阵的方式来存储，以及它是如何工作的。</p><p><img src="6.png" alt="词性标注的线性模型"></p><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>对于模型的训练，我们将采用一种叫做<strong>在线学习（Online training）</strong>的方式。这是一种经常用于<strong>推荐系统</strong>的学习算法，方便对模型进行实时训练。你可以把它看作是一种近似于我们之前所提到的随机梯度下降法的学习算法。它每次选取<strong>一个实例</strong>进行训练。由于样本的标签是经过one-hot处理的离散值，而我们模型的输出是取值范围在负无穷到正无穷 ，所以我们在这里无法使用前述的梯度下降算法进行参数的训练。取而代之的是如下的算法。</p><p><img src="7.png" alt="Online Training"></p><p>简单的讲解一下，可以看到，我们每次选取一个样本进行训练，如果该样本预测正确，那么不修改模型的参数，否则，将该样本与正确词性关联的特征权重全部加1，与错误词性关联的特征权重全部减1。你可以看作是<strong>给预测正确词性的特征一个激励，而给预测错误词性的特征一个惩罚</strong>。</p><p>特别地，我们在这里还可以使用上图中$v$作为模型特征权重，这叫做<strong>averaged perceptron</strong>，我经过实验发现使用$v$确实比$w$更好。有关学习算法的优化问题我将专门撰写一篇博客，介绍常见的优化算法，如momentum算法，RMsprop算法和Adam算法的数学原理等。</p><h2 id="什么是对数线性模型"><a href="#什么是对数线性模型" class="headerlink" title="什么是对数线性模型"></a>什么是对数线性模型</h2><p>回顾一下我们之前介绍的线性模型，它可以将词性标注转化为一个多分类问题，通过给当前词标注为每种词性的情况进行打分，并选择分值最高的词性作为当前词的标注结果，从而进行词性预测。但这样做其实存在着一些弊端：</p><ol><li><strong>一些极端值可能会大大影响分类的效果。</strong></li><li>对于分类问题，$y$取值为 0 或者1，但如果你使用的是线性模型，那么假设函数的输出值可能远大于 1，或者远小于0，即使所有训练样本的标签都等于 0 或 1。尽管我们知道标签应该取值0 或者1，但是如果算法得到的值远大于1或者远小于0的话，就会感觉很奇怪。<strong>同时，我们也就无法使用损失函数进行梯度下降优化。</strong></li></ol><p>为了解决上述问题，我们可以使用<strong>对数线性模型（log-linear model）</strong>，或许它的另一个名称更为常用，也可以叫做<strong>逻辑回归模型（logistic regression model）</strong>，不过似乎人们在使用逻辑回归模型时，默认解决的是二分类问题，这里我们称之为<strong>多分类的逻辑回归模型</strong>似乎更合适。</p><p>对数线性模型主要做的就是<strong>将线性模型输出的分值使用非线性函数映射到[0，1]区间上，即将分值转化为概率</strong>，这种形式大大减少了极端值的影响，同时概率应用在分类问题上也更易于理解，我们也可以通过样本的真实标签和预测概率定义目标函数，从而使用梯度下降法进行模型训练。</p><h2 id="从线性模型到对数线性模型"><a href="#从线性模型到对数线性模型" class="headerlink" title="从线性模型到对数线性模型"></a>从线性模型到对数线性模型</h2><p>为了将分值转化为概率，我们需要使用一些非线性函数进行映射。<strong>比较常用的两种函数分别为：Sigmoid函数和Softmax函数，前者用于二分类的对数线性模型中，而后者用于多分类的对数线性模型中。</strong>顺便提一下，在深度学习中，Sigmoid和Softmax是最为常用的几种<strong>激活函数（activation function）</strong>之一，他们为神经网络增加了非线性特征，从而使神经网络的表达能力大大增强。与此同时，他们也经常是分类任务的神经网络输出层的首选激活函数，其在输出层的作用和在对数线性模型中的作用是一样的，即将分布在任意区间内的分值转化为[0，1]上的概率。</p><h3 id="Sigmoid函数（二分类问题）"><a href="#Sigmoid函数（二分类问题）" class="headerlink" title="Sigmoid函数（二分类问题）"></a>Sigmoid函数（二分类问题）</h3><p>我们使用$z$来表示原先的线性模型的假设函数输出（注意：你可能会在别的地方看到式子的最后加上了偏差项$b$，我在这里没有将偏差项特别拎出来，而是为特征向量额外添加了一个维度$x_0=1$，来和权重$w_0$共同表示偏差）：<br>$$<br>z=w^Tx<br>$$<br>则Sigmoid函数的形式为：<br>$$<br>g(z)=\frac{1}{1+e^{-z}}<br>$$<br>可以看到，它的函数图像如下：</p><p><img src="4.jpg" alt="Sigmoid"></p><p> 可以很明显的看出，该函数将<strong>实数域映射成了[0,1]的区间</strong> ，无论线性模型的输出是什么，我们都可以将其转化为[0，1]上的值，也就是概率。</p><p>所以，加入了Sigmoid函数后，对数线性模型的假设函数变为：<br>$$<br>h_w(x)=g(z)=\frac{1}{1+e^{-z}}=\frac{1}{1+e^{-w^Tx}}<br>$$</p><h3 id="Softmax函数（多分类问题）"><a href="#Softmax函数（多分类问题）" class="headerlink" title="Softmax函数（多分类问题）"></a>Softmax函数（多分类问题）</h3><p>我们依然使用$z$来表示原先的线性模型的假设函数输出，由于多分类问题每个样本会输出多个概率值，每个概率值都是该样本标注为某个词性的概率，我们使用$z_i$来表示当前样本被标注为第$i$种词性的分值，共有$n$种词性。则Softmax函数的形式为：<br>$$<br>g(z_i)=\frac{e^{z_i}}{\sum_{j=1}^{n}{e^{z_j}}}<br>$$<br>所以，加入了Softmax函数后，对数线性模型的假设函数变为：<br>$$<br>h_w(x_i)=g(z_i)=\frac{e^{z_i}}{\sum_{j=1}^{n}{e^{z_j}}}=\frac{e^{w^T_ix}}{\sum_{j=1}^{n}{e^{w^T_jx}}}<br>$$<br>我们发现，该函数实际上对每一个类别 i 的概率进行了归一化处理，从而保证其范围在[0，1]上，此外，它还保证了对于每一个样本，其标注为每一个类别的条件概率之和为1<strong>（这也是另一种多分类方法One vs All所不能做到的）</strong>。实际上，你还可以推导发现，<strong>Sigmoid函数其实是Softmax函数在类别 n=2 时的特殊形式</strong>。</p><h2 id="对数线性模型背后的数学原理"><a href="#对数线性模型背后的数学原理" class="headerlink" title="对数线性模型背后的数学原理"></a>对数线性模型背后的数学原理</h2><p>事实上，上述两种非线性映射函数并不是科学家们一拍脑袋就定义出来的，他们都是有严格的概率统计学证明的。Sigmoid函数是Softmax函数在二分类时的特殊形式，而Softmax函数可以通过信息论中的<strong>最大熵模型</strong>进行推导。我们根据<strong>求解最大熵函数在给定的约束条件下的极值（使用拉格朗日乘子法）</strong>，可以得到最大熵模型的参数形式，也就是Softmax函数的形式。</p><p>具体证明过程可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/10-maxent-loglinear/main.pdf" target="_blank" rel="noopener">李老师的讲义</a>。</p><h2 id="定义对数线性模型的优化目标"><a href="#定义对数线性模型的优化目标" class="headerlink" title="定义对数线性模型的优化目标"></a>定义对数线性模型的优化目标</h2><p>如果我们在对数线性模型中依然使用线性回归模型的均方差损失函数进行梯度下降，我们将发现<strong>加入了非线性映射函数的均方差损失函数不再是一个凸优化问题，无法保证获得全局最优解</strong>，所以我们需要另寻新的损失函数。</p><p>按照我们惯用的做法，我们依然可以通过<strong>极大化似然估计</strong>的方式来求解对数线性模型的优化目标。</p><blockquote><p><strong>极大似然估计：利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值（模型已定，参数未知）</strong> 。</p></blockquote><p>由于我们的词性标注问题是多分类问题，所以我在这里就推导一下Softmax函数的目标函数，事实上，Sigmoid函数只是它的一种特殊情况。</p><p>我们假设当前词预测为第 i 种词性的概率为$\hat{y_i}$，根据Softmax函数，我们的模型现在是：<br>$$<br>\hat{y_i}=h_w(x_i)=\frac{e^{w^T_ix}}{\sum_{j=1}^{n}{e^{w^T_jx}}}<br>$$<br>我们已知模型的真实概率分布，也就是样本结果信息，即训练集中每一个样本的特征向量和标签。<strong>极大似然估计的目标就是找到一组合适的模型的参数，使得这些样本结果出现的概率最大。</strong>也就是说，对于每一个样本，我们都希望它被标注为正确标签的概率最大。 对于整个训练集，我们当然是期望所有样本的联合概率都达到最大。我们的目标函数，本身是个联合概率，但是假设每个样本独立，那就可以写成连乘形式：<br>$$<br>J(w)=\frac{1}{N}\prod^{N}_{i=1}\prod^{M}_{j=1}(\frac{e^{w^T_jx_i}}{\sum_{k=1}^{M}{e^{w^T_kx_i}}})^{y_{ij}}<br>$$<br>其中，$N$指样本数量，$i$指第几个样本，$M$指类别数量，$j$指第几个类别，$y_{ij}$指第$i$个样本被标注为第$j$个类别的取值是0还是1。</p><p>我们还可以发现，对于每一个样本$i$，其标签都是一个One-hot向量，即只有一个正确标签为1，其余均为0，所以我们可以对上述目标函数进行化简。设$y_{i}$为第$i$个样本的正确标签，则目标函数简化为：<br>$$<br>J(w)=\frac{1}{N}\prod^{N}_{i=1}(\frac{e^{w^T_ix_i}}{\sum_{k=1}^{M}{e^{w^T_kx_i}}})^{y_{i}}<br>$$<br>到了这一步，其实我们就可以使用当前的目标函数进行梯度下降，计算模型参数了。但是，我们发现<strong>连乘的形式会使得我们梯度求解变得很复杂，所以为了简化计算，我们可以对目标函数取对数</strong>：<br>$$<br>logJ(w)=\frac{1}{N}\sum^{N}_{i=1}y_{i}log(\frac{e^{w^T_ix_i}}{\sum_{k=1}^{M}{e^{w^T_kx_i}}})=\frac{1}{N}\sum^{N}_{i=1}y_{i}log\hat{y_i}<br>$$<br>以上就是我们极大化似然估计的目标函数，我们只需要使用梯度上升法对它进行优化即可获得最合适的$w$。此外，<strong>我们也可以加上一个负号，将其转化为最小化损失函数的形式，从而进行梯度下降求解</strong>。<br>$$<br>Loss(w)=-\frac{1}{N}\sum^{N}_{i=1}y_{i}log\hat{y_i}<br>$$<br>上面这个式子就是Softmax对数线性模型的损失函数，它其实就是我们常说的<strong>交叉熵（cross entropy）损失函数</strong>，更多有关交叉熵的知识来自于信息论，我在此就不多加介绍了。</p><p>特别地，如果你根据上述损失函数计算梯度，<strong>你会发现对于同一个特征权重，交叉熵损失函数的梯度居然神奇地和均方差损失函数一致！</strong>可以自己动手推导一遍。</p><h2 id="用对数线性模型解决词性标注问题"><a href="#用对数线性模型解决词性标注问题" class="headerlink" title="用对数线性模型解决词性标注问题"></a>用对数线性模型解决词性标注问题</h2><p>有关对数线性模型以及梯度下降法的知识在之前我已经全部介绍过了。在这里我们只需要应用即可。</p><p><strong>依然是使用我们的特征模板构建特征空间，模型使用Softmax函数进行概率转化，模型的训练方式采用随机梯度下降法，损失函数选择交叉熵损失函数。正则化方式选择L2正则化，随机打乱数据集，并使用学习率下降算法，对学习率进行模拟退火处理，使模型在梯度下降后期趋于稳定。</strong></p><p>具体代码可以参考 <a href="https://github.com/SUDA-LA/CIP" target="_blank" rel="noopener">https://github.com/SUDA-LA/CIP</a> 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我在线性模型和对数线性模型学习过程中总结的基础知识，接下来，我还会介绍条件随机场（CRF）模型，并给出其解决词性标注问题的方法。</p><h2 id="参考资料（部分）"><a href="#参考资料（部分）" class="headerlink" title="参考资料（部分）"></a>参考资料（部分）</h2><ul><li><a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">苏州大学李正华老师的课件</a></li><li>李航老师《统计学习方法》的第六章</li><li>Andrew Ng的机器学习课程</li><li>Andrew Ng的深度学习课程</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：隐马尔可夫模型</title>
      <link href="/2020/03/17/nlp-zi-xue-bi-ji-yin-ma-er-ke-fu-mo-xing/"/>
      <url>/2020/03/17/nlp-zi-xue-bi-ji-yin-ma-er-ke-fu-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是我在学习苏州大学李正华老师的中文信息处理课程（<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">中文信息处理（Chinese Information Processing）Course Resources</a>）时，对于隐马尔可夫模型的一些个人见解和思考，同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己对于该模型的理解，如有错误欢迎在评论区指出，非常感谢！</p><h2 id="从问题出发"><a href="#从问题出发" class="headerlink" title="从问题出发"></a>从问题出发</h2><p>隐马尔可夫模型（Hidden Markov Model，HMM模型）是一个序列化标注模型，也能被看作是一种seq2seq（序列到序列）模型。在对隐马尔可夫模型进行学习时，我们引入一个自然语言处理领域的经典序列化问题：<strong>词性标注任务</strong>。接下来的讲解中，将围绕这个问题进行讨论。</p><ul><li>给定一个句子X，输出句子中每一个单词对应的词性。</li></ul><p><img src="1.png" alt="词性标注任务"></p><h2 id="什么是隐马尔可夫模型"><a href="#什么是隐马尔可夫模型" class="headerlink" title="什么是隐马尔可夫模型"></a>什么是隐马尔可夫模型</h2><p>《统计学习方法》中对于隐马尔可夫模型有着如下的定义：</p><blockquote><p>隐马尔科夫是关于时序的概率模型，描述由一个隐藏的马尔科夫链随机生成不可观测的状态随机序列，再由各个状态生成一个观测而产生观测随机序列的过程，隐藏的马尔科夫链生成的随机状态的序列被称为状态序列（state sequence），每个状态生成一个观测，由此而产生的观测的随机序列，称之为观测序列（observation sequence）,序列的每一个位置都可以看作是一个时刻。</p></blockquote><p>上述定义初看比较晦涩难懂，我们需要逐步进行解释。</p><ul><li><p>首先，什么是观测序列和状态序列呢？观测序列通常指可以直接获得的序列，状态序列则是我们无法直接获得的序列，HMM模型的目的就是为了通过可观测到的数据，预测不可观测到的数据。我们结合词性标注问题来看，在此问题中，<strong>观测序列指的是句子的单词序列，而状态序列则指的是句子的词性序列</strong>。</p></li><li><p>那么，什么是马尔可夫链？马尔可夫链是具有马尔可夫性质的随机变量的一个数列，描述了一个状态序列。马尔可夫性质指的是每个状态值取决于前面有限个状态，这在HMM模型中称为<strong>齐次马尔科夫链假设</strong>。需要注意的是<strong>马尔可夫链并没有限定后一个状态的变化仅仅取决于前一个状态，而是说取决于前面有限个状态</strong>。不过为了简化模型，我们在HMM中使用一阶（二元）马尔可夫链，即每个状态仅依赖于前一个状态。带入到词性标注问题中，他指的是<strong>当前的词性仅依赖于前一个词性是什么</strong>。例如，动词后常接名词，很少再接一个动词。那么，根据齐次马尔科夫链假设，如果前一个词性是动词，我们可以推测出当前词倾向于是名词而非动词。</p></li><li><p>接下来，我们要解决的问题是观测序列如何生成状态序列。HMM模型中对于状态序列至观测序列的发射有着这样的假设：<strong>任意时刻的观察状态只仅仅依赖于当前时刻的隐藏状态</strong>。这也叫做<strong>观测独立性假设</strong>，与齐次马尔科夫链假设一样，它也是为了简化模型。带入到词性标注问题中，它指的是<strong>当前词仅与当前词性有关</strong>。举例来说，当给定一个词“苹果”，我们根据训练集统计得知名词词性发射至“苹果”的概率远大于其它词性，所以我们可以预测当前词倾向于是名词。</p></li><li><p>根据齐次马尔可夫假设和观测独立性假设，对于一个长度为$L$的句子，我们用$X=x(0),x(1)……x(L-1)$表示词序列（观测序列），$Y=y(0),y(1)…y(L-1)$表示词性序列（状态序列），那么词性序列的转移过程可以表示为：<br>$$<br>p(y_i|y_0…y_i-1)=p(y_i|y_i-1)（一阶马尔可夫性质）<br>$$</p></li></ul><p>  由词性序列$Y$产生词序列$X$的发射过程可以表示为：<br>  $$<br>  p(x_0…x_L|y_0…y_L)= \prod_{i=0}^L{p(x_i|y_i)}(观测独立性假设)<br>  $$</p><h2 id="什么样的问题需要隐马尔可夫模型"><a href="#什么样的问题需要隐马尔可夫模型" class="headerlink" title="什么样的问题需要隐马尔可夫模型"></a>什么样的问题需要隐马尔可夫模型</h2><blockquote><p>考虑一个简单的例子，有人试图通过一片海藻推断天气——民间传说告诉我们‘湿透的’海藻意味着潮湿阴雨，而‘干燥的’海藻则意味着阳光灿烂。如果它处于一个中间状态（‘有湿气’），我们就无法确定天气如何。然而，天气的状态并没有受限于海藻的状态，所以我们可以在观察的基础上预测天气是雨天或晴天的可能性。另一个有用的线索是前一天的天气状态（或者，至少是它的可能状态）——通过综合昨天的天气及相应观察到的海藻状态，我们有可能更好的预测今天的天气。 </p></blockquote><p>使用HMM模型时我们的问题一般有这两个特征：</p><ol><li><p>我们的问题是基于序列的，比如时间序列，或者状态序列。NLP中常见的机器翻译、词性标注、分词等任务都可以看作是序列化问题。</p></li><li><p>我们的问题中有两类数据，一类序列数据是可以观测到的，即观测序列；而另一类数据是不能观察到的，即隐藏状态序列，简称状态序列。比如，在机器翻译中，我们可以将源语言文本看作是观测序列，目标语言文本看作是状态序列；又比如，词性标注中，词序列是观测序列，词性序列是状态序列。</p></li></ol><h2 id="隐马尔可夫模型：生成模型OR判别模型"><a href="#隐马尔可夫模型：生成模型OR判别模型" class="headerlink" title="隐马尔可夫模型：生成模型OR判别模型"></a>隐马尔可夫模型：生成模型OR判别模型</h2><ul><li>假设样本的特征向量为$X$，标签向量为$Y$。由生成方法学习到的模型称之为生成模型，生成方法是由数据学习联合分布$P(X,Y)$：<br>$$<br>P(X,Y)=P(X|Y)P(Y)<br>$$<br>然后求出条件概率分布$P(Y∣X)$作为预测：</li></ul><p>$$<br>P(Y∣X)=\frac{P(X,Y)}{P(X)}<br>$$</p><p>​        生成模型需要先把所有训练数据的分布情况摸透，最终确定一个分布，并且此分布是包含了所有特征和标签        的联合分布$P(X,Y)$。当我们需要对新的样本的特征向量进行预测时，使用上述公式，即可求出$P(Y∣X)$，即        样本$X$被标注为标签$Y$的概率。</p><p>​        典型的生成模型有：朴素贝叶斯模型，<strong>隐马尔可夫模型</strong>，生成对抗网络（GAN），变分自编码器（VAE）。</p><ul><li><p>由判别方法学习到的模型称之为判别模型，判别方法是由数据直接学习决策函数或者条件概率分布$P(Y∣X) $作为预测的模型。典型的判别模型有：k近邻模型，感知机模型，决策树，逻辑回归模型，最大熵模型，支持向量机，提升方法和<strong>条件随机场</strong>等。</p><p>判别模型直接根据训练数据的标签$Y$，通过定义特征进行学习，使用复杂的函数映射及决策叠加等方法，最后拟合出一个较优的边界。当新的特征向量到来时，我们使用训练得到的决策界进行预测即可。比较经典的判别模型是逻辑回归模型，它通过定义损失函数，最大化似然估计，利用梯度下降等方式将决策边界的拟合转化为最小化损失函数的凸优化问题。</p></li><li><p>总结：<strong>生成模型是指对联合概率建模，判别模型是对条件概率建模 ，HMM模型属于生成模型，因为HMM模型中没有建立决策边界，而是直接对联合概率分布建模。当给定观测序列时，我们使用前向算法计算每条状态序列的概率，选取概率最大的状态序列路径作为序列标注的结果。</strong></p></li><li><p>一个简单的图示表示生成模型和判别模型的区别：</p><p><img src="4.jpg" alt="生成模型和判别模型"></p></li></ul><h2 id="隐马尔可夫模型：概率模型"><a href="#隐马尔可夫模型：概率模型" class="headerlink" title="隐马尔可夫模型：概率模型"></a>隐马尔可夫模型：概率模型</h2><p><strong>概率模型</strong>（probabilistic model ）中，我们需要利用已知变量 “推断（inference）” 未知变量的条件分布。 根据我们之前的介绍，隐马尔可夫模型就是一种概率模型。</p><p><strong>概率图模型</strong>（probabilistic graphical model ）是一类用图表达变量相关关系的概率模型。一个节点表示一个或一组随机变量，节点之间的边表示变量间的概率相关关系。根据边的性质不同，概率图模型可以分为两种：第一类使用有向无环图表示变量之间的依赖关系，称为有向图模型或贝叶斯网（ Bayesian network ）；第二类是使用无向图表示变量之间的相关关系，成为无向图模型或马尔可夫网（Markov network）。根据下图可以看出：<strong>隐马尔可夫模型属于概率图模型中的有向图模型</strong>。</p><p><img src="4.png" alt="隐马尔可夫模型示意图"></p><p>我在知乎上看到了一张很清楚的图片，分享给大家，介绍了常见概率图模型的分类。</p><p><img src="2.png" alt="概率图模型的分类"></p><h2 id="隐马尔可夫模型中需要学习的三个参数"><a href="#隐马尔可夫模型中需要学习的三个参数" class="headerlink" title="隐马尔可夫模型中需要学习的三个参数"></a>隐马尔可夫模型中需要学习的三个参数</h2><p>简单来说，HMM模型主要使用了两个特征，分别是<strong>发射特征</strong>（词性到词的概率）和<strong>转移特征</strong>（前一个词性到当前词性的概率）。特别的，我们还会引入第三个特征，即<strong>初始特征</strong>，它主要指的是句子中第一个词性是什么的概率。它本质上来说仍然是一个转移特征，只不过是从第0个词性（也就是空）转移而来。</p><p>在实际参数学习过程中，这三个特征都是以矩阵的形式存储。 <strong>关于假设，重要的一点是三个特征矩阵并不随时间的改变而改变——这个矩阵在整个系统的生命周期中是固定不变的</strong>。 </p><p>为了简化模型，HMM定义了<strong>两个假设</strong>，即我们前面提到的<strong>齐次马尔可夫假设</strong>和<strong>观测独立性假设</strong>，根据前者，我们使用了转移特征和初始特征，根据后者，我们使用了发射特征。<strong>这些假设虽然简化了模型，但同时由于过于粗糙，导致HMM只能使用三类特征，无法考虑句子中的更多信息</strong>。在我的接下来的文章中，将探讨<strong>线性模型</strong>和<strong>对数线性模型</strong>，他们虽然无法解决序列标注问题，一次只能预测一个词的词性，但是<strong>能够使用更多的特征</strong>。特别的，<strong>条件随机场</strong>结合了对数线性模型与隐马尔可夫模型的优点，实现了<strong>可以使用无限制的特征模板进行序列化标注</strong>。</p><p>HMM（隐马尔可夫模型）、LR（逻辑回归模型，即对数线性模型）、CRF（条件随机场）的关系如下图所示。</p><p><img src="3.png" alt="几种模型的对比"></p><h2 id="隐马尔可夫模型的五个要素"><a href="#隐马尔可夫模型的五个要素" class="headerlink" title="隐马尔可夫模型的五个要素"></a>隐马尔可夫模型的五个要素</h2><p>总结一下，隐马尔可夫模型的核心就是五个要素： </p><ul><li>两个序列：<ul><li>观测序列：句子（词序列）</li><li>状态序列：词性序列</li></ul></li><li>三个矩阵：<ul><li>初始概率矩阵：第一个词性的概率，实际上是一个一维向量</li><li>发射概率矩阵：词性发射到词的概率，维度为[训练集中的词性数,训练集中的词数]</li><li>状态转移概率矩阵：从一个词性变化到另一个词性的概率，维度为[训练集中的词性数,训练集中的词性数]</li></ul></li></ul><p>任何一个能用以上五个参数描述的模型都是隐马尔可夫模型。</p><ul><li>这里，我们补充一个HMM的例子：</li></ul><blockquote><p>例子：病情转化<br>假设：某一时刻只有一种疾病，且只依赖于上一时刻疾病，一种疾病只有一种症状，且只依赖于当时的疾病<br>症状（观察值）：发烧，咳嗽，咽喉肿痛，流涕<br>疾病（状态值）：感冒，肺炎，扁桃体炎，猝死<br>转移概率：从一种疾病转变到另一种疾病的概率<br>输出概率：某一疾病呈现出某一症状的概率<br>初始分布：初始疾病的概率</p></blockquote><h2 id="隐马尔可夫模型解决序列标注问题的过程"><a href="#隐马尔可夫模型解决序列标注问题的过程" class="headerlink" title="隐马尔可夫模型解决序列标注问题的过程"></a>隐马尔可夫模型解决序列标注问题的过程</h2><ol><li><p><strong>训练过程</strong>：利用训练数据，统计得到HMM模型的三个参数，也就是上一节提到的三个矩阵。主要的方法有：<strong>极大似然估计法（有监督学习）</strong>和 <strong>Baum-Welch算法（无监督学习）</strong>。</p></li><li><p><strong>预测过程</strong>：给定一个句子的词序列，通过我们训练好的模型预测出最有可能的词性序列。主要的方法为<strong>维特比算法</strong>。</p></li></ol><h2 id="隐马尔可夫模型的训练过程"><a href="#隐马尔可夫模型的训练过程" class="headerlink" title="隐马尔可夫模型的训练过程"></a>隐马尔可夫模型的训练过程</h2><h3 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h3><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">$w$</td><td align="center">观测序列中的单词</td></tr><tr><td align="center">$y$</td><td align="center">状态序列中的词性</td></tr><tr><td align="center">$N=\{y_0,…,y_n\}$</td><td align="center">状态集合，包含了数据集中所有的n个状态，即词性</td></tr><tr><td align="center">$M=\{w_0,…,w_n\}$</td><td align="center">观测集合，包含了数据集中所有的m个观测，即词</td></tr><tr><td align="center">$A=[a_{ij}]_{N*N}$</td><td align="center">状态转移矩阵，包含了词性间的转移概率，其中$a_{ij}=P(y_i|y_j)$，且这里的转移需要是两个连续出现的词性（一阶马尔可夫假设）</td></tr><tr><td align="center">$B=[b_{ij}]_{N*M}$</td><td align="center">状态发射矩阵，包含了词性到词的发射概率，其中$b_{ij}=P(w_i|y_j)$</td></tr><tr><td align="center">$C=[c_i]_N$</td><td align="center">初始状态矩阵，包含了每一个词性出现在词性序列的第一个节点的概率</td></tr></tbody></table><h3 id="极大似然估计法（有监督学习）"><a href="#极大似然估计法（有监督学习）" class="headerlink" title="极大似然估计法（有监督学习）"></a>极大似然估计法（有监督学习）</h3><p>机器学习中，有监督学习指的是训练数据给出了标签。在词性标注问题中，即指的是训练数据给出了词性序列。</p><p>在有监督学习的参数学习过程中， <strong>参数的计算频率近似于参数的概率</strong> ，我们可以利用极大似然估计法进行证明。具体证明的过程参考李老师的讲义<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/7-hmm-tagging-MLE/main.pdf" target="_blank" rel="noopener"> HMM模型中极大似然估计的由来 </a> 。基于上述推导，通过对训练数据进行统计，我们便可计算出模型的三个基本参数矩阵，并可以使用他们进行预测。</p><p>具体的<strong>训练过程</strong>如下：</p><ul><li><p>Step1.统计状态的概率分布，也就是初始概率矩阵 $C$，这一步<strong>直接计算各词性在序列首节点（即句首）出现的频率即可</strong>。</p></li><li><p>Step2. 统计状态转移矩阵 $A$，<strong>这一步需要分别统计当前词性转移至所有词性的次数$\sum_{k=1}^N{count(y_i,y_k)}$和统计当前词性转移至目标词性的次数$count(y_i,y_j)$</strong>，根据一阶马尔可夫假设，这里统计的词性间的转移次数<strong>只统计两个词性连续出现的情况</strong>。将统计得到的两个次数相除，即可得到当前训练集中某词性转移到目标词性的频率，根据极大似然估计，该频率就是状态转移概率。<br>$$<br>a_{ij}=\frac{count(y_i,y_j)}{\sum_{k=1}^N{count(y_i,y_k)}}<br>$$</p></li></ul><p>根据上述公式，我们可以预测出所有状态自身和相互转移的概率，填充状态转移矩阵。</p><ul><li>Step3. 统计状态发射矩阵 $B$，<strong>这一步需要分别统计当前词性发射至所有词的次数$\sum_{k=1}^M{count(y_i,w_k)}$和统计当前词性发射至目标词的次数$count(y_i,w_j)$</strong>。将统计得到的两个次数相除，即可得到当前数据集中某词性发射到目标词的概率，根据极大似然估计，该频率就是状态发射概率。<br>$$<br>b_{ij}=\frac{count(y_i,w_j)}{\sum_{k=1}^N{count(y_i,w_k)}}<br>$$<br>根据上述公式，我们可以预测出所有状态自身和相互转移的概率，填充状态发射矩阵。</li></ul><p>至此，我们完成了在人工标注的数据集上的隐马尔可夫模型所有参数的学习，并可以将其投入至结果预测中。</p><h2 id="Baum-Welch算法（无监督学习）"><a href="#Baum-Welch算法（无监督学习）" class="headerlink" title="Baum-Welch算法（无监督学习）"></a>Baum-Welch算法（无监督学习）</h2><p>机器学习中，无监督学习指的是训练数据没有给出标签。在词性标注问题中，即指的是训练数据只有句子，没有对应的词性。在这个问题中，无监督学习远比有监督学习复杂。这里仅给出我现在对该算法的理解，如果大家发现有问题可以在评论区指出。</p><p>我的理解是：Baum-Welch算法就是一个<strong>EM</strong>的过程，参数的求解需要使用到<strong>前向后向（Forward-Backward）算法</strong>。</p><p>EM的意思是 <strong>Expectation Maximization</strong> ，即期望最大化。这个算法一般分为两步，即E步（Expection 步）和M步（Maximization 步）：</p><ol><li>随机初始化模型参数$\theta$的初值$\theta_0$。</li><li>E步：计算联合分布的条件概率期望$Q$</li><li>M步：<strong>极大化似然函数</strong>$L(\theta)$，得到新的$\theta$</li><li>重复E、M步骤直到$\theta$收敛</li></ol><p>这里说的比较简略，从极大似然估计到EM算法的推导大家可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/7-hmm-em/main.pdf" target="_blank" rel="noopener">李老师的课件</a>以及这篇知乎上的文章<a href="https://zhuanlan.zhihu.com/p/36331115" target="_blank" rel="noopener">人人都懂EM算法</a>。</p><p>如果你有机器学习的基础，那你很可能学习过<strong>K-Means算法</strong>，这是一种无监督的聚类算法。它本质上就是一种EM算法。对于给定的许多个无标签的样本点，K-Means可以将他们聚成任意n个类别。具体的做法是先随机选取数据集中的n个点作为聚类的质心点，计算每个点到每个质心点的距离，将他们归类到距离最小的类别下；然后对于每一个类别，重新计算其质心点；我们反复迭代进行上述的归类和质心计算的步骤，直到质心不再变化。<strong>随机初始化和重置质心的过程其实就是EM算法的E步，计算样本点到质心的距离并将其聚类到最近的质心的过程其实就是EM算法的M步。</strong></p><p>K-Means算法直接对样本点进行归类，而不是计算每个类别的概率，所以属于<strong>Hard EM</strong>。Hard EM和 Soft EM的区别和我之前在吴恩达的深度学习课程上看到的 SoftMax和HardMax的区别很像，个人感觉本质是一样。</p><p><strong>总结一下，当我们的样本没有给定标注数据，即只有句子没有词性时，我们可以对需要学习的三个参数矩阵进行随机初始化（np.rand），初步确定模型，然后极大化数据的某种似然，调整得到新的参数矩阵，通过不断地迭代，参数矩阵将逐渐收敛，当它们的变化范围缩小到某个可以被接受的阈值时，我们可以停止迭代，将当前的参数矩阵用于预测。</strong></p><p><strong>EM算法的收敛性可以使用Jensen不等式来证明</strong>，具体过程非常精妙，详细内容可以参考<a href="https://www.cnblogs.com/jerrylead/archive/2011/04/06/2006936.html" target="_blank" rel="noopener">吴恩达的讲义</a>。</p><p>需要注意的是，<strong>EM算法无法保证全局最优解</strong>，和梯度下降算法非常类似，他们能够稳定达到全局最优的条件都是似然函数（损失函数）是一个凸函数。（PS：似然函数和损失函数的关系我个人认为非常紧密，后面会专门写一篇blog说一下这个问题）</p><p><strong>前向后向算法</strong>的使用，主要是因为对于网格中的每一个状态，它既计算到达此状态的“前向”概率（给定当前模型的近似估计），又计算到达此状态的“后向”概率（给定当前模型的近似估计）。 这些都可以通过利用递归进行加速计算。<strong>使用前向算法和后向算法的相互合作，我们可以得到很多有用的信息，并可以将它们运用在EM算法过程中的极大化似然估计上</strong>。（<strong>PS：这里的Forward算法和后面Viterbi算法中的Forward算法并不完全相同，这里是 sum-product ，你可以看作是神经网络中的正向传播过程，对于传至当前状态的概率进行求和；而后者是 max-product，对于传至当前状态的概率取最大值</strong> ）</p><p>这里顺带说一句，前向算法还可以用于计算序列的概率，从而选择模型。如果我们训练了多个词性标注的HMM模型，那么对于一个需要标注的句子，我们可以通过前向算法计算它在不同模型中可能出现的概率，然后选取最大概率的模型用于预测。</p><h2 id="隐马尔可夫模型的预测（解码）过程"><a href="#隐马尔可夫模型的预测（解码）过程" class="headerlink" title="隐马尔可夫模型的预测（解码）过程"></a>隐马尔可夫模型的预测（解码）过程</h2><p>学习完隐马尔可夫模型的参数后，便可以使用这三个参数矩阵对我们输入的句子进行词性预测了。在这里，我们使用一种叫做<strong>维特比（viterbi）算法</strong>的动态规划算法进行状态序列的解码，也就是词性序列的预测。</p><p>维特比算法是一种<strong>动态规划求解篱笆网络（Lattice）的最优路径问题的方法</strong>。此处，我依然不会给出详细的公式，具体公式大家可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/7-hmm-em/main.pdf" target="_blank" rel="noopener">李老师的课件</a>，我仅以通俗的语言简单地解释一下维特比算法的原理。</p><p><img src="5.png" alt="篱笆网络（Lattice）的最短路径问题"></p><p>维特比算法可以应用在任何<strong>有向无环图的最优路径计算</strong>上，这里它恰巧符合隐马尔可夫算法的解码需求。它主要分为两个步骤：</p><ol><li>前向传播计算序列的最大概率。</li><li>反向回溯确定最大概率序列的路径。</li></ol><p>维特比算法前向传播的过程主要采用了动态规划思想，因为在上述有向无环图中，同一个节点可以被多次访问，所以如果采用穷举法计算所有序列，会产生对子问题的大量重复计算。我们自然想到采用动态规划的方法来降低时间复杂度，因为这里满足动态规划的三个基本要求：（1）重叠子问题（2）最优子结构（3）无后效性。</p><p>这个算法并不难理解，我也就不一步步推给大家看了，感兴趣的同学可以看一下这个问题<a href="https://www.zhihu.com/question/20136144" target="_blank" rel="noopener">如何通俗地讲解 viterbi 算法？</a>。简单阐述一下就是：<strong>状态矩阵中，当前节点的值等于上一层各节点的值乘以对应的转移路径的权值所得结果中的最优值（max-product），同时，我们还建立一个回溯矩阵，保存状态矩阵中每个节点的值是由上一层的哪个节点转移而来。当前向传播计算到最后一层时，我们选取最后一层的节点中的最优值，并通过回溯矩阵反向回溯得到对应的最优序列。特别地，在隐马尔可夫模型中，我们在前向传播计算每个节点最优值的时候，还需要考虑发射概率。</strong></p><p>通过维特比算法，我们可以较快的利用训练好的模型去预测一个句子的最大概率词性序列，并输出。</p><p>在实际运用模型的过程中，我们还会发现这样的一个问题：训练得到的参数矩阵很可能是较为稀疏的，例如从一个词性从未发射到某个单词过。同时，训练集的规模有限，不可能包含所有的词和词性。由于状态矩阵的转移涉及概率的累乘，上述未登录的情况将导致发射或转移或初始概率为0，进而使得前向传播计算出的整条序列地概率为0。<strong>为了解决零概率问题，我们需要还引入平滑方法，例如Laplace平滑等</strong>。更多方法可以参考<a href="https://www.jianshu.com/p/a28acdc32b56" target="_blank" rel="noopener">NLP系列学习:数据平滑</a>。<br>$$<br>a_{ij}=\frac{count(y_i,y_j)+\lambda}{\sum_{k=1}^N[{count(y_i,y_k)+\lambda}]}<br>$$<br>特别注意的是，如果你使用Laplace平滑，下方的$\lambda$一定不要忘记加，我曾经写模型的时候就犯过这样的错误。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我学习隐马尔可夫模型过程中的笔记和思考，接下来我将继续介绍序列标注概率图模型中的最大熵马尔可夫模型（MEMM）和条件随机场模型（CRF），并阐明他们之间的关系。</p><h2 id="参考资料（部分）"><a href="#参考资料（部分）" class="headerlink" title="参考资料（部分）"></a>参考资料（部分）</h2><ul><li><a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/7-hmm-tagging/main.pdf" target="_blank" rel="noopener">李正华老师的课件</a></li><li>李航老师的《统计学习方法》第10章</li><li><a href="http://www.comp.leeds.ac.uk/roger/HiddenMarkovModels/html_dev/main.html" target="_blank" rel="noopener"> HMM学习最佳范例 </a></li><li><a href="https://blog.csdn.net/lukabruce/article/details/82380511" target="_blank" rel="noopener">隐马尔科夫模型（Hidden Markov Model，HMM）</a></li><li><a href="https://zhuanlan.zhihu.com/p/85454896" target="_blank" rel="noopener">一站式解决：隐马尔可夫模型（HMM）全过程推导及实现</a></li><li><a href="https://www.zhihu.com/question/35866596" target="_blank" rel="noopener">如何用简单易懂的例子解释条件随机场（CRF）模型？它和HMM有什么区别？</a></li><li><a href="https://www.zhihu.com/question/20962240" target="_blank" rel="noopener">如何用简单易懂的例子解释隐马尔可夫模型？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2020/03/17/kmp-suan-fa/"/>
      <url>/2020/03/17/kmp-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文整理了KMP算法的原理及代码，可以使用LEETCODE上的题目进行测试：<a href="https://leetcode-cn.com/problems/implement-strstr/submissions/" title="28. 实现 strStr()" target="_blank" rel="noopener">28. 实现 strStr()</a>。</p><h2 id="从Brute-Force算法说起"><a href="#从Brute-Force算法说起" class="headerlink" title="从Brute-Force算法说起"></a>从Brute-Force算法说起</h2><p>BF算法是最为简单的一种字符串匹配算法，它采用纯暴力匹配的思想。对于目标串S和模式串P，其基本匹配思路如下：</p><ul><li>枚举 i = 0, 1, 2 … , len（S）-len（P）</li><li>将 S[i : i+len（P）] 与 P 作比较。如果一致，则找到了一个匹配。</li></ul><p><img src="1.jpg" alt="BF算法匹配流程"></p><p>BF算法的缺点在于每一次都是将目标串中的指针直接回溯为i+1。</p><p>我们记 n = |S| 为串 S 的长度，m = |P| 为串 P 的长度。不难想到，最坏情况下其时间复杂度为$O(MN)$。</p><p><img src="2.jpg" alt="BF算法python实现"></p><h2 id="KMP算法：Brute-Force算法的优化"><a href="#KMP算法：Brute-Force算法的优化" class="headerlink" title="KMP算法：Brute-Force算法的优化"></a>KMP算法：Brute-Force算法的优化</h2><p>为了优化BF算法，我们需要尽可能地减少匹配的趟数。那么，我们如何达到这一目的呢？</p><p>如果把模式串视为一把标尺，在主串上移动，那么 Brute-Force 就是每次失配之后只右移一位；改进算法则是每次失配之后，移很多位，跳过那些不可能匹配成功的位置。为了减少重复匹配，我们需要在失配处计算移动的位数，而不是单纯的回退目标串和模式串中的指针。通过一个名叫“部分匹配表”的东西，我们可以跳过绝不可能匹配成功的字符串比较，从而实现算法的优化。</p><h3 id="部分匹配表"><a href="#部分匹配表" class="headerlink" title="部分匹配表"></a>部分匹配表</h3><p>部分匹配表（Partial Match Table）的含义为：</p><ul><li><p>对于长度为m的字符串P，部分匹配表是与之对应的长度为m的一个数组PMT。</p></li><li><p>PMT[i]的值等于：字符串P的前i位字符组成的子字符串中，前缀集合和后缀集合中公共子串（前缀和后缀不包括自身）的最大长度。</p></li></ul><p>对于字符串“abababca”，它的PMT如下表所示：</p><p><img src="3.png" alt="PMT"></p><p>例如，对于”aba”，它的前缀集合为{”a”, ”ab”}，后缀 集合为{”ba”, ”a”}。两个集合的交集为{”a”}，那么长度最长的元素就是字符串”a”了，长 度为1，所以对于”aba”而言，它在PMT表中对应的值就是1。再比如，对于字符串”ababa”，它的前缀集合为{”a”, ”ab”, ”aba”, ”abab”}，它的后缀集合为{”baba”, ”aba”, ”ba”, ”a”}， 两个集合的交集为{”a”, ”aba”}，其中最长的元素为”aba”，长度为3。</p><h3 id="如何使用部分匹配表进行优化"><a href="#如何使用部分匹配表进行优化" class="headerlink" title="如何使用部分匹配表进行优化"></a>如何使用部分匹配表进行优化</h3><p><img src="4.png" alt="KMT算法示意图"></p><p>我们以上图为例进行说明。当目标串S的指针为i，模式串P的指针为j时，此时匹配失败了。按照BF算法，我们会将i回退至下标为1处，j回退至下标为0处继续匹配。这显然是很笨拙的。</p><p>通过观察，我们可以发现， S[:i] 和 P[:j] 是成功匹配的，只是 S[i] 和 P[j] 不相同。</p><p>这时，我们在上一节所得的模式串的部分匹配表就派上了用场。通过 PMT[j-1] ，我们可以得知，P[:j] 这一子串中前后缀公共子串的最大长度为4。又因为 S[:i] 和 P[:j] 是相等的，所以 P[:j] 的后缀也就是 S[:i] 的后缀。那么，我们可以推知目标串i之前的4位和模式串开头的4位是相同的。就是图中的灰色部分。那这部分就不用再比较了。</p><p>有了上面的思路，我们就可以使用PMT加速字符串的查找了。我们看到如果是在 j 位 失配，那么影响 j 指针回溯的位置的其实是第 j −1 位的 PMT 值。</p><p>以上其实就是KMP算法的基本思想了，我们总结一下：KMP算法的目的是使用部分匹配表，来跳过必不可能成功的匹配，减少匹配的趟数。</p><h3 id="KMP算法的流程"><a href="#KMP算法的流程" class="headerlink" title="KMP算法的流程"></a>KMP算法的流程</h3><p>我们现在来总结一下KMP算法主程序的基本流程：</p><p>假设现在文本串 S 匹配到 tar 位置，模式串 P 匹配到 pos 位置：</p><ol><li><p>如果当前字符匹配成功，则tar++，pos++，继续匹配二者的下个字符。若当前的pos等于模式串的长度，则说明全部匹配成功，此时可以返回tar减去pos的值，即模式串在目标串中出现的首个字符的下标。</p></li><li><p>如果当前匹配失败，且pos大于0，说明此时模式串已经成功匹配了部分字符，可以尝试利用部分匹配表跳过必然无法匹配成功的子串，令pos=PMT[pos-1]。</p></li><li><p>如果匹配失败，且pos等于0，说明此时模式串的第一个字符就无法匹配，则tar++，尝试与目标串的下个字符匹配。</p></li></ol><p>根据上述的流程，我们可以编写KMP算法主体函数如下：</p><pre class="line-numbers language-python"><code class="language-python">        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span>pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>            tar<span class="token operator">=</span><span class="token number">0</span>            pos<span class="token operator">=</span><span class="token number">0</span>            PMT<span class="token operator">=</span>getPMT<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>tar<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>st<span class="token punctuation">[</span>tar<span class="token punctuation">]</span><span class="token operator">==</span>pattern<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    tar<span class="token operator">+=</span><span class="token number">1</span>                    pos<span class="token operator">+=</span><span class="token number">1</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token operator">==</span>len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> tar<span class="token operator">-</span>pos                <span class="token keyword">elif</span> <span class="token punctuation">(</span>pos<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    pos<span class="token operator">=</span>PMT<span class="token punctuation">[</span>pos<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    tar<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="KMP算法的难点：获取部分匹配表"><a href="#KMP算法的难点：获取部分匹配表" class="headerlink" title="KMP算法的难点：获取部分匹配表"></a>KMP算法的难点：获取部分匹配表</h3><p>KMP算法的基本思想其实并不难，但KMP算法主要的难点在于如何求解模式串的PMT数组。这里我们可以采取<strong>动态规划</strong>的方式求解。</p><ul><li>问题：对于模式串P，已知PMT[0],PMT[1],PMT[2]…PMT[x-1]，求解PMT[x]。</li></ul><p>观察上述问题，我们发现，该问题符合最优子结构和重叠子问题的动态规划要求，动态规划具体的转移情况我们进行分类讨论。</p><ul><li>情况一：已知now=PMT[x-1]，若P[x]==P[now]，则PMT[x]=now+1。如下图所示，因为我们已知前x-1个字符中有长度为now的公共前后缀，如果当前前缀的后一位P[now]等于当前后缀的后一位P[x]，则公共前后缀长度自然可以加1。</li></ul><p><img src="4.jpg" alt="情况1"></p><ul><li>情况二： 若P[x]!=P[now]，则令now=PMT[now-1]，再次尝试比较P[x]和P[now]，如果相等则PMT[x]=now+1，如果不相等再重复之前的过程，直到now等于0。如下图所示，此时由于子串A必然与子串B相等，则子串A的后缀与子串B的后缀必然相同，所以子串A的最大公共前后缀即为前x-1个字符中第二长的公共前后缀。</li></ul><p><img src="5.jpg" alt="情况2"></p><p>根据上述分析，我们可以编写获取模式串PMT数组的代码如下：</p><pre class="line-numbers language-python"><code class="language-python">        <span class="token keyword">def</span> <span class="token function">getPMT</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>            PMT<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#PMT[0]必定为0</span>            x<span class="token operator">=</span><span class="token number">1</span>            now<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">==</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    now<span class="token operator">+=</span><span class="token number">1</span>                    PMT<span class="token punctuation">.</span>append<span class="token punctuation">(</span>now<span class="token punctuation">)</span>                    x<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">elif</span> now<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                    now<span class="token operator">=</span>PMT<span class="token punctuation">[</span>now<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    PMT<span class="token punctuation">.</span>append<span class="token punctuation">(</span>now<span class="token punctuation">)</span>                    x<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">return</span> PMT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，KMP算法介绍完毕。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>KMP算法在我看来，主要有两方面的内容，一是通过动态规划求解模式串的部分匹配表；二是通过部分匹配表来跳过必不可能的情况，提升匹配的速度。其核心难点在于PMT动态规划的转移方程，需要静下心来自己推导一遍。</p><p>我们不难看出，对于长度为M的目标串S和长度为N的模式串P，KMP算法的时间复杂度由两部分组成：一是match函数中需要让指针遍历目标串S的每一个位置，需要耗费$O(M)$的时间，二是getPMT函数中计算部分匹配表，这一部分我们采用均摊时间复杂度分析，可以发现耗费的时间为$O(N)$。</p><p>利用KMP算法，我们将BF算法的时间复杂度$O(MN)$成功降为$O(M+N)$，使速度大大提升。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日两题</title>
      <link href="/2020/03/13/leetcode-ti-jie-chi-xu-geng-xin/"/>
      <url>/2020/03/13/leetcode-ti-jie-chi-xu-geng-xin/</url>
      
        <content type="html"><![CDATA[<h1 id="每日算法-LEETCODE-PYTHON3"><a href="#每日算法-LEETCODE-PYTHON3" class="headerlink" title="每日算法(LEETCODE,PYTHON3)"></a>每日算法(LEETCODE,PYTHON3)</h1><h2 id="2020-3-2-（2-medium）"><a href="#2020-3-2-（2-medium）" class="headerlink" title="2020.3.2 （2 medium）"></a>2020.3.2 （2 medium）</h2><h3 id="第3题-无重复的字符的最长字串"><a href="#第3题-无重复的字符的最长字串" class="headerlink" title="第3题 无重复的字符的最长字串"></a>第3题 无重复的字符的最长字串</h3><p><img src="3.png" alt="第3题 无重复的字符的最长字串"></p><h4 id="思路1-动态规划"><a href="#思路1-动态规划" class="headerlink" title="思路1 动态规划"></a>思路1 动态规划</h4><p>我的最初思路：可以采用动态规划法（区间DP），从区间为2的子串开始计算无重复字符的长度，接着计算下个更大的区间，依次类推，直到区间长度等于字符串长度。</p><ul><li><p>空间复杂度优化：这道题的动态规划状态矩阵中，可以发现有一半的空间（对角线以下）全部为0，所以可以压缩。</p></li><li><p>时间复杂度优化：分析后发现，这道题其实不需要动态规划，因为本质上没有重叠子问题。我尝试了两层循环遍历字符串的所有子串，一旦出现重复就可以跳出与当前最大长度比较，后面的子串不用再比较了，必有重复的字符。时间复杂度$O(N^2)$</p></li></ul><h4 id="思路2-滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）"><a href="#思路2-滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）" class="headerlink" title="思路2 滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）"></a>思路2 滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）</h4><p>使用左右两个指针维护一个无重复字符的窗口，两个指针初始都在0处。通过右指针不断向右延伸添加新的字符，并记录当前窗口大小，每次与当前最大值比较，如果大于当前最大值，则可以更新。当窗口延伸至新字符已存在于窗口内时。把窗口左侧的字符不断移除（左指针收缩），直到当前窗口无重复子串。继续滑动窗口，直到右指针触及字符串尾部，此时可以输出当前最大长度即可。</p><p>滑动窗口法减少了对字符串的重复遍历。</p><pre><code>class Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        if not s:return 0 #字符串为空的处理        left = 0        lookup = []        n = len(s)        max_len = 0        cur_len = 0        for i in range(n):            cur_len += 1            if s[i] in lookup:                pos=len(lookup)-lookup[::-1].index(s[i]) #寻找重复字符出现在窗口内的最后一次位置，直接将左指针移动到该位置后面即可。                lookup=lookup[pos:]                left += pos                cur_len -= pos            if cur_len &gt; max_len:max_len = cur_len            lookup.append(s[i])        return max_len</code></pre><h3 id="第4题-寻找两个有序数组的中位数"><a href="#第4题-寻找两个有序数组的中位数" class="headerlink" title="第4题 寻找两个有序数组的中位数"></a>第4题 寻找两个有序数组的中位数</h3><p><img src="4.png" alt="第4题 寻找两个有序数组的中位数"></p><h4 id="思路1-指针遍历"><a href="#思路1-指针遍历" class="headerlink" title="思路1 指针遍历"></a>思路1 指针遍历</h4><p>我的方法：归并排序的思想，通过设置两个指针对两个有序数组进行归并排序，若已排序到中位数位置，则输入当前指针指向的数。</p><p>缺点：时间复杂度$O(M+N)$，较高。空间复杂度可以优化至$O(1)$，即只存当前数和前一个数。</p><p>要想获得log级别的时间复杂度，需要使用二分法或者堆。</p><pre><code>class Solution:    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:        mid_pos=(len(nums1)+len(nums2)-1)/2        p=0        q=0        li=[]        count=-1        while (p!=len(nums1))and(q!=len(nums2)):            if (nums1[p]&lt;=nums2[q]):                li.append(nums1[p])                count+=1                p+=1                if (count&gt;=mid_pos):                    if mid_pos%1!=0:                        return (li[-1]+li[-2])/2                    else:                        return li[-1]            else:                li.append(nums2[q])                count+=1                q+=1                if (count&gt;=mid_pos):                    if mid_pos%1!=0:                        return (li[-1]+li[-2])/2                    else:                        return li[-1]        if (p==len(nums1)):            for i in range(q,len(nums2)):                li.append(nums2[i])                count+=1                if (count&gt;=mid_pos):                    if mid_pos%1!=0:                        return (li[-1]+li[-2])/2                    else:                        return li[-1]        elif (q==len(nums2)):            for i in range(p,len(nums1)):                li.append(nums1[i])                count+=1                if (count&gt;=mid_pos):                    if mid_pos%1!=0:                        return (li[-1]+li[-2])/2                    else:                        return li[-1]</code></pre><h4 id="思路2-递归二分"><a href="#思路2-递归二分" class="headerlink" title="思路2 递归二分"></a>思路2 递归二分</h4><p>为了使时间复杂度指数倍地下降，我们以数组[1，3，4，9]和[1，2，3，4，5，6，7，8，9，10]为例。计算得知：（1+14）/2=7.5，所以二者合并后的中位数为：第7小数和第8小数的平均值。</p><p>首先，我们学习一种二分法求解两个有序数组合并后第k小的数的方法，我们以第7小数为例：</p><p>1.先计算7整除2的商为3，然后比较第一个数组和第二个数组的第3个数（如果某个数组的元素不足3个，则比较它的最后一个数）。将较小的那个数及之前所有的数从所在的数组中去除。（此时它们必在合并后前6小的数中，具体证明可以自己推导一遍）。</p><p>2.此时，求解第7小的数变为：在更新后的两个数组中求解第4小的数（因为已经确定了3个）。</p><p>3.计算4整除2的商为2，然后比较两个数组的第2个数，与第1步中类似，将较小的数及之前的所有数从所在数组中删除。</p><p>4.此时，求解第4小的数变为：在更新后的两个数组中求解第2小的数（因为又确定了2个）。</p><p>5.重复以上过程，直到问题变为求解第1小的数，这时比较两个数组中的第1个数，返回较小值即可。</p><p>通过以上算法，我们可以用二分删除法计算出合并后第7小数和第8小数，然后便可计算中位数。</p><ul><li>时间复杂度:每进行一次循环，我们就减少 k/2 个元素，所以时间复杂度是 $O(log(k))$，而 k=（m+n）/2，所以最终的复杂也就是 O（log（m+n））。</li></ul><pre><code>class Solution:    def findk(self,nums1,nums2,k):#求解合并后第k小数        m=k//2        if (len(nums1)&gt;len(nums2)):#保证第一个数组较小            return self.findk(nums2,nums1,k)        if (len(nums1)==0):#如果第一个数组为空，直接返回第二个数组的第k个数即可            return nums2[k-1]        i=min(len(nums1),m)#防止第一个数组长度不足m        if (k==1):#如果求解第1小数，则直接比较二者第1个数即可            return min(nums1[0],nums2[0])        if (nums1[i-1]&gt;nums2[m-1]):#删除第二个数组的前m个数，再递归查找            return self.findk(nums1,nums2[m:],k-m)        else:#删除第一个数组的前i个数，再递归查找            return self.findk(nums1[i:],nums2,k-i)    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:        if (len(nums1)+len(nums2)+1)%2!=0:#数组总长为偶数            return (self.findk(nums1,nums2,int((len(nums1)+len(nums2)+1)/2))+self.findk(nums1,nums2,int((len(nums1)+len(nums2)+1)/2)+1))/2        else:#数组总长为奇数            return self.findk(nums1,nums2,int((len(nums1)+len(nums2)+1)/2))</code></pre><ul><li>空间复杂度:O（1）。<strong>因为这里使用了尾递归！</strong></li></ul><h4 id="什么是尾递归"><a href="#什么是尾递归" class="headerlink" title="什么是尾递归"></a>什么是尾递归</h4><p>以递归方式实现阶乘函数的实现：</p><pre><code>int recsum(int n) {    if (n &lt; 0)        return 0;    else if(n == 0 || n == 1)        return 1;    else        return n * fact(n - 1);}</code></pre><p>以尾递归方式实现阶乘函数的实现：</p><pre><code>int tailrecsum(int n, int res=0){    if (n &lt; 0)        return 0;    else if(n == 0)        return res;    else        return facttail(n - 1, n + res);}</code></pre><p>非尾递归，下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。</p><p>尾递归，进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。</p><p><strong>尾递归的判断标准是函数运行最后一步是否调用自身，而不是是否在函数的最后一行调用自身。</strong></p><p>上述例子中：</p><ul><li><p>递归方式的倒数第二步是调用自身求解recsum（n-1），而最后一步是将recsum（n-1）的结果与n相乘并返回，所以rescum(n)的运算依赖于rescum（n-1）的运算。需要将本层函数压栈保存，当计算完最后一层后，再进行层层返回，得出结果。</p></li><li><p>尾递归方式的最后一步就是调用自身求解n-1时的结果，并将当前层的结果作为参数传入下一层，不需要再返回当前层进行运算。下层计算结果对上层“无用”（上一层运算已经做完，不依赖后续的递归），为了效率，可以直接将下一层需要的空间覆盖在上一层上。</p></li></ul><p>总结：</p><ul><li><p>尾递归，比线性递归多一个参数，这个参数是上一次调用函数得到的结果；所以，关键点在于，尾递归每次调用都在收集结果，避免了线性递归不收集结果只能依次展开消耗内存的坏处。</p></li><li><p>使用尾递归可以带来一个好处：因为进入最后一步后不再需要参考外层函数（caller）的信息，因此没必要保存外层函数的stack，递归需要用的stack只有目前这层函数的，因此避免了栈溢出风险。 </p></li></ul><p><strong>本题中，所有递归调用都是当前层递归的最后一步，所以不需要额外的栈空间保存当前层，时间复杂度为O（1）。</strong></p><h2 id="2020-3-3-（2-medium）"><a href="#2020-3-3-（2-medium）" class="headerlink" title="2020.3.3 （2 medium）"></a>2020.3.3 （2 medium）</h2><h3 id="第5题-最长回文子串"><a href="#第5题-最长回文子串" class="headerlink" title="第5题 最长回文子串"></a>第5题 最长回文子串</h3><p><img src="5.png" alt="第5题 最长回文子串"></p><h4 id="思路1："><a href="#思路1：" class="headerlink" title="思路1："></a>思路1：</h4><p>区间动态规划+状态空间压缩，利用区间首尾字符是否相等，且去除首尾字符后的子串是否为回文串，来判断当前区间是否为回文子串。</p><ul><li><p>时间复杂度：$O(N^2)$</p></li><li><p>空间复杂度：$O(N^2)$（可以压缩一半）</p></li></ul><h4 id="思路2："><a href="#思路2：" class="headerlink" title="思路2："></a>思路2：</h4><p>中心扩展法，不需要额外的状态矩阵。对于一个长度为n的字符串，有2n-1个中心（奇偶回文串分类讨论）可以选取，由中心向两侧扩散寻找该中心所能构成的最长回文子串，若大于当前最大值，则将最大值替换为当前长度。</p><ul><li><p>时间复杂度：$O(N^2)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><pre><code>class Solution:    def longestPalindrome(self, s: str) -&gt; str:        max_length=&#39;&#39;        for i in range(len(s)):            if (i!=len(s)-1):                if len(self.expandcenter(s,i,i))&gt;len(max_length):                    max_length=self.expandcenter(s,i,i)                if len(self.expandcenter(s,i,i+1))&gt;len(max_length):                    max_length=self.expandcenter(s,i,i+1)            else:                if len(self.expandcenter(s,i,i))&gt;len(max_length):                    max_length=self.expandcenter(s,i,i)        return max_length    def expandcenter(self,s,l,r):#中心扩展法向两侧搜索判断        if (l==r):#奇回文串            length=1            while True:                l-=1                r+=1                if (l&gt;=0)and(r&lt;=len(s)-1)and(s[l]==s[r]):                    length+=2                else:                    return s[l+1:r]        else:#偶回文串            length=0            while True:                if (l&gt;=0)and(r&lt;=len(s)-1)and(s[l]==s[r]):                    length+=2                else:                    return s[l+1:r]                l-=1                r+=1</code></pre><h4 id="进阶算法："><a href="#进阶算法：" class="headerlink" title="进阶算法："></a>进阶算法：</h4><p>Manacher算法，时间复杂度只有$O(N)$，但比较复杂。可以参考<a href="https://www.jianshu.com/p/392172762e55" target="_blank" rel="noopener">https://www.jianshu.com/p/392172762e55</a></p><h3 id="第6题-Z-字形变换"><a href="#第6题-Z-字形变换" class="headerlink" title="第6题 Z 字形变换"></a>第6题 Z 字形变换</h3><p><img src="6.png" alt="第6题 Z 字形变换"></p><h4 id="思路1：-1"><a href="#思路1：-1" class="headerlink" title="思路1："></a>思路1：</h4><p>通过观察变换前后的字符串，利用规律求解，直接使用下标运算。</p><pre><code>class Solution:    def convert(self, s: str, numRows: int) -&gt; str:        a=2*numRows-2        result=&#39;&#39;        if (a==0):            return s        for i in range(numRows):            t=i            while(t&lt;len(s)):                result+=s[t]                delta=2*(numRows-i-1)                if (i!=0) and (t+delta&lt;len(s)) and(delta&gt;0):                    result+=s[t+delta]                t+=a        return result</code></pre><ul><li><p>时间复杂度：$O(N)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><h4 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h4><p>按顺序遍历字符串，并设置与行数相等的数组。遍历时，按照Z字形变化的格式放入对应的数组（行数先加1，遍历到底部再减1，遍历到顶部再加1，直到遍历完）</p><pre><code>class Solution:    def convert(self, s: str, numRows: int) -&gt; str:        if numRows &lt; 2: return s        res = [&quot;&quot; for _ in range(numRows)]        i, flag = 0, -1        for c in s:            res[i] += c            if i == 0 or i == numRows - 1: flag = -flag            i += flag        return &quot;&quot;.join(res)</code></pre><h2 id="2020-3-4-（1-hard-1-medium）"><a href="#2020-3-4-（1-hard-1-medium）" class="headerlink" title="2020.3.4 （1 hard 1 medium）"></a>2020.3.4 （1 hard 1 medium）</h2><h3 id="第10题-正则表达式匹配"><a href="#第10题-正则表达式匹配" class="headerlink" title="第10题 正则表达式匹配"></a>第10题 正则表达式匹配</h3><p><img src="10.png" alt="第10题 正则表达式匹配"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>本题可以用递归求解，但时空复杂度很高。</p><p>考虑到本题符合动态规划的两个基本要求：（1）重叠子问题，（2）最优子结构。所以本题可以使用动态规划来求解。</p><p>解决可递归问题的三种方法：</p><ul><li>递归：自顶向下，代码简单，但是复杂度高，可能会进行重复的计算，同时会使用大量的栈空间。</li><li>备忘录：自顶向下，将递归中的子问题求解结果保存起来，防止重复计算，降低了时间复杂度，但栈空间的消耗依然存在。</li><li>动态规划：自底向上，使用状态矩阵，由子问题通过状态转移方程递推出最后的结果。</li></ul><p>本题中，可以使用状态矩阵$dp(i,j)$表示text[i:]和pattern[j:]是否能匹配。我们可以用更短的字符串匹配问题来表示原本的问题。</p><ul><li><p>当首字母匹配且第二个字母为”*”时，可以尝试转移到匹配0次（目标串不变，模式串变）或1次（目标串变，模式串不变，因为此时可以多次匹配）的状态矩阵。</p></li><li><p>当首字母不匹配且第二个字母为”*”时，转移到匹配0次（目标串不变，模式串变）的状态矩阵。</p></li><li><p>首字母匹配且第二个字母不为”*”时，转移到首字母匹配1次（目标串和模式串都变）的状态矩阵。</p></li><li><p>否则，当前状态为False，即无法匹配。</p></li><li><p>$dp(-1,-1)$说明此时模式串和目标串完成了全匹配，可以成功，默认为True。</p></li></ul><pre><code>class Solution(object):    def isMatch(self, text, pattern):        dp=[[False for x in range(len(pattern)+1)] for x in range(len(text)+1)]        dp[-1][-1]=True #两个字符串都为空必然匹配        for i in range(len(text),-1,-1): #为什么i从len(text))开始，而j从len(pattern)-1开始：字符串为空，正则表达式不为空，可能匹配成功（存在*），而正则表达式为空，字符串不为空，必然不可能匹配成功            for j in range(len(pattern)-1,-1,-1):                f_match=(i&lt;len(text))and(pattern[j] in [text[i],&#39;.&#39;]) #第一个对i的限制条件是为了防止后面访问text[i]时数组越界                if (j+1&lt;len(pattern))and(pattern[j+1]==&#39;*&#39;):                    if f_match:                        dp[i][j]=dp[i][j+2] or dp[i+1][j]                    else:                        dp[i][j]=dp[i][j+2]                else:                    if f_match:                        dp[i][j]=dp[i+1][j+1]        return dp[0][0]</code></pre><h3 id="第11题-盛最多水的容器"><a href="#第11题-盛最多水的容器" class="headerlink" title="第11题 盛最多水的容器"></a>第11题 盛最多水的容器</h3><p><img src="11.png" alt="第11题 盛最多水的容器"></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h4><p>双指针法（这种从两端向内收缩的双指针我叫做双侧指针，如第3题中滑动窗口的同一侧出发的指针我叫做快慢指针）。</p><p>由于容器的容积只与短板有关，我们可以使用两个指针从数组的两侧每一次向内收缩短板，计算当前的容积，直到两个指针相交。</p><p>为什么只收缩短板：如果收缩长板，那么移动后的板长要么小于移动前的短板长度，要么大于短板长度，前者会使容积变小，后者会使容积不变，所以我们只有移动短板才可能使容积变大。</p><ul><li><p>时间复杂度：$O(N)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><pre><code>class Solution:    def maxArea(self, height: List[int]) -&gt; int:        max_v=0        left=0        right=len(height)-1        while (left&lt;right):            v=min(height[left],height[right])*(right-left)            if v&gt;max_v:                max_v=v            if (height[left]&lt;height[right]):                left+=1            else:                right-=1        return max_v</code></pre><h2 id="2020-3-5-（4-medium）"><a href="#2020-3-5-（4-medium）" class="headerlink" title="2020.3.5 （4 medium）"></a>2020.3.5 （4 medium）</h2><h3 id="第12题-整数转罗马数字"><a href="#第12题-整数转罗马数字" class="headerlink" title="第12题 整数转罗马数字"></a>第12题 整数转罗马数字</h3><p><img src="12.png" alt="第12题 整数转罗马数字"></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路:"></a>思路:</h4><p>贪心算法，每次取当前能够匹配的最大罗马数字进行选择。类似于用最少的纸币凑出整数。</p><pre><code>class Solution:    def intToRoman(self, num: int) -&gt; str:        # 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中        # 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想        nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]        romans = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]        index = 0        res = &#39;&#39;        while index &lt; 13:            # 注意：这里是等于号，表示尽量使用大的&quot;面值&quot;            while num &gt;= nums[index]:                res += romans[index]                num -= nums[index]            index += 1        return res</code></pre><h3 id="第15题-三数之和"><a href="#第15题-三数之和" class="headerlink" title="第15题 三数之和"></a>第15题 三数之和</h3><p><img src="15.png" alt="第15题 三数之和"></p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路:"></a>思路:</h4><p>在一个有序数组中求解两个数之和，可以使用暴力遍历的方法，但时间复杂度很高。在这里，我们可以使用双侧指针法，先在数组两端各固定一个指针。当两数之和小于target时，左指针加1（由于是有序数组，会使和变大），当两数之和大于target时，右指针减1，等于target时，保存结果，并左右指针同时向内收缩。</p><p>那么，知道了两数之和问题的解决方案后，我们可以求解三数之和（本质上，任意n数之和都可以采取相同的方法）。我们先对数组进行排序，然后固定一个数，便可将问题转化为两数之和，接着对于该数之后的所有数进行两数之和的求解。求解完成后，我们可以接着固定下一个数，直到求出所有结果。</p><p>要注意的问题：</p><ul><li><p>结果的去重（求解两数之和时，相同的数字不应重复使用。同时，固定的数若等于上个数，则他的所有情况都被上个数的遍历所包含，也可以跳过）。</p></li><li><p>性能的提升（剪枝，当右指针的数小于0时或者固定的数大于0时，三数之和必定不等于0，因为此时三个数都大于0或者都小于0）</p></li><li><p>时间复杂度：$O(N^2)+O(NlogN)=O(N^2)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><pre><code>class Solution {    public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList();        Arrays.sort(nums); # 排序        int len = nums.length;        if(nums == null || len &lt; 3) return ans;        for (int i = 0; i &lt; len ; i++) {            if(nums[i] &gt; 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; // 去重            int L = i+1;            int R = len-1;            while(L &lt; R){                if (nums[R]&lt;0){                    break;                }                int sum = nums[i] + nums[L] + nums[R];                if(sum == 0){                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));                    while (L&lt;R &amp;&amp; nums[L] == nums[L+1]) L++; // 去重                    while (L&lt;R &amp;&amp; nums[R] == nums[R-1]) R--; // 去重                    L++;                    R--;                }                else if (sum &lt; 0){                    while (L&lt;R &amp;&amp; nums[L] == nums[L+1]){                        L++; // 去重;                    }                    L++;                }                else if (sum &gt; 0) {                    while (L&lt;R &amp;&amp; nums[R] == nums[R-1]){                        R--; // 去重                    } // 去重                    R--;                }            }        }                return ans;    }}</code></pre><h3 id="第16题-最接近的三数之和"><a href="#第16题-最接近的三数之和" class="headerlink" title="第16题 最接近的三数之和"></a>第16题 最接近的三数之和</h3><p><img src="16.png" alt="第16题 最接近的三数之和"></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路:"></a>思路:</h4><p>与第15题几乎没有区别，只是双指针收缩时，每次记录当前的三数之和，看与结果的差值是否为当前最小，最小则修改当前的最接近的三数之和。当差值为0时可以直接返回。</p><pre><code>class Solution:    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:        nums.sort()        closest=nums[0]+nums[1]+nums[2]        diff=abs(closest-target)        for i in range(len(nums)-2):            if i&gt;0 and nums[i]==nums[i-1]:                continue            L=i+1            R=len(nums)-1            while (L&lt;R):                summa=nums[i]+nums[L]+nums[R]                if abs(summa-target)&lt;diff:                    closest=summa                    diff=abs(closest-target)                if (summa&gt;target):                    R-=1                elif (summa&lt;target):                    L+=1                else:                    return summa        return closest</code></pre><h3 id="第18题-四数之和"><a href="#第18题-四数之和" class="headerlink" title="第18题 四数之和"></a>第18题 四数之和</h3><p><img src="18.png" alt="第18题 四数之和"></p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路:"></a>思路:</h4><p>任意n数之和都求解，都可以先固定一个数，转化为n-1数之和问题，逐步转化，直到最后变为求解二数之和。这里的四数之和也是类似的道理，其去重的思想与三数之和也是一样的。</p><pre><code>class Solution {    public static List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums,int target) {        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList();        Arrays.sort(nums); // 排序        int len = nums.length;        if(nums == null || len &lt; 4) return ans;        for (int i = 0; i &lt; len-3 ; i++) {//多固定了一个数，将问题转化为内部的三数之和            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; // 去重            for (int j =i+1;j&lt;len-2;j++){                if(j &gt; i+1 &amp;&amp; nums[j] == nums[j-1]) continue; // 去重                int L = j+1;                int R = len-1;                while(L &lt; R){                    int sum = nums[i] + nums[j]+nums[L] + nums[R];                    if(sum == target){                        ans.add(Arrays.asList(nums[i],nums[j],nums[L],nums[R]));                        while (L&lt;R &amp;&amp; nums[L] == nums[L+1]) L++; // 去重                        while (L&lt;R &amp;&amp; nums[R] == nums[R-1]) R--; // 去重                        L++;                        R--;                    }                    else if (sum &lt; target) L++;                    else if (sum &gt; target) R--;                }            }        }                return ans;    }}</code></pre><h2 id="2020-3-6-（2-medium）"><a href="#2020-3-6-（2-medium）" class="headerlink" title="2020.3.6 （2 medium）"></a>2020.3.6 （2 medium）</h2><h3 id="第17题-电话号码的字母组合"><a href="#第17题-电话号码的字母组合" class="headerlink" title="第17题 电话号码的字母组合"></a>第17题 电话号码的字母组合</h3><p><img src="17.png" alt="第17题 电话号码的字母组合"></p><h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1:"></a>思路1:</h4><p>打表+队列，类似于BFS。</p><pre><code>class Solution:    def letterCombinations(self, digits: str) -&gt; List[str]:        dic={&#39;2&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],&#39;3&#39;:[&#39;d&#39;,&#39;e&#39;,&#39;f&#39;],&#39;4&#39;:[&#39;g&#39;,&#39;h&#39;,&#39;i&#39;],&#39;5&#39;:[&#39;j&#39;,&#39;k&#39;,&#39;l&#39;],&#39;6&#39;:[&#39;m&#39;,&#39;n&#39;,&#39;o&#39;],&#39;7&#39;:[&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;],&#39;8&#39;:[&#39;t&#39;,&#39;u&#39;,&#39;v&#39;],&#39;9&#39;:[&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]}        result=[]        for char in digits:            if result==[]:                result=dic[char]            else:                l=len(result)                for i in range(l):                    st=result[0]                    result=result[1:]#出队                    for c in dic[char]:                        result.append(st+c)#入队        return result</code></pre><p>时间复杂度:$O(3^M+4^N)$</p><h4 id="思路2-1"><a href="#思路2-1" class="headerlink" title="思路2:"></a>思路2:</h4><p>这里也可以使用回溯+递归的方法，将其看作是一个类似于全排列的问题。</p><pre><code>class Solution:    def letterCombinations(self, digits):        &quot;&quot;&quot;        :type digits: str        :rtype: List[str]        &quot;&quot;&quot;        phone = {&#39;2&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],                 &#39;3&#39;: [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;],                 &#39;4&#39;: [&#39;g&#39;, &#39;h&#39;, &#39;i&#39;],                 &#39;5&#39;: [&#39;j&#39;, &#39;k&#39;, &#39;l&#39;],                 &#39;6&#39;: [&#39;m&#39;, &#39;n&#39;, &#39;o&#39;],                 &#39;7&#39;: [&#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;],                 &#39;8&#39;: [&#39;t&#39;, &#39;u&#39;, &#39;v&#39;],                 &#39;9&#39;: [&#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;]}        def backtrack(combination, next_digits):            # if there is no more digits to check            if len(next_digits) == 0:                # the combination is done                output.append(combination)            # if there are still digits to check            else:                # iterate over all letters which map                 # the next available digit                for letter in phone[next_digits[0]]:                    # append the current letter to the combination                    # and proceed to the next digits                    backtrack(combination + letter, next_digits[1:])//这里可以看作是进行了回溯，因为直接使用了新的字符串，所以不用恢复状态         output = []        if digits:            backtrack(&quot;&quot;, digits)        return output</code></pre><h3 id="第19题-删除链表的倒数第N个节点"><a href="#第19题-删除链表的倒数第N个节点" class="headerlink" title="第19题 删除链表的倒数第N个节点"></a>第19题 删除链表的倒数第N个节点</h3><p><img src="19.png" alt="第19题 删除链表的倒数第N个节点"></p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>快慢指针法+dummy head。</p><p>快指针在前遍历链表，慢指针在后用于保存快指针的前第N个节点。当快指针遍历到链表的尾部，则可以使用慢指针删除节点。这里需要注意，当要删除的节点是第一个节点时，若使用题目中给出的头指针，需要分类讨论进行操作。为了不进行分类讨论，我们在链表开头处添加一个空的头结点（dummy head）。</p><ul><li><p>时间复杂度:$O(N)$</p></li><li><p>空间复杂度:$O(1)$</p></li></ul><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:        fore_head=ListNode(0)        fore_head.next=head        p=fore_head        back_n=fore_head        while (p.next!=None):            p=p.next            if (n&gt;0):                n-=1            elif (n==0)://n减到0时，才能移动慢指针，否则说明前第n个元素越界                back_n=back_n.next        back_n.next=back_n.next.next        return fore_head.next</code></pre><h2 id="2020-3-7-（1-medium-1-hard）"><a href="#2020-3-7-（1-medium-1-hard）" class="headerlink" title="2020.3.7 （1 medium 1 hard）"></a>2020.3.7 （1 medium 1 hard）</h2><h3 id="第22题-括号生成"><a href="#第22题-括号生成" class="headerlink" title="第22题 括号生成"></a>第22题 括号生成</h3><p><img src="22.png" alt="第22题 括号生成"></p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路:"></a>思路:</h4><p>二叉树的先根遍历+剪枝。使用count记录当前字符串内左括号个数减去右括号个数的值，当count&lt;0或者count&gt;n，n为剩余的目标括号对数时，进行剪枝。</p><pre><code>class Solution:    def generateParenthesis(self, n: int) -&gt; List[str]:        count=0        st=&#39;&#39;        result=[]        def dp(count,n,st):            if (0&lt;=count&lt;=n):#剪枝                if (n==0):#满足要求                    result.append(st)                else:#先根遍历                    dp(count-1,n-1,st+&#39;)&#39;)                    dp(count+1,n,st+&#39;(&#39;)        dp(count,n,st)        return result</code></pre><h3 id="第23题-合并K个排序链表"><a href="#第23题-合并K个排序链表" class="headerlink" title="第23题 合并K个排序链表"></a>第23题 合并K个排序链表</h3><p><img src="23.png" alt="第23题 合并K个排序链表"></p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路:"></a>思路:</h4><p>分治法，类似于标准归并排序的思想。先将相邻的链表两两合并，得到个数为原来一半的新链表，接着继续两两合并，重复直到只剩下最后一个链表，即为最终的结果。</p><p>两两合并的方法，采用的是双指针法，即两个链表各设置一个指针，用于比较和插入结果链表。</p><ul><li>时间复杂度：$O(NlogK)$，N是所有链表中元素的总和，K是链表个数。</li></ul><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        def merge(list1,list2):#两两合并            p=list1            q=list2            head=ListNode(0)            m=head            while (p!=None) and (q!=None):                if p.val&lt;q.val:                    m.next=p                    m=m.next                    p=p.next                else:                    m.next=q                    m=m.next                    q=q.next            if (p==None):                m.next=q            elif (q==None):                m.next=p            return head.next        amount = len(lists)        interval = 1        while interval &lt; amount:#两两合并            for i in range(0, amount - interval, interval * 2):                lists[i] = merge(lists[i], lists[i + interval])            interval *= 2        return lists[0] if amount &gt; 0 else lists</code></pre><p>为什么不使用逐一合并的算法呢？那样合并的过程写起来会很简单？</p><ul><li><p>逐一合并的时间复杂度：$O(NK)$</p></li><li><p>因为这里的两两排序实际上运用了分治法的思想，逐一合并的话，每一次合并在最坏的情况下都需要比较N个节点，而两两合并，每一轮合并的最坏情况才需要比较N个节点。逐一合并需要进行（K-1）次，而两两合并仅需要进行（logN）轮，所以时间复杂度大大降低。</p></li></ul><p><img src="23-2.png" alt="分治法"></p><h2 id="2020-3-8-（1-hard-1-medium）"><a href="#2020-3-8-（1-hard-1-medium）" class="headerlink" title="2020.3.8 （1 hard 1 medium）"></a>2020.3.8 （1 hard 1 medium）</h2><h3 id="第24题-两两交换链表中的节点"><a href="#第24题-两两交换链表中的节点" class="headerlink" title="第24题 两两交换链表中的节点"></a>第24题 两两交换链表中的节点</h3><p><img src="24.png" alt="第24题 两两交换链表中的节点"></p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路:"></a>思路:</h4><p>本质上就是两个一组翻转链表。可以使用头插法+dummy head。使用三个指针pre、p、q，将q结点插入至p结点之前，即完成了一次交换。然后移动指针至下两个节点处，继续交换。</p><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def swapPairs(self, head: ListNode) -&gt; ListNode:        h=ListNode(0)#dummy head         h.next=head        pre=h        p=head        if (head==None):            return head        else:            q=p.next            while (p!=None)and(q!=None):                p.next=q.next                q.next=p                pre.next=q                #两个一组翻转链表                pre=p                p=p.next                if p!=None:                    q=p.next                #移动至下两个节点进行操作           return h.next</code></pre><h3 id="第25题-K-个一组翻转链表"><a href="#第25题-K-个一组翻转链表" class="headerlink" title="第25题  K 个一组翻转链表"></a>第25题  K 个一组翻转链表</h3><p><img src="25.png" alt="第25题  K 个一组翻转链表"></p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路:"></a>思路:</h4><p>上一题的扩展，使用dummy head+头插法即可。</p><ul><li>pre指针：当前组的第一个节点的前一个节点，用于插入元素。</li><li>q指针： 要插到头部的那个节点。</li><li>p指针： q节点的前一个节点，用于删除q节点。</li></ul><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode:        h=ListNode(0)        h.next=head        pre=h        p=head        count=0        t=pre.next        while(t!=None):#统计当前链表的长度            count+=1            t=t.next        if (head==None):            return head        else:            q=p.next            while (pre!=None) and (p!=None) and (q!=None):                if (count&lt;k):#当前链表的剩余长度是否可以进行翻转                    return h.next                for i in range(k-1):                    p.next=q.next                    q.next=pre.next                    pre.next=q                     q=p.next                      #当前组内的节点进行头插法翻转                pre=p                p=pre.next                if p==None:                    return h.next                q=p.next                count-=k                #指针移动至下一组开始处        return h.next</code></pre><h2 id="2020-3-9-（3-easy）"><a href="#2020-3-9-（3-easy）" class="headerlink" title="2020.3.9 （3 easy）"></a>2020.3.9 （3 easy）</h2><h3 id="第26题-删除排序数组中的重复项"><a href="#第26题-删除排序数组中的重复项" class="headerlink" title="第26题 删除排序数组中的重复项"></a>第26题 删除排序数组中的重复项</h3><p><img src="26.png" alt="第26题 删除排序数组中的重复项"></p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路:"></a>思路:</h4><p>快慢指针法，慢指针指向当前数组内无重复的子序列的最后一项，快指针用于遍历整个数组。</p><ul><li>当快指针指向的元素与慢指针指向的元素不相等时，将该元素加入至慢指针维护的无重复子序列中，慢指针和快指针都加1。</li><li>当元素相等时，快指针直接遍历下一个元素。</li><li>时间复杂度：$O(N)$</li></ul><pre><code>class Solution:    def removeDuplicates(self, nums: List[int]) -&gt; int:        slow=0        for fast in range(1,len(nums)):            if (nums[slow]!=nums[fast]):                slow+=1                nums[slow]=nums[fast]        return slow+1#由于慢指针指向的是子序列最后一项的下标，子序列长度需要加1</code></pre><h3 id="第27题-移除元素"><a href="#第27题-移除元素" class="headerlink" title="第27题 移除元素"></a>第27题 移除元素</h3><p><img src="27.png" alt="第27题 移除元素"></p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路:"></a>思路:</h4><p>同样使用快慢指针法，快指针用于遍历，慢指针维护一个没有target元素的子序列，指向该子序列末尾的后一个元素。</p><pre><code>class Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        slow=0        for fast in range(len(nums)):            if (nums[fast]!=val):                nums[slow]=nums[fast]                slow+=1        return slow</code></pre><p>这里，慢指针与26题有一些区别，27题的慢指针指向的是符合要求的子序列的后一项，而26题是最后一项。这是因为26题中，单个元素不可能重复，而27题中，单个元素也可能是需要被移除的。</p><h3 id="第28题-实现-strStr"><a href="#第28题-实现-strStr" class="headerlink" title="第28题 实现 strStr()"></a>第28题 实现 strStr()</h3><p><img src="27.png" alt="第28题 实现 strStr()"></p><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路:"></a>思路:</h4><p>KMP算法，具体可以看这里：<a href="/2020/03/17/kmp-suan-fa">KMP算法总结</a></p><h2 id="2020-3-10-（1-hard-1-medium）"><a href="#2020-3-10-（1-hard-1-medium）" class="headerlink" title="2020.3.10 （1 hard 1 medium）"></a>2020.3.10 （1 hard 1 medium）</h2><h3 id="第29题-两数相除"><a href="#第29题-两数相除" class="headerlink" title="第29题 两数相除"></a>第29题 两数相除</h3><p><img src="29.png" alt="第29题 两数相除"></p><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路:"></a>思路:</h4><p>我们最初很容易可以想到使用累减法来解决除法问题，但这会很慢，所以我们需要使用递归方法加速累减。</p><p>递归的具体过程是，在递归函数内部，我们在保证当前除数不大于被除数的情况下，使除数不断翻倍，并记录倍数。当除数即将大于当前被除数时，我们停止翻倍，并记录下当前的倍数，加到商上。此时，我们将除数减去当前的被除数，剩余的结果重复之前的过程，直到剩余的数小于原始的除数。</p><p>本质上，这题的思想类似于快速幂算法，都是使用翻倍来加速，利用二分思想优化至logN级别的时间复杂度。因为一个一个减肯定不如翻倍翻倍减快速。</p><p>特别的，这道题还需要考虑补码的机制问题，当被除数等于$-2^31$时，商最大只能等于$2^31-1$。</p><pre><code>class Solution:    def divide(self, dividend: int, divisor: int) -&gt; int:        if dividend==0:#防止除数为0            return 0        if divisor==1:#除数为1，直接返回结果，加速运算            return dividend        if divisor==-1:#除数为-1，直接返回结果的负数，加速运算            if dividend==-2**31:#考虑integer的溢出                return 2**31-1            else:                return -dividend        flag=-1        if ((dividend&gt;0) and (divisor&gt;0)) or ((dividend&lt;0) and (divisor&lt;0)):#考虑符号            flag=1        dividend=abs(dividend)        divisor=abs(divisor)        def div(result,a):#递归求解            if (a&lt;divisor):                return result            count=1            result+=count            b=divisor            a-=b            while (b+b)&lt;=a:#翻倍累减                count+=count                result+=count                b+=b                a-=b            return div(result,a)#尾递归，减少栈空间调用        return flag*(div(0,dividend))</code></pre><h3 id="第30题-串联所有单词的子串"><a href="#第30题-串联所有单词的子串" class="headerlink" title="第30题 串联所有单词的子串"></a>第30题 串联所有单词的子串</h3><p><img src="30.png" alt="第30题 串联所有单词的子串"></p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路:"></a>思路:</h4><p>滑动窗口法+哈希表。</p><p>由于题目中提到了所有单词等长，那么我们对于n个长度为k的单词可以维护一个长度为k*n的滑动窗口。接着，我们利用哈希表建立words列表中的单词和单词数目的映射。然后，我们可以使用滑动窗口进行滑动匹配，每次移动一个单词的长度。对于窗口内部，我们统计每k长度的字符串，若出现了不在哈希表的键中的字符串，或者字符串出现的次数大于哈希表中对应的值时，说明此窗口失配，进行下一次匹配，否则，记录下窗口起始位置。</p><pre><code>class Solution:    def findSubstring(self, s: str, words: List[str]) -&gt; List[int]:        dic={}        result=[]        if s==&quot;&quot; or words==[]:#目标串或者待匹配列表为空            return []        for w in words:#建哈希表（字典）            if w in dic.keys():                dic[w]+=1            else:                dic[w]=1        l=len(words[0])        window=l*len(words)        for i in range(len(s)-window+1):#滑动匹配            end=i+window            tmp=dic.copy()            flag=1            for j in range(i,end,l):                w=s[j:j+l]                if w not in tmp.keys():                    flag=0                    break                tmp[w]-=1                if tmp[w]&lt;0:                    flag=0                    break            if flag:                result.append(i)        return result</code></pre><h2 id="2020-3-11-（2-medium-1-hard）"><a href="#2020-3-11-（2-medium-1-hard）" class="headerlink" title="2020.3.11 （2 medium 1 hard）"></a>2020.3.11 （2 medium 1 hard）</h2><h3 id="第31题-下一个排列"><a href="#第31题-下一个排列" class="headerlink" title="第31题 下一个排列"></a>第31题 下一个排列</h3><p><img src="31.png" alt="第31题 下一个排列"></p><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路:"></a>思路:</h4><p>核心思想：</p><ul><li>我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。</li><li>我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：</li></ul><ol><li>在尽可能靠右的低位进行交换，需要从后向前查找</li><li>将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换</li><li>将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列</li></ol><pre><code>class Solution:    def nextPermutation(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        def swap(a,b):#交换数组中的两个元素            temp=nums[a]            nums[a]=nums[b]            nums[b]=temp        p=len(nums)-1        while (p&gt;0):            if (nums[p]&gt;nums[p-1]):从后向前遍历，找到从后向前看的第一个下降的位置                min_pos=p                for i in range(len(nums)-1,p,-1):#搜索最小的大数并交换                    if (nums[i]&gt;nums[p-1]):                        min_pos=i                        break                swap(min_pos,p-1)                for i in range(int((len(nums)-p)/2)):#原地翻转，将大数后所有数重置为升序                    swap(p+i,len(nums)-i-1)                break            else:                p-=1        if (p&lt;=0):#如果为降序数组，则重置为升序数组            nums.sort()        return nums</code></pre><p><strong>这类题一定要把情况自己模拟一遍，寻找下一个转移的规律。</strong></p><h3 id="第32题-最长有效括号"><a href="#第32题-最长有效括号" class="headerlink" title="第32题 最长有效括号"></a>第32题 最长有效括号</h3><p><img src="32.png" alt="第32题 最长有效括号"></p><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路:"></a>思路:</h4><p>双向滑动窗口。</p><p>使用双指针维护一个滑动窗口。先从左向右滑动窗口，左右指针初始为0，使用一个变量count来存储当前窗口内左括号数量减去右括号数量的值。右指针不断向前遍历，当遍历到当前窗口内count&lt;0时，将左右指针都移动到当前右指针的下一个位置，重置窗口，当count==0时，使用当前窗口长度比较并尝试更新最大长度，当count&gt;0时，右指针继续向前遍历。</p><p>上述滑动完成后，再反向从右往左滑动一次窗口。此时的结果即为最大长度。</p><pre><code>class Solution:    def longestValidParentheses(self, s: str) -&gt; int:        p=0        q=0        count=0        max_len=0        if (len(s)&lt;2):            return 0        while (q&lt;len(s)):            if (s[q]==&quot;(&quot;):                count+=1            elif (s[q]==&quot;)&quot;):                count-=1            if (count&lt;0):                q+=1                p=q                count=0            else:                if (count==0):                    if (q-p+1)&gt;max_len:                        max_len=q-p+1                q+=1        #从左向右滑动        p=len(s)-1        q=len(s)-1        count=0        while (p &gt;=0):            if (s[p] == &quot;(&quot;):                count += 1            elif (s[p] == &quot;)&quot;):                count -= 1            if (count &gt; 0):                p-= 1                q = p                count = 0            else:                if (count == 0):                    if (q - p + 1) &gt; max_len:                        max_len = q - p + 1                p-= 1        #从右向左滑动        return max_len</code></pre><h3 id="第33题-搜索旋转排序数组"><a href="#第33题-搜索旋转排序数组" class="headerlink" title="第33题 搜索旋转排序数组"></a>第33题 搜索旋转排序数组</h3><p><img src="33.png" alt="第33题 搜索旋转排序数组"></p><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路:"></a>思路:</h4><p>由于题目要求时间复杂度在logN级别，所以必须是用二分法进行查找。但我们知道二分查找只适用于有序数组，所以我们需要使用嵌套二分。</p><p>首先，我们将数组从中间一分为二，根据旋转排序数组的性质，必然至少有一半有序。我们先判断左半数组是否有序，若有序，判断目标是否在它的范围内，若在，则在左半数组中二分查找，而不在，则去右半数组中二分查找。否则，即为右半数组有序，若目标在范围内，则在右半数组中二分，否则去左半数组中二分。</p><pre><code>class Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left=0        right=len(nums)-1        while (left&lt;=right):            mid=(left+right)//2            if nums[mid]==target:#中间数为目标                return mid            if (nums[left]&lt;=nums[mid]):#左半数组有序                if (nums[left]&lt;=target&lt;=nums[mid]):#目标在左半数组中                    right=mid-1                else:                    left=mid+1            else:#右半数组有序                if (nums[mid]&lt;=target&lt;=nums[right]):#目标在右半数组中                    left=mid+1                else:                    right=mid-1        return -1</code></pre><h2 id="2020-3-12-（2-medium-1-hard）"><a href="#2020-3-12-（2-medium-1-hard）" class="headerlink" title="2020.3.12 （2 medium 1 hard）"></a>2020.3.12 （2 medium 1 hard）</h2><h3 id="第34题-在排序数组中查找元素的第一个和最后一个位置"><a href="#第34题-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="第34题 在排序数组中查找元素的第一个和最后一个位置"></a>第34题 在排序数组中查找元素的第一个和最后一个位置</h3><p><img src="41.png" alt="第34题 在排序数组中查找元素的第一个和最后一个位置"></p><h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路:"></a>思路:</h4><p>由于时间复杂度控制在logN级别，所以很明显需要使用二分查找。</p><p>我们以二分查找获取左边界为例进行说明。首先，我们使用的是常规二分查找的框架，即比较目标与当前区间的中位数。不过常规二分查找是当目标大于中位数时进入右区间查找，小于中位数时进入左区间查找，等于中位数时返回当前中位数的位置。不同的是，此时我们需要查找的是元素的第一个位置。所以，我们需要进行这样的修改：当中位数等于目标时，目标元素的起始位置很明显要么在中位数处，要么在中位数左侧区间，此时我们直接进入左区间查找即可，其余的做法和常规二分查找一样。你可能会疑惑万一第一个位置就是中位数怎么办。不用担心，当遍历完左区间后无法再次找到目标元素，此时会在左区间的末尾尝试进入右区间，又回到了我们原先的中位数处。</p><p>二分查找右边界的方法同理，只是将中位数等于目标时改为进入右区间查找即可。</p><p>注意，当得到左右边界后还要判定是否合法。</p><p>通过两次二分，我们可以在$O(logN)$的时间复杂度内完成查找。</p><pre><code>class Solution:    def searchRange(self, nums: List[int], target: int) -&gt; List[int]:        if nums==[]:            return [-1,-1]        def getLeftBound(nums,target):#查找左边界            left=0            right=len(nums)-1            while (left&lt;=right):                mid=(left+right)//2                if (nums[mid]&gt;=target):                    right=mid-1                else:                    left=mid+1            if (left&gt;=0) and (left&lt;len(nums)) and (nums[left]==target):#左边界合法                return left            return -1        def getRightBound(nums,target):#查找右边界            left=0            right=len(nums)-1            while (left&lt;=right):                mid=(left+right)//2                if (nums[mid]&lt;=target):                    left=mid+1                else:                    right=mid-1            if (right&gt;=0) and (right&lt;len(nums)) and (nums[right]==target):#右边界合法                return right            return -1        return [getLeftBound(nums,target),getRightBound(nums,target)]</code></pre><h3 id="第36题-有效的数独"><a href="#第36题-有效的数独" class="headerlink" title="第36题 有效的数独"></a>第36题 有效的数独</h3><p><img src="36.png" alt="第36题 有效的数独"></p><h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路:"></a>思路:</h4><p>使用三个二维数组，分别存放每一行、每一列、每一个子数独当前放置的值。依次遍历这81个格子，每次遍历时将非空格子中的数放入对应的行、列、子数独的列表中。若出现了重复，则说明当前数独无效。</p><ul><li>时间复杂度：$O(1)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code>class Solution:    def isValidSudoku(self, board: List[List[str]]) -&gt; bool:        cols=[[] for x in range(9)]        rows=[[] for x in range(9)]        sons=[[] for x in range(9)]        for i in range(9):            for j in range(9):                if board[i][j]!=&#39;.&#39;:                    if (board[i][j] in cols[j]) or (board[i][j] in rows[i]) or (board[i][j] in sons[(i//3)*3+j//3]):                        return False                    else:                        cols[j].append(board[i][j])                        rows[i].append(board[i][j])                        sons[(i//3)*3+j//3].append(board[i][j])        return True</code></pre><h3 id="第37题-解数独"><a href="#第37题-解数独" class="headerlink" title="第37题 解数独"></a>第37题 解数独</h3><p><img src="37.png" alt="第37题 解数独"></p><h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路:"></a>思路:</h4><p>递归+回溯。类似的问题还有走迷宫、皇后问题、全排列等，本质的思路都是去使用回溯算法递归的尝试每种可能的情况。</p><p>回溯算法模板如下：</p><blockquote><p>def backtrack(…):<br> if (符合结束条件):<br>      保存结果<br>  else:<br>      for 选择 in 选择列表：<br>          if 选择合法：<br>              进行选择<br>              backtrack(…)#递归进入下一个位置进行选择<br>              撤销选择</p></blockquote><p>本题中，我们对每一个格子进行遍历，如果当前格子非空，我们便在“1”到“9”中选择合法的数字填入当前格子，并进入下一个格子继续选择。如果一直到最后一个格子都可以成功填入数字，则说明解完了数独，可以返回真。如果当前格子无法填入任何数字，则需要回溯至上一层递归函数，去恢复数独的状态，并选择下一个数字尝试填入。</p><p>判定当前数独矩阵是否合法，参考第36题即可。</p><pre><code>class Solution:    def solveSudoku(self, board) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify board in-place instead.        &quot;&quot;&quot;        cols=[[] for x in range(9)]        rows=[[] for x in range(9)]        sons=[[] for x in range(9)]        def could_place(i,j,value):#是否可以在当前格子放置value数字            if (value in cols[j]) or (value in rows[i]) or (value in sons[(i//3)*3+j//3]):                return False            return True        def place(i,j,value):#放置数字            cols[j].append(value)            rows[i].append(value)            sons[(i//3)*3+j//3].append(value)            board[i][j]=value        def remove(i,j,value):#移除数字            cols[j].remove(value)            rows[i].remove(value)            sons[(i//3)*3+j//3].remove(value)            board[i][j]=&quot;.&quot;        def DFS(i,j):#回溯函数            if i&gt;8:#结束递归条件               return True            if board[i][j]==&quot;.&quot;:#当前格子是否为空                for value in range(1,10):#遍历选择                    value=str(value)                    if (could_place(i,j,value)):#如果选择合法                        place(i,j,value)#进行选择                        if (j==8):#判断是否走到行尾                            if not(DFS(i+1,0)):#如果当前可以递归找到解，那么直接返回真，不需要再继续选择，否则回溯继续选择。                                remove(i,j,value)                            else:                                return True                        else:                            if not(DFS(i,j+1)):                                remove(i,j,value)                            else:                                return True            else:                if (j==8):                    return DFS(i+1,0)                else:                    return DFS(i,j+1)            return False        for i in range(9):#统计已经存在的数            for j in range(9):                if board[i][j]!=&#39;.&#39;:                    if (board[i][j] in cols[j]) or (board[i][j] in rows[i]) or (board[i][j] in sons[(i//3)*3+j//3]):                        return                    else:                        cols[j].append(board[i][j])                        rows[i].append(board[i][j])                        sons[(i//3)*3+j//3].append(board[i][j])        DFS(0,0)</code></pre><h2 id="2020-3-13-（2-medium）"><a href="#2020-3-13-（2-medium）" class="headerlink" title="2020.3.13 （2 medium）"></a>2020.3.13 （2 medium）</h2><h3 id="第39题-组合总和"><a href="#第39题-组合总和" class="headerlink" title="第39题 组合总和"></a>第39题 组合总和</h3><p><img src="39.png" alt="第39题 组合总和"></p><h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路:"></a>思路:</h4><p>递归回溯算法+剪枝</p><p>递归组合分解，每次选择候选数组中的一个元素，用目标值减去它。</p><ul><li>若得到的结果大于0，说明还可以继续分解，将当前选择的元素加入至路径列表，并尝试继续分解。</li><li>如果当前结果等于0，说明分解成功，将当前选择的元素加入至路径列表，并将当前路径列表加入至结果列表。</li><li>如果当前结果小于0，说明无法再分解，特别地，当候选数组升序时，后面的元素很明显也无法分解，需要跳出循环。</li></ul><p><img src="39-1.png" alt="回溯法"><br>此外，有可能出现重复的结果，即虽然路径不同，但元素相同。考虑到这一问题，尝试进行剪枝：</p><ul><li>记录下当前选择的元素的下标，下一次选择元素从该下标开始。<br><img src="39-2.png" alt="剪枝"></li></ul><pre><code>class Solution:    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:        result=[]        candidates.sort()        def back(re,index,target):            for i in range(index,len(candidates)):#遍历选择                num=candidates[i]                target_now=target-num                if target_now&lt;0:                    break                re.append(num)#选择                if target_now==0:                    res=re[:]                    result.append(res)                else:                    back(re,i,target_now)                re.pop()#回溯恢复        back([],0,target)        return result</code></pre><h3 id="第40题-组合总和2"><a href="#第40题-组合总和2" class="headerlink" title="第40题 组合总和2"></a>第40题 组合总和2</h3><p><img src="40.png" alt="第40题 组合总和2"></p><h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路:"></a>思路:</h4><p>和上一题类似，依然使用剪枝+递归回溯的思路来做。</p><p>有两个区别，一个是候选数组可能会出现重复，我们采用三数之和问题里类似的剪枝思路进行去重。第二个区别是数字不能重复使用，所以递归进行下一次元素的选择时，要从当前元素下标的下一个开始。</p><p><img src="40-1.png" alt="剪枝过程"></p><pre><code>class Solution:    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:        result=[]        candidates.sort()        def back(re,index,target):            if (index&lt;len(candidates)):                for i in range(index,len(candidates)):                    if i!=index and (candidates[i]==candidates[i-1]):#去重                        continue                    target_now=target-candidates[i]                    if (target_now&lt;0):                        break                    re.append(candidates[i])                    if (target_now==0):                        result.append(re[:])                    else:                        back(re,i+1,target_now)#从下一元素开始遍历，防止数字重复使用                    re.pop()        back([],0,target)        return result</code></pre><h2 id="2020-3-14-（2-hard-1-medium）"><a href="#2020-3-14-（2-hard-1-medium）" class="headerlink" title="2020.3.14 （2 hard 1 medium）"></a>2020.3.14 （2 hard 1 medium）</h2><h3 id="第41题-缺失的第一个正数"><a href="#第41题-缺失的第一个正数" class="headerlink" title="第41题 缺失的第一个正数"></a>第41题 缺失的第一个正数</h3><p><img src="41.png" alt="第41题 缺失的第一个正数"></p><h4 id="思路-23"><a href="#思路-23" class="headerlink" title="思路:"></a>思路:</h4><p>我们很容易想到利用哈希表（即字典）进行统计，然后去寻找第一个缺失的正数。但是考虑到题目的要求为时间复杂度$O(N)$以及常数级别的空间复杂度，我们可以考虑将数组自身作为一个哈希表，对应的哈希函数为:</p><p>$$f(nums[i])=nums[i]-1$$</p><p>通过哈希函数，将可以进行映射的数组元素映射到对应位置上，然后依次遍历寻找第一个映射不正确的位置即可。</p><p>复杂度分析：</p><ul><li><p>时间复杂度：$O(N)$，这里$N$是数组的长度。<br>说明：while 循环不会每一次都把数组里面的所有元素都看一遍。如果有一些元素在这一次的循环中被交换到了它们应该在的位置，那么在后续的遍历中，由于它们已经在正确的位置上了，代码再执行到它们的时候，就会被跳过。最极端的一种情况是，在第 1 个位置经过这个 while 就把所有的元素都看了一遍，这个所有的元素都被放置在它们应该在的位置，那么 for 循环后面的部分的 while 的循环体都不会被执行。平均下来，每个数只需要看一次就可以了，while 循环体被执行很多次的情况不会每次都发生。这样的复杂度分析的方法叫做<strong>均摊复杂度分析</strong>。</p></li><li><p>空间复杂度：$O(1)$。</p></li></ul><pre><code>class Solution:    def firstMissingPositive(self, nums: List[int]) -&gt; int:        def swap(pos1,pos2):            nums[pos1],nums[pos2]=nums[pos2],nums[pos1]        size=len(nums)        for i in range(size):            while (0&lt;nums[i]&lt;=size)and (nums[i]!=nums[nums[i]-1]):#当当前位置的数字可以进行哈希映射，并且不在对应位置时，与对应位置的数字交换。如果重复了或者无法映射（不在范围内），则不映射。                swap(i,nums[i]-1)        for i in range(size):#寻找第一个不符合映射规则的位置            if nums[i]!=i+1:                return i+1        return size+1#都符合，那么就输出下一个正数</code></pre><p>注:为什么使用nums[i]!=nums[nums[i]-1]来判断而不是i!=nums[i]-1？</p><p>因为后者无法处理重复的数字。</p><h3 id="第42题-接雨水"><a href="#第42题-接雨水" class="headerlink" title="第42题 接雨水"></a>第42题 接雨水</h3><p><img src="42.png" alt="第42题 接雨水"></p><h4 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h4><p>双指针+左右各一次遍历。从左向右遍历时，保证左指针指向的是短板。右指针不断向前遍历，每次右指针遇到长板后，计算此时所形成的容器的容积，再将左指针移到右指针处，右指针继续向前遍历。直到右指针遍历到数组末尾。然后再用相同的方式反向搜索一遍即可。将所有容积相加即为答案。</p><ul><li><p>时间复杂度:两次遍历，$O(N)$。</p></li><li><p>空间复杂度：$O(1)$。</p></li></ul><pre><code>class Solution:    def trap(self, height: List[int]) -&gt; int:        left=0        right=left+1        water=0        while (right&lt;len(height)):#从左向右            if height[right]&gt;=height[left]:                width=right-left-1                tmp=0                for i in range(left+1,right):#减去被柱子占用的体积                    tmp-=height[i]                tmp+=width*height[left]                water+=tmp                left=right            right+=1        right=len(height)-1        left=right-1        while (left&gt;=0):#从右向左            if height[left]&gt;height[right]:                width=right-left-1                tmp=0                for i in range(left+1,right):                    tmp-=height[i]                tmp+=width*height[right]                water+=tmp                right=left            left-=1        return water</code></pre><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>实际上，这里并不需要两次遍历，因为从左向右和从右向左的遍历都会在最高的柱子处停下。所以我们可以同时从两侧开始逼近，每次让左右指针较小的那个移动。</p><p>同时，我们可以维护一个left_max和right_max，即左右指针当前遍历到的最高柱。利用它们可以计算当前格子的积水。</p><pre><code>class Solution:    def trap(self, height: List[int]) -&gt; int:        left_max=0        right_max=0        left=0        right=len(height)-1        water=0        while left&lt;=right:            if height[left]&lt;height[right]:#确保不会越过山顶                if (height[left]&gt;=left_max):                    left_max=height[left]                else:                    water+=left_max-height[left]#利用max变量求解当前格的积水                left+=1            else:                if (height[right]&gt;=right_max):                    right_max=height[right]                else:                    water+=right_max-height[right]                right-=1        return water</code></pre><p>数组必有一个 ”山顶“（若有多个高度相同山顶，任取一个即可）。</p><p>根据”木桶原理“，山顶左侧的元素的盛水量 ，由左侧最大值决定；山顶右侧元素的盛水量，由右侧最大值决定。</p><p>双指针法的两个指针最终会停在 “山顶” 处。</p><h3 id="第43题-字符串相乘"><a href="#第43题-字符串相乘" class="headerlink" title="第43题 字符串相乘"></a>第43题 字符串相乘</h3><p><img src="43.png" alt="第43题 字符串相乘"><br>大数乘法问题，采取模拟竖式计算的方式求解。使用两个数组来存放两个数字字符串，数组的低位存数字字符串的低位。将第1个数组的第i位与第2个数组的第j位相乘，放入结果数组的第i+j位上。计算完成后，遍历结果数组，将所有大于9的进行进位操作。再反向遍历去掉最末尾的0。最后反向拼接成字符串输出即可。</p><pre><code>class Solution:    def multiply(self, num1: str, num2: str) -&gt; str:        numLi1=[int(x) for x in num1[::-1]]        numLi2=[int(x) for x in num2[::-1]]        len1=len(numLi1)        len2=len(numLi2)        res=[0 for x in range(len1+len2)]        for i in range(len1):#模拟两个数字的每一位相乘            for j in range(len2):                res[i+j]+=numLi1[i]*numLi2[j]        for i in range(len1+len2):#进位操作            if res[i]&gt;9:                res[i+1]+=res[i]#10                res[i]%=10          for i in range(len(res)-1,0,-1):#去除结果开头的0            if res[i]==0 :                res.pop()            else:                break        res=[str(x) for x in res[::-1]]        return &quot;&quot;.join(res)</code></pre><ul><li>时间复杂度:$O(MN)$</li><li>空间复杂度:$O(M+N)$</li></ul><h2 id="2020-3-15-（2-hard）"><a href="#2020-3-15-（2-hard）" class="headerlink" title="2020.3.15 （2 hard）"></a>2020.3.15 （2 hard）</h2><h3 id="第44题-通配符匹配"><a href="#第44题-通配符匹配" class="headerlink" title="第44题 通配符匹配"></a>第44题 通配符匹配</h3><p><img src="44.png" alt="第44题 通配符匹配"></p><h4 id="思路-25"><a href="#思路-25" class="headerlink" title="思路:"></a>思路:</h4><p>类似于第十题，可以采用相同的动态规划方法处理，甚至比第十题简单一些。由子串的匹配转移到当前串的匹配，直到转移至目标串和模式串的匹配。</p><pre><code>class Solution:    def isMatch(self, s: str, p: str) -&gt; bool:        dp=[[False for x in range(len(p)+1)] for x in range(len(s)+1)]        dp[-1][-1]=True        for i in range(len(s),-1,-1):#动态规划            for j in range(len(p)-1,-1,-1):                if p[j]==&quot;*&quot;:                    if i&lt;len(s):                        dp[i][j]=dp[i+1][j] or dp[i][j+1]                    else:                        dp[i][j]=dp[i][j+1]                else:                    if i&lt;len(s) and(p[j]==&quot;?&quot; or p[j]==s[i]):                        dp[i][j]=dp[i+1][j+1]        return dp[0][0]</code></pre><ul><li>时间复杂度:$O(MN)$</li><li>空间复杂度:$O(MN)$</li></ul><h4 id="更好的思路："><a href="#更好的思路：" class="headerlink" title="更好的思路："></a>更好的思路：</h4><p>有一种更好的思路来进行匹配，降低了时空复杂度，使用的是回溯和贪心的思想。具体看这里:<a href="https://leetcode-cn.com/problems/wildcard-matching/solution/tong-pei-fu-pi-pei-by-leetcode/" target="_blank" rel="noopener">40题解</a></p><h3 id="第45题-跳跃游戏2"><a href="#第45题-跳跃游戏2" class="headerlink" title="第45题 跳跃游戏2"></a>第45题 跳跃游戏2</h3><p><img src="45.png" alt="第45题 跳跃游戏2"></p><h4 id="思路-26"><a href="#思路-26" class="headerlink" title="思路:"></a>思路:</h4><p>贪心思路。在当前可以跳到的下一跳候选位置中，选择继续跳跃能够到达最远位置的候选位置，贪心地进行跳跃。当即将跳到数组末尾或者超过数组末尾时，返回当前步数加1，否则继续跳跃。</p><pre><code>class Solution:    def jump(self, nums: List[int]) -&gt; int:        now=0#当前位置        count=0#步数        l=len(nums)-1#数组末尾位置        if l==0:            return count        while True:            if now+nums[now]&gt;=l:#即将到达末尾                return count+1            farthest=0            next=0            for i in range(now+1,now+nums[now]+1):#贪心地选择能够抵达更远地方的下一跳位置                farthest_now=i+nums[i]                if farthest_now&gt;farthest:                    farthest=farthest_now                    next=i            now=next            count+=1</code></pre><h2 id="2020-3-16-（4-medium）"><a href="#2020-3-16-（4-medium）" class="headerlink" title="2020.3.16 （4 medium）"></a>2020.3.16 （4 medium）</h2><h3 id="第46题-全排列"><a href="#第46题-全排列" class="headerlink" title="第46题 全排列"></a>第46题 全排列</h3><p><img src="46.png" alt="第46题 全排列"></p><h4 id="思路-27"><a href="#思路-27" class="headerlink" title="思路:"></a>思路:</h4><p>深度优先搜索+回溯。</p><p>为了防止重复遍历数字，使用一个已访问矩阵来存储数字是否已被访问。</p><pre><code>class Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        result=[]        visited=[False for x in nums]        def dfs(re):            if (len(re)==len(nums)):                result.append(re)            else:                for i in range(len(nums)):                    if (visited[i]==False):                        re.append(nums[i])                        visited[i]=True                        dfs(re[:])                        re.pop()                        visited[i]=False        dfs([])        return result</code></pre><p>需要注意的是，一般回溯法中将路径列表添加至结果时，需要添加一个深拷贝，而不能是引用。否则它将跟随回溯变化。</p><h3 id="第47题-全排列2"><a href="#第47题-全排列2" class="headerlink" title="第47题 全排列2"></a>第47题 全排列2</h3><p><img src="47.png" alt="第47题 全排列2"></p><h4 id="思路-28"><a href="#思路-28" class="headerlink" title="思路:"></a>思路:</h4><p>与上一题基础的全排列类似，我们依然使用的是DFS+backtrack算法，但是在这里我们需要进行剪枝处理，去重。</p><p>去重的思路是：先排序，对于多个未访问的连续的相同数字，我们每次只选择第一个进行深度优先搜索，防止重复的搜索。</p><pre><code>class Solution:    def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:        result=[]        visited=[False for x in nums]        nums.sort()        def dfs(re):            if (len(re)==len(nums)):                result.append(re)            else:                for i in range(len(nums)):                    if (i!=0 and nums[i]==nums[i-1] and visited[i-1]==False):#剪枝处理                        continue                    if (visited[i]==False):                        re.append(nums[i])                        visited[i]=True                        dfs(re[:])                        re.pop()                        visited[i]=False        dfs([])        return result</code></pre><h3 id="第48题-旋转图像"><a href="#第48题-旋转图像" class="headerlink" title="第48题 旋转图像"></a>第48题 旋转图像</h3><p><img src="48.png" alt="第48题 旋转图像"></p><h4 id="思路-29"><a href="#思路-29" class="headerlink" title="思路:"></a>思路:</h4><p>先对数组进行转置，再对其进行左右翻转。</p><p>需要进行原地修改。</p><pre><code>class Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify matrix in-place instead.        &quot;&quot;&quot;        for i in range(len(matrix)):            for j in range(i+1,len(matrix[0])):                tmp=matrix[i][j]                matrix[i][j]=matrix[j][i]                matrix[j][i]=tmp        for i in range(len(matrix)):            for j in range(len(matrix[0])//2):                tmp=matrix[i][j]                matrix[i][j]=matrix[i][len(matrix)-j-1]                matrix[i][len(matrix)-j-1]=tmp        return matrix</code></pre><h3 id="第49题-字母异位词分组"><a href="#第49题-字母异位词分组" class="headerlink" title="第49题 字母异位词分组"></a>第49题 字母异位词分组</h3><p><img src="49.png" alt="第49题 字母异位"></p><h4 id="思路-30"><a href="#思路-30" class="headerlink" title="思路:"></a>思路:</h4><p>使用哈希表进行求解。将每个单词的字母按照字典序进行排序，作为哈希表的key，那么字母异位词必然会放入同一个key中。哈希表的value为对应key的字母异位词组成的列表。在最后输出values组成的列表即可。</p><pre><code>class Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        dic={}        for word in strs:            tmp=tuple(sorted(word))            if tmp not in dic.keys():                dic[tmp]=[word]            else:                dic[tmp].append(word)        return list(dic.values())</code></pre><p>实际上，还可以不用对单词进行排序，仅统计二十六个字母出现的次数，也能达到相同的效果，将时间复杂度由$O(NKlogK)$降为$O(NK)$</p><pre><code>class Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        dic={}        for word in strs:            tmp=[0 for x in range(26)]            for ch in word:                tmp[ord(ch)-ord(&#39;a&#39;)]+=1            tmp=tuple(tmp)            if tmp not in dic.keys():                dic[tmp]=[word]            else:                dic[tmp].append(word)        return list(dic.values())</code></pre><h2 id="2020-3-17-（1-medium-1-hard）"><a href="#2020-3-17-（1-medium-1-hard）" class="headerlink" title="2020.3.17 （1 medium 1 hard）"></a>2020.3.17 （1 medium 1 hard）</h2><h3 id="第50题-Pow（x-n）"><a href="#第50题-Pow（x-n）" class="headerlink" title="第50题 Pow（x,n）"></a>第50题 Pow（x,n）</h3><p><img src="50.png" alt="第50题 Pow（x,n）"></p><h4 id="思路-31"><a href="#思路-31" class="headerlink" title="思路:"></a>思路:</h4><p>快速幂算法，采用递归的思路，通过二分法进行加速，将时间复杂度从累乘法的$O(N)$减少到$O(logN)$。基本思想是将$X^n$用两个$X^/frac{n}{2}$表示，这里需要对n的奇偶性进行分类讨论，如果是奇数，无法被2整除的话，还需要再乘以一个x。不断向下二分递归求解，直到将问题转化为求解$X^1$和$X^0$，再层层回退求解结果。</p><p>具体思路有些类似于第29题两数相除，本质思想都是使用递归二分进行加速。</p><p>特别地，当n为负数时，可以将$X^n$转化为$/frac{1}{X}^{-n}$求解。</p><pre><code>class Solution:    def myPow(self, x: float, n: int) -&gt; float:        def fastpow(x,n):            if n==0:                return 1            if n&gt;0:                half=fastpow(x,n//2)                if n%2==0:                    return half*half                else:                    return x*half*half        if n&lt;0:            x=1/x            n=-n        return fastpow(x,n)</code></pre><p>特别地，需要注意Integer类型的补码机制问题，必要时可以采用long，不过python没有这个烦恼。</p><p>也可以使用非递归方式进行求解。</p><pre><code>class Solution:    def myPow(self, x: float, n: int) -&gt; float:        if n&lt;0:            x=1/x            n=-n        result=1        if n==0:            return 1.0        while (n&gt;0):            if n%2==0:                result*=2            else:                result=result*result*x            n//=2        return result</code></pre><h3 id="第51题-N皇后"><a href="#第51题-N皇后" class="headerlink" title="第51题 N皇后"></a>第51题 N皇后</h3><p><img src="51.png" alt="第51题 N皇后"></p><h4 id="思路-32"><a href="#思路-32" class="headerlink" title="思路:"></a>思路:</h4><p>和解数独和全排列等题目类似，依然是使用回溯算法进行递归求解。</p><p>在这个问题中，我们将棋盘看作是一个二维数组，按行进行递归，按列进行选择，每行选择一列放置皇后。如果每一行都能放置一个皇后，则可以将当前棋盘加入至结果数组。</p><p>特别地，我们需要判断当前位置是否可以放置一个皇后。由于皇后会攻击同行、同列、四个对角线上的棋子，所以我们需要保证当前行、当前列、当前四个对角线上没有别的皇后。前两个很好判断，对角线可以使用两个皇后的横坐标与纵坐标的差值绝对值是否相等来判断。</p><pre><code>class Solution:    def solveNQueens(self, n: int) -&gt; List[List[str]]:        def couldplace(chessboard,row,col):#是否可以放置            for i in range(row):                if chessboard[i]==col or abs(i-row)==abs(chessboard[i]-col):                    return False            return True        def trans(li):#将棋盘转化为输出格式            result=[]            for i in li:                result.append(&#39;.&#39;*(i)+&#39;Q&#39;+&#39;.&#39;*(n-i-1))            return result        result=[]        def back(chessboard,row):#递归回溯            if row&gt;=n:#当前行数若超过棋盘范围，则已放置完，可将当前棋盘加入结果数组                result.append(chessboard[:])            else:                for i in range(n):#进行选择                    if (couldplace(chessboard,row,i)):                        chessboard[row]=i                        back(chessboard,row+1)                        chessboard[row]=-1#回溯        chessboard=[-1 for i in range(n)]        back(chessboard,0)        for i in range(len(result)):            result[i]=trans(result[i])        return result</code></pre><p>这里，我使用了一种优化方法，每一次并没有存储真实的棋盘，而是开了一个二维数组，每个数组放置当前行的皇后位置。最后将其转化为输出格式即可。</p><h2 id="2020-3-18-（1-easy-2-medium）"><a href="#2020-3-18-（1-easy-2-medium）" class="headerlink" title="2020.3.18 （1 easy 2 medium）"></a>2020.3.18 （1 easy 2 medium）</h2><h3 id="第53题-最大子序和"><a href="#第53题-最大子序和" class="headerlink" title="第53题 最大子序和"></a>第53题 最大子序和</h3><p><img src="53.png" alt="第53题 最大子序和"></p><h4 id="思路-33"><a href="#思路-33" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划，状态矩阵dp[i]为以元素nums[i]结尾的子数组的最大连续和，转移方程为dp[i]=（1）nums[i]（if dp[i-1]&lt;=0） （2）dp[i-1]+nums[i]（if dp[i-1]&gt;0）。因为当前只有前面的连续子数组最大和为正数，才能对当前连续子数组最大和产生正贡献，否则只会使其变小。</p><p>特别地，为了节约空间，我们可以将nums列表原地修改为dp列表。</p><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code>class Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        max_sum=nums[0]        for i in range(1,len(nums)):            if nums[i-1]&gt;0:                nums[i]+=nums[i-1]            max_sum=max(nums[i],max_sum)#比较当前连续子数组和是否大于全局最大值        return max_sum</code></pre><h3 id="第54题-螺旋矩阵"><a href="#第54题-螺旋矩阵" class="headerlink" title="第54题 螺旋矩阵"></a>第54题 螺旋矩阵</h3><p><img src="54.png" alt="第54题 螺旋矩阵"></p><h4 id="思路-34"><a href="#思路-34" class="headerlink" title="思路:"></a>思路:</h4><p>按圈模拟指针的变化。这一类题目需要自己寻找一下指针变化的规律。</p><pre><code>class Solution:    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:        level=0#圈数        row=0        col=0        if matrix==[]:            return []        result=[matrix[row][col]]        count=1#步数        row_nums=len(matrix)        col_nums=len(matrix[0])        size=row_nums*col_nums        while count&lt;size:            for i in range(level+1,col_nums-level):                col+=1                result.append(matrix[row][col])                count+=1                if count&gt;=size:                    return result            for i in range(level+1,row_nums-level):                row+=1                result.append(matrix[row][col])                count+=1                if count&gt;=size:                    return result            for i in range(level+1,col_nums-level):                col-=1                result.append(matrix[row][col])                count+=1                if count&gt;=size:                    return result            for i in range(level+1,row_nums-level-1):                row-=1                result.append(matrix[row][col])                count+=1                if count&gt;=size:                    return result            #模拟顺时针的遍历，这里写的比较冗余，实际上可以使用列表+取余的方式简化增量的计算。            level+=1            col+=1            result.append(matrix[row][col])            count+=1        return result</code></pre><h3 id="第55题-跳跃游戏"><a href="#第55题-跳跃游戏" class="headerlink" title="第55题 跳跃游戏"></a>第55题 跳跃游戏</h3><p><img src="55.png" alt="第55题 跳跃游戏"></p><h4 id="思路-35"><a href="#思路-35" class="headerlink" title="思路:"></a>思路:</h4><p>我们基于这样的一个假设：如果能跳到位置i，那么位置i之前的所有位置0，1…i-1都能跳到。</p><p>那么问题已经迎刃而解了，我们遍历每一个位置，如果当前位置无法被跳到（大于当前所能到达的最远位置），则说明后面的所有位置都无法跳到，自然也就无法到达数组的末尾。如果当前位置可以跳到，将其所能到达的最远位置与当前最远位置比较，取最大值进行更新当前最远位置。</p><p>时间复杂度：$O(N)$</p><p>空间复杂度: $O(1)$</p><pre><code>class Solution:    def canJump(self, nums: List[int]) -&gt; bool:        farthest=0        for i in range(len(nums)):            if i&gt;farthest:                return False            farthest=max(farthest,i+nums[i])        return True</code></pre><p>也可以和跳跃游戏2一样采用贪心算法求解，不过时间复杂度会高一些。</p><h2 id="2020-3-19-（2-medium-1-hard）"><a href="#2020-3-19-（2-medium-1-hard）" class="headerlink" title="2020.3.19 （2 medium 1 hard）"></a>2020.3.19 （2 medium 1 hard）</h2><h3 id="第56题-合并区间"><a href="#第56题-合并区间" class="headerlink" title="第56题 合并区间"></a>第56题 合并区间</h3><p><img src="56.png" alt="第56题 合并区间"></p><h4 id="思路-36"><a href="#思路-36" class="headerlink" title="思路:"></a>思路:</h4><p>先按每个区间的左边界，为所有区间进行升序排序。接着，遍历每个区间，若当前区间的右边界大于或等于下一区间的左边界，那么说明二者有重复，可以进行合并。合并后，新区间的左边界为当前区间的左边界（升序排序），有边界为两个区间右边界的最大值（两种情况）。将下一区间原地修改为合并后的新区间，可以节约空间，并将当前区间置空。完成后，继续向前遍历。</p><p>最后，将所有空列表进行删除处理，返回最终的列表即可。</p><p>时间复杂度：$O(N)$</p><p>空间复杂度：$O(1)$</p><pre><code>class Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        if len(intervals)&gt;1:            intervals.sort()            for i in range(len(intervals)-1):                if intervals[i][1]&gt;=intervals[i+1][0]:                    intervals[i+1][0]=intervals[i][0]                    intervals[i+1][1]=max(intervals[i][1],intervals[i+1][1])                    intervals[i]=[]            for i in range(len(intervals)-1,-1,-1):                if intervals[i]==[]:                    intervals.remove([])        return intervals</code></pre><h3 id="第57题-插入区间"><a href="#第57题-插入区间" class="headerlink" title="第57题 插入区间"></a>第57题 插入区间</h3><p><img src="57.png" alt="第57题 插入区间"></p><h4 id="思路-37"><a href="#思路-37" class="headerlink" title="思路:"></a>思路:</h4><p>二分查找插入位置，插入新区间，然后采用上一题的思路进行合并。插入需要耗费$O(logN)$，合并需要耗费$O(N)$，总时间复杂度为$O(NlogN)$。</p><pre><code>class Solution:    def insert(self, intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:        def search(target):            left=0            right=len(intervals)-1            while (left&lt;=right):                mid=(left+right)//2                if (intervals[mid][0]==target):                    return mid                elif (intervals[mid][0]&gt;target):                    right=mid-1                else:                    left=mid+1            return left        insert_pos=search(newInterval[0])        intervals.insert(insert_pos,newInterval)        if len(intervals)&gt;1:            for i in range(len(intervals)-1):                if intervals[i][1]&gt;=intervals[i+1][0]:                    intervals[i+1][0]=intervals[i][0]                    intervals[i+1][1]=max(intervals[i][1],intervals[i+1][1])                    intervals[i]=[]            for i in range(len(intervals)-1,-1,-1):                if intervals[i]==[]:                    intervals.remove([])        return intervals</code></pre><p>还可以使用贪心算法，先将新区间插入至插入位置，并将其与前一个区间尝试合并。再向后遍历，尝试合并，直到无法进行合并。</p><h3 id="第60题-第k个排列"><a href="#第60题-第k个排列" class="headerlink" title="第60题 第k个排列"></a>第60题 第k个排列</h3><p><img src="60.png" alt="第60题 第k个排列"></p><h4 id="思路-38"><a href="#思路-38" class="headerlink" title="思路:"></a>思路:</h4><p>DFS算法，因为n！种排列本质是由n组n-1！排列组合而成，根据这一性质，我们可以得知当前的偏移值在哪一组n-1！中，从而计算得到当前位置上应填入的数字，接着取余数获取新的偏移值，不断递归，直到获取最终结果。</p><p>这里的DFS不需要进行回溯，因为每一位数字只有一个是符合条件的，不需要恢复状态去进行下一个选择。</p><pre><code>class Solution:    def getPermutation(self, n: int, k: int) -&gt; str:        def factorial(n):#求解n!            result=1            for i in range(2,n+1):                result*=i            return result        visited=[False for _ in range(n)]        def dfs(n,k,result):            if n==0:                return result            f=factorial(n-1)            base=k//f            offset=k%f            for i in range(len(visited)):                if visited[i]==False:                    if base&lt;=0:#第base个未访问过的元素，即为当前位置上应该填入的数字                        result+=str(i+1)                        visited[i]=True                        return dfs(n-1,offset,result)                    else:                        base-=1        return dfs(n,k-1,&quot;&quot;)#这里数组从0开始，需要将k减1</code></pre><h2 id="2020-3-20-（4-medium）"><a href="#2020-3-20-（4-medium）" class="headerlink" title="2020.3.20 （4 medium）"></a>2020.3.20 （4 medium）</h2><h3 id="第61题-旋转链表"><a href="#第61题-旋转链表" class="headerlink" title="第61题 旋转链表"></a>第61题 旋转链表</h3><p><img src="61.png" alt="第61题 旋转链表"></p><h4 id="思路-39"><a href="#思路-39" class="headerlink" title="思路:"></a>思路:</h4><p>快慢指针法+头插法。</p><p>先统计链表的长度L，令K=K%L，放置进行重复的旋转。再使用快慢指针定位链表最后K个元素的起始位置和终止位置，并将这K个元素插入至链表头部即可。</p><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def rotateRight(self, head: ListNode, k: int) -&gt; ListNode:        dummyhead=ListNode(0)        dummyhead.next=head        fast=slow=dummyhead        l=0        p=dummyhead        if head!=None:            while (p.next!=None):                p=p.next                l+=1            k%=l            while (fast.next!=None):                if (k&gt;0):                    fast=fast.next                    k-=1                else:                    slow=slow.next                    fast=fast.next            fast.next=dummyhead.next            dummyhead.next=slow.next            slow.next=None        return dummyhead.next</code></pre><p>也可以将原先的链表修改成一个环，再从原倒数第K%L个元素处断开环，新得到的链表即为旋转后链表。</p><h3 id="第62题-不同路径"><a href="#第62题-不同路径" class="headerlink" title="第62题 不同路径"></a>第62题 不同路径</h3><p><img src="62.png" alt="第62题 不同路径"></p><h4 id="思路-40"><a href="#思路-40" class="headerlink" title="思路:"></a>思路:</h4><p>我的最初思路想当然地考虑到了DFS+回溯算法，这也是这一类走迷宫问题的常用算法。</p><p>但是，我很快观察到，这道题里有重叠的子问题，那么使用递归将非常缓慢。例如，从位置（0，1）和位置（1，0）都可以走到位置（1，1），如果我们使用递归，将重复从位置（1，1）向下搜索可行解两次，导致了不必要的时间消耗。</p><p>解决重叠子问题的方法就是动态规划。这道题里，我们的状态矩阵dp[i][j]为到达网格中（i，j）位置的路径数目，转移方程为：</p><ol><li>dp[i][j]=1,if i==0 and j==0;</li><li>dp[i][j]=dp[i-1][j],if i&gt;0 and j==0;</li><li>dp[i][j]=dp[i][j-1],if j&gt;0 and i==0;</li><li>dp[i][j]=dp[i-1][j]+dp[i][j-1],if i&gt;0 and j&gt;0.</li></ol><pre><code>class Solution:    def uniquePaths(self, m: int, n: int) -&gt; int:        dp=[[0 for _ in range(m)] for _ in range(n)]#状态矩阵        dp[0][0]=1        for i in range(n):#状态转移            for j in range(m):                if i&gt;0 and j==0:                    dp[i][j]=dp[i-1][j]                elif i==0 and j&gt;0:                    dp[i][j]=dp[i][j-1]                elif i&gt;0 and j==0:                    dp[i][j]=dp[i-1][j]                elif i&gt;0 and j&gt;0:                    dp[i][j]=dp[i][j-1]+dp[i-1][j]        return dp[n-1][m-1]</code></pre><h3 id="第63题-不同路径2"><a href="#第63题-不同路径2" class="headerlink" title="第63题 不同路径2"></a>第63题 不同路径2</h3><p><img src="63.png" alt="第63题 不同路径"></p><h4 id="思路-41"><a href="#思路-41" class="headerlink" title="思路:"></a>思路:</h4><p>思路与上一题基本一致，唯一的区别在于当状态矩阵转移到有障碍物的位置时，应将状态矩阵该位置修改为0.因为很明显该位置有了障碍物后不可达。</p><p>特别地，我们可以将题目提供的数组原地修改为状态矩阵，便可只适用常数级别的额外空间。</p><pre><code>class Solution:    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:        if obstacleGrid[0][0]==1:#初始位置有障碍物，并不可能到达终点            return 0        obstacleGrid[0][0]=1        for i in range(len(obstacleGrid)):            for j in range(len(obstacleGrid[0])):                if obstacleGrid[i][j]==1 and (i&gt;0 or j&gt;0):#将有障碍物的位值设为不可达                    obstacleGrid[i][j]=0                else:#状态转移                    if i&gt;0 and j==0:                        obstacleGrid[i][j]=obstacleGrid[i-1][j]                    elif i==0 and j&gt;0:                        obstacleGrid[i][j]=obstacleGrid[i][j-1]                    elif i&gt;0 and j&gt;0:                        obstacleGrid[i][j]=obstacleGrid[i][j-1]+obstacleGrid[i-1][j]        return obstacleGrid[-1][-1]</code></pre><h3 id="第64题-最小路径和"><a href="#第64题-最小路径和" class="headerlink" title="第64题 最小路径和"></a>第64题 最小路径和</h3><p><img src="64.png" alt="第64题 最小路径和"></p><h4 id="思路-42"><a href="#思路-42" class="headerlink" title="思路:"></a>思路:</h4><p>与62、63题思路基本一致，仍然是动态规划的思想。转移方程略有不同，核心是当前位置上的数字加上上方位置和左侧位置的路径和的最小值。</p><pre><code>class Solution:    def minPathSum(self, grid: List[List[int]]) -&gt; int:        for i in range(len(grid)):            for j in range(len(grid[0])):                if i&gt;0 and j==0:                    grid[i][j]+=grid[i-1][j]                elif i==0 and j&gt;0:                    grid[i][j]+=grid[i][j-1]                elif i&gt;0 and j&gt;0:                    grid[i][j]+=min(grid[i][j-1],grid[i-1][j])        return grid[-1][-1]</code></pre><h2 id="2020-3-29-（1-medium-1-hard）"><a href="#2020-3-29-（1-medium-1-hard）" class="headerlink" title="2020.3.29 （1 medium 1 hard）"></a>2020.3.29 （1 medium 1 hard）</h2><h3 id="第72题-编辑距离"><a href="#第72题-编辑距离" class="headerlink" title="第72题 编辑距离"></a>第72题 编辑距离</h3><p><img src="72.png" alt="第72题 编辑距离"></p><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>动态规划的经典模板题之一，设dp[i] [j]为word1的前i个字符调整至word2的前j个字符所需的最少操作数目。则dp转移方程为：</p><ul><li>dp[i] [j]=0，if i==0 and j==0（空字符串到空字符串，不需要编辑）</li><li>dp[i] [j]=i，if i&gt;0 and j==0（word1的前i个字符调整至空字符串，需要删除i次）</li><li>dp[i] [j]=j，if i==0 and j&gt;0（空字符串调整至word2的前j个字符串，需要添加j次）</li><li>dp[i] [j]=dp[i-1] [j-1]，if i&gt;0 and j&gt;0 and word1[i-1]==word2[j-1] （如果word1的第i个字符和word2的第j个字符相等，那么这一位上不需要操作，直接看word1的前i-1个字符调整至word2的前j-1个字符需要几步即可）</li><li>dp[i] [j]=min（dp[i-1] [j]，dp[i] [j-1], dp[i-1] [j-1]）+1，if i&gt;0 and j&gt;0 and word1[i-1]!=word2[j-1] （如果word1的第i个字符和word2的第j个字符不相等，那我们假设当前的匹配是由添加、删除、替换一个字符而来的，比较三者操作前的状态需要的最少操作数目，选取最小值加上当前这一步，作为当前的最少操作数目）</li></ul><blockquote><p>以 word1 为 “horse”，word2 为 “ros”，且 dp[5] [3] 为例，即要将 word1的前 5 个字符转换为 word2的前 3 个字符，也就是将 horse 转换为 ros，因此有：</p><p>(1) dp[i-1] [j-1]，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 2 个字符 ro，然后将第五个字符 word1[4]（因为下标基数以 0 开始） 由 e 替换为 s（即替换为 word2 的第三个字符，word2[2]）</p><p>(2) dp[i] [j-1]，即先将 word1 的前 5 个字符 horse 转换为 word2 的前 2 个字符 ro，然后在末尾补充一个 s，即插入操作</p><p>(3) dp[i-1] [j]，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 3 个字符 ros，然后删除 word1 的第 5 个字符</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word1<span class="token punctuation">:</span> str<span class="token punctuation">,</span> word2<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>word2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>word1<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>word1<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>word2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>                <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>j                <span class="token keyword">elif</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> word1<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span>word2<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度: $O(MN)$。</li><li>空间复杂度：$O(MN)$。</li><li>这一题有些类似于通识符匹配的那道题。</li></ul><h3 id="第75题-颜色分类"><a href="#第75题-颜色分类" class="headerlink" title="第75题 颜色分类"></a>第75题 颜色分类</h3><p><img src="75.png" alt="第75题 颜色分类"></p><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>三路快排的思想。使用三个指针curr，p0，p2。curr用于遍历数组，p0用于表示全0区间的右边界的下一个位置，p2用于表示全2区间的左边界的下一个位置。具体扫描算法如下：</p><ul><li>当curr小于p2时（说明所有元素尚且没有被扫描完）：<ul><li>如果nums[curr]==0，那么将nums[curr]与nums[p0]交换，并且curr加1，p0加1，相当于全0区间向右扩展了，且由于当前数必然是1或者0，所以可以向后继续遍历（因为之前的元素都已经被遍历过，如果是2会被交换到后面去）。</li><li>如果nums[curr]==2，那么将nums[curr]与nums[p2]交换，并且p2减1，相当于全2区间向左扩展了。由于此时交换过来的数字我们不知道是0、1还是2，所以curr不能加一，还需要继续判断当前元素。</li><li>如果nums[curr]==1，那么直接使curr加1，向后继续遍历。</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortColors</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify nums in-place instead.        """</span>        curr<span class="token punctuation">,</span>p0<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        p2<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token operator">&lt;=</span>p2<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>p0<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>p0<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span>                curr<span class="token operator">+=</span><span class="token number">1</span>                p0<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                curr<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span>                p2<span class="token operator">-=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度: $O(N)$。</li><li>空间复杂度：$O(1)$。</li><li>这道题既有些像快排，使用指针维护区间的思想也有些像26题和27题。</li></ul><h2 id="2020-3-30-（1-medium-1-hard）"><a href="#2020-3-30-（1-medium-1-hard）" class="headerlink" title="2020.3.30 （1 medium 1 hard）"></a>2020.3.30 （1 medium 1 hard）</h2><h3 id="第76题-最小覆盖子串"><a href="#第76题-最小覆盖子串" class="headerlink" title="第76题 最小覆盖子串"></a>第76题 最小覆盖子串</h3><p><img src="76.png" alt="第76题 最小覆盖子串"></p><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><p>经典的滑动窗口题，类似的题目还有 <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">无重复字符的最长子串</a> 、 <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">找到字符串中所有字母异位词</a> 等。基本思路都是使用双指针维护一个符合题目要求的滑动区间。</p><p>本题中，我们使用双指针left和right，right负责向前遍历搜索，如果区间[left：right+1]包含了T中所有的字母，我们尝试移动left，保证当前区间仍然包含T中所有的字母。如果left移动后区间不符合要求，我们记录当前区间，将其与最小覆盖子串比较，更新最小覆盖子串。然后，right继续向前搜索，直到最后一个字符。</p><ul><li>时间复杂度：$O(M+N)$, M为s长度，N为t长度。 在最坏的情况下，可能会对S中的每个元素遍历两遍，左指针和右指针各一遍。 </li><li>空间复杂度：$O(1)$。最多128个字符。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span><span class="token number">0</span>        count_t<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#哈希表统计t中每个字符出现的次数</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> t<span class="token punctuation">:</span>            <span class="token keyword">if</span> ch <span class="token operator">not</span> <span class="token keyword">in</span> count_t<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                count_t<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                count_t<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>        formed<span class="token operator">=</span><span class="token number">0</span><span class="token comment" spellcheck="true">#已覆盖的字符数（指的是不重复的字符）</span>        min_length<span class="token operator">=</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span>        min_st<span class="token operator">=</span><span class="token string">""</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#右区间遍历搜索s的所有字符</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token keyword">in</span> count_t<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> count_t<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当前字符所有出现次数被完全覆盖</span>                    formed<span class="token operator">+=</span><span class="token number">1</span>                count_t<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">if</span> formed<span class="token operator">==</span>len<span class="token punctuation">(</span>count_t<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#完全覆盖了t中所有的字符</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#左区间收缩，尝试寻找最小覆盖字串</span>                    <span class="token keyword">if</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token keyword">in</span> count_t<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        count_t<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>                        <span class="token keyword">if</span> count_t<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#失去匹配</span>                            formed<span class="token operator">-=</span><span class="token number">1</span>                            left<span class="token operator">+=</span><span class="token number">1</span>                            <span class="token keyword">break</span>                    left<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> right<span class="token operator">-</span>left<span class="token operator">&lt;</span>min_length<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#记录失配前的最小子串，更新当前最小覆盖字串</span>                        min_length<span class="token operator">=</span>right<span class="token operator">-</span>left                        min_st<span class="token operator">=</span>s<span class="token punctuation">[</span>left<span class="token number">-1</span><span class="token punctuation">:</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>            right<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> min_st<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第79题-单词搜索"><a href="#第79题-单词搜索" class="headerlink" title="第79题 单词搜索"></a>第79题 单词搜索</h3><p><img src="79.png" alt="第79题 单词搜索"></p><h4 id="思路-43"><a href="#思路-43" class="headerlink" title="思路:"></a>思路:</h4><p>DFS模板题，剑指Offer原题，基本思路就是从每一个单元格开始向上下左右四个方向递归深搜，如果当前单元格不越界且匹配，那么继续搜索下一个字符。考虑到不能搜索重复的单元格，需要使用visited矩阵进行判断，并对其回溯。为了减少空间复杂度，可以原地修改board为visited。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exist</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>            <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index<span class="token operator">==</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> index<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span>word<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>                    tmp<span class="token punctuation">,</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token boolean">False</span>                    <span class="token keyword">if</span> dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> dfs<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token number">-1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> dfs<span class="token punctuation">(</span>row<span class="token number">-1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">True</span>                    board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span>tmp            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-3-31（2-hard）"><a href="#2020-3-31（2-hard）" class="headerlink" title="2020.3.31（2 hard）"></a>2020.3.31（2 hard）</h2><h3 id="第84题-柱状图中最大的矩形"><a href="#第84题-柱状图中最大的矩形" class="headerlink" title="第84题 柱状图中最大的矩形"></a>第84题 <a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">柱状图中最大的矩形</a></h3><p><img src="84.png" alt="第84题 柱状图中最大的矩形"></p><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>由于矩形的面积和区间内最小高度的柱子有关，我们先尝试基本做法动态规划，DP求解数组中每一个区间的最小高度，然后乘以区间的宽度，尝试更新当前最大面积。尝试后发现超时，时间复杂度为$O(n^2)$。</p><p>为了减少时间复杂度，我们可以尝试分治法。通过观察，可以发现，最大面积矩形存在于以下几种情况：</p><ol><li><p>确定了最矮柱子以后，矩形的宽尽可能往两边延伸。</p></li><li><p>在最矮柱子左边的最大面积矩形（子问题）。</p></li><li><p>在最矮柱子右边的最大面积矩形（子问题）。</p></li></ol><p>找到了划分子问题的方法，我们可以尝试分治算法求解。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> heights<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> left<span class="token operator">></span>right <span class="token operator">or</span> left<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">or</span> right<span class="token operator">>=</span>len<span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            tmp<span class="token operator">=</span>heights<span class="token punctuation">[</span>left<span class="token punctuation">:</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>            min_height<span class="token operator">=</span>min<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>            min_pos<span class="token operator">=</span>tmp<span class="token punctuation">.</span>index<span class="token punctuation">(</span>min_height<span class="token punctuation">)</span><span class="token operator">+</span>left            <span class="token keyword">return</span> max<span class="token punctuation">(</span>min_height<span class="token operator">*</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>max<span class="token punctuation">(</span>recur<span class="token punctuation">(</span>left<span class="token punctuation">,</span>min_pos<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>recur<span class="token punctuation">(</span>min_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> recur<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而，我们发现，虽然分治法的平均时间复杂度为$O(nlogn)$，但依然存在着缺陷，即假如数组有序，那么分治法将退化为暴力算法，时间复杂度为$O(n^2)$。</p><p>为了进一步优化，我们需要尝试以空间换时间的算法。我们知道，这道题还有一种暴力的思路，就是类似于最小回文子串问题的中心扩展法，即“ 依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度多少。 ”</p><p><img src="84-2.png" alt="暴力求解"></p><p>这个算法的核心思想是找到每个高度的柱子左侧和右侧的第一个高度小于它的柱子，利用他们所夹的区间和当前柱子的高度即可得到当前高度的矩形的最大面积。时间复杂度为$O(n^2)$。</p><p>那么有没有办法优化它呢？我们可以使用一个单调栈来解决这个问题。</p><ul><li>栈中存放当前高度数组的下标，并在当前高度数组的两端增加高度为0的哨兵，以减少判断。</li><li>遍历高度数组，维持当前栈的非递减性。如果当前高度小于栈顶下标的高度，那么说明栈顶元素必然被当前高度和之前某个高度夹在中间，根据我们之前的中心扩散算法，可以得到该栈顶元素代表的高度的矩阵的最大面积。具体的做法是：栈顶元素不断出栈，查看它出栈后的栈顶元素是否小于它，小于则找到了左边界，然后利用我们当前遍历到的高度作为右边界，计算当前矩阵最大面积，尝试更新结果。</li><li>继续上述过程，直到当前高度大于或等于栈顶下标高度，此时，将当前高度入栈，继续向前并遍历。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> heights<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        heights<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>heights<span class="token operator">+</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#引入哨兵</span>        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>heights<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#此时栈顶下标高度的矩形的面积可被确定</span>                now<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">while</span> heights<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">==</span>heights<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#寻找左边界，即第一个小于栈顶元素的高度</span>                    stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                res<span class="token operator">=</span>max<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">-</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>heights<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#更新结果</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#当前下标入栈（为什么是下标，因为我们要计算矩形的宽度）</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$，每个元素都要出栈、入栈各一次。</li><li>空间复杂度：$O(n)$，维护一个单调栈。</li></ul><h3 id="85题-最大矩形"><a href="#85题-最大矩形" class="headerlink" title="85题 最大矩形"></a>85题 <a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">最大矩形</a></h3><p><img src="85.png" alt="第85题 最大矩形"></p><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><p>基本思路是将求解矩阵中的最大矩形转化为84题中的柱状图中的最大矩形，然后再使用84题的单调栈方法求解。对于矩阵的每一个位置，我们可以求解其位置上“1”的高度，然后对于矩阵中的每一行，我们可以计算出当前行上”1“矩阵的最大面积，并尝试更新结果。</p><ul><li>时间复杂度：$O(MN)$，计算高度时遍历一次矩阵，计算最大面积时再遍历一次矩阵，共2MN次。</li><li>空间复杂度：$O(N)$，每一次求解每行的最大面积时，需要使用一个与列数大小相等的单调栈。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maximalRectangle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">getLargestArea</span><span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token punctuation">:</span>            heights<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>heights<span class="token operator">+</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            res<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>heights<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    now<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>heights<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">==</span>heights<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                    res<span class="token operator">=</span>max<span class="token punctuation">(</span>heights<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">-</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">return</span> res        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>int<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span> <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'0'</span> <span class="token keyword">else</span> <span class="token number">1</span><span class="token operator">+</span>matrix<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>            res<span class="token operator">=</span>max<span class="token punctuation">(</span>getLargestArea<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-1-（3-medium）"><a href="#2020-4-1-（3-medium）" class="headerlink" title="2020.4.1 （3 medium）"></a>2020.4.1 （3 medium）</h2><h3 id="94题-二叉树的中序遍历"><a href="#94题-二叉树的中序遍历" class="headerlink" title="94题 二叉树的中序遍历"></a>94题 <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></h3><p><img src="94.png" alt="第94题"></p><h5 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h5><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="非递归解法"><a href="#非递归解法" class="headerlink" title="非递归解法"></a>非递归解法</h5><p>思路：使用辅助栈。只要弄懂了递归的过程，就可以使用栈来模拟。</p><p>每到一个节点 A，因为根的访问在中间，将 A 入栈。然后遍历左子树，接着访问 A，最后遍历右子树。在访问完 A 后，A 就可以出栈了。因为 A 和其左子树都已经访问完成。</p><p>二叉树的先序、中序、后序遍历的非递归解法都是使用一个辅助栈来暂存需要回过头来访问的节点，从而代替递归函数的返回过程。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        p<span class="token operator">=</span>root        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">or</span> stack<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历左子树，不断将当前节点入栈，因为要遍历完左子树才能访问</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>left            p<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#遍历完左子树后，取出栈顶元素，进行访问</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>right<span class="token comment" spellcheck="true">#继续遍历右子树</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(N)$，所有节点各入栈出栈一次。</li><li>空间复杂度：$O(N)$，最坏情况下需要大小为N的辅助栈。</li></ul><h3 id="144题-二叉树的前序遍历"><a href="#144题-二叉树的前序遍历" class="headerlink" title="144题 二叉树的前序遍历"></a>144题 <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历</a></h3><p><img src="144.png" alt="第144题"></p><h5 id="递归解法-1"><a href="#递归解法-1" class="headerlink" title="递归解法"></a>递归解法</h5><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        preorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="非递归解法-1"><a href="#非递归解法-1" class="headerlink" title="非递归解法"></a>非递归解法</h5><p>思路：依然使用辅助栈，先将当前节点的右孩子入栈保存，然后访问当前节点，接着遍历当前节点的左孩子。遍历完左子树后，继续遍历右子树。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        p<span class="token operator">=</span>root        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">or</span> stack<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#先访问当前节点</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#暂存右孩子至栈中，等遍历完左子树开始访问</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>left<span class="token comment" spellcheck="true">#遍历左孩子</span>            p<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#遍历完左子树后，开始遍历右子树</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="145题-二叉树的后序遍历"><a href="#145题-二叉树的后序遍历" class="headerlink" title="145题 二叉树的后序遍历"></a>145题 二叉树的后序遍历</h3><p><img src="145.png" alt="第145题"></p><h5 id="递归解法-2"><a href="#递归解法-2" class="headerlink" title="递归解法"></a>递归解法</h5><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>                postorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                postorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        postorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="非递归解法-2"><a href="#非递归解法-2" class="headerlink" title="非递归解法"></a>非递归解法</h5><p>思路：我们知道，二叉树的后序遍历是“左-右-根”，而二叉树的逆前序遍历是“右-左-根”，所以我们可以使用辅助栈实现二叉树的逆前序遍历后，再将结果翻转，即为后序遍历。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        p<span class="token operator">=</span>root        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">or</span> stack<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>right            p<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-2-（2-medium-1easy）"><a href="#2020-4-2-（2-medium-1easy）" class="headerlink" title="2020.4.2 （2 medium 1easy）"></a>2020.4.2 （2 medium 1easy）</h2><h3 id="96题-不同的二叉搜索树"><a href="#96题-不同的二叉搜索树" class="headerlink" title="96题 不同的二叉搜索树"></a>96题 <a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">不同的二叉搜索树</a></h3><p><img src="96.png" alt="第96题"></p><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><p>动态规划求解，DFS太耗费时间。我们设状态矩阵DP[i]为1..i为节点的二叉搜索树的数目，f[i]为以i为根节点的二叉搜索树数目，则有：</p><ul><li>DP[i]=f[1]+f[2]+…+f[i]，即计算以1到i的每个节点为根节点的二叉搜索树数目之和。</li><li>f[j]=DP[j-1]*DP[i-j]，即以j为根节点的二叉搜索树，左侧有j-1个节点，右侧有i-j个节点，又因为j+1到i为节点的二叉搜索树数目与1到i-j的二叉搜索树一致，所以可以用DP[i-j]来代替。则左右两边子树组合数目为DP[j-1]乘以DP[i-j]。</li><li>则动态规划转移方程为：DP[i]=DP[0] <em> DP[i-1]+DP[1] </em> DP[i-2]+…+DP[i] * DP[0]</li><li>这个动态规划方程在数学上有一个名字，叫做“卡特兰数”</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token comment" spellcheck="true">#注意，这里的0个数组成的二叉搜索树数目为1，这是因为左子树为空也合法。</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>dp<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="98题-验证二叉搜索树"><a href="#98题-验证二叉搜索树" class="headerlink" title="98题 验证二叉搜索树"></a>98题 <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a></h3><p><img src="98.png" alt="第98题"></p><h4 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h4><p>我们知道，如果我们中序遍历二叉搜索树，那么得到的序列必然是递增的，我们就可以通过这一性质验证二叉搜索树。我们中序遍历二叉搜索树，并且记录下当前中序遍历得到的序列的最后一个元素值，如果当前元素值大于它，说明满足二叉搜索树的性质，可以继续递归判断。如果非递增了，就返回False。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>last_value<span class="token operator">=</span>None        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#我们认为空子树是二叉搜索树，方便递归</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历左子树，看是否满足递增</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>last_value<span class="token operator">==</span>None <span class="token operator">or</span> root<span class="token punctuation">.</span>val<span class="token operator">></span>self<span class="token punctuation">.</span>last_value<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#看当前节点是否满足递增</span>                    self<span class="token punctuation">.</span>last_value<span class="token operator">=</span>root<span class="token punctuation">.</span>val                    <span class="token keyword">if</span> inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#看右子树是否满足递增</span>                        <span class="token keyword">return</span> <span class="token boolean">True</span><span class="token comment" spellcheck="true">#如果左中右都满足，返回True</span>            <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token comment" spellcheck="true">#如果有一项不满足，返回False</span>        <span class="token keyword">return</span> inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="101题-对称二叉树"><a href="#101题-对称二叉树" class="headerlink" title="101题 对称二叉树"></a>101题 <a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">对称二叉树</a></h3><p><img src="101.png" alt="第101题"></p><h4 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer类似题，递归求解法，我们知道，两个节点对称的条件为：</p><ol><li>两个节点均为空。</li><li>两个节点均不为空，且节点a的值等于节点b的值，且节点a的左子树和节点b的右子树镜像，节点b的左子树和节点a的右子树镜像。</li></ol><p>当根节点非空时，我们递归判断左右子树是否对称即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> a<span class="token operator">==</span>None <span class="token operator">and</span> b<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> a<span class="token operator">!=</span>None <span class="token operator">and</span> b<span class="token operator">!=</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> a<span class="token punctuation">.</span>val<span class="token operator">==</span>b<span class="token punctuation">.</span>val <span class="token operator">and</span> match<span class="token punctuation">(</span>a<span class="token punctuation">.</span>left<span class="token punctuation">,</span>b<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">and</span> match<span class="token punctuation">(</span>a<span class="token punctuation">.</span>right<span class="token punctuation">,</span>b<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> match<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(n)$。</li></ul><h2 id="2020-4-3-（2-medium-1easy）"><a href="#2020-4-3-（2-medium-1easy）" class="headerlink" title="2020.4.3 （2 medium 1easy）"></a>2020.4.3 （2 medium 1easy）</h2><h3 id="第104题-二叉树的最大深度"><a href="#第104题-二叉树的最大深度" class="headerlink" title="第104题 二叉树的最大深度"></a>第104题 <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a></h3><p><img src="104.png" alt="第104题"></p><h4 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h4><p>数据结构基本题，剑指offer二叉树原题，递归搜索即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第105题-从前序与中序遍历序列构造二叉树"><a href="#第105题-从前序与中序遍历序列构造二叉树" class="headerlink" title="第105题  从前序与中序遍历序列构造二叉树"></a>第105题 <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener"> 从前序与中序遍历序列构造二叉树</a></h3><p><img src="105.png" alt="第105题"></p><h4 id="思路：-10"><a href="#思路：-10" class="headerlink" title="思路："></a>思路：</h4><p>数据结构基本题，剑指offer二叉树原题，分治法即可。</p><ul><li>前序遍历确定当前子树的根节点。</li><li>中序遍历确定左右子树节点数目。</li><li>根据左右子树节点数目，从前序、中序遍历中切分出左、右子树的前序、中序遍历，分治法确定当前节点左右孩子。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>preL<span class="token punctuation">,</span>preR<span class="token punctuation">,</span>inL<span class="token punctuation">,</span>inR<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> preL<span class="token operator">></span>preR <span class="token operator">or</span> inL<span class="token operator">></span>inR<span class="token punctuation">:</span>                <span class="token keyword">return</span> None            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preL<span class="token punctuation">]</span><span class="token punctuation">)</span>            in_pos<span class="token operator">=</span>inorder<span class="token punctuation">[</span>inL<span class="token punctuation">:</span>inR<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preL<span class="token punctuation">]</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>left<span class="token operator">=</span>build<span class="token punctuation">(</span>preL<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>preL<span class="token operator">+</span>in_pos<span class="token punctuation">,</span>inL<span class="token punctuation">,</span>inL<span class="token operator">+</span>in_pos<span class="token number">-1</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>build<span class="token punctuation">(</span>preL<span class="token operator">+</span>in_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>preR<span class="token punctuation">,</span>inL<span class="token operator">+</span>in_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>inR<span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token keyword">return</span> build<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>preorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>inorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第114题-二叉树展开为链表"><a href="#第114题-二叉树展开为链表" class="headerlink" title="第114题 二叉树展开为链表"></a>第114题 <a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表</a></h3><p><img src="114.png" alt="第114题"></p><h4 id="思路：-11"><a href="#思路：-11" class="headerlink" title="思路："></a>思路：</h4><p>我自己的方法有些类似于剑指Offer中的二叉树转双向链表。</p><ul><li>使用一个全局变量tail作为指针，指向当前已生成链表中的最后一个节点。</li><li>先序遍历二叉树，每次修改tail指针的左节点为当前节点，即使用left指针模拟链表的next指针。</li><li>调整链表，使用right指针模拟next指针，并将left指针置空。（为什么不直接用right指针模拟？因为先序遍历是根-左-右的顺序，对左孩子的遍历可能导致根节点的right指针被覆盖，导致无法继续遍历右孩子）</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">flatten</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify root in-place instead.        """</span>        self<span class="token punctuation">.</span>tail<span class="token operator">=</span>None        <span class="token keyword">def</span> <span class="token function">flat</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>tail<span class="token operator">!=</span>None<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>left<span class="token operator">=</span>root            self<span class="token punctuation">.</span>tail<span class="token operator">=</span>root            flat<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            flat<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">change</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token operator">=</span>None<span class="token punctuation">,</span>root<span class="token punctuation">.</span>left            change<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                 flat<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        change<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(n)$。</li></ul><h2 id="2020-4-4-（2-hard-1easy）"><a href="#2020-4-4-（2-hard-1easy）" class="headerlink" title="2020.4.4 （2 hard 1easy）"></a>2020.4.4 （2 hard 1easy）</h2><h3 id="124题-二叉树中的最大路径和"><a href="#124题-二叉树中的最大路径和" class="headerlink" title="124题  二叉树中的最大路径和"></a>124题 <a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener"> 二叉树中的最大路径和</a></h3><p><img src="124.png" alt="第124题"></p><h4 id="思路：-12"><a href="#思路：-12" class="headerlink" title="思路："></a>思路：</h4><p>我的思路是递归求解，先给出代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>max_sum<span class="token operator">=</span>root<span class="token punctuation">.</span>val        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            left_sum<span class="token operator">=</span>max<span class="token punctuation">(</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>            right_sum<span class="token operator">=</span>max<span class="token punctuation">(</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>            now_path_sum<span class="token operator">=</span>root<span class="token punctuation">.</span>val<span class="token operator">+</span>left_sum<span class="token operator">+</span>right_sum            self<span class="token punctuation">.</span>max_sum<span class="token operator">=</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>max_sum<span class="token punctuation">,</span>now_path_sum<span class="token punctuation">)</span>            <span class="token keyword">return</span> root<span class="token punctuation">.</span>val<span class="token operator">+</span>max<span class="token punctuation">(</span>left_sum<span class="token punctuation">,</span>right_sum<span class="token punctuation">)</span>        recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>max_sum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果当前节点为空，我们的递归函数返回0，表示经过该节点的最大路径和为0。</p><p>接着我们递归计算左子树和右子树，如果递归函数返回值大于0，说明加上它有可能会使当前节点路径和变大，否则不走路径和小于0的子树。</p><p>当前节点的最大路径和即为当前节点的值加上左子树和0的最大值加上右子树和0的最大值，加上后即可尝试更新当前二叉树的最大路径和。</p><p>接下来是进行返回，也是本题中最容易出错的地方！返回值不是当前节点的最大路径和，而是只能走一边的子树，因为二叉树的节点不能被重复访问！</p><h3 id="128题-最长连续序列"><a href="#128题-最长连续序列" class="headerlink" title="128题  最长连续序列"></a>128题 <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener"> 最长连续序列</a></h3><p><img src="128.png" alt="第128题"></p><h4 id="思路：-13"><a href="#思路：-13" class="headerlink" title="思路："></a>思路：</h4><p>我们先从暴力算法想起，暴力算法的做法是遍历数组中的每一个数，查看他的下一个数是否在数组中，如果在，那么就再查看下一个数，直到出现不在数组中的数，记录下当前长度并尝试更新最大长度。由于数组无序，所以每次查找都需要$O(n)$的时间复杂度，最坏情况下（即数组降序），需要的时间复杂度为$O(n^3)$。</p><p>为了优化至$O(n)$的时间复杂度，首先，我们可以建立辅助的数据结构——哈希表。这里，我们使用哈希集合，hashset和hashmap的区别在于，hashset只存key不存value，而hashmap存了键值对。我们知道，哈希集合的查找时间复杂度仅需$O(1)$（直接哈希函数），所以此时的时间复杂度已经降为$O(n^2)$。</p><p>为了进一步优化，我们进行剪枝操作，当我们访问到num，假如num-1已经在hashset中，那么我们就不对他进行向后搜索。即：我们现在只对序列开头的数进行向后搜索。因为我们使用的是hashset，所以判断num-1是否存在依然很快。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        hashset<span class="token operator">=</span>set<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        first_num<span class="token operator">=</span><span class="token number">0</span>        max_length<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> num<span class="token number">-1</span> <span class="token operator">not</span> <span class="token keyword">in</span> hashset<span class="token punctuation">:</span>                length<span class="token operator">=</span><span class="token number">1</span>                <span class="token keyword">while</span> num<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">in</span> hashset<span class="token punctuation">:</span>                    num<span class="token operator">+=</span><span class="token number">1</span>                    length<span class="token operator">+=</span><span class="token number">1</span>                max_length<span class="token operator">=</span>max<span class="token punctuation">(</span>length<span class="token punctuation">,</span>max_length<span class="token punctuation">)</span>        <span class="token keyword">return</span> max_length<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(n)$。</li></ul><h3 id="136题-只出现一次的数字"><a href="#136题-只出现一次的数字" class="headerlink" title="136题 只出现一次的数字"></a>136题 <a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">只出现一次的数字</a></h3><p><img src="136.png" alt="第136题"></p><h4 id="思路：-14"><a href="#思路：-14" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，异或运算，一个数异或自身为0，异或0为自身。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            result<span class="token operator">^</span><span class="token operator">=</span>num        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-5-（2-medium-1easy）"><a href="#2020-4-5-（2-medium-1easy）" class="headerlink" title="2020.4.5 （2 medium 1easy）"></a>2020.4.5 （2 medium 1easy）</h2><h3 id="139题-单词拆分"><a href="#139题-单词拆分" class="headerlink" title="139题 单词拆分"></a>139题 <a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">单词拆分</a></h3><p><img src="139.png" alt="第139题"></p><h4 id="思路：-15"><a href="#思路：-15" class="headerlink" title="思路："></a>思路：</h4><p>这类题最常见的解法就是动态规划法了。类似的问题还有：正则表达式匹配等。</p><p>我在一开始却尝试了DFS，递归超时了。<strong>类似的题目是不能用DFS的！必然超时！希望自己以后能记住这个教训！因为这道题存在着重叠子问题，就像走迷宫问题一样，假设字符串s的前 i 个字符的匹配可以通过多条路径得到，那么它们从第 i 个字符往后的路径都是相同的，如果使用递归，由于无法记录递归过程中的状态，会产生大量的重复计算。</strong>解决的方案可以是带备忘录的递归，但动态规划显然更加有效。</p><p>我们使用DP求解。DP状态矩阵dp[i]为s的前i个字符是否匹配。转移方程为：遍历wordDict中的word，dp[i]=dp[i-len（word）]（if i-len（word）&gt;=0 and dp[i-len（word）] and s[i-len（word）:i]==word）。即假如前i个字符的末尾存在wordDict中的某个单词，且去除该单词后，前i-len（word）个字符也能拆分，说明前i个字符可以被拆分。</p><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> wordDict<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        sorted<span class="token punctuation">(</span>wordDict<span class="token punctuation">,</span>key<span class="token operator">=</span>len<span class="token punctuation">,</span>reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> word <span class="token keyword">in</span> wordDict<span class="token punctuation">:</span>                start<span class="token operator">=</span>i<span class="token operator">-</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span>                <span class="token keyword">if</span> start<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> dp<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>start<span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token operator">==</span>word<span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                    <span class="token keyword">break</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="141题-环形链表"><a href="#141题-环形链表" class="headerlink" title="141题 环形链表"></a>141题 <a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表</a></h3><p><img src="141.png" alt="第141题"></p><h4 id="思路：-16"><a href="#思路：-16" class="headerlink" title="思路："></a>思路：</h4><p>hashset存放已经访问过的节点，遍历链表，如果访问到已存在hashset中的节点时，返回True，即存在环，否则将当前节点加入hashset，继续向前遍历。</p><ul><li>时间复杂度：$O(n)$，哈希表的查找为$O(1)$</li><li>空间复杂度：$O(n)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        nodes<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        p<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> p <span class="token keyword">in</span> nodes<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            nodes<span class="token punctuation">.</span>add<span class="token punctuation">(</span>p<span class="token punctuation">)</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了更进一步的优化时间复杂度和空间复杂度，我们可以原地修改链表，对访问过的节点的值设为”visited“，如果遍历到已访问节点，return True。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        p<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>val<span class="token operator">==</span><span class="token string">"visited"</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            p<span class="token punctuation">.</span>val<span class="token operator">=</span><span class="token string">"visited"</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h3 id="142题-环形链表-II"><a href="#142题-环形链表-II" class="headerlink" title="142题 环形链表 II"></a>142题 <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">环形链表 II</a></h3><p><img src="142.png" alt="第142题"></p><p>这道题要求我们不能原地修改链表，所以141题中的第二种方法就不能使用，只能使用哈希集合的方法。但是，有没有方法能够不使用额外的数据结构呢？</p><p>我们可以使用Floyd算法，采用快慢指针的做法求出环形链表的环入口节点。</p><ul><li>定义双指针fast、slow，均指向head节点。</li><li>fast、slow向前遍历，fast每次走两步，slow每次走一步。</li><li>假如fast走到了None，说明链表无环，直接返回None。</li><li>否则，fast和slow必然会在环中的某一个节点处相遇，此时，fast节点走过的路程为f，slow节点走过的路程为s，环的长度为b，则必有：（1）f=2s（因为快指针每次走两步，慢指针走一步，快指针的路程必然是慢指针的两倍），（2）f=s+nb（要想相遇，快指针必然比慢指针多走了n圈）。二者相减，得：s=nb，f=2nb。</li><li>我们知道，想要从起点走到环入口，需要走a+nb，其中，a是指从链表起点到环入口的步数，nb为在环中转圈的步数。所以，我们已有：s=nb，只要让慢指针再走a步，即可到达环入口节点。</li><li>我们可以移动fast到头节点，让快指针和慢指针每次都走一步，最终，快慢指针将在环入口处相遇，此时:f=a,s=a+nb。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        fast<span class="token operator">=</span>head        slow<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> fast<span class="token operator">==</span>None <span class="token operator">or</span> fast<span class="token punctuation">.</span>next<span class="token operator">==</span>None <span class="token operator">or</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> None            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next            <span class="token keyword">if</span> fast<span class="token operator">==</span>slow<span class="token punctuation">:</span>                <span class="token keyword">break</span>        fast<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token operator">!=</span>slow<span class="token punctuation">)</span><span class="token punctuation">:</span>            fast<span class="token punctuation">,</span>slow<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">,</span>slow<span class="token punctuation">.</span>next        <span class="token keyword">return</span> slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="2020-4-6-（3-medium）"><a href="#2020-4-6-（3-medium）" class="headerlink" title="2020.4.6 （3 medium）"></a>2020.4.6 （3 medium）</h2><h3 id="146题-LRU缓存机制"><a href="#146题-LRU缓存机制" class="headerlink" title="146题 LRU缓存机制"></a>146题 <a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LRU缓存机制</a></h3><p><img src="146.png" alt="第146题"></p><h4 id="思路：-17"><a href="#思路：-17" class="headerlink" title="思路："></a>思路：</h4><p>基本思路是使用一个类似于队列的数据结构，我们将最近使用的键值对放置到队首，这样队尾键值对必然是最近最少使用的。当添加新的键值对，而缓存已满时，我们需要将队尾的键值对出队，并将新的键值对添加到队首，从而实现了LRU缓存机制。</p><p>特别地，题目要求我们使用$O(1)$级别的时间复杂度，我们很容易便想到了哈希表，其查找节点的时间复杂度为$O(1)$（类似于为链表中的节点建立索引）。更进一步，我们需要修改原先的队列为双向链表，因为只有双向链表可以保证删除节点的时间复杂度在$O(1)$，而我们需要在以下两种情况进行删除节点操作（插入节点都是在头部，均为$O(1)$：</p><ul><li>当我们需要进行get操作时，需要将被访问的键值对的节点移动到双向链表开头，需要先删除，再插入。</li><li>当我们需要进行put操作，而缓存已满时，需要将尾部键值对删除。</li></ul><p>所以，使用双向链表是必要的。特别地，为了减少插入、删除过程中的额外判断，我们使用链表中经常需要用到的伪头节点和伪尾节点。（如果直接使用字典，虽然python3中dictionary是有序的，但无法选择插入的位置）</p><p>算法的基本流程如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// key 映射到 Node(key, val)</span>HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Node<span class="token operator">></span> map<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Node(k1, v1) &lt;-> Node(k2, v2)...</span>DoubleList cache<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key 不存在<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                将数据 <span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> 提到开头；        <span class="token keyword">return</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key 已存在<span class="token punctuation">)</span> <span class="token punctuation">{</span>        把旧的数据删除；        将新节点 x 插入到开头；    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cache 已满<span class="token punctuation">)</span> <span class="token punctuation">{</span>            删除链表的最后一个数据腾位置；            删除 map 中映射到该数据的键；        <span class="token punctuation">}</span>         将新节点 x 插入到开头；        map 中新建 key 对新节点 x 的映射；    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们自己实现双向链表、节点、以及调整节点至开头，插入节点至开头，删除尾部节点操作后，完整的代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>key<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>key<span class="token operator">=</span>key        self<span class="token punctuation">.</span>val<span class="token operator">=</span>val        self<span class="token punctuation">.</span>next<span class="token operator">=</span>None        self<span class="token punctuation">.</span>prev<span class="token operator">=</span>None<span class="token keyword">class</span> <span class="token class-name">LinkedList</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>head<span class="token operator">=</span>Node<span class="token punctuation">(</span>None<span class="token punctuation">,</span>None<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>tail<span class="token operator">=</span>Node<span class="token punctuation">(</span>None<span class="token punctuation">,</span>None<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token operator">=</span>self<span class="token punctuation">.</span>tail        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev<span class="token operator">=</span>self<span class="token punctuation">.</span>head    <span class="token keyword">def</span> <span class="token function">move_to_head</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>        node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next<span class="token operator">=</span>node<span class="token punctuation">.</span>next        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev<span class="token operator">=</span>node<span class="token punctuation">.</span>prev        node<span class="token punctuation">.</span>prev<span class="token operator">=</span>self<span class="token punctuation">.</span>head        node<span class="token punctuation">.</span>next<span class="token operator">=</span>self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token operator">=</span>node        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev<span class="token operator">=</span>node        <span class="token keyword">return</span> node<span class="token punctuation">.</span>val    <span class="token keyword">def</span> <span class="token function">add_to_head</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>        node<span class="token punctuation">.</span>prev<span class="token operator">=</span>self<span class="token punctuation">.</span>head        node<span class="token punctuation">.</span>next<span class="token operator">=</span>self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token operator">=</span>node        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev<span class="token operator">=</span>node    <span class="token keyword">def</span> <span class="token function">pop_tail</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        node<span class="token operator">=</span>self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev        node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next<span class="token operator">=</span>self<span class="token punctuation">.</span>tail        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev<span class="token operator">=</span>node<span class="token punctuation">.</span>prev        <span class="token keyword">return</span> node<span class="token punctuation">.</span>key<span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> capacity<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>capacity<span class="token operator">=</span>capacity        self<span class="token punctuation">.</span>hashmap<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        self<span class="token punctuation">.</span>length<span class="token operator">=</span><span class="token number">0</span>        self<span class="token punctuation">.</span>linkedlist<span class="token operator">=</span>LinkedList<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>hashmap<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>move_to_head<span class="token punctuation">(</span>self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">put</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">:</span> int<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>hashmap<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>val<span class="token operator">=</span>value            self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>move_to_head<span class="token punctuation">(</span>self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> self<span class="token punctuation">.</span>length<span class="token operator">&lt;</span>self<span class="token punctuation">.</span>capacity<span class="token punctuation">:</span>            node<span class="token operator">=</span>Node<span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>add_to_head<span class="token punctuation">(</span>node<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span>node            self<span class="token punctuation">.</span>length<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            node<span class="token operator">=</span>Node<span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>            key_del<span class="token operator">=</span>self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>pop_tail<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>hashmap<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>key_del<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>add_to_head<span class="token punctuation">(</span>node<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span>node<span class="token comment" spellcheck="true"># Your LRUCache object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = LRUCache(capacity)</span><span class="token comment" spellcheck="true"># param_1 = obj.get(key)</span><span class="token comment" spellcheck="true"># obj.put(key,value)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后总结一下，我们维护一个链表，链表中数据从前至后依次为上次使用时间从近至远。为了减低时间复杂度，我们使用双向链表和哈希表减少调整链表所花费的时间。</p><h3 id="148题-排序链表"><a href="#148题-排序链表" class="headerlink" title="148题 排序链表"></a>148题 <a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">排序链表</a></h3><p><img src="148.png" alt="第148题"></p><h4 id="思路-44"><a href="#思路-44" class="headerlink" title="思路:"></a>思路:</h4><p>由于时间复杂度需要在$O(nlogn)$，所以可用的算法有：归并排序，快速排序，堆排序等。考虑到合并链表比较方便，所以我们在这里选用归并排序。</p><p>与常规的归并排序类似，我们进行递归合并。先调用自身函数归并排序左半部分和右半部分，再调用合并两个有序链表的函数归并左右部分。</p><p>这里需要注意的是，当前需要排序的是链表而非数组，所以我们无法通过下标运算直接得到中间节点，对当前链表进行二分划分。假如我们直接遍历链表得到长度再遍历长度的一半找到中间节点，则时间复杂度为$O(3n/2)$。为了优化，我们可以使用快慢指针法。让快指针每次走两步，慢指针每次走一步，当快指针走到链表终点时，慢指针必然位于中间节点。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">getMiddle</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> head<span class="token operator">==</span>None <span class="token operator">or</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> head            slow<span class="token operator">=</span>head            fast<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token operator">!=</span>None <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next                fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            <span class="token keyword">return</span> slow        <span class="token keyword">def</span> <span class="token function">mergeTwoList</span><span class="token punctuation">(</span>head1<span class="token punctuation">,</span>head2<span class="token punctuation">)</span><span class="token punctuation">:</span>            dummyhead<span class="token operator">=</span>ListNode<span class="token punctuation">(</span>None<span class="token punctuation">)</span>            p1<span class="token operator">=</span>dummyhead            p2<span class="token operator">=</span>head1            p3<span class="token operator">=</span>head2            <span class="token keyword">while</span> <span class="token punctuation">(</span>p2<span class="token operator">!=</span>None <span class="token operator">and</span> p3<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> p2<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>p3<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                    p1<span class="token punctuation">.</span>next<span class="token operator">=</span>p2                    p2<span class="token operator">=</span>p2<span class="token punctuation">.</span>next                    p1<span class="token operator">=</span>p1<span class="token punctuation">.</span>next                <span class="token keyword">else</span><span class="token punctuation">:</span>                    p1<span class="token punctuation">.</span>next<span class="token operator">=</span>p3                    p3<span class="token operator">=</span>p3<span class="token punctuation">.</span>next                    p1<span class="token operator">=</span>p1<span class="token punctuation">.</span>next            p1<span class="token punctuation">.</span>next<span class="token operator">=</span>p2 <span class="token keyword">if</span> p2<span class="token operator">!=</span>None <span class="token keyword">else</span> p3            <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next        <span class="token keyword">if</span> head<span class="token operator">==</span>None <span class="token operator">or</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        mid<span class="token operator">=</span>getMiddle<span class="token punctuation">(</span>head<span class="token punctuation">)</span>        tmp<span class="token operator">=</span>mid<span class="token punctuation">.</span>next        mid<span class="token punctuation">.</span>next<span class="token operator">=</span>None        head1<span class="token operator">=</span>self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>head<span class="token punctuation">)</span>        head2<span class="token operator">=</span>self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>        <span class="token keyword">return</span> mergeTwoList<span class="token punctuation">(</span>head1<span class="token punctuation">,</span>head2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="152题-乘积最大子数组"><a href="#152题-乘积最大子数组" class="headerlink" title="152题 乘积最大子数组"></a>152题 <a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">乘积最大子数组</a></h3><p><img src="152.png" alt="第152题"></p><h4 id="思路-45"><a href="#思路-45" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划，类似于最大连续子序和问题。我们使用dp[i]表示前i个数字中子数组的最大乘积。动态规划转移方程为：</p><blockquote><p>maxDP[i + 1] = max(maxDP[i] <em> A[i + 1], A[i + 1],minDP[i] </em> A[i + 1])<br>minDP[i + 1] = min(minDP[i] <em> A[i + 1], A[i + 1],maxDP[i] </em> A[i + 1])<br>dp[i + 1] = max(dp[i], maxDP[i + 1])</p></blockquote><p>在这里，maxDP[i] 是以第i个数字结尾的子数组的最大乘积，minDP[i]是以第i个数字结尾的子数组的最小乘积。之所以我们需要保留最小乘积，是因为考虑到第i+1个数字是负数的情况。</p><p>由于我们发现，所有的动态规划转移方程都只需要用到前一个状态，所以我们只需要使用三个变量即可代替状态矩阵（滚动数组法优化DP空间的思想）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProduct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        imax<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        imin<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        max_product<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>                imax<span class="token punctuation">,</span>imin<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>imin<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>imax<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                imax<span class="token punctuation">,</span>imin<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>imax<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>imin<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            max_product<span class="token operator">=</span>max<span class="token punctuation">(</span>imax<span class="token punctuation">,</span>max_product<span class="token punctuation">)</span>        <span class="token keyword">return</span> max_product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，imax和imin必须同步更新，因为imin的更新需要使用到imax的值，如果imax的值先被改变，结果将出错。</p><h2 id="2020-4-7-（4-easy）"><a href="#2020-4-7-（4-easy）" class="headerlink" title="2020.4.7 （4 easy）"></a>2020.4.7 （4 easy）</h2><h3 id="155题-最小栈"><a href="#155题-最小栈" class="headerlink" title="155题 最小栈"></a>155题 <a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">最小栈</a></h3><p><img src="155.png" alt="第155题"></p><h4 id="思路：-18"><a href="#思路：-18" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，我们可以使用一个辅助栈，存放栈内前i个元素中的最小值，以空间换时间。</p><ul><li>时间复杂度：$O(1)$。</li><li>空间复杂度：$O(n)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MinStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>stack1<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>stack2<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack2<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>min<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">getMin</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your MinStack object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MinStack()</span><span class="token comment" spellcheck="true"># obj.push(x)</span><span class="token comment" spellcheck="true"># obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.top()</span><span class="token comment" spellcheck="true"># param_4 = obj.getMin()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="160题-相交链表"><a href="#160题-相交链表" class="headerlink" title="160题 相交链表"></a>160题 <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">相交链表</a></h3><p><img src="160.png" alt="第160题"></p><h4 id="思路：-19"><a href="#思路：-19" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，我们最容易想到的方法是采用哈希表的方式，记录下A、B链表中的每一个节点，找到第一个重复的节点返回。但有没有方法可以不使用额外的空间呢？答案是有的，我们可以使用双指针法，这有些类似于环形链表142题。</p><p>我们创建指针p指向headA，指针q指向headB，使二者向前遍历链表A和B。当p遍历到链表A结尾时，令p=headB，当q遍历到链表B结尾时，令q=headA。如果链表A和链表B存在相交点时，p和q继续向后遍历，必然会在相交点处相等。如果不存在相交点，p和q继续向后遍历，必然会同时遍历到链表结尾。</p><p>原理：</p><p><img src="160-1.png" alt="第160题示意图"></p><p>假如相交，则a+b+c必然等于c+b+a！p指针和q指针在链表相交点处必然走过相同的路程。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> headA<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> headB<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> headA<span class="token operator">==</span>None <span class="token operator">or</span> headB<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        p<span class="token operator">=</span>headA        q<span class="token operator">=</span>headB        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>next<span class="token operator">==</span>None <span class="token operator">and</span> q<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> None            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next <span class="token keyword">if</span> p<span class="token punctuation">.</span>next<span class="token operator">!=</span>None <span class="token keyword">else</span> headB            q<span class="token operator">=</span>q<span class="token punctuation">.</span>next <span class="token keyword">if</span> q<span class="token punctuation">.</span>next<span class="token operator">!=</span>None <span class="token keyword">else</span> headA        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="169题-多数元素"><a href="#169题-多数元素" class="headerlink" title="169题 多数元素"></a>169题 <a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">多数元素</a></h3><p><img src="169.png" alt="第169题"></p><h4 id="思路：-20"><a href="#思路：-20" class="headerlink" title="思路："></a>思路：</h4><p>常规的做法有：（1）哈希表记录各元素出现的次数，选择出现次数最多的元素（时：$O(n)$，空：$O(n)$）（2）排序法，取中值。（时：$O(nlogn)$，空：$O(1)$）</p><p>为了获得最优的时空复杂度，我们还可以使用投票算法：</p><ul><li>如果我们把众数记为 +1，把其他数记为 -1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。 </li><li>我们遍历数组，使用count记录下当前投票和。如果count等于0，那么就更新候选人。接着进行投票，如果当前值等于候选人，count加1，否则count减1。</li><li>投票算法证明：<ol><li>如果候选人不是maj（多数元素） 则 maj,会和其他非候选人一起反对 会反对候选人,所以候选人一定会下台(maj==0时发生换届选举)</li><li>如果候选人是maj , 则maj 会支持自己，其他候选人会反对，同样因为maj 票数超过一半，所以maj 一定会成功当选</li></ol></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        count<span class="token operator">=</span><span class="token number">0</span>        candidate<span class="token operator">=</span>None        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                candidate<span class="token operator">=</span>num            count<span class="token operator">+=</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">if</span> num<span class="token operator">==</span>candidate <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> candidate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><h3 id="198题-打家劫舍"><a href="#198题-打家劫舍" class="headerlink" title="198题 打家劫舍"></a>198题 <a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">打家劫舍</a></h3><p><img src="198.png" alt="第198题"></p><h4 id="思路：-21"><a href="#思路：-21" class="headerlink" title="思路："></a>思路：</h4><p>动态规划模板题，有些类似于01背包问题。动态规划状态矩阵dp[i]用于表示偷前i家的最大金额，转移方程为：</p><ul><li>dp[i]=max（dp[i-1]，dp[i-2]+nums[i]）</li></ul><p>即考虑偷当前这家和不偷当前这家的收益谁更大，选择最大收益。（偷这家就不能偷上一家）</p><p>由于只用到前两个状态，所以我们可以使用滚动数组的思想进行空间优化。</p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        a<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        b<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            a<span class="token punctuation">,</span>b<span class="token operator">=</span>b<span class="token punctuation">,</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>        <span class="token keyword">return</span> b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-7-（3-medium-1-easy）"><a href="#2020-4-7-（3-medium-1-easy）" class="headerlink" title="2020.4.7 （3 medium 1 easy）"></a>2020.4.7 （3 medium 1 easy）</h2><h3 id="200题-岛屿数量"><a href="#200题-岛屿数量" class="headerlink" title="200题 岛屿数量"></a>200题 <a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">岛屿数量</a></h3><p><img src="200.png" alt="第200题"></p><h4 id="思路：-22"><a href="#思路：-22" class="headerlink" title="思路："></a>思路：</h4><p>DFS模板题，使用一个visited矩阵来存放某个位置是否已被访问过。</p><p>遍历grid矩阵，每次遇到尚未被访问的岛屿时，将计数变量加1，再使用DFS遍历该岛屿的所有土地，并标记为已访问，访问过的土地或者水域都不会进行访问。这样，将会把该岛屿的所有土地都访问一次，然后终止递归。最后，所有的岛屿将被遍历一次，计数变量的值即为岛屿数。</p><p>特别地，为了减少空间占用，我们还可以原地修改grid矩阵来表示已访问过。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numIslands</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> row<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">or</span> row<span class="token operator">>=</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span> <span class="token operator">or</span> col<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">or</span> col<span class="token operator">>=</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span>            <span class="token keyword">if</span> grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"1"</span><span class="token punctuation">:</span>                grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"0"</span>                dfs<span class="token punctuation">(</span>row<span class="token number">-1</span><span class="token punctuation">,</span>col<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token number">-1</span><span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        islands<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"1"</span><span class="token punctuation">:</span>                    islands<span class="token operator">+=</span><span class="token number">1</span>                    dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span>        <span class="token keyword">return</span> islands<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(mn)$。</li><li>空间复杂度：$O(mn)$，递归栈。</li></ul><p>这道题还可以用<a href="https://blog.csdn.net/qq_41593380/article/details/81146850" target="_blank" rel="noopener">并查集</a>来做。基本思路就是将连同的陆地合并到同一个集合中，最后统计集合数目即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numIslands</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">class</span> <span class="token class-name">UnionFind</span><span class="token punctuation">:</span>            <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>count <span class="token operator">=</span> n                self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">def</span> <span class="token function">get_count</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> self<span class="token punctuation">.</span>count            <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>                now<span class="token operator">=</span>p                <span class="token keyword">while</span> p <span class="token operator">!=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">:</span>                    p <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span>                <span class="token keyword">while</span> now <span class="token operator">!=</span> p<span class="token punctuation">:</span>                    now<span class="token punctuation">,</span>self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">=</span>self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">,</span>p                <span class="token keyword">return</span> p            <span class="token keyword">def</span> <span class="token function">is_connected</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token keyword">def</span> <span class="token function">union</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>                p_root <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span>                q_root <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>                <span class="token keyword">if</span> p_root <span class="token operator">!=</span> q_root<span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>q_root<span class="token punctuation">]</span><span class="token operator">=</span>p_root                    self<span class="token punctuation">.</span>count<span class="token operator">-=</span><span class="token number">1</span>        row <span class="token operator">=</span> len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 特判</span>        <span class="token keyword">if</span> row <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        col <span class="token operator">=</span> len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">get_index</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> x <span class="token operator">*</span> col <span class="token operator">+</span> y        <span class="token comment" spellcheck="true"># 注意：我们不用像 DFS 和 BFS 一样，4 个方向都要尝试，只要看一看右边和下面就可以了</span>        directions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 多开一个空间，把水域 "0" 都归到这个虚拟的老大上</span>        dummy_node <span class="token operator">=</span> row <span class="token operator">*</span> col        <span class="token comment" spellcheck="true"># 多开的一个空间就是那个虚拟的空间</span>        uf <span class="token operator">=</span> UnionFind<span class="token punctuation">(</span>dummy_node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 如果是水域，都连到那个虚拟的空间去</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">:</span>                    uf<span class="token punctuation">.</span>union<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> dummy_node<span class="token punctuation">)</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true"># 向下向右如果都是陆地，即 "1"，就要合并一下</span>                    <span class="token keyword">for</span> direction <span class="token keyword">in</span> directions<span class="token punctuation">:</span>                        new_x <span class="token operator">=</span> i <span class="token operator">+</span> direction<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                        new_y <span class="token operator">=</span> j <span class="token operator">+</span> direction<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                        <span class="token keyword">if</span> new_x <span class="token operator">&lt;</span> row <span class="token operator">and</span> new_y <span class="token operator">&lt;</span> col <span class="token operator">and</span> grid<span class="token punctuation">[</span>new_x<span class="token punctuation">]</span><span class="token punctuation">[</span>new_y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">:</span>                            uf<span class="token punctuation">.</span>union<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> get_index<span class="token punctuation">(</span>new_x<span class="token punctuation">,</span> new_y<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 不要忘记把那个虚拟结点减掉</span>        <span class="token keyword">return</span> uf<span class="token punctuation">.</span>get_count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>顾名思义，并查集的主要操作有两个，分别是并和查。类似于这种最小连通子树的问题，我们使用图结构未免过于复杂，所以并查集能够很好的解决这一问题。</p><p>我们使用一个数组parent存放每个节点的父节点。</p><ul><li>查操作：如果节点A的父节点是自身，那么他就是所在树的根节点，否则向上递归搜索，直到找到所在树的根节点。（查询每个节点所在子树的根节点，如果A和B所在子树的根节点相同，则说明它们是连通的）</li><li>特别地，为了进行路径压缩，我们在查操作递归查找到根节点后，将递归路径上的所有节点的父节点设置为根节点，从而确保所有的节点都可以在两步之内找到根节点。</li><li>并操作：合并节点A和节点B所在的子树。具体做法是：查找A所在子树的根节点，查找B所在子树的根节点，修改A的根节点的父节点为B的根节点。</li><li>初始情况下，我们设定每一个位置都是一个集合（子树），并查集的count数为总位置数目加1（有一个虚拟节点）。然后我们遍历所有位置，如果当前位置是陆地，则合并右方和下方的陆地至当前位置的子树，每次合并后将count数减1，说明集合数减1。如果当前位置是水域，则将其合并到伪节点下。</li><li>最后，我们将并查集内的集合数目减1，即为岛屿数目（其中有一个集合是水域的集合）。</li></ul><h3 id="206题-反转链表"><a href="#206题-反转链表" class="headerlink" title="206题 反转链表"></a>206题 <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a></h3><p><img src="206.png" alt="第206题"></p><h4 id="思路：-23"><a href="#思路：-23" class="headerlink" title="思路："></a>思路：</h4><p>可以使用头插法，遍历链表中的每个节点都插入到头部即可。</p><p>也可以使用快慢指针法，慢指针开始时指向None，快指针指向Head。每次将快指针的next指向慢指针，即实现了反转。然后将快慢指针同时向前移动一个节点，继续修改快指针的next。、</p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        p<span class="token operator">=</span>None        q<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp<span class="token punctuation">,</span>q<span class="token punctuation">.</span>next<span class="token operator">=</span>q<span class="token punctuation">.</span>next<span class="token punctuation">,</span>p            p<span class="token punctuation">,</span>q<span class="token operator">=</span>q<span class="token punctuation">,</span>tmp        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="207题-课程表"><a href="#207题-课程表" class="headerlink" title="207题  课程表"></a>207题 <a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener"> 课程表</a></h3><p><img src="207.png" alt="第207题"></p><h4 id="思路：-24"><a href="#思路：-24" class="headerlink" title="思路："></a>思路：</h4><p>这是一个有向图找环路的问题，基本的思路是拓扑排序。</p><p>我们每次找到一个入度为0的节点，将其从图上删除，并删除以它为起点的所有边，修改相应的边终点的入度。循环执行上述操作，直到图中不存在节点，说明无环。如果无法将节点全部清空，说明存在环。</p><ul><li>时间复杂度：$O(N + M)$： 遍历一个图需要访问所有节点和所有临边；</li><li>空间复杂度：$O(N + M)$： 为建立邻接表所需额外空间。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canFinish</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> numCourses<span class="token punctuation">:</span> int<span class="token punctuation">,</span> prerequisites<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        indegree<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>numCourses<span class="token punctuation">)</span><span class="token punctuation">]</span>        hashmap<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>numCourses<span class="token punctuation">)</span><span class="token punctuation">:</span>            hashmap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> edge <span class="token keyword">in</span> prerequisites<span class="token punctuation">:</span>            indegree<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>            hashmap<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> hashmap<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果还剩下节点，那么继续删除节点</span>            flag<span class="token operator">=</span><span class="token boolean">False</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>indegree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    flag<span class="token operator">=</span><span class="token boolean">True</span>                    <span class="token keyword">for</span> next <span class="token keyword">in</span> hashmap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                        indegree<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>                    indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>                    hashmap<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">if</span> flag<span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果不存在入度为0的节点，那么说明必然存在环路</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span class="token comment" spellcheck="true">#节点可以被全部删除，说明无环</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="215题-数组中的第K个最大元素"><a href="#215题-数组中的第K个最大元素" class="headerlink" title="215题 数组中的第K个最大元素"></a>215题 <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">数组中的第K个最大元素</a></h3><p><img src="215.png" alt="第215题"></p><h4 id="思路：-25"><a href="#思路：-25" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，两种做法：快速选择法和辅助堆。具体解析可见剑指Offer的博客。</p><p>辅助堆：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        heap<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>heap<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>heap<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(nlogk)$，堆的插入、删除都需要$O(logk)$，最坏情况下，每个数字都要入堆出堆一次。</li><li>空间复杂度：$O(k)$，辅助堆。</li></ul><p>快速选择：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#和快速排序中的分治一样，将当前区间首部的枢纽元素调整至正确的位置</span>            i<span class="token operator">=</span>left<span class="token operator">+</span><span class="token number">1</span>            j<span class="token operator">=</span>right            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>right <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    i<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j<span class="token operator">></span>left <span class="token operator">and</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">>=</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    j<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">if</span> i<span class="token operator">&lt;</span>j<span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                    <span class="token keyword">break</span>            <span class="token keyword">return</span> j        <span class="token keyword">def</span> <span class="token function">quickSelect</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#快速选择算法</span>            m<span class="token operator">=</span>partition<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> m<span class="token operator">==</span>k<span class="token punctuation">:</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span>            <span class="token keyword">elif</span> m<span class="token operator">></span>k<span class="token punctuation">:</span>                <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span>left<span class="token punctuation">,</span>m<span class="token number">-1</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>k<span class="token punctuation">)</span>        random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#非常重要！</span>        <span class="token keyword">if</span> k<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> k<span class="token operator">></span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> nums        <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span>k<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是：如果数组有序，那么快速选择法的时间复杂度会大幅提高。（原理和快排一样，当数组有序时，会退化成冒泡排序，时间复杂度升至$O(MN)$）所以我们需要提前随机打乱数组。</p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法整理汇总（附代码）</title>
      <link href="/2020/02/16/sort-algorithms/"/>
      <url>/2020/02/16/sort-algorithms/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。</p><p><strong>本文并不会详细讲解每种排序算法的原理</strong>，网上有很多很好的教程，大家可以自己去搜了看。</p><p>最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 <a href="https://leetcode-cn.com/problems/sort-an-array/" title="LeetCode 912. 排序数组" target="_blank" rel="noopener">LeetCode 912. 排序数组</a> 这道题。</p><h2 id="性质汇总"><a href="#性质汇总" class="headerlink" title="性质汇总"></a>性质汇总</h2><blockquote><p>如果发现表中有错误，请留言告知。</p></blockquote><table><thead><tr><th>算法</th><th>最好</th><th>最坏</th><th>平均</th><th>空间</th><th align="center">稳定性</th><th align="center">是否基于比较</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>插入排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>快速排序</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(n\log n)$</td><td>$O(\log n)$~$O(n)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>归并排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>希尔排序</td><td>$O(n^{1.3})$</td><td>$O(n^2)$</td><td>$O(n\log n)$~$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>基数排序</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>桶排序</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n+m)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>堆排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr></tbody></table><blockquote><p>如果表格显示有问题的话，还可以直接看下面的汇总图：</p></blockquote><p><img src="1.png" alt="十大经典排序算法性质汇总"></p><h3 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h3><p>我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。</p><p><strong>冒泡排序</strong><br><a href="https://en.wikipedia.org/wiki/Bubble_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bubble_sort</a></p><p><strong>选择排序</strong><br><a href="https://en.wikipedia.org/wiki/Selection_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Selection_sort</a></p><p><strong>插入排序</strong><br><a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Insertion_sort</a></p><p><strong>快速排序</strong><br><a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Quicksort</a></p><p><strong>归并排序</strong><br><a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Merge_sort</a></p><p><strong>希尔排序</strong><br><a href="https://en.wikipedia.org/wiki/Shellsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Shellsort</a></p><p><strong>计数排序</strong><br><a href="https://en.wikipedia.org/wiki/Counting_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Counting_sort</a></p><p><strong>基数排序</strong><br><a href="https://en.wikipedia.org/wiki/Radix_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Radix_sort</a></p><p><strong>桶排序</strong><br><a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bucket_sort</a></p><p><strong>堆排序</strong><br><a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heapsort</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>所有的排序算法接口都是相同的，也就是 <code>vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums)</code> 。只需要你传入一个 <code>vector&lt;int&gt;</code> 类型的数组，就能返回排序后的结果。</p><p>运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sortArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 冒泡排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> i<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 选择排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">selectSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    idx <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 插入排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">insertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 快速排序（24 ms）</span>    <span class="token keyword">void</span> <span class="token function">qSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序（192 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rnums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序 + 非递归（80 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSortNR</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> len <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> n<span class="token operator">-</span>len<span class="token punctuation">;</span> l <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span>len<span class="token number">-1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> l<span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>len<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token operator">-</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 希尔排序（40 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">shellSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j<span class="token operator">-</span>gap <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">-</span><span class="token operator">=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计数排序（32 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">countSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> maxv<span class="token operator">-</span>minv<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token operator">+</span>minv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 基数排序（不适用于负数）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">radixSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxv <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxv <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>            maxd<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rank</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxd <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> count<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rank<span class="token punctuation">[</span><span class="token operator">--</span>count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            maxd<span class="token operator">--</span><span class="token punctuation">;</span>            base <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 桶排序 (20 ms)</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> bs <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>maxv<span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">bucket</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bucket<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sz <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 堆排序（32 ms）</span>    <span class="token keyword">void</span> <span class="token function">adjust</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> c1 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c2 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>c2<span class="token operator">&lt;</span>s <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>c2<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> c2 <span class="token operator">:</span> c1<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
