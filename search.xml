<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NLP自学笔记：线性模型</title>
      <link href="/2020/03/25/nlp-zi-xue-bi-ji-xian-xing-mo-xing/"/>
      <url>/2020/03/25/nlp-zi-xue-bi-ji-xian-xing-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是我在学习苏州大学李正华老师的中文信息处理课程（<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">中文信息处理（Chinese Information Processing）Course Resources</a>）时，对于线性模型的一些个人见解和思考，同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己对于该模型的理解，如有错误欢迎在评论区指出，非常感谢！</p><h2 id="从问题出发"><a href="#从问题出发" class="headerlink" title="从问题出发"></a>从问题出发</h2><p>与隐马尔可夫模型的讲解类似，我们在这里依旧围绕自然语言处理中的经典问题<strong>词性标注问题</strong>进行讨论和解释。</p><ul><li>给定一个句子X，输出句子中每一个单词对应的词性。</li></ul><p><img src="1.png" alt="词性标注任务"></p><p>与隐马尔可夫模型不同的是，线性模型与对数线性模型将词性标注转化为了一个<strong>多元分类</strong>问题，它们将不再以整个句子序列作为模型的输入，整个句子的词性序列作为模型的输出，而是假设<strong>词语之间的预测相互独立</strong>，将问题转化为<strong>从所有可能的词性类别中选取某个词语最有可能的类别进行输出</strong>。</p><h2 id="什么是线性模型"><a href="#什么是线性模型" class="headerlink" title="什么是线性模型"></a>什么是线性模型</h2><p>线性模型（Linear Model)，又称为<strong>线性回归模型</strong>，是一种<strong>有监督学习模型</strong>。我们曾经在高中的时候学习过一种回归方法——线性回归。将这个方法泛化，就可以得到我们的线性模型。</p><p>我们以吴恩达老师在coursera上的机器学习课程中的房价预测例子进行说明。</p><p><img src="2.png" alt="房价预测"></p><p>如上图所示，假设我们得到了一个当地的房价数据集，其中包括了房子的面积、卧室数、层数、房龄等信息，同时给出了对应的房价。我们需要解决的问题就是如何<strong>利用房子的信息预测出它的价格</strong>。在机器学习中，我们把类似于面积、卧室数等这些样本的信息叫做<strong>样本的特征（Feature）</strong>，它们是我们进行预测的依据。我们把需要预测的值叫做<strong>样本的标签（Label)</strong>。训练集中的每一个样本是一个<strong>（特征，标签)二元组</strong>。</p><p>在机器学习中，样本的特征往往是人工选择的，例如上述的面积、卧室数、层数等房屋信息。如何选择合适的特征是一门高深的学问，我们称其为<strong>特征工程</strong>。特征往往不止一个，所以使用<strong>向量</strong>的形式对其进行表示。在这里，我使用列向量$\vec x=(x_1,x_2…x_n)$来表示特征向量，由于书写列向量不是很方便，所以只能这么书写，但你需要记住$\vec x$是一个列向量。</p><p>当给定某个房子的面积、卧室数、层数、房龄等特征，在线性模型中，我们会使用一个线性方程来计算房子的价格。我们使用$h$表示这个线性方程，$h$代表<strong>hypothesis</strong>(<strong>假设</strong>) ，具体公式如下：<br>$$<br>h_{w}(x)=w_0+w_1x_1+w_2x_2+…+w_nx_n<br>$$<br>我们为每个特征给定一个特征权重$w$，这个权重可以是正数也可以是负数。其中，$w_0$为<strong>偏置项</strong>（bias），专门用来表示方程中的常数项。通过训练样本学习权重$w$，我们便可使用上述方程进行预测。</p><p>为了使公式简洁一些，引入$x_0=1$，使用列向量$\vec w=(w_0,w_1…w_n)$来表示权重向量，则公式转化为：<br>$$<br>h_{w}(x)=w_0x_0+w_1x_1+w_2x_2+…+w_nx_n\<br>=w^Tx<br>$$</p><h2 id="线性模型的泛化"><a href="#线性模型的泛化" class="headerlink" title="线性模型的泛化"></a>线性模型的泛化</h2><p>看到上述的线性方程，你可能会疑惑：上述方程得到的仅仅是一条直线方程，而需要拟合的数据点往往不能通过简单的直线来拟合。换句话说， 如果仅仅使用在此之前的单元和多元线性回归，<strong>我们只能得到多维空间的高维平面</strong>。为了进一步增强泛化能力，我们可以引入<strong>幂次项特征和多项式特征</strong>。 </p><p>例如，我们的模型原先只是一个线性方程：<br>$$<br>h_{w}(x)=w_1x_1+w_2x_2<br>$$<br>为了增强拟合能力，我们可以令$x_3=x_1^2$，$x_4=x_2^2$，$x_5=x_1x_2$。于是，我们的模型将变为：<br>$$<br>h_{w}(x)=w_1x_1+w_2x_2+w_3x_3+w_4x_4+w_5x_5\<br>=w_1x_1+w_2x_2+w_3x_1^2+w_4x_2^2+w_5x_1x_2<br>$$<br>可以看到，此时我们的模型将可以拟合复杂的非线性函数。<strong>也就是说，很多复杂的模型都可以转化为线性模型进行建模。</strong></p><p>但需要注意的是：<strong>过多地使用幂次项特征和多项式特征会使模型的拟合能力太强，从而导致过拟合的问题</strong>。我将专门 写一篇blog来讲解机器学习中的过拟合问题，并介绍一些解决过拟合的办法，如正则化和dropout等。</p><h2 id="线性模型的特征提取"><a href="#线性模型的特征提取" class="headerlink" title="线性模型的特征提取"></a>线性模型的特征提取</h2><h3 id="连续型特征"><a href="#连续型特征" class="headerlink" title="连续型特征"></a>连续型特征</h3><p>特征分为连续型特征和离散型特征。<strong>连续型特征顾名思义就是取值是连续的特征，例如上述例子中的房子面积。</strong>在实际的机器学习过程中， 很少直接将连续值作为线性回归模型和逻辑回归模型的特征输入，而是将连续特征离散化为一系列0、1特征交给模型，这样做的优势有以下几点： </p><ol><li>离散特征的增加和减少都很容易，易于模型的<strong>快速迭代</strong>。</li><li>稀疏向量内积乘法运算<strong>速度快</strong>，计算结果<strong>方便存储，容易扩展</strong>。</li><li>离散化后的特征对异常数据有很强的<strong>鲁棒性</strong>：比如一个特征是年龄&gt;30是1，否则0。如果特征没有离散化，一个异常数据“年龄300岁”会给模型造成很大的干扰。</li><li>线性回归模型和逻辑回归模型属于广义线性模型，表达能力受限；单变量离散化为N个后，每个变量有单独的权重，相当于为模型引入了非线性，<strong>能够提升模型表达能力，加大拟合</strong>。</li><li>离散化后可以<strong>进行特征交叉</strong>，由M+N个变量变为M*N个变量，进一步引入非线性，提升表达能力。</li><li>特征离散化后，模型会更<strong>稳定</strong>，比如如果对用户年龄离散化，20-30作为一个区间，不会因为一个用户年龄长了一岁就变成一个完全不同的人。当然处于区间相邻处的样本会刚好相反，所以怎么划分区间是门学问。</li><li>特征离散化以后，起到了简化模型的作用，降低了模型<strong>过拟合</strong>的风险。</li></ol><h3 id="离散性特征"><a href="#离散性特征" class="headerlink" title="离散性特征"></a>离散性特征</h3><p><strong>离散型特征顾名思义就是取值是离散的特征，例如上述例子中的房龄、卧室数和层数。</strong>对于离散型特征，我们使用一种叫做<strong>one-hot</strong>的方法进行编码。</p><p>one-hot的基本思想：<strong>将离散型特征的每一种取值都看成一种状态</strong>，若你的这一特征中有N个不相同的取值，那么我们就可以将该特征抽象成N种不同的状态，one-hot编码保证了每一个取值只会使得一种状态处于“激活态”，也就是说这N种状态中只有一个状态位值为1，其他状态位都是0。举个例子，假设我们以学历为例，我们想要研究的类别为小学、中学、大学、硕士、博士五种类别，我们使用one-hot对其编码就会得到：</p><blockquote><p>小学-&gt;[1,0,0,0,0]</p><p>中学-&gt;[0,1,0,0,0]</p><p>大学-&gt;[0,0,1,0,0]</p><p>硕士-&gt;[0,0,0,1,0]</p><p>博士-&gt;[0,0,0,0,1]</p></blockquote><p><strong>特别地，如果该离散型特征只有True或False两种取值，那么我们通常用1表示True，0表示False</strong>。</p><h2 id="线性模型的训练过程"><a href="#线性模型的训练过程" class="headerlink" title="线性模型的训练过程"></a>线性模型的训练过程</h2><h3 id="定义优化目标"><a href="#定义优化目标" class="headerlink" title="定义优化目标"></a>定义优化目标</h3><p>当我们写出了假设函数$h$后，接下来我们要做的就是通过已有的训练集得到合适的模型权重$\vec w=(w_0,w_1…w_n)$。</p><p>为了进行权重的训练，首先，我们要定义三个函数：</p><ol><li><strong>损失函数（Loss Function ）</strong>：<strong>单个样本</strong>的预测值和真实值（标签）的误差。</li><li><strong>代价函数（Cost Function ）</strong>：<strong>整个训练集所有样本</strong>的预测值和真实值（标签）的误差，也就是损失函数的平均。</li><li><strong>目标函数（Object Function）</strong>：<strong>最终需要优化的函数</strong>。等于经验风险+结构风险（也就是代价函数 + 正则化项）。</li></ol><p><strong>这里，我们先不讲解正则化的知识，假设我们的目标函数即为代价函数</strong>。那么线性模型的优化问题即为最小化所有样本的误差的平均值。线性模型的误差可以用许多函数来表示，其中比较常用的一种是<strong>均方误差</strong>（Mean squared error），这里我们使用均方误差来描述我们的模型误差（PS：更多损失函数可以参考<a href="https://www.jiqizhixin.com/articles/091202" target="_blank" rel="noopener">机器学习中常用的损失函数你知多少？</a>）</p><p>假设训练集中样本的标签为$y$，样本的数量为$m$，预测值为假设函数的输出$h_{w}(x)$，则需要优化的目标函数为：<br>$$<br>J(w)=\frac{1}{2m}\sum_{i=1}^{m}(h_w(x^{(i)})-y^{(i)})^2<br>$$<br>我们的目标便是<strong>选择出可以使得模型的均方误差能够最小的模型参数</strong>，即<strong>找到合适的模型权重$\vec w$，使$J(w)$取得最小值</strong>。需要注意的是，目标函数中的1/2仅仅是为了方便求导。</p><h3 id="从极大似然估计到损失函数"><a href="#从极大似然估计到损失函数" class="headerlink" title="从极大似然估计到损失函数"></a>从极大似然估计到损失函数</h3><p>在隐马尔可夫模型的讲解中，我曾经说过损失函数和极大似然估计有着紧密的联系，例如<strong>我们在逻辑回归模型里使用的交叉熵损失函数其实就是似然函数加上负号</strong>。也就是说，<strong>最优化问题既可以理解为最大化模型的似然估计，也可以理解为最小化模型的损失函数</strong>。</p><p>为什么会出现这样的现象呢？其实这并不是巧合，是可以通过数学公式进行推导的。具体推导内容可以参考这篇讲义<a href="https://wenku.baidu.com/view/78d16462c9d376eeaeaad1f34693daef5ff713d2.html" target="_blank" rel="noopener">各损失函数与最大似然</a>。</p><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><h4 id="正规方程法"><a href="#正规方程法" class="headerlink" title="正规方程法"></a>正规方程法</h4><p>正规方程法可以用于求解线性模型的目标函数取得最小值时，权重$w$的准确值。但在机器学习中，我们很少使用这种方法求解模型的权重，我在这里简单提一下它的弊端：</p><ol><li>对于一个由$n$个训练样本的特征向量$x$组成的训练集矩阵$X$，计算极值点的时间复杂度为$O(n^3)$，<strong>当训练集规模很大时，正规方程法将变得十分缓慢。</strong></li><li>正规方程法需要使用训练集矩阵$X$的逆矩阵$X^{(-1)}$，但是<strong>我们无法保证$X$一定可逆。</strong></li><li><strong>只适用于线性模型</strong>，不适合逻辑回归模型等其他模型 。</li></ol><h4 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h4><p>我们已经说过，当训练集规模很大时，例如有上百万、上千万的数据时，正规方程法将会非常缓慢，那么有没有办法能够降低时间复杂度呢？答案是有的，我们在这里可以使用<strong>梯度下降法</strong>进行求解。</p><p>为了将问题简化，我们假设模型现在只存在两个特征，对应的权重为$\theta_0$和$\theta_1$。 我们绘制一个等高线图，三个坐标分别为$\theta_0$和$\theta_1$和$J(\theta_0,\theta_1)$： </p><p><img src="3.png" alt="等高线图"></p><p>则可以看出在三维空间中存在一个使得$J(\theta_0,\theta_1)$最小的点，我们可以发现均方差损失函数的图像很明显是一个<strong>凸函数</strong>，即不存在局部最优解的问题。 </p><p>梯度下降法的相当于<strong>我们下山的过程</strong>，每次我们要走一步下山，寻找最低的地方，那么最可靠的方法便是环顾四周，寻找下山速度最快的方向前进，持续该过程，最后便能无限接近最低点。</p><p>对于函数而言，<strong>便是求得该函数对所有参数的偏导（梯度），每次根据梯度更新这些参数，直到参数收敛为止，注意这些参数必须同步进行更新</strong>。 从数学上的角度来看，梯度的方向是函数增长速度最快的方向，那么梯度的反方向就是函数减少最快的方向。那么，如果想计算一个函数的最小值，就可以使用梯度下降法的思想来做。 </p><p>假设模型共有$n$个特征，加上偏置项的特征$x_0=1$，共有$n+1$个特征。则对于某个权重参数$w_j$进行梯度下降的公式可以表示为：<br>$$<br>w_j=w_j-\alpha\frac{dJ(w)}{dw_j}=w_j-\alpha\frac{1}{m}\sum^{m}_{i=1}(h_w(x^{(i)})-y^{(i)})x_j^{(i)}<br>$$<br>其中，<strong>$\alpha$是一个由我们自己设置的超参数（hyper parameter）——学习率</strong> （<strong>learning rate</strong>），它决定了我们沿着能让目标函数下降程度最大的方向向下迈出的步子有多大。 </p><p>梯度下降的过程形象表示便是如下图所示，一步一步下降达到最低点。</p><p> <img src="3.jpg" alt="梯度下降的直观表示"></p><p>需要说明以下几点：</p><ul><li><p>$\alpha$为学习率，学习率决定了学习的速度，<strong>我们需要选择合适的学习率</strong>。</p><ul><li><p>如果$\alpha$过小，那么学习的时间就会很长，导致算法的低效。</p></li><li><p>如果$\alpha$过大，那么由于每一步更新过大，可能无法收敛到最低点。由于越偏离最低点函数的导数越大，如果$\alpha$过大，某一次更新直接跨越了最低点，来到了比更新之前<strong>更高</strong>的地方。那么下一步更新步会更大，如此反复震荡，离最低点越来越远。</p></li><li><p>以上两种情况如下图所示 ：</p><p><img src="2.jpg" alt></p></li></ul></li><li><p><strong>我们的算法不一定能达到最优解</strong>。 但是由于此问题中的目标函数是<strong>凸函数</strong>，所以利用梯度下降法，是可以找到全局最优解的。关于凸优化的问题，我在这里不详细阐述。 </p></li><li><p>我们这里得到的是<strong>数值解</strong>而非解析解，存在着一定误差。</p></li></ul><p>顺便说一下，我这里举例的是<strong>批量梯度下降（batch gradient descent,BGD）</strong>，即尝试将<strong>所有样本</strong>的误差优化到最小。这种方法的优点是每次下降都是朝着全局最优的方向前进。但是，我们发现它每次都要计算所有样本的损失，这在大批量数据的情况下会非常缓慢。</p><p>还有一种梯度下降的方法叫做<strong>随机梯度下降法（ Stochastic gradient descent）</strong>，它每次选取<strong>一个随机样本</strong>，尝试优化它的损失函数。虽然随机梯度下降法每次下降是朝着局部最优的方向前进，无法保证全局的优化，但整体而言，它的下降方向还是朝着全局最优点前进的。与此同时，它的计算量相较于批量梯度下降大大减少了。</p><p>此外，还有一种方法叫做<strong>小批量梯度下降法（mini-batch gradient descent）</strong>，这是现在最为常用的一种梯度下降学习法，它是BGD和SGD的折中。它每次尝试优化一个mini-batch-size数量的样本，即减少了运算量，又降低了梯度下降方向出错的可能性。</p><h3 id="过拟合与正则化"><a href="#过拟合与正则化" class="headerlink" title="过拟合与正则化"></a>过拟合与正则化</h3><p>在前面我们提到了可以通过引入<strong>幂次项特征和多项式特征</strong>来增加模型的拟合能力。但是，模型的拟合能力过强有时候并不是一件好事。下面，我将介绍线性回归模型中的<strong>过拟合（over-fitting） 问题</strong>。</p><p>首先，我们给出过拟合的定义：</p><blockquote><p>在统计学中，过拟合（英语：overfitting，或称过度拟合）现象是指在拟合一个统计模型时，使用过多参数。对比于可获取的数据总量来说，一个荒谬的模型只要足够复杂，是可以完美地适应数据。过拟合一般可以视为违反奥卡姆剃刀原则。当可选择的参数的自由度超过数据所包含信息内容时，这会导致最后（拟合后）模型使用任意的参数，这会减少或破坏模型一般化的能力更甚于适应数据。过拟合的可能性不只取决于参数个数和数据，也跟模型架构与数据的一致性有关。此外对比于数据中预期的噪声或错误数量，跟模型错误的数量也有关。 </p></blockquote><p>通俗的说，过拟合问题的本质是<strong>我们模型的学习能力太强，导致过于强调拟合训练集的样本，从而丢失了泛化的能力</strong>。当模型出现了过拟合的问题，它虽然能非常好地适应我们的训练集，但在新输入变量进行预测时可能会效果不好 。</p><p>我们借用吴恩达老师coursera课程中的PPT来描述过拟合、欠拟合、好的拟合三种情况。</p><p><img src="4.png" alt="拟合的情况"></p><p>在这里，我尝试用一个易于理解的例子来解释上述三种情况：</p><blockquote><p>我们可以把学生做练习题的过程看成是模型的训练过程，学生在做了很多练习题后，可以参加考试了，我们可以把考试看作为模型的预测过程。欠拟合很简单，就是平时不认真学习，做练习题和参加考试的分数自然都很低，也就是训练集和测试集的准确率都很低。那么过拟合是什么呢？过拟合就是平时只知道死记硬背，仅仅记住了练习题，却不知道举一反三，虽然平时作业分数很高，但是考试成绩却并不好，也就是训练集准确率很高，但测试集准确率很低。最佳的情况就是既认真做练习，又不局限于练习题，这种就是我们虽说的拟合较好的情况。</p></blockquote><p>为了解决过拟合的问题，我们应该引入一个<strong>参数项</strong>，<strong>在进行梯度下降的时候尽可能使得参数变小</strong>，这样可以使得很多额外的特征的权重接近于0。 这个方法也叫做<strong>正则化</strong>（regularization）。此外，还有一些防止过拟合的办法，例如神经网络中的dropout等，我会在接下来的博客中继续为大家介绍。</p><p>正则化中的参数项一般也叫做正则项，常用的正则项有以下两种：</p><ul><li>L1正则项：各个权重的<strong>绝对值之和</strong>，可以产生稀疏权值矩阵，即产生一个稀疏模型，可以用于<strong>特征选择</strong> 。同时，一定程度上也可以防止过拟合 。</li><li>L2正则项：各个权重的<strong>平方和</strong>，可以防止模型过拟合。</li></ul><p>线性模型和对数线性模型中，我们通常采用的是L2正则项。加入正则项后，模型的代价函数变为：<br>$$<br>J(w)=\frac{1}{2m}[\sum_{i=1}^{m}(h_w(x^{(i)})-y^{(i)})^2+\lambda\sum_{j=1}^{n}w^2]<br>$$<br>梯度下降的公式变为：<br>$$<br>w_j=w_j-\alpha\frac{dJ(w)}{dw_j}=w_j-\alpha\frac{1}{m}\sum^{m}_{i=1}[(h_w(x^{(i)})-y^{(i)})x_j^{(i)}+\lambda w_j]<br>$$<br>我们发现，通过引入正则化项，可以使模型的所有参数在梯度下降时多下降一些，从而尽可能地减小。上式中，$\lambda$是一个用于控制正则化程度的超参数，我们一般称其为<strong>正则化系数</strong>，如果$\lambda$过大，则所有权重将趋近于0， 这样我们所得到的只能是一条平行于x轴的直线 。 所以对于正则化，我们要取一个合理的$\lambda$的值 。超参数的选择是机器学习中最为常见的问题，我们一般使用<strong>开发集</strong>进行调参。</p><p>顺便提一下，过拟合的情况下，增加训练集的样本数量将会使模型的性能得到提升。在当今这个海量数据的时代，数据是容易获得的，所以深度学习的常见做法是训练出一个拟合能力很强（层数深、神经元多）的神经网络，加上大规模的训练样本，再加上一些正则化的方法，所得出的模型通常性能最好。</p><h2 id="回到词性标注问题上来"><a href="#回到词性标注问题上来" class="headerlink" title="回到词性标注问题上来"></a>回到词性标注问题上来</h2><p>相信通过前面的介绍，你已经对线性模型有了基本的认识，下面我们回到词性标注任务上，简单地介绍一下如何基于多元分类的思想使用线性回归模型进行词性标注。</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>在我们之前的介绍中，你可能会发现，线性模型主要是用于解决机器学习中的<strong>回归（regression）问题</strong>。也就是说，它预测的最终结果通常是连续值。虽然与对数线性模型相比，线性模型不常用于<strong>分类（classification）</strong>，但在介绍对数线性模型之前，我们仍可以通过一些方法使其运用在分类标注词性上。</p><p>最基本的思想就是，<strong>我们通过选取词语的一些特征，训练出一个线性模型，模型的输出为该词语标注为各词性的分值（score），然后我们选取分值最大的词性作为预测的结果。</strong>通过这一转化，我们将线性回归模型运用在了分类问题上。</p><h3 id="特征获取"><a href="#特征获取" class="headerlink" title="特征获取"></a>特征获取</h3><p>与之前预测房价的例子不同，词性标注模型的特征不是事先定义好的，而是通过<strong>特征模板（feature template）</strong>在训练集中抽取而来的。特征模板需要专家进行手工的定义。目前，学术界常用的用于词性标注的特征模板如下表所示。</p><p><img src="5.png" alt="特征模板"></p><p>可以看到，我们一共使用了14种特征模板，其中包含了许多有用的信息，例如词信息，字信息，词缀信息等等。</p><p>在实际训练过程中，我们需要先构建<strong>特征空间（feature space）</strong>。它是训练集中所有特征的集合。<strong>构建的方式是：我们每次选取一个词，根据特征模板抽取相应的14种特征，并将其加入到特征空间内。需要注意的是特征空间中不能出现重复的特征。</strong></p><p>在这里，我们还可以对特征抽取进行优化。我们观察特征模板可以发现，<strong>对于每个样本，每一种特征的模板都需要抽取每一种词性的特征，而对于所有不同的词性，其特征模板的后缀都是相同的</strong>。通过计算机中经常使用的<strong>段加偏移</strong>的思想，我们可以大大减少构建特征空间所耗费的时间，将时间复杂度由$O(MN)$降为$O(M+N)$。具体的优化操作不再赘述，大家可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/9-linear-model/main2.pdf" target="_blank" rel="noopener">李老师的讲义</a>。</p><p>我在这里画出了这个线性模型的示意图，你应该就能理解为什么它的特征空间可以用二维矩阵的方式来存储，以及它是如何工作的。</p><p><img src="6.png" alt="词性标注的线性模型"></p><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>对于模型的训练，我们将采用一种叫做<strong>在线学习（Online training）</strong>的方式。这是一种经常用于<strong>推荐系统</strong>的学习算法，方便对模型进行实时训练。你可以把它看作是一种近似于我们之前所提到的随机梯度下降法的学习算法。它每次选取<strong>一个实例</strong>进行训练。由于样本的标签是经过one-hot处理的离散值，而我们模型的输出是取值范围在负无穷到正无穷的连续值，所以我们在这里无法使用前述的梯度下降算法进行参数的训练。取而代之的是如下的算法。</p><p><img src="7.png" alt="Online Training"></p><p>简单的讲解一下，可以看到，我们每次选取一个样本进行训练，如果该样本预测正确，那么不修改模型的参数，否则，将该样本与正确词性关联的特征权重全部加1，与错误词性关联的特征权重全部减1。你可以看作是<strong>给预测正确词性的特征一个激励，而给预测错误词性的特征一个惩罚</strong>。</p><p>特别地，我们在这里还可以使用上图中$v$作为模型特征权重，这叫做<strong>averaged perceptron</strong>。有关学习算法的优化问题我将专门撰写一篇博客，介绍常见的优化算法，如momentum算法，RMsprop算法和Adam算法等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是线性回归模型的基础知识，我本来只想对它做一下简略的介绍，将梯度下降、正则化这些方法留到对数线性模型的博客中进行总结，但考虑到叙述的连贯性，一并在线性模型中进行了介绍。下面，我将介绍传统机器学习中的大杀器——逻辑回归模型（Logistic Regression Model），也就是我们所说的对数线性模型，并按照惯例，给出其解决词性标注问题的基本思想。</p><h2 id="参考资料（部分）"><a href="#参考资料（部分）" class="headerlink" title="参考资料（部分）"></a>参考资料（部分）</h2><ul><li><a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">苏州大学李正华老师的课件</a></li><li>李航老师《统计学习方法》的第六章</li><li>Andrew Ng的机器学习课程</li><li>Andrew Ng的深度学习课程</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer题解</title>
      <link href="/2020/03/21/jian-zhi-offer-ti-jie/"/>
      <url>/2020/03/21/jian-zhi-offer-ti-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近随便投了字节跳动的暑期实习生，没想到简历过关了，4.12日先去笔试。考虑到Leetcode上面的题目比较多，决定先把《剑指Offer》上的所有题目都刷一遍。</p><h2 id="1-数组中重复的数字"><a href="#1-数组中重复的数字" class="headerlink" title="1. 数组中重复的数字"></a>1. <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中重复的数字</a></h2><p>思路：使用<strong>哈希表或者集合</strong>等数据结构，遍历数组中的数字，当数字没有出现在集合中时，将其加入集合，当数字已经出现在集合中时，说明其重复了，直接返回。</p><p>时间复杂度：$O(n)$，n为数组大小。</p><p>空间复杂度:  $O(n)$</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dic<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-二维数组中的查找"><a href="#2-二维数组中的查找" class="headerlink" title="2.  二维数组中的查找"></a>2. <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener"> 二维数组中的查找</a></h2><p>思路：有些类似于<strong>二叉查找树</strong>的思路，从右上角开始搜索，左侧的数字都比当前数小，下方的数字都比当前数大。如果当前数小于目标，则向下移动一格，大于目标，则向左移动一格，等于目标返回True，超出边界时需要返回False。</p><p>时间复杂度：$O(m+n)$，这是从右上角搜索到左下角的最坏情况，m为行数，n为列数。</p><p>空间复杂度:  $O(1)$</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findNumberIn2DArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> matrix<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            row<span class="token operator">=</span><span class="token number">0</span>            col<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>                    col<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">elif</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>                    row<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-替换空格"><a href="#3-替换空格" class="headerlink" title="3.替换空格"></a>3.<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">替换空格</a></h2><p>思路：将字符串转换为字符列表进行遍历替换即可。（也可以直接调用字符串的replace函数）</p><p><strong>注意：Python中常见的不可变类型有数字、字符串和元组，可变类型有列表和字典。区别主要是： 当不可变数据类型的对应变量的值发生了改变，那么它对应的内存地址也会发生改变。 而可变数据类型可以在不改变内存地址的前提下修改对应内存的值。所以，如果我们要原地修改字符串的内容，需要将其转换为列表。</strong></p><p>时间复杂度：$O(n)$，n为原字符串长度。</p><p>空间复杂度:  $O(m)$，m为替换空格后字符串长度。</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">replaceSpace</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        stLi<span class="token operator">=</span>list<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>stLi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> stLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">' '</span><span class="token punctuation">:</span>                stLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'%20'</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>stLi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-从尾到头打印链表"><a href="#4-从尾到头打印链表" class="headerlink" title="4.从尾到头打印链表"></a>4.<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">从尾到头打印链表</a></h2><p>思路1：递归法，递归结束条件为当前指针为None，利用递归的机制进行求解。<strong>（非尾递归，会先将当前层递归函数保存在栈空间中，等待下层递归函数执行完返回）</strong></p><p>时间复杂度：$O(n)$，n为链表长度。</p><p>空间复杂度:  $O(n)$。</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reversePrint</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>reversePrint<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">[</span>head<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token keyword">if</span> head<span class="token operator">!=</span>None <span class="token keyword">else</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：执行语句 A if 条件语句 else 执行语句B，如果条件满足则执行A，否则执行B。</p><p>思路2：<strong>辅助栈</strong>，利用栈的性质（先进后出）求解。</p><p>时间复杂度：$O(n)$，n为链表长度。</p><p>空间复杂度:  $O(n)$。</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reversePrint</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        p<span class="token operator">=</span>head        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> result<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-重建二叉树"><a href="#5-重建二叉树" class="headerlink" title="5. 重建二叉树"></a>5. <a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">重建二叉树</a></h2><p>思路：我们生成二叉树主要有两种做法，一是利用标记了空节点的层次遍历序列，二是利用前序（后序）遍历加上中序遍历。后者的具体做法是<strong>分治法</strong>：</p><ul><li><strong>前序遍历的第 1 个结点一定是二叉树的根结点</strong>；</li><li>在中序遍历中，根结点把中序遍历序列分成了两个部分，左边部分构成了二叉树的根结点的左子树，右边部分构成了二叉树的根结点的右子树。</li><li>查找根结点在中序遍历序列中的位置，可以遍历，也可以在一开始就记录下来。</li></ul><p><img src="5.png" alt="分治法"></p><p>通过分治，我们可以递归求解。</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>preL<span class="token punctuation">,</span>preR<span class="token punctuation">,</span>inL<span class="token punctuation">,</span>inR<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> preL<span class="token operator">></span>preR <span class="token operator">or</span> inL<span class="token operator">></span>inR<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当前子树为空</span>                <span class="token keyword">return</span> None            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preL<span class="token punctuation">]</span><span class="token punctuation">)</span>            inPos<span class="token operator">=</span>inorder<span class="token punctuation">.</span>index<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            leftLen<span class="token operator">=</span>inPos<span class="token operator">-</span>inL            root<span class="token punctuation">.</span>left<span class="token operator">=</span>build<span class="token punctuation">(</span>preL<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>preL<span class="token operator">+</span>leftLen<span class="token punctuation">,</span>inL<span class="token punctuation">,</span>inPos<span class="token number">-1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#分治，划分左子树和右子树的序列</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>build<span class="token punctuation">(</span>preL<span class="token operator">+</span>leftLen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>preR<span class="token punctuation">,</span>inPos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>inR<span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token keyword">if</span> preorder<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> build<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>preorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>inorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-用两个栈实现队列"><a href="#6-用两个栈实现队列" class="headerlink" title="6. 用两个栈实现队列"></a>6. <a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">用两个栈实现队列</a></h2><p>思路： 我们可以设计栈A用于入队操作，栈B用于将元素倒序，从而实现出队操作。 </p><ul><li><p><strong>加入队尾 <code>appendTail()</code>函数：</strong> 将数字 <code>val</code> 加入栈 <code>A</code> 即可。</p></li><li><p>删除队首<code>deleteHead()</code>函数：</p><p>有以下三种情况。</p><ol><li><strong>当栈 <code>B</code> 不为空：</strong> <code>B</code>中仍有已完成倒序的元素，因此直接返回 <code>B</code> 的栈顶元素。</li><li><strong>否则，当 <code>A</code> 为空：</strong> 即两个栈都为空，无元素，因此返回 -1 。</li><li><strong>否则：</strong> 将栈 <code>A</code> 元素全部转移至栈 <code>B</code> 中，实现元素倒序，并返回栈 <code>B</code> 的栈顶元素。</li></ol></li></ul><p>时间复杂度：入队$O(1)$，出队$O(n)$</p><p>空间复杂度：$O(n)$</p><p>这个思路只需要保证入队、出队操作的正确返回即可，不需要维护一个真正的用栈模拟的队列。还可以用栈A模拟队列，辅助栈B用于模拟队列的入队或者出队操作，不过那样会比较慢，因为每一次使用辅助栈B都会涉及倒序操作。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">CQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>A<span class="token punctuation">,</span> self<span class="token punctuation">.</span>B <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">appendTail</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>A<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">deleteHead</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>B<span class="token punctuation">:</span>             <span class="token keyword">return</span> self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>A<span class="token punctuation">:</span>             <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>A<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>A<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7.斐波那契数列"></a>7.<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">斐波那契数列</a></h2><p>思路：经典题，<strong>动态规划</strong>求解，相较于递归节约时间和空间。</p><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        fib<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            fib<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>fib<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>fib<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">1000000007</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#实际上python只需要在return时取余即可，这里是向java等语言看齐，防止越界</span>        <span class="token keyword">return</span> fib<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事实上，这道题的DP状态矩阵还可以进一步优化，仅<strong>使用两个变量存储</strong>，降为$O(1)$。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a <span class="token operator">+</span> b        <span class="token keyword">return</span> a <span class="token operator">%</span> <span class="token number">1000000007</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-青蛙跳台阶问题"><a href="#8-青蛙跳台阶问题" class="headerlink" title="8.青蛙跳台阶问题"></a>8.<a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">青蛙跳台阶问题</a></h2><p>思路：依然是<strong>动态规划</strong>问题，青蛙跳到第1级台阶只有一个路径，第2级台阶只有两个路径，第n级台阶的路径为跳到第n-2级台阶的路径数加上跳到第n-1级台阶的路径数之和。    </p><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numWays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        a<span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span>        <span class="token keyword">if</span> n<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> a        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            a<span class="token punctuation">,</span>b<span class="token operator">=</span>b<span class="token punctuation">,</span>a<span class="token operator">+</span>b        <span class="token keyword">return</span> b<span class="token operator">%</span><span class="token number">1000000007</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-旋转数组的最小数字"><a href="#9-旋转数组的最小数字" class="headerlink" title="9.旋转数组的最小数字"></a>9.<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">旋转数组的最小数字</a></h2><p>思路：这种类型的题目，如果我们直接使用线性级别的时间复杂度肯定能做，但没啥意思。查找、排序的题目如果想达到对数级别的时间复杂度，一定要尝试<strong>二分法（减治思想）</strong>。</p><ul><li>本题的思路是通过二分法减治<strong>排除必不可能是最小值的元素</strong>。<ul><li>首先，与常规二分法一样，我们设置两个指针left和right指向数组的左右边界。mid=（left+right）//2</li><li>我们比较numbers[mid]与numbers[right]的值，分为以下三种情况:<ul><li>numbers[mid]&lt;numbers[right]：根据旋转数组的性质，说明从numbers[mid]到numbers[right]必然是升序序列，所以mid+1到right的数字必然大于mid位置的数字，所以它们都不可能是最小值，可以排除，进入[left，mid]闭区间查找最小值。</li><li>numbers[mid]&gt;numbers[right]：根据旋转数组的性质，说明旋转点必然在numbers[mid+1]到numbers[right]之间，进入[mid+1，right]闭区间查找最小值。</li><li>numbers[mid]==numbers[right]：此时，我们不知道最小值在[left，mid]闭区间还是[mid+1，right]闭区间中， 例 [1, 0, 1, 1, 1]中，最小值在[left，mid]，例[1, 1, 1, 0, 1]中，最小值在[mid+1，right]中。虽然我们无法进行二分减治，但是此时我们确定了两个相等的数，并且我们知道删除其中一个不影响最终寻找最小值，我们可以将right减1，缩小区间，再次尝试二分。</li><li>迭代二分后，最终left将超过right，此时left的位置即为最小值的位置。</li></ul></li></ul></li><li>为什么不比较numbers[mid]与numbers[left]的值？<ul><li>例子[1,2,3,4,5]中，numbers[mid]&gt;numbers[left]，最小值在[left，mid]中，但在例子[3,4,5,1,2]中，numbers[mid]&gt;numbers[left]，最小值却在[mid+1，right]中，考虑到未旋转的特殊情况，我们不能使用中间数与首个数比较。</li></ul></li></ul><p>时间复杂度：$O(logn)$</p><p>空间复杂度：$O(1)$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> numbers<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#二分查找这里是小于等于，因为二分查找需要比较最后一个长度为1的区间的值与目标是否相等，这里仅需找到最后一个长度为1的区间即可</span>            mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">if</span> numbers<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>numbers<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">elif</span> numbers<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>numbers<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                right<span class="token operator">=</span>mid            <span class="token keyword">else</span><span class="token punctuation">:</span>                right<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> numbers<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-矩阵中的路径"><a href="#10-矩阵中的路径" class="headerlink" title="10.矩阵中的路径"></a>10.<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">矩阵中的路径</a></h2><p>思路：这类走迷宫问题，我们首先很容易想到的就是<strong>DFS+回溯算法</strong>。类似的题目还有解数独、全排列、皇后问题等。基本的思路就是尝试从矩阵中的每个位置出发，如果当前位置的字符等于目标字符串的首字符，那么继续向左、右、上、下四个方向尝试匹配，目前字符串的指针加1。如果目标字符串的指针到达其长度，说明已经完成匹配，可以返回True。特别地，在这里，同一位置的字符不能重复选择，我们需要设置一个visited矩阵。</p><p><img src="10.png" alt="复杂度分析"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exist</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> board<span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index<span class="token operator">==</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span>word<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">and</span> visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">:</span>                    visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                    res<span class="token operator">=</span>backtrack<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token number">-1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token number">-1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#这里不能直接return，否则无法回溯</span>                    visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">False</span><span class="token comment" spellcheck="true">#回溯已访问矩阵</span>                    <span class="token keyword">return</span> res        <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">##尝试每个位置出发</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PS：这里的visited矩阵可以不用开，直接原地修改board矩阵的元素为False即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exist</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index<span class="token operator">==</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span>word<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>                    tmp<span class="token punctuation">,</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token boolean">False</span>                    res<span class="token operator">=</span>backtrack<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token number">-1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token number">-1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                    board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span>tmp                    <span class="token keyword">return</span> res        <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-机器人的运动范围"><a href="#11-机器人的运动范围" class="headerlink" title="11. 机器人的运动范围"></a>11.<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener"> 机器人的运动范围</a></h2><p>思路：DFS，有点类似于二叉树的节点数统计。判断当前位置是否可以到达的条件是：</p><ol><li>没有越界；</li><li>数位和小于k；</li><li>未访问过。</li></ol><p>一旦该位置不可到达，立刻返回0；如果该位置可达，那么返回1+dfs(row+1,col)+dfs(row,col+1)，表示当前节点可达且继续向右、下方遍历。</p><p>注意，此处机器人虽然可以向上、下、左、右进行遍历，但是我们发现一个地图上所有的格子都可以通过向右走和向下走到达，那么为了防止重复的判断，我们只向下和向右走。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">movingCount</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;</span>m <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;</span>n <span class="token operator">and</span> <span class="token punctuation">(</span>row<span class="token operator">//</span><span class="token number">10</span><span class="token operator">+</span>row<span class="token operator">%</span><span class="token number">10</span><span class="token operator">+</span>col<span class="token operator">//</span><span class="token number">10</span><span class="token operator">+</span>col<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span>k <span class="token operator">and</span> visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">:</span>                visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>dfs<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token operator">+</span>dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：$O(mn)$</p><p>空间复杂度：$O(mn)$</p><h2 id="12-剪绳子"><a href="#12-剪绳子" class="headerlink" title="12.剪绳子"></a>12.<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">剪绳子</a></h2><p>思路：动态规划，dp[i]为整数i可以拆分得到的最大乘积。转移方程为：从1到i-1遍历分解因子j，选择分解后乘积最大的结果，作为当前的状态值。需要注意的是max(dp[i-j],i-j)这一步，因为整数i拆分后的最大乘积不一定大于i，所以要进行比较，例如dp[2]=1&lt;2，所以2并不需要拆分。</p><ul><li>时间复杂度：$O(N^2)$，两侧 <code>for</code> 循环。</li><li>空间复杂度：$O(N)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">integerBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token operator">-</span>j<span class="token punctuation">)</span><span class="token operator">*</span>j<span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，我们通过<a href="https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-shu-xue-fang-fa-han-wan-zheng-t/" target="_blank" rel="noopener">数学证明</a>可以得知，只要尽量把整数i分解为更多的3或2即可，省去了许多分解因子的比较。</p><p>同时，我们还可以使用滚动数组的方法减少状态矩阵的空间占用。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">integerBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            <span class="token number">3</span> <span class="token operator">*</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><h2 id="13-剪绳子-II"><a href="#13-剪绳子-II" class="headerlink" title="13.剪绳子 II"></a>13.<a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/" target="_blank" rel="noopener">剪绳子 II</a></h2><p>思路：和上一题一样，由于我们求导得到的极大值点为e，所以我们要尽量把整数分解为更多的3或者2。最后结果取余1000000007即可（python没有溢出的问题），否则要用快速幂取余法求余数。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">integerBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            <span class="token number">3</span> <span class="token operator">*</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">1000000007</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-二进制中1的个数"><a href="#14-二进制中1的个数" class="headerlink" title="14.二进制中1的个数"></a>14.<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">二进制中1的个数</a></h2><p>思路：根据十进制数与二进制数进行转换的方法，按位判断。</p><ul><li>时间复杂度：$O(logN)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hammingWeight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        count<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                count<span class="token operator">+=</span><span class="token number">1</span>            n<span class="token operator">//=</span><span class="token number">2</span>        <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化的思路：根据以下事实：</p><ul><li>一个数 n与一个比它小 1 的数（n - 1）进行与运算（&amp;）之后，得到的结果会消除 n中最低位的 1.</li></ul><pre><code>示例1: 7 &amp; 600111      &amp;   =》 0011000110示例2: 8 &amp; 701000      &amp;   =》 0000000111</code></pre><p>可以看到，通过与运算不断地消去1，直到 n==0 即可。统计消去的次数，即为n中1的个数。</p><ul><li>时间复杂度：$O(M)$。M为1的个数。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hammingWeight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        count<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            n<span class="token operator">&amp;</span><span class="token operator">=</span>n<span class="token number">-1</span>            count<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="15-数值的整数次方"><a href="#15-数值的整数次方" class="headerlink" title="15.数值的整数次方"></a>15.<a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">数值的整数次方</a></h2><p>思路：快速幂算法，曾经在我的另一篇博客中有提到，第50题。基本思想是二分递归。</p><ul><li>时间复杂度：$O(logN)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">myPow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> float<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">fastpow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">1</span>            half<span class="token operator">=</span>fastpow<span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> half<span class="token operator">*</span>half            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> x<span class="token operator">*</span>half<span class="token operator">*</span>half        <span class="token keyword">if</span> n<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>            n<span class="token operator">=</span><span class="token operator">-</span>n            x<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span>x        <span class="token keyword">return</span> fastpow<span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="16-打印从1到最大的n位数"><a href="#16-打印从1到最大的n位数" class="headerlink" title="16.打印从1到最大的n位数"></a>16.<a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">打印从1到最大的n位数</a></h2><p>思路：这道题没什么好说的，如果用python的列表很好做。但如果是其他语言的话，数字可能在后期会溢出。当可能溢出时，需要把问题转化为大数加法，应考虑进位和最高位是否进位的问题。此外，还可以将其转化为0-9在n个位置上的全排列问题。后两种解法都需要考虑怎么去除最前面的0。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">printNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>pow<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="17-删除链表的节点"><a href="#17-删除链表的节点" class="headerlink" title="17.删除链表的节点"></a>17.<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">删除链表的节点</a></h2><p>思路：数据结构中单链表的最基础操作，使用一个指针，当其next节点的值为需要删除的值时，通过移动next指针指向next节点的next指针，完成删除操作。</p><p>特别地，为了不讨论在链表头部删除节点的特殊情况，我们额外添加一个空的头节点。</p><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def deleteNode(self, head: ListNode, val: int) -&gt; ListNode:        dummyhead=ListNode(0)        dummyhead.next=head        p=dummyhead        while (p.next!=None):            if p.next.val==val:                p.next=p.next.next                break            p=p.next        return dummyhead.next</code></pre><h2 id="18-正则表达式匹配"><a href="#18-正则表达式匹配" class="headerlink" title="18.正则表达式匹配"></a>18.<a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">正则表达式匹配</a></h2><p>思路：动态规划求解，这道题我在我的另一篇博客里有提及。</p><ul><li>时间复杂度：$O(MN)$。</li><li>空间复杂度：$O(MN)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> p<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                first_match<span class="token operator">=</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">or</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'.'</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">and</span> p<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'*'</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">or</span> <span class="token punctuation">(</span>first_match <span class="token operator">and</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>first_match <span class="token operator">and</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="19-表示数值的字符串"><a href="#19-表示数值的字符串" class="headerlink" title="19. 表示数值的字符串"></a>19.<a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener"> 表示数值的字符串</a></h2><p>这道题个人感觉纯靠耐心，利用判断慢慢做，暂时先不做了</p><h2 id="20-调整数组顺序使奇数位于偶数前面"><a href="#20-调整数组顺序使奇数位于偶数前面" class="headerlink" title="20. 调整数组顺序使奇数位于偶数前面"></a>20. <a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">调整数组顺序使奇数位于偶数前面</a></h2><p>思路：双指针法，我的思路来自于快速排序。指针left指向数组最左侧，指针right指向数组最右侧，如果left处的数字是一个奇数，说明该位置上的数字没问题，我们将left加1；如果是一个偶数，则将其与right处的数字交换，此时right处的数字必为偶数，我们可以将right减1。接着，我们看right处的数字，如果它是一个偶数，说明right处数字没问题，可以将right减1，否则，我们将其与left处的数字交换，此时left处必是奇数，我们可以将left+1.</p><p>由于数组中必然一半是奇数，一半是偶数，上述算法当left==right时跳出即可，说明所有数字已成功移动。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exchange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp<span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>tmp        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                swap<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>                right<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                left<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                right<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                swap<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>                left<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="21-链表中倒数第k个节点"><a href="#21-链表中倒数第k个节点" class="headerlink" title="21.链表中倒数第k个节点"></a>21.<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">链表中倒数第k个节点</a></h2><p>思路：快慢指针法，构建一前一后间隔为k的两个指针，当前方的指针指向None时，返回后方指针。特别地，要讨论一下当快指针到达正数第k个节点之前，慢指针将不会出发。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getKthFromEnd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        p<span class="token operator">=</span>head        q<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>k<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>next                q<span class="token operator">=</span>q<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                k<span class="token operator">-=</span><span class="token number">1</span>                q<span class="token operator">=</span>q<span class="token punctuation">.</span>next        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="22-反转链表"><a href="#22-反转链表" class="headerlink" title="22.反转链表"></a>22.<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">反转链表</a></h2><p>思路：有点类似于主站的k个一组反转链表，简化版，可以用头插法或者尾插法实现翻转。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        p<span class="token operator">=</span>head        q<span class="token operator">=</span>head<span class="token punctuation">.</span>next        <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            p<span class="token punctuation">.</span>next<span class="token operator">=</span>q<span class="token punctuation">.</span>next            q<span class="token punctuation">.</span>next<span class="token operator">=</span>head            head<span class="token operator">=</span>q            q<span class="token operator">=</span>p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这道题由于所有插入均在头部，所以不需要使用dummy head。</p><h2 id="23-合并两个排序的链表"><a href="#23-合并两个排序的链表" class="headerlink" title="23. 合并两个排序的链表"></a>23. <a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">合并两个排序的链表</a></h2><p>思路：这题类似于主站的第21题，我曾在另一篇博客里详细说过，主要的思路是用两个指针比较两个链表中的元素，并选取较小的放入新链表。</p><ul><li>时间复杂度：$O(M+N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> l2<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        dummyhead<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        p<span class="token punctuation">,</span>q<span class="token operator">=</span>l1<span class="token punctuation">,</span>l2        r<span class="token operator">=</span>dummyhead        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None <span class="token operator">and</span> q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>                r<span class="token punctuation">.</span>next<span class="token operator">=</span>p                p<span class="token operator">=</span>p<span class="token punctuation">.</span>next                r<span class="token operator">=</span>r<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                r<span class="token punctuation">.</span>next<span class="token operator">=</span>q                q<span class="token operator">=</span>q<span class="token punctuation">.</span>next                r<span class="token operator">=</span>r<span class="token punctuation">.</span>next        <span class="token keyword">if</span> p<span class="token operator">==</span>None<span class="token punctuation">:</span>            r<span class="token punctuation">.</span>next<span class="token operator">=</span>q        <span class="token keyword">else</span><span class="token punctuation">:</span>            r<span class="token punctuation">.</span>next<span class="token operator">=</span>p        <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>归并排序中合并相邻链表的常规做法，需要注意的是当插入空链表时需要分类讨论，为了减少判断，我们可以使用一个伪头结点。</p><h2 id="24-树的子结构"><a href="#24-树的子结构" class="headerlink" title="24.树的子结构"></a>24.<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">树的子结构</a></h2><p>思路：我们先使用先序遍历，遍历树A。然后调用另一个函数，判断A的当前子树是否与B匹配。如果当前子树与B匹配，返回True，否则继续尝试遍历A当前子树的左子树和右子树，看它们与B是否匹配。</p><p>匹配的函数：</p><ol><li>如果当前节点B为空，说明树B已经匹配至越过叶子节点，返回True</li><li>如果当前节点A为空，说明树A已经匹配至越过叶子节点，但树B还没有匹配完，失配了，返回False</li><li>如果当前节点A和节点B均非空，且A的值与B的值相等，则继续尝试匹配A、B节点的左节点和右节点。</li><li>如果A的值与B的值不等，说明失配，返回False。</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSubStructure</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> B<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>B<span class="token operator">==</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token operator">==</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">.</span>val<span class="token operator">==</span>B<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> match<span class="token punctuation">(</span>A<span class="token punctuation">.</span>left<span class="token punctuation">,</span>B<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> match<span class="token punctuation">(</span>A<span class="token punctuation">.</span>right<span class="token punctuation">,</span>B<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> A<span class="token operator">==</span>None <span class="token operator">or</span> B<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> match<span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>isSubStructure<span class="token punctuation">(</span>A<span class="token punctuation">.</span>left<span class="token punctuation">,</span>B<span class="token punctuation">)</span> <span class="token operator">or</span> self<span class="token punctuation">.</span>isSubStructure<span class="token punctuation">(</span>A<span class="token punctuation">.</span>right<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="25-二叉树的镜像"><a href="#25-二叉树的镜像" class="headerlink" title="25.二叉树的镜像"></a>25.<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">二叉树的镜像</a></h2><p>思路：观察镜像翻转后的二叉树可知，我们可以从上向下进行递归翻转。对于每一个节点，我们将其左子树和右子树交换，然后递归进入左子树和右子树的根节点，继续交换它们的左右子树。你会发现，如果你将当前层调整至镜像后，下一层节点其实已经被两个一组翻转了，只需要交换两个一组内部的节点即可完成翻转。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(N)$。递归要占用栈空间。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token operator">=</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>root<span class="token punctuation">.</span>left            self<span class="token punctuation">.</span>mirrorTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>mirrorTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="26-对称的二叉树"><a href="#26-对称的二叉树" class="headerlink" title="26.对称的二叉树"></a>26.<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">对称的二叉树</a></h2><p>思路：</p><ul><li>对称二叉树规律：<ul><li>对于树中任意两个对称节点A和B，一定有：<ul><li>A.val = B.val：即此两对称节点值相等。</li><li>A 的 左子节点 和 B的 右子节点 对称；</li><li>A 的 右子节点 和 B的 左子节点 对称。</li><li>如果A、B均为空，我们认为它们是对称的。</li><li>如果A、B中一个空一个非空，则必然不对称。</li></ul></li></ul></li><li>根据以上规律，考虑从顶至底递归判断每对节点是否对称，从而判断树是否为对称二叉树。</li></ul><p><img src="26.png" alt="规律"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> A<span class="token operator">==</span>None <span class="token operator">and</span> B<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> A<span class="token operator">==</span>None <span class="token operator">or</span> B<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> A<span class="token punctuation">.</span>val<span class="token operator">==</span>B<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> match<span class="token punctuation">(</span>A<span class="token punctuation">.</span>left<span class="token punctuation">,</span>B<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token operator">and</span> match<span class="token punctuation">(</span>A<span class="token punctuation">.</span>right<span class="token punctuation">,</span>B<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> match<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">if</span> root <span class="token keyword">else</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(N)$。递归要占用栈空间。</li></ul><h2 id="27-顺时针打印矩阵"><a href="#27-顺时针打印矩阵" class="headerlink" title="27.顺时针打印矩阵"></a>27.<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">顺时针打印矩阵</a></h2><p>思路：螺旋矩阵，模拟题，做过很多次了。主站第54题，可以看我的另一篇博客。</p><ul><li>时间复杂度：$O(MN)$。</li><li>空间复杂度：$O(N)$。递归要占用栈空间。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        level<span class="token operator">=</span><span class="token number">0</span>        row<span class="token operator">=</span><span class="token number">0</span>        col<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">if</span> matrix<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        result<span class="token operator">=</span><span class="token punctuation">[</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">]</span>        count<span class="token operator">=</span><span class="token number">1</span>        row_nums<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span>        col_nums<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        size<span class="token operator">=</span>row_nums<span class="token operator">*</span>col_nums        <span class="token keyword">while</span> count<span class="token operator">&lt;</span>size<span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col_nums<span class="token operator">-</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>                col<span class="token operator">+=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>row_nums<span class="token operator">-</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>                row<span class="token operator">+=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col_nums<span class="token operator">-</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>                col<span class="token operator">-=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>row_nums<span class="token operator">-</span>level<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                row<span class="token operator">-=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            level<span class="token operator">+=</span><span class="token number">1</span>            col<span class="token operator">+=</span><span class="token number">1</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>            count<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="28-包含min函数的栈"><a href="#28-包含min函数的栈" class="headerlink" title="28.包含min函数的栈"></a>28.<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">包含min函数的栈</a></h2><p>思路：入栈、出栈、取栈顶元素的操作都很简单，Java中可以用数组或者链表来模拟，而python中可以直接用列表来模拟。唯一的难点在于如何找到当前最小值。如果取最小值的时候遍历整个栈，时间复杂度会是线性的，比较高。我们可以以空间换时间，通过建立一个辅助栈，记录当前栈中的某个元素及其之前的所有元素中的最小值。</p><ul><li>时间复杂度：$O(1)$。</li><li>空间复杂度：$O(N)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MinStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>A<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>B<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>A<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> x<span class="token operator">&lt;</span>self<span class="token punctuation">.</span>B<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">else</span> self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>B<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>A<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>A<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>B<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your MinStack object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MinStack()</span><span class="token comment" spellcheck="true"># obj.push(x)</span><span class="token comment" spellcheck="true"># obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.top()</span><span class="token comment" spellcheck="true"># param_4 = obj.min()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="29-栈的压入、弹出序列"><a href="#29-栈的压入、弹出序列" class="headerlink" title="29.栈的压入、弹出序列"></a>29.<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">栈的压入、弹出序列</a></h2><p>思路：辅助栈模拟法。通过采用一个辅助栈模拟压入、弹出的过程。按照压入序列，每次往辅助栈中压入一个数字，同时查看弹出序列中的第 i 个元素是否为辅助栈的栈顶元素（i初始为0），是则从辅助栈中弹出该元素，并将 i 加1，尝试弹出下一个元素，否则继续压入数字。如果最终辅助栈为空，说明弹出序列在当前压入序列下合法。</p><ul><li>时间复杂度：$O(N)$。将所有元素一遍入栈，一遍出栈，需要 $O(2N)$。</li><li>空间复杂度：$O(N)$。使用了辅助栈 <code>st</code>。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">validateStackSequences</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pushed<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> popped<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        i<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> pushed<span class="token punctuation">:</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>popped<span class="token punctuation">)</span> <span class="token operator">and</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>popped<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                i<span class="token operator">+=</span><span class="token number">1</span>         <span class="token keyword">return</span> <span class="token boolean">True</span> <span class="token keyword">if</span> stack<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="30-I-从上到下打印二叉树"><a href="#30-I-从上到下打印二叉树" class="headerlink" title="30. I. 从上到下打印二叉树"></a>30.<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener"> I. 从上到下打印二叉树</a></h2><p>思路：基本的BFS，队列实现。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            i<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">while</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>None<span class="token punctuation">:</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span>                i<span class="token operator">+=</span><span class="token number">1</span>            queue<span class="token operator">=</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">]</span>        <span class="token keyword">return</span> queue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="31-II-从上到下打印二叉树-II"><a href="#31-II-从上到下打印二叉树-II" class="headerlink" title="31.II. 从上到下打印二叉树 II"></a>31.<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">II. 从上到下打印二叉树 II</a></h2><p>思路：依然是BFS的基本题，采用队列的方式。每一层开始时记录下当前队列中的节点数目 L，并开始让父节点出队，左右子节点非空入队，共重复L次，即完成了一层的遍历，将当前队列中的节点添加至结果数组中。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">]</span><span class="token punctuation">)</span>                l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span>                    queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="32-III-从上到下打印二叉树-III"><a href="#32-III-从上到下打印二叉树-III" class="headerlink" title="32. III. 从上到下打印二叉树 III"></a>32.<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener"> III. 从上到下打印二叉树 III</a></h2><p>思路：依然是BFS的基本题，使用一个level变量记录一下当前的层数即可。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        level<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> level<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span>                    queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                level<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> result   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33.二叉搜索树的后序遍历序列"></a>33.<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">二叉搜索树的后序遍历序列</a></h2><p>思路：这道题就是看数组是否满足某一个二叉搜索树的后序遍历。我们知道：</p><ul><li>后序遍历的最后一个节点都是根节点。数组顺序为： [ 左子树 | 右子树 | 根节点 ] 。</li><li>对于二叉搜索树的任意一个节点，左子树的所有节点必然小于它，右子树的所有节点必然大于它。</li></ul><p>根据上述两个性质，我们可以进行递归分治判断，我们先判断根节点的的左子树是否均比他小，右子树是否均比他大，若成立，则继续判断左子树和右子树是否符合二叉搜索树的定义。至于如何划分子树，可以根据根节点来划分，如果出现了比根节点大的值，则该节点及其后在根节点之前的所有节点均为右子树的节点。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">verifyPostorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> postorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> left<span class="token operator">>=</span>right<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            p<span class="token operator">=</span>left            <span class="token keyword">while</span> <span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">&lt;</span>postorder<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                p<span class="token operator">+=</span><span class="token number">1</span>            pos<span class="token operator">=</span>p            <span class="token keyword">while</span> <span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">></span>postorder<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                p<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> p<span class="token operator">==</span>right<span class="token punctuation">:</span>                <span class="token keyword">return</span> match<span class="token punctuation">(</span>left<span class="token punctuation">,</span>pos<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">and</span> match<span class="token punctuation">(</span>pos<span class="token punctuation">,</span>right<span class="token number">-1</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> match<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>postorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>时间复杂度：$O(N^2)$。最坏情况下是当二叉树退化为链表。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><h2 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34.二叉树中和为某一值的路径"></a>34.<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">二叉树中和为某一值的路径</a></h2><p>思路：递归搜索+回溯。类似于组合数的问题，我在另一篇博客中有提到过，基本做法是从根节点向下递归搜索，如果当前节点为空，则直接返回，如果当前节点不为空，则将当前节点加入至当前路径列表，并将它的值加入至当前路径和中。接着讨论两种情况：（1）当前节点为叶子节点且当前路径和为0，那么将当前路径加入至结果列表中；（2）否则，继续搜索左孩子节点和右孩子节点。讨论完成后，回溯至最初的状态。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>re<span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            re<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            sum<span class="token operator">-=</span>root<span class="token punctuation">.</span>val            <span class="token keyword">if</span> sum<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> root<span class="token punctuation">.</span>left<span class="token operator">==</span>None <span class="token operator">and</span> root<span class="token punctuation">.</span>right<span class="token operator">==</span>None<span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>re<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>re<span class="token punctuation">,</span>sum<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>re<span class="token punctuation">,</span>sum<span class="token punctuation">)</span>            re<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            sum<span class="token operator">+=</span>root<span class="token punctuation">.</span>val        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> re<span class="token punctuation">]</span> <span class="token keyword">for</span> re <span class="token keyword">in</span> result<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>时间复杂度：$O(N)$。本质上就是一次先序遍历加上判断的过程。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35.复杂链表的复制"></a>35.<a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">复杂链表的复制</a></h2><p>思路：这题本质上是模拟复杂链表的深拷贝。既然是深拷贝，我们就不能直接引用，而是应该使用新建值相同的节点类的方式进行拷贝。但是这道题有一个问题，就是存在random指针指向链表中的任意节点或者 <code>null</code>。 所以如何保证拷贝random指针的节点和拷贝next指针的节点的一致性，是我们需要解决的问题。也就是说，如果我们按照next指针顺序进行拷贝节点的话，如果需要拷贝的节点已经因为之前被某个节点的random指针指向，而已经被拷贝过了，如何知道它已经拷贝且正确指向他呢？</p><p>我的思路是使用一个哈希表，哈希表的key是原链表中的节点，哈希表的value是新拷贝得到的节点。当我们进行拷贝时，如果需要拷贝的节点尚且不在哈希表的key中，则我们可以进行拷贝，并将原节点-新节点的键值对保存进哈希表中，当我们再次拷贝某节点，会发现它已被拷贝过，直接将next或random指针指向它即可。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。哈希表使用了额外的空间。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""# Definition for a Node.class Node:    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):        self.val = int(x)        self.next = next        self.random = random"""</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">copyRandomList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Node'</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> head<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        copyhead<span class="token operator">=</span>Node<span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token operator">=</span>copyhead        q<span class="token operator">=</span>head        visited<span class="token operator">=</span><span class="token punctuation">{</span>head<span class="token punctuation">:</span>copyhead<span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> q<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span>                <span class="token keyword">if</span> q<span class="token punctuation">.</span>next <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    visited<span class="token punctuation">[</span>q<span class="token punctuation">.</span>next<span class="token punctuation">]</span><span class="token operator">=</span>Node<span class="token punctuation">(</span>q<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                p<span class="token punctuation">.</span>next<span class="token operator">=</span>visited<span class="token punctuation">[</span>q<span class="token punctuation">.</span>next<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                p<span class="token punctuation">.</span>next<span class="token operator">=</span>None            <span class="token keyword">if</span> q<span class="token punctuation">.</span>random<span class="token operator">!=</span>None<span class="token punctuation">:</span>                <span class="token keyword">if</span> q<span class="token punctuation">.</span>random <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    visited<span class="token punctuation">[</span>q<span class="token punctuation">.</span>random<span class="token punctuation">]</span><span class="token operator">=</span>Node<span class="token punctuation">(</span>q<span class="token punctuation">.</span>random<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                p<span class="token punctuation">.</span>random<span class="token operator">=</span>visited<span class="token punctuation">[</span>q<span class="token punctuation">.</span>random<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                p<span class="token punctuation">.</span>random<span class="token operator">=</span>None            p<span class="token punctuation">,</span>q<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">,</span>q<span class="token punctuation">.</span>next        <span class="token keyword">return</span> copyhead<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他思路：</p><p><img src="35.png" alt></p><ul><li>我们可以将链表看成是graph，利用BFS或者DFS+哈希表进行求解。本质思想和直接迭代按照单链表的next指针顺序复制是一样的。</li></ul><h2 id="35-二叉搜索树与双向链表"><a href="#35-二叉搜索树与双向链表" class="headerlink" title="35.二叉搜索树与双向链表"></a>35.<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">二叉搜索树与双向链表</a></h2><p>思路：首先，我们知道，二叉搜索树的性质有一条是中序遍历所得到的结果是升序排序的序列。恰好，我们要构造的双向链表也是升序排序的，所以我们会想到使用中序遍历来进行原地转换。</p><p>具体算法如下：</p><ul><li><p>设置全局变量head，tail指针，指向当前链表的头尾节点，初始均为None。（为什么一定要全局节点，因为这里的指针是不可变类型，所以在内部函数中对其修改不会改变外层的值，如果是可变类型则会产生改变）</p></li><li><p>开始中序遍历，如果当前节点为空，那么什么也不做，直接返回。如果当前节点非空，先递归遍历左子树。如果当前head指针非空，说明当前节点是二叉搜索树的第一个节点，即最小值，自然也就是双向链表的head节点，那么让head指向他。如果当前tail非空，说明左子树的遍历已经为双向链表加入了节点，且tail指向的是当前双向链表的尾部节点，那么进行如下修改：（1）让当前节点的left指针指向当前tail（2）让当前tail的right指针指向当前节点。接下来，无论tail是否为空，让它指向当前节点。上述三个操作相当于把当前节点加入至双向链表尾部，并让tail指向他。接下来，递归遍历右子树。简而言之，上述过程就是按照中序遍历的顺序不断原地修改二叉搜索树，tail指针始终指向当前节点的前一个节点。</p></li><li><p>完成中序遍历后，我们获得了一个头尾尚未连接的双向链表，此时我们将头节点和尾节点连接即可。</p></li><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(1)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""# Definition for a Node.class Node:    def __init__(self, val, left=None, right=None):        self.val = val        self.left = left        self.right = right"""</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>head<span class="token operator">=</span>None        self<span class="token punctuation">.</span>tail<span class="token operator">=</span>None    <span class="token keyword">def</span> <span class="token function">treeToDoublyList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Node'</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>             inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>head<span class="token operator">==</span>None<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>head<span class="token operator">=</span>root            <span class="token keyword">if</span> self<span class="token punctuation">.</span>tail<span class="token operator">!=</span>None<span class="token punctuation">:</span>                root<span class="token punctuation">.</span>left<span class="token operator">=</span>self<span class="token punctuation">.</span>tail                self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>right<span class="token operator">=</span>root            self<span class="token punctuation">.</span>tail<span class="token operator">=</span>root            inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>left<span class="token operator">=</span>self<span class="token punctuation">.</span>tail        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>head        <span class="token keyword">return</span> self<span class="token punctuation">.</span>head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="36-序列化二叉树"><a href="#36-序列化二叉树" class="headerlink" title="36.序列化二叉树"></a>36.<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">序列化二叉树</a></h2><p>思路：这道题我曾经在大二的数据结构课上做过，可以用两种方式来解决。这里我们先说层次遍历的解法。</p><p>BFS的解法：</p><ul><li>序列化：BFS的序列化按照常规做法，依然是使用队列来完成。先将根节点加入队列。每次从队首取出一个节点，如果当前节点为空，那么向序列化的字符串中添加一个”*”作为占位符，否则将它的value添加进字符串，中间用“，”隔开。然后，将其左右孩子节点均加入队列中。重复上述过程直到队列为空。</li></ul><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Encodes a tree to a single string.        :type root: TreeNode        :rtype: str        """</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span>        data<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token operator">==</span>None<span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>node<span class="token punctuation">.</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">","</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>反序列化：BFS的反序列化较为复杂，由于不是完全二叉树，不可以直接用下标运算求解子节点位置，需要使用一个辅助队列来存放当前剩余的需要处理的节点，并使用一个指针来遍历序列化字符串中逗号隔开的每个元素。</li></ul><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Decodes your encoded data to tree.        :type data: str        :rtype: TreeNode        """</span>        data<span class="token operator">=</span>data<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"*"</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None        root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span>        i<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">"*"</span><span class="token punctuation">:</span>                leftNode<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                node<span class="token punctuation">.</span>left<span class="token operator">=</span>leftNode                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>leftNode<span class="token punctuation">)</span>            i<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">"*"</span><span class="token punctuation">:</span>                rightNode<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                node<span class="token punctuation">.</span>right<span class="token operator">=</span>rightNode                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>rightNode<span class="token punctuation">)</span>            i<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一种更为简单直观的方式是DFS的做法，直接使用先序遍历求解。</p><ul><li>序列化：先序遍历，每次将当前节点加入至序列化字符串中，如果当前节点为空，则加入“*”占位符，否则加入value，然后递归遍历左子树和右子树。</li></ul><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Encodes a tree to a single string.        :type root: TreeNode        :rtype: str        """</span>        data<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        preorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">","</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>反序列化：依然是先序遍历的方式递归重建二叉树。</li></ul><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Decodes your encoded data to tree.        :type data: str        :rtype: TreeNode        """</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">:</span>            now<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> now<span class="token operator">==</span><span class="token string">"*"</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> None            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>left<span class="token operator">=</span>build<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>build<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            <span class="token keyword">return</span> root        queue<span class="token operator">=</span>data<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> build<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="37-字符串的排列"><a href="#37-字符串的排列" class="headerlink" title="37.字符串的排列"></a>37.<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">字符串的排列</a></h2><p>思路：全排列问题，采用DFS+递归的方式解决。需要注意的是这里应该进行去重，去重的思路有两种：</p><ul><li>哈希表或者集合的方式去重。</li><li>先对字符串进行字典序排序（字符串没有sort函数，必须调用全局函数sorted（）），如果当前序号的字符等于前一个字符，且前一个字符尚未被访问，则可以跳过对他的搜索。因为它的所有组合已经被前一个字符的搜索所覆盖了。具体可以参考主站的第47题<a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">全排列 II</a>。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">permutation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        s<span class="token operator">=</span>sorted<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">DFS</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token operator">==</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token boolean">True</span> <span class="token operator">and</span> <span class="token operator">not</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">and</span> visited<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                        DFS<span class="token punctuation">(</span>st<span class="token operator">+</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">False</span>        DFS<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(N*N!)$。N为字符串长度</li><li>空间复杂度：$O(N*N!)$。</li></ul><h2 id="38-数组中出现次数超过一半的数字"><a href="#38-数组中出现次数超过一半的数字" class="headerlink" title="38.数组中出现次数超过一半的数字"></a>38.<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中出现次数超过一半的数字</a></h2><p>思路：排序然后取中位数即可。因为假如某个数字出现次数超过一半，则排序后必然出现在中间位置上。</p><ul><li>时间复杂度：$O(NlogN)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="39-最小的k个数"><a href="#39-最小的k个数" class="headerlink" title="39.最小的k个数"></a>39.<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">最小的k个数</a></h2><p>思路：经典的TOP K问题！主要思路有有两种，分别是使用堆（优先队列）或者快速选择。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li>基本思路：使用一个大顶堆来存储数组中前k小的元素。一开始，先使用数组中前K个元素建大顶堆，此时，堆顶的元素为前K个元素中的最大值。然后从K+1个元素向后依次遍历，如果当前元素小于大顶堆的堆顶元素，说明堆顶元素不仅大于堆中的K-1个元素，且大于当前元素，必不可能是前K小的元素。所以，我们将当前元素加入至堆中，并调整堆至继续符合大顶堆。继续向后遍历，维护大顶堆，直到遍历到数组末尾，此时堆中的元素即为数组的前K小的值。</li><li>时间复杂度：$O()$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：从HMM到条件随机场</title>
      <link href="/2020/03/17/nlp-zi-xue-bi-ji-cong-hmm-dao-tiao-jian-sui-ji-chang/"/>
      <url>/2020/03/17/nlp-zi-xue-bi-ji-cong-hmm-dao-tiao-jian-sui-ji-chang/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：线性模型和对数线性模型</title>
      <link href="/2020/03/17/nlp-zi-xue-bi-ji-xian-xing-mo-xing-he-dui-shu-xian-xing-mo-xing/"/>
      <url>/2020/03/17/nlp-zi-xue-bi-ji-xian-xing-mo-xing-he-dui-shu-xian-xing-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是我在学习苏州大学李正华老师的中文信息处理课程（<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">中文信息处理（Chinese Information Processing）Course Resources</a>）时，对于线性模型和对数线性模型的一些个人见解和思考，同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己对于该模型的理解，如有错误欢迎在评论区指出，非常感谢！</p><h2 id="从问题出发"><a href="#从问题出发" class="headerlink" title="从问题出发"></a>从问题出发</h2><p>与隐马尔可夫模型的讲解类似，我们在这里依旧围绕自然语言处理中的经典问题<strong>词性标注问题</strong>进行讨论和解释。</p><ul><li>给定一个句子X，输出句子中每一个单词对应的词性。</li></ul><p><img src="1.png" alt="词性标注任务"></p><p>与隐马尔可夫模型不同的是，线性模型与对数线性模型将词性标注转化为了一个<strong>多元分类</strong>问题，它们将不再以整个句子序列作为模型的输入，整个句子的词性序列作为模型的输出，而是假设<strong>词语之间的预测相互独立</strong>，将问题转化为<strong>从所有可能的词性类别中选取某个词语最有可能的类别进行输出</strong>。</p><h2 id="什么是线性模型"><a href="#什么是线性模型" class="headerlink" title="什么是线性模型"></a>什么是线性模型</h2><p>线性模型（Linear Model)，又称为<strong>线性回归模型</strong>，是一种<strong>有监督学习模型</strong>。我们曾经在高中的时候学习过一种回归方法——线性回归。将这个方法泛化，就可以得到我们的线性模型。</p><p>我们以吴恩达老师在coursera上的机器学习课程中的房价预测例子进行说明。</p><p><img src="2.png" alt="房价预测"></p><p>如上图所示，假设我们得到了一个当地的房价数据集，其中包括了房子的面积、卧室数、层数、房龄等信息，同时给出了对应的房价。我们需要解决的问题就是如何<strong>利用房子的信息预测出它的价格</strong>。在机器学习中，我们把类似于面积、卧室数等这些样本的信息叫做<strong>样本的特征（Feature）</strong>，它们是我们进行预测的依据。我们把需要预测的值叫做<strong>样本的标签（Label)</strong>。训练集中的每一个样本是一个<strong>（特征，标签)二元组</strong>。</p><p>在机器学习中，样本的特征往往是人工选择的，例如上述的面积、卧室数、层数等房屋信息。如何选择合适的特征是一门高深的学问，我们称其为<strong>特征工程</strong>。特征往往不止一个，所以使用<strong>向量</strong>的形式对其进行表示。在这里，我使用列向量$\vec x=(x_1,x_2…x_n)$来表示特征向量，由于书写列向量不是很方便，所以只能这么书写，但你需要记住$\vec x$是一个列向量。</p><p>当给定某个房子的面积、卧室数、层数、房龄等特征，在线性模型中，我们会使用一个线性方程来计算房子的价格。我们使用$h$表示这个线性方程，$h$代表<strong>hypothesis</strong>(<strong>假设</strong>) ，具体公式如下：<br>$$<br>h_{w}(x)=w_0+w_1x_1+w_2x_2+…+w_nx_n<br>$$<br>我们为每个特征给定一个特征权重$w$，这个权重可以是正数也可以是负数。其中，$w_0$为<strong>偏置项</strong>（bias），专门用来表示方程中的常数项。通过训练样本学习权重$w$，我们便可使用上述方程进行预测。</p><p>为了使公式简洁一些，引入$x_0=1$，使用列向量$\vec w=(w_0,w_1…w_n)$来表示权重向量，则公式转化为：<br>$$<br>h_{w}(x)=w_0x_0+w_1x_1+w_2x_2+…+w_nx_n\<br>=w^Tx<br>$$</p><h2 id="线性模型的泛化"><a href="#线性模型的泛化" class="headerlink" title="线性模型的泛化"></a>线性模型的泛化</h2><p>看到上述的线性方程，你可能会疑惑：上述方程得到的仅仅是一条直线方程，而需要拟合的数据点往往不能通过简单的直线来拟合。换句话说， 如果仅仅使用在此之前的单元和多元线性回归，<strong>我们只能得到多维空间的高维平面</strong>。为了进一步增强泛化能力，我们可以引入<strong>幂次项特征和多项式特征</strong>。 </p><p>例如，我们的模型原先只是一个线性方程：<br>$$<br>h_{w}(x)=w_1x_1+w_2x_2<br>$$<br>为了增强拟合能力，我们可以令$x_3=x_1^2$，$x_4=x_2^2$，$x_5=x_1x_2$。于是，我们的模型将变为：<br>$$<br>h_{w}(x)=w_1x_1+w_2x_2+w_3x_3+w_4x_4+w_5x_5\<br>=w_1x_1+w_2x_2+w_3x_1^2+w_4x_2^2+w_5x_1x_2<br>$$<br>可以看到，此时我们的模型将可以拟合复杂的非线性函数。<strong>也就是说，很多复杂的模型都可以转化为线性模型进行建模。</strong></p><p>但需要注意的是：<strong>过多地使用幂次项特征和多项式特征会使模型的拟合能力太强，从而导致过拟合的问题</strong>。我将专门 写一篇blog来讲解机器学习中的过拟合问题，并介绍一些解决过拟合的办法，如正则化和dropout等。</p><h2 id="线性模型的特征提取"><a href="#线性模型的特征提取" class="headerlink" title="线性模型的特征提取"></a>线性模型的特征提取</h2><h3 id="连续型特征"><a href="#连续型特征" class="headerlink" title="连续型特征"></a>连续型特征</h3><p>特征分为连续型特征和离散型特征。<strong>连续型特征顾名思义就是取值是连续的特征，例如上述例子中的房子面积。</strong>在实际的机器学习过程中， 很少直接将连续值作为线性回归模型和逻辑回归模型的特征输入，而是将连续特征离散化为一系列0、1特征交给模型，这样做的优势有以下几点： </p><ol><li>离散特征的增加和减少都很容易，易于模型的<strong>快速迭代</strong>。</li><li>稀疏向量内积乘法运算<strong>速度快</strong>，计算结果<strong>方便存储，容易扩展</strong>。</li><li>离散化后的特征对异常数据有很强的<strong>鲁棒性</strong>：比如一个特征是年龄&gt;30是1，否则0。如果特征没有离散化，一个异常数据“年龄300岁”会给模型造成很大的干扰。</li><li>线性回归模型和逻辑回归模型属于广义线性模型，表达能力受限；单变量离散化为N个后，每个变量有单独的权重，相当于为模型引入了非线性，<strong>能够提升模型表达能力，加大拟合</strong>。</li><li>离散化后可以<strong>进行特征交叉</strong>，由M+N个变量变为M*N个变量，进一步引入非线性，提升表达能力。</li><li>特征离散化后，模型会更<strong>稳定</strong>，比如如果对用户年龄离散化，20-30作为一个区间，不会因为一个用户年龄长了一岁就变成一个完全不同的人。当然处于区间相邻处的样本会刚好相反，所以怎么划分区间是门学问。</li><li>特征离散化以后，起到了简化模型的作用，降低了模型<strong>过拟合</strong>的风险。</li></ol><h3 id="离散性特征"><a href="#离散性特征" class="headerlink" title="离散性特征"></a>离散性特征</h3><p><strong>离散型特征顾名思义就是取值是离散的特征，例如上述例子中的房龄、卧室数和层数。</strong>对于离散型特征，我们使用一种叫做<strong>one-hot</strong>的方法进行编码。</p><p>one-hot的基本思想：<strong>将离散型特征的每一种取值都看成一种状态</strong>，若你的这一特征中有N个不相同的取值，那么我们就可以将该特征抽象成N种不同的状态，one-hot编码保证了每一个取值只会使得一种状态处于“激活态”，也就是说这N种状态中只有一个状态位值为1，其他状态位都是0。举个例子，假设我们以学历为例，我们想要研究的类别为小学、中学、大学、硕士、博士五种类别，我们使用one-hot对其编码就会得到：</p><blockquote><p>小学-&gt;[1,0,0,0,0]</p><p>中学-&gt;[0,1,0,0,0]</p><p>大学-&gt;[0,0,1,0,0]</p><p>硕士-&gt;[0,0,0,1,0]</p><p>博士-&gt;[0,0,0,0,1]</p></blockquote><p><strong>特别地，如果该离散型特征只有True或False两种取值，那么我们通常用1表示True，0表示False</strong>。</p><h2 id="线性模型的训练过程"><a href="#线性模型的训练过程" class="headerlink" title="线性模型的训练过程"></a>线性模型的训练过程</h2><h3 id="定义优化目标"><a href="#定义优化目标" class="headerlink" title="定义优化目标"></a>定义优化目标</h3><p>当我们写出了假设函数$h$后，接下来我们要做的就是通过已有的训练集得到合适的模型权重$\vec w=(w_0,w_1…w_n)$。</p><p>为了进行权重的训练，首先，我们要定义三个函数：</p><ol><li><strong>损失函数（Loss Function ）</strong>：<strong>单个样本</strong>的预测值和真实值（标签）的误差。</li><li><strong>代价函数（Cost Function ）</strong>：<strong>整个训练集所有样本</strong>的预测值和真实值（标签）的误差，也就是损失函数的平均。</li><li><strong>目标函数（Object Function）</strong>：<strong>最终需要优化的函数</strong>。等于经验风险+结构风险（也就是代价函数 + 正则化项）。</li></ol><p><strong>这里，我们先不讲解正则化的知识，假设我们的目标函数即为代价函数</strong>。那么线性模型的优化问题即为最小化所有样本的误差的平均值。线性模型的误差可以用许多函数来表示，其中比较常用的一种是<strong>均方误差</strong>(Mean squared error) ，这里我们使用均方误差来描述我们的模型误差（PS：更多损失函数可以参考<a href="https://www.jiqizhixin.com/articles/091202" target="_blank" rel="noopener">机器学习中常用的损失函数你知多少？</a>）</p><p>假设训练集中样本的标签为$y$，样本的数量为$m$，预测值为假设函数的输出$h_{w}(x)$，则需要优化的目标函数为：<br>$$<br>J(w)=\frac{1}{2m}\sum_{i=1}^{m}(h_w(x^{(i)})-y^{(i)})^2<br>$$<br>我们的目标便是<strong>选择出可以使得建模误差的平方和能够最小的模型参数</strong>，即<strong>找到合适的模型权重$\vec w$，使$J(w)$取得最小值</strong>。需要注意的是，目标函数中的1/2仅仅是为了方便求导。</p><h3 id="从极大似然估计到损失函数"><a href="#从极大似然估计到损失函数" class="headerlink" title="从极大似然估计到损失函数"></a>从极大似然估计到损失函数</h3><p>在隐马尔可夫模型的讲解中，我曾经说过损失函数和极大似然估计有着紧密的联系，例如<strong>我们在逻辑回归模型里使用的交叉熵损失函数其实就是似然函数加上负号</strong>。也就是说，<strong>最优化问题既可以理解为最大化模型的似然估计，也可以理解为最小化模型的损失函数</strong>。</p><p>为什么会出现这样的现象呢？其实这并不是巧合，是可以通过数学公式进行推导的。具体推导内容可以参考这篇讲义<a href="https://wenku.baidu.com/view/78d16462c9d376eeaeaad1f34693daef5ff713d2.html" target="_blank" rel="noopener">各损失函数与最大似然</a>。</p><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><h4 id="正规方程法"><a href="#正规方程法" class="headerlink" title="正规方程法"></a>正规方程法</h4><p>正规方程法可以用于求解线性模型的目标函数取得最小值时，权重$w$的准确值。但在机器学习中，我们很少使用这种方法求解模型的权重，我在这里简单提一下它的弊端：</p><ol><li>对于一个由$n$个训练样本的特征向量$x$组成的训练集矩阵$X$，计算极值点的时间复杂度为$O(n^3)$，<strong>当训练集规模很大时，正规方程法将变得十分缓慢。</strong></li><li>正规方程法需要使用训练集矩阵$X$的逆矩阵$X^{(-1)}$，但是<strong>我们无法保证$X$一定可逆。</strong></li><li><strong>只适用于线性模型</strong>，不适合逻辑回归模型等其他模型 。</li></ol><h4 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h4><p>我们已经说过，当训练集规模很大时，例如有上百万、上千万的数据时，正规方程法将会非常缓慢，那么有没有办法能够降低时间复杂度呢？答案是有的，我们在这里可以使用<strong>梯度下降法</strong>进行求解。</p><p>为了将问题简化，我们假设模型现在只存在两个特征，对应的权重为$\theta_0$和$\theta_1$。 我们绘制一个等高线图，三个坐标分别为$\theta_0$和$\theta_1$和$J(\theta_0,\theta_1)$： </p><p><img src="3.png" alt="等高线图"></p><p>则可以看出在三维空间中存在一个使得$J(\theta_0,\theta_1)$最小的点，我们可以发现均方差损失函数的图像很明显是一个<strong>凸函数</strong>，即不存在局部最优解的问题。 </p><p>梯度下降法的相当于<strong>我们下山的过程</strong>，每次我们要走一步下山，寻找最低的地方，那么最可靠的方法便是环顾四周，寻找下山速度最快的方向前进，持续该过程，最后便能无限接近最低点。</p><p>对于函数而言，<strong>便是求得该函数对所有参数的偏导（梯度），每次根据梯度更新这些参数，直到参数收敛为止，注意这些参数必须同步进行更新</strong>。 从数学上的角度来看，梯度的方向是函数增长速度最快的方向，那么梯度的反方向就是函数减少最快的方向。那么，如果想计算一个函数的最小值，就可以使用梯度下降法的思想来做。 </p><p>假设模型共有$n$个特征，加上偏置项的特征$x_0=1$，共有$n+1$个特征。则对于某个权重参数$w_j$进行梯度下降的公式可以表示为：<br>$$<br>w_j=w_j-\alpha\frac{dJ(w)}{dw_j}=w_j-\alpha\frac{1}{m}\sum^{m}_{i=1}(h_w(x^{(i)})-y^{(i)})x_j^{(i)}<br>$$<br>其中，<strong>$\alpha$是一个由我们自己设置的超参数（hyper parameter）——学习率</strong> （<strong>learning rate</strong>），它决定了我们沿着能让目标函数下降程度最大的方向向下迈出的步子有多大。 </p><p>梯度下降的过程形象表示便是如下图所示，一步一步下降达到最低点。</p><p> <img src="3.jpg" alt="梯度下降的直观表示"></p><p>需要说明以下几点：</p><ul><li><p>$\alpha$为学习率，学习率决定了学习的速度，<strong>我们需要选择合适的学习率</strong>。</p><ul><li><p>如果$\alpha$过小，那么学习的时间就会很长，导致算法的低效。</p></li><li><p>如果$\alpha$过大，那么由于每一步更新过大，可能无法收敛到最低点。由于越偏离最低点函数的导数越大，如果$\alpha$过大，某一次更新直接跨越了最低点，来到了比更新之前<strong>更高</strong>的地方。那么下一步更新步会更大，如此反复震荡，离最低点越来越远。</p></li><li><p>以上两种情况如下图所示 ：</p><p><img src="2.jpg" alt></p></li></ul></li><li><p><strong>我们的算法不一定能达到最优解</strong>。 但是由于线性回归模型中的函数都是<strong>凸函数</strong>,所以利用梯度下降法，是可以找到全局最优解的，在这里不详细阐述。 </p></li><li><p>我们这里得到的是<strong>数值解</strong>而非解析解，存在着一定误差。</p></li></ul><p>顺便说一下，我这里举例的是<strong>批量梯度下降（batch gradient descent,BGD）</strong>，即尝试将<strong>所有样本</strong>的误差优化到最小。这种方法的优点是每次下降都是朝着全局最优的方向前进。但是，我们发现它每次都要计算所有样本的损失，这在大批量数据的情况下会非常缓慢。</p><p>还有一种梯度下降的方法叫做<strong>随机梯度下降法（ Stochastic gradient descent）</strong>，它每次选取<strong>一个随机样本</strong>，尝试优化它的损失函数。虽然随机梯度下降法每次下降是朝着局部最优的方向前进，无法保证全局的优化，但整体而言，它的下降方向还是朝着全局最优点前进的。与此同时，它的计算量相较于批量梯度下降大大减少了。</p><p>此外，还有一种方法叫做<strong>小批量梯度下降法（mini-batch gradient descent）</strong>，这是现在最为常用的一种梯度下降学习法，它是BGD和SGD的折中。它每次尝试优化一个mini-batch-size数量的样本，即减少了运算量，又降低了梯度下降方向出错的可能性。</p><h3 id="过拟合与正则化"><a href="#过拟合与正则化" class="headerlink" title="过拟合与正则化"></a>过拟合与正则化</h3><p>在前面我们提到了可以通过引入<strong>幂次项特征和多项式特征</strong>来增加模型的拟合能力。但是，模型的拟合能力过强有时候并不是一件好事。下面，我将介绍线性回归模型中的<strong>过拟合 (over-fitting) 问题</strong>。</p><p>首先，我们给出过拟合的定义：</p><blockquote><p>在统计学中，过拟合（英语：overfitting，或称过度拟合）现象是指在拟合一个统计模型时，使用过多参数。对比于可获取的数据总量来说，一个荒谬的模型只要足够复杂，是可以完美地适应数据。过拟合一般可以视为违反奥卡姆剃刀原则。当可选择的参数的自由度超过数据所包含信息内容时，这会导致最后（拟合后）模型使用任意的参数，这会减少或破坏模型一般化的能力更甚于适应数据。过拟合的可能性不只取决于参数个数和数据，也跟模型架构与数据的一致性有关。此外对比于数据中预期的噪声或错误数量，跟模型错误的数量也有关。 </p></blockquote><p>通俗的说，过拟合问题的本质是<strong>我们模型的学习能力太强，导致过于强调拟合训练集的样本，从而丢失了泛化的能力</strong>。当模型出现了过拟合的问题，它虽然能非常好地适应我们的训练集，但在新输入变量进行预测时可能会效果不好 。</p><p>我们借用吴恩达老师coursera课程中的PPT来描述过拟合、欠拟合、好的拟合三种情况。</p><p><img src="4.png" alt="拟合的情况"></p><p>在这里，我尝试用一个易于理解的例子来解释上述三种情况：</p><blockquote><p>我们可以把学生做练习题的过程看成是模型的训练过程，学生在做了很多练习题后，可以参加考试了，我们可以把考试看作为模型的预测过程。欠拟合很简单，就是平时不认真学习，做练习题和参加考试的分数自然都很低，也就是训练集和测试集的准确率都很低。那么过拟合是什么呢？过拟合就是平时只知道死记硬背，仅仅记住了练习题，却不知道举一反三，虽然平时作业分数很高，但是考试成绩却并不好，也就是训练集准确率很高，但测试集准确率很低。最佳的情况就是既认真做练习，又不局限于练习题，这种就是我们虽说的拟合较好的情况。</p></blockquote><p>为了解决过拟合的问题，我们应该引入一个<strong>参数项</strong>，<strong>在进行梯度下降的时候尽可能使得参数变小</strong>，这样可以使得很多额外的特征的权重接近于0。 这个方法也叫做<strong>正则化</strong>（regularization）。此外，还有一些防止过拟合的办法，例如神经网络中的dropout等，我会在接下来的博客中继续为大家介绍。</p><p>正则化中的参数项一般也叫做正则项，常用的正则项有以下两种：</p><ul><li>L1正则项：各个权重的<strong>绝对值之和</strong>，可以产生稀疏权值矩阵，即产生一个稀疏模型，可以用于<strong>特征选择</strong> 。同时，一定程度上 也可以防止过拟合 。</li><li>L2正则项：各个权重的<strong>平方和</strong>，可以防止模型过拟合（overfitting）。</li></ul><p>线性模型和对数线性模型中，我们通常采用的是L2正则项。加入正则项后，模型的代价函数变为：<br>$$<br>J(w)=\frac{1}{2m}[\sum_{i=1}^{m}(h_w(x^{(i)})-y^{(i)})^2+\lambda\sum_{j=1}^{n}w^2]<br>$$<br>梯度下降的公式变为：<br>$$<br>w_j=w_j-\alpha\frac{dJ(w)}{dw_j}=w_j-\alpha\frac{1}{m}\sum^{m}_{i=1}[(h_w(x^{(i)})-y^{(i)})x_j^{(i)}+\lambda w_j]<br>$$<br>我们可以发现，通过引入正则化项，可以使模型的所有参数在梯度下降时多下降一些，从而尽可能地减小。上式中，$\lambda$是一个用于控制正则化程度的超参数，我们一般称其为<strong>正则化系数</strong>，如果$\lambda$过大，则所有权重将趋近于0， 这样我们所得到的只能是一条平行于x轴的直线 。 所以对于正则化，我们要取一个合理的$\lambda$的值 。超参数的选择是机器学习中最为常见的问题，我们一般使用<strong>开发集</strong>进行调参。</p><p>顺便提一下，过拟合的情况下，增加训练集的样本数量将会使模型的性能得到提升。在当今这个海量数据的时代，数据是容易获得的，所以深度学习的常见做法是训练出一个拟合能力很强（层数深、神经元多）的神经网络，加上大规模的训练样本，再加上一些正则化的方法，所得出的模型通常性能最好。</p><h2 id="回到词性标注问题上来"><a href="#回到词性标注问题上来" class="headerlink" title="回到词性标注问题上来"></a>回到词性标注问题上来</h2><p>相信通过前面的介绍，你已经对线性模型有了基本的认识，下面我们回到词性标注任务上，简单地介绍一下如何基于多元分类的思想使用线性回归模型进行词性标注。</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>在我们之前的介绍中，你可能会发现，线性模型主要是用于解决机器学习中的<strong>回归（regression）问题</strong>。也就是说，它预测的最终结果通常是连续值。虽然与对数线性模型相比，线性模型不常用于<strong>分类（classification）</strong>，但在介绍对数线性模型之前，我们仍可以通过一些方法使其运用在分类标注词性上。</p><p>最基本的思想就是，<strong>我们通过选取词语的一些特征，训练出一个线性模型，模型的输出为该词语标注为各词性的分值（score），然后我们选取分值最大的词性作为预测的结果。</strong>通过这一转化，我们将线性回归模型运用在了分类问题上。</p><h3 id="特征获取"><a href="#特征获取" class="headerlink" title="特征获取"></a>特征获取</h3><p>与之前预测房价的例子不同，词性标注模型的特征不是事先定义好的，而是通过<strong>特征模板（feature template）</strong>在训练集中抽取而来的。特征模板需要专家进行手工的定义。目前，学术界常用的用于词性标注的特征模板如下表所示。</p><p><img src="5.png" alt="特征模板"></p><p>可以看到，我们一共使用了14种特征模板，其中包含了许多有用的信息，例如词信息，字信息，词缀信息等等。</p><p>在实际训练过程中，我们需要先构建<strong>特征空间（feature space）</strong>。它是训练集中所有特征的集合。<strong>构建的方式是：我们每次选取一个词，根据特征模板抽取相应的14种特征，并将其加入到特征空间内。需要注意的是特征空间中不能出现重复的特征。</strong></p><p>在这里，我们还可以对特征抽取进行优化。我们观察特征模板可以发现，<strong>对于每个样本，每一种特征的模板都需要抽取每一种词性的特征，而对于所有不同的词性，其特征模板的后缀都是相同的</strong>。通过计算机中经常使用的<strong>段加偏移</strong>的思想，我们可以大大减少构建特征空间所耗费的时间，将时间复杂度由$O(N^2)$降为$O(N)$。具体的优化操作不再赘述，大家可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/9-linear-model/main2.pdf" target="_blank" rel="noopener">李老师的讲义</a>。</p><p>我在这里画出了这个线性模型的示意图，你应该就能理解为什么它的特征空间可以用二维矩阵的方式来存储，以及它是如何工作的。</p><p><img src="6.png" alt="词性标注的线性模型"></p><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>对于模型的训练，我们将采用一种叫做<strong>在线学习（Online training）</strong>的方式。这是一种经常用于<strong>推荐系统</strong>的学习算法，方便对模型进行实时训练。你可以把它看作是一种近似于我们之前所提到的随机梯度下降法的学习算法。它每次选取<strong>一个实例</strong>进行训练。由于样本的标签是经过one-hot处理的离散值，而我们模型的输出是取值范围在负无穷到正无穷的连续值，所以我们在这里无法使用前述的梯度下降算法进行参数的训练。取而代之的是如下的算法。</p><p><img src="7.png" alt="Online Training"></p><p>简单的讲解一下，可以看到，我们每次选取一个样本进行训练，如果该样本预测正确，那么不修改模型的参数，否则，将该样本与正确词性关联的特征权重全部加1，与错误词性关联的特征权重全部减1。你可以看作是<strong>给预测正确词性的特征一个激励，而给预测错误词性的特征一个惩罚</strong>。</p><p>特别地，我们在这里还可以使用上图中$v$作为模型特征权重，这叫做<strong>averaged perceptron</strong>。有关学习算法的优化问题我将专门撰写一篇博客，介绍常见的优化算法，如momentum算法，RMsprop算法和Adam算法的数学原理等。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：隐马尔可夫模型</title>
      <link href="/2020/03/17/nlp-zi-xue-bi-ji-yin-ma-er-ke-fu-mo-xing/"/>
      <url>/2020/03/17/nlp-zi-xue-bi-ji-yin-ma-er-ke-fu-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是我在学习苏州大学李正华老师的中文信息处理课程（<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">中文信息处理（Chinese Information Processing）Course Resources</a>）时，对于隐马尔可夫模型的一些个人见解和思考，同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己对于该模型的理解，如有错误欢迎在评论区指出，非常感谢！</p><h2 id="从问题出发"><a href="#从问题出发" class="headerlink" title="从问题出发"></a>从问题出发</h2><p>隐马尔可夫模型（Hidden Markov Model，HMM模型）是一个序列化标注模型，也能被看作是一种seq2seq（序列到序列）模型。在对隐马尔可夫模型进行学习时，我们引入一个自然语言处理领域的经典序列化问题：<strong>词性标注任务</strong>。接下来的讲解中，将围绕这个问题进行讨论。</p><ul><li>给定一个句子X，输出句子中每一个单词对应的词性。</li></ul><p><img src="1.png" alt="词性标注任务"></p><h2 id="什么是隐马尔可夫模型"><a href="#什么是隐马尔可夫模型" class="headerlink" title="什么是隐马尔可夫模型"></a>什么是隐马尔可夫模型</h2><p>《统计学习方法》中对于隐马尔可夫模型有着如下的定义：</p><blockquote><p>隐马尔科夫是关于时序的概率模型，描述由一个隐藏的马尔科夫链随机生成不可观测的状态随机序列，再由各个状态生成一个观测而产生观测随机序列的过程，隐藏的马尔科夫链生成的随机状态的序列被称为状态序列（state sequence），每个状态生成一个观测，由此而产生的观测的随机序列，称之为观测序列（observation sequence）,序列的每一个位置都可以看作是一个时刻。</p></blockquote><p>上述定义初看比较晦涩难懂，我们需要逐步进行解释。</p><ul><li><p>首先，什么是观测序列和状态序列呢？观测序列通常指可以直接获得的序列，状态序列则是我们无法直接获得的序列，HMM模型的目的就是为了通过可观测到的数据，预测不可观测到的数据。我们结合词性标注问题来看，在此问题中，<strong>观测序列指的是句子的单词序列，而状态序列则指的是句子的词性序列</strong>。</p></li><li><p>那么，什么是马尔可夫链？马尔可夫链是具有马尔可夫性质的随机变量的一个数列，描述了一个状态序列。马尔可夫性质指的是每个状态值取决于前面有限个状态，这在HMM模型中称为<strong>齐次马尔科夫链假设</strong>。需要注意的是<strong>马尔可夫链并没有限定后一个状态的变化仅仅取决于前一个状态，而是说取决于前面有限个状态</strong>。不过为了简化模型，我们在HMM中使用一阶（二元）马尔可夫链，即每个状态仅依赖于前一个状态。带入到词性标注问题中，他指的是<strong>当前的词性仅依赖于前一个词性是什么</strong>。例如，动词后常接名词，很少再接一个动词。那么，根据齐次马尔科夫链假设，如果前一个词性是动词，我们可以推测出当前词倾向于是名词而非动词。</p></li><li><p>接下来，我们要解决的问题是观测序列如何生成状态序列。HMM模型中对于状态序列至观测序列的发射有着这样的假设：<strong>任意时刻的观察状态只仅仅依赖于当前时刻的隐藏状态</strong>。这也叫做<strong>观测独立性假设</strong>，与齐次马尔科夫链假设一样，它也是为了简化模型。带入到词性标注问题中，它指的是<strong>当前词仅与当前词性有关</strong>。举例来说，当给定一个词“苹果”，我们根据训练集统计得知名词词性发射至“苹果”的概率远大于其它词性，所以我们可以预测当前词倾向于是名词。</p></li><li><p>根据齐次马尔可夫假设和观测独立性假设，对于一个长度为$L$的句子，我们用$X=x(0),x(1)……x(L-1)$表示词序列（观测序列），$Y=y(0),y(1)…y(L-1)$表示词性序列（状态序列），那么词性序列的转移过程可以表示为：<br>$$<br>p(y_i|y_0…y_i-1)=p(y_i|y_i-1)（一阶马尔可夫性质）<br>$$</p></li></ul><p>  由词性序列$Y$产生词序列$X$的发射过程可以表示为：<br>  $$<br>  p(x_0…x_L|y_0…y_L)= \prod_{i=0}^L{p(x_i|y_i)}(观测独立性假设)<br>  $$</p><h2 id="什么样的问题需要隐马尔可夫模型"><a href="#什么样的问题需要隐马尔可夫模型" class="headerlink" title="什么样的问题需要隐马尔可夫模型"></a>什么样的问题需要隐马尔可夫模型</h2><blockquote><p>考虑一个简单的例子，有人试图通过一片海藻推断天气——民间传说告诉我们‘湿透的’海藻意味着潮湿阴雨，而‘干燥的’海藻则意味着阳光灿烂。如果它处于一个中间状态（‘有湿气’），我们就无法确定天气如何。然而，天气的状态并没有受限于海藻的状态，所以我们可以在观察的基础上预测天气是雨天或晴天的可能性。另一个有用的线索是前一天的天气状态（或者，至少是它的可能状态）——通过综合昨天的天气及相应观察到的海藻状态，我们有可能更好的预测今天的天气。 </p></blockquote><p>使用HMM模型时我们的问题一般有这两个特征：</p><ol><li><p>我们的问题是基于序列的，比如时间序列，或者状态序列。NLP中常见的机器翻译、词性标注、分词等任务都可以看作是序列化问题。</p></li><li><p>我们的问题中有两类数据，一类序列数据是可以观测到的，即观测序列；而另一类数据是不能观察到的，即隐藏状态序列，简称状态序列。比如，在机器翻译中，我们可以将源语言文本看作是观测序列，目标语言文本看作是状态序列；又比如，词性标注中，词序列是观测序列，词性序列是状态序列。</p></li></ol><h2 id="隐马尔可夫模型：生成模型OR判别模型"><a href="#隐马尔可夫模型：生成模型OR判别模型" class="headerlink" title="隐马尔可夫模型：生成模型OR判别模型"></a>隐马尔可夫模型：生成模型OR判别模型</h2><ul><li>假设样本的特征向量为$X$，标签向量为$Y$。由生成方法学习到的模型称之为生成模型，生成方法是由数据学习联合分布$P(X,Y)$：<br>$$<br>P(X,Y)=P(X|Y)P(Y)<br>$$<br>然后求出条件概率分布$P(Y∣X)$作为预测：</li></ul><p>$$<br>P(Y∣X)=\frac{P(X,Y)}{P(X)}<br>$$</p><p>​        生成模型需要先把所有训练数据的分布情况摸透，最终确定一个分布，并且此分布是包含了所有特征和标签        的联合分布$P(X,Y)$。当我们需要对新的样本的特征向量进行预测时，使用上述公式，即可求出$P(Y∣X)$，即        样本$X$被标注为标签$Y$的概率。</p><p>​        典型的生成模型有：朴素贝叶斯模型，<strong>隐马尔可夫模型</strong>，生成对抗网络（GAN），变分自编码器（VAE）。</p><ul><li><p>由判别方法学习到的模型称之为判别模型，判别方法是由数据直接学习决策函数或者条件概率分布$P(Y∣X) $作为预测的模型。典型的判别模型有：k近邻模型，感知机模型，决策树，逻辑回归模型，最大熵模型，支持向量机，提升方法和<strong>条件随机场</strong>等。</p><p>判别模型直接根据训练数据的标签$Y$，通过定义特征进行学习，使用复杂的函数映射及决策叠加等方法，最后拟合出一个较优的边界。当新的特征向量到来时，我们使用训练得到的决策界进行预测即可。比较经典的判别模型是逻辑回归模型，它通过定义损失函数，最大化似然估计，利用梯度下降等方式将决策边界的拟合转化为最小化损失函数的凸优化问题。</p></li><li><p>总结：<strong>生成模型是指对联合概率建模，判别模型是对条件概率建模 ，HMM模型属于生成模型，因为HMM模型中没有建立决策边界，而是直接对联合概率分布建模。当给定观测序列时，我们使用前向算法计算每条状态序列的概率，选取概率最大的状态序列路径作为序列标注的结果。</strong></p></li><li><p>一个简单的图示表示生成模型和判别模型的区别：</p><p><img src="4.jpg" alt="生成模型和判别模型"></p></li></ul><h2 id="隐马尔可夫模型：概率模型"><a href="#隐马尔可夫模型：概率模型" class="headerlink" title="隐马尔可夫模型：概率模型"></a>隐马尔可夫模型：概率模型</h2><p><strong>概率模型</strong>（probabilistic model ）中，我们需要利用已知变量 “推断（inference）” 未知变量的条件分布。 根据我们之前的介绍，隐马尔可夫模型就是一种概率模型。</p><p><strong>概率图模型</strong>（probabilistic graphical model ）是一类用图表达变量相关关系的概率模型。一个节点表示一个或一组随机变量，节点之间的边表示变量间的概率相关关系。根据边的性质不同，概率图模型可以分为两种：第一类使用有向无环图表示变量之间的依赖关系，称为有向图模型或贝叶斯网（ Bayesian network ）；第二类是使用无向图表示变量之间的相关关系，成为无向图模型或马尔可夫网（Markov network）。根据下图可以看出：<strong>隐马尔可夫模型属于概率图模型中的有向图模型</strong>。</p><p><img src="4.png" alt="隐马尔可夫模型示意图"></p><p>我在知乎上看到了一张很清楚的图片，分享给大家，介绍了常见概率图模型的分类。</p><p><img src="2.png" alt="概率图模型的分类"></p><h2 id="隐马尔可夫模型中需要学习的三个参数"><a href="#隐马尔可夫模型中需要学习的三个参数" class="headerlink" title="隐马尔可夫模型中需要学习的三个参数"></a>隐马尔可夫模型中需要学习的三个参数</h2><p>简单来说，HMM模型主要使用了两个特征，分别是<strong>发射特征</strong>（词性到词的概率）和<strong>转移特征</strong>（前一个词性到当前词性的概率）。特别的，我们还会引入第三个特征，即<strong>初始特征</strong>，它主要指的是句子中第一个词性是什么的概率。它本质上来说仍然是一个转移特征，只不过是从第0个词性（也就是空）转移而来。</p><p>在实际参数学习过程中，这三个特征都是以矩阵的形式存储。 <strong>关于假设，重要的一点是三个特征矩阵并不随时间的改变而改变——这个矩阵在整个系统的生命周期中是固定不变的</strong>。 </p><p>为了简化模型，HMM定义了<strong>两个假设</strong>，即我们前面提到的<strong>齐次马尔可夫假设</strong>和<strong>观测独立性假设</strong>，根据前者，我们使用了转移特征和初始特征，根据后者，我们使用了发射特征。<strong>这些假设虽然简化了模型，但同时由于过于粗糙，导致HMM只能使用三类特征，无法考虑句子中的更多信息</strong>。在我的接下来的文章中，将探讨<strong>线性模型</strong>和<strong>对数线性模型</strong>，他们虽然无法解决序列标注问题，一次只能预测一个词的词性，但是<strong>能够使用更多的特征</strong>。特别的，<strong>条件随机场</strong>结合了对数线性模型与隐马尔可夫模型的优点，实现了<strong>可以使用无限制的特征模板进行序列化标注</strong>。</p><p>HMM（隐马尔可夫模型）、LR（逻辑回归模型，即对数线性模型）、CRF（条件随机场）的关系如下图所示。</p><p><img src="3.png" alt="几种模型的对比"></p><h2 id="隐马尔可夫模型的五个要素"><a href="#隐马尔可夫模型的五个要素" class="headerlink" title="隐马尔可夫模型的五个要素"></a>隐马尔可夫模型的五个要素</h2><p>总结一下，隐马尔可夫模型的核心就是五个要素： </p><ul><li>两个序列：<ul><li>观测序列：句子（词序列）</li><li>状态序列：词性序列</li></ul></li><li>三个矩阵：<ul><li>初始概率矩阵：第一个词性的概率，实际上是一个一维向量</li><li>发射概率矩阵：词性发射到词的概率，维度为[训练集中的词性数,训练集中的词数]</li><li>状态转移概率矩阵：从一个词性变化到另一个词性的概率，维度为[训练集中的词性数,训练集中的词性数]</li></ul></li></ul><p>任何一个能用以上五个参数描述的模型都是隐马尔可夫模型。</p><ul><li>这里，我们补充一个HMM的例子：</li></ul><blockquote><p>例子：病情转化<br>假设：某一时刻只有一种疾病，且只依赖于上一时刻疾病，一种疾病只有一种症状，且只依赖于当时的疾病<br>症状（观察值）：发烧，咳嗽，咽喉肿痛，流涕<br>疾病（状态值）：感冒，肺炎，扁桃体炎，猝死<br>转移概率：从一种疾病转变到另一种疾病的概率<br>输出概率：某一疾病呈现出某一症状的概率<br>初始分布：初始疾病的概率</p></blockquote><h2 id="隐马尔可夫模型解决序列标注问题的过程"><a href="#隐马尔可夫模型解决序列标注问题的过程" class="headerlink" title="隐马尔可夫模型解决序列标注问题的过程"></a>隐马尔可夫模型解决序列标注问题的过程</h2><ol><li><p><strong>训练过程</strong>：利用训练数据，统计得到HMM模型的三个参数，也就是上一节提到的三个矩阵。主要的方法有：<strong>极大似然估计法（有监督学习）</strong>和 <strong>Baum-Welch算法（无监督学习）</strong>。</p></li><li><p><strong>预测过程</strong>：给定一个句子的词序列，通过我们训练好的模型预测出最有可能的词性序列。主要的方法为<strong>维特比算法</strong>。</p></li></ol><h2 id="隐马尔可夫模型的训练过程"><a href="#隐马尔可夫模型的训练过程" class="headerlink" title="隐马尔可夫模型的训练过程"></a>隐马尔可夫模型的训练过程</h2><h3 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h3><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">$w$</td><td align="center">观测序列中的单词</td></tr><tr><td align="center">$y$</td><td align="center">状态序列中的词性</td></tr><tr><td align="center">$N={y_0,…,y_n}$</td><td align="center">状态集合，包含了数据集中所有的n个状态，即词性</td></tr><tr><td align="center">$M={w_0,…,w_n}$</td><td align="center">观测集合，包含了数据集中所有的m个观测，即词</td></tr><tr><td align="center">$A=[a_{ij}]_{N*N}$</td><td align="center">状态转移矩阵，包含了词性间的转移概率，其中$a_{ij}=P(y_i|y_j)$，且这里的转移需要是两个连续出现的词性（一阶马尔可夫假设）</td></tr><tr><td align="center">$B=[b_{ij}]_{N*M}$</td><td align="center">状态发射矩阵，包含了词性到词的发射概率，其中$b_{ij}=P(w_i|y_j)$</td></tr><tr><td align="center">$C=[c_i]_N$</td><td align="center">初始状态矩阵，包含了每一个词性出现在词性序列的第一个节点的概率</td></tr></tbody></table><h3 id="极大似然估计法（有监督学习）"><a href="#极大似然估计法（有监督学习）" class="headerlink" title="极大似然估计法（有监督学习）"></a>极大似然估计法（有监督学习）</h3><p>机器学习中，有监督学习指的是训练数据给出了标签。在词性标注问题中，即指的是训练数据给出了词性序列。</p><p>在有监督学习的参数学习过程中， <strong>参数的计算频率近似于参数的概率</strong> ，我们可以利用极大似然估计法进行证明。具体证明的过程参考李老师的讲义<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/7-hmm-tagging-MLE/main.pdf" target="_blank" rel="noopener"> HMM模型中极大似然估计的由来 </a> 。基于上述推导，通过对训练数据进行统计，我们便可计算出模型的三个基本参数矩阵，并可以使用他们进行预测。</p><p>具体的<strong>训练过程</strong>如下：</p><ul><li><p>Step1.统计状态的概率分布，也就是初始概率矩阵 $C$，这一步<strong>直接计算各词性在序列首节点（即句首）出现的频率即可</strong>。</p></li><li><p>Step2. 统计状态转移矩阵 $A$，<strong>这一步需要分别统计当前词性转移至所有词性的次数$\sum_{k=1}^N{count(y_i,y_k)}$和统计当前词性转移至目标词性的次数$count(y_i,y_j)$</strong>，根据一阶马尔可夫假设，这里统计的词性间的转移次数<strong>只统计两个词性连续出现的情况</strong>。将统计得到的两个次数相除，即可得到当前训练集中某词性转移到目标词性的频率，根据极大似然估计，该频率就是状态转移概率。<br>$$<br>a_{ij}=\frac{count(y_i,y_j)}{\sum_{k=1}^N{count(y_i,y_k)}}<br>$$</p></li></ul><p>根据上述公式，我们可以预测出所有状态自身和相互转移的概率，填充状态转移矩阵。</p><ul><li>Step3. 统计状态发射矩阵 $B$，<strong>这一步需要分别统计当前词性发射至所有词的次数$\sum_{k=1}^M{count(y_i,w_k)}$和统计当前词性发射至目标词的次数$count(y_i,w_j)$</strong>。将统计得到的两个次数相除，即可得到当前数据集中某词性发射到目标词的概率，根据极大似然估计，该频率就是状态发射概率。<br>$$<br>b_{ij}=\frac{count(y_i,w_j)}{\sum_{k=1}^N{count(y_i,w_k)}}<br>$$<br>根据上述公式，我们可以预测出所有状态自身和相互转移的概率，填充状态发射矩阵。</li></ul><p>至此，我们完成了在人工标注的数据集上的隐马尔可夫模型所有参数的学习，并可以将其投入至结果预测中。</p><h2 id="Baum-Welch算法（无监督学习）"><a href="#Baum-Welch算法（无监督学习）" class="headerlink" title="Baum-Welch算法（无监督学习）"></a>Baum-Welch算法（无监督学习）</h2><p>机器学习中，无监督学习指的是训练数据没有给出标签。在词性标注问题中，即指的是训练数据只有句子，没有对应的词性。在这个问题中，无监督学习远比有监督学习复杂。这里仅给出我现在对该算法的理解，如果大家发现有问题可以在评论区指出。</p><p>我的理解是：Baum-Welch算法就是一个<strong>EM</strong>的过程，参数的求解需要使用到<strong>前向后向（Forward-Backward）算法</strong>。</p><p>EM的意思是 <strong>Expectation Maximization</strong> ，即期望最大化。这个算法一般分为两步，即E步（Expection 步）和M步（Maximization 步）：</p><ol><li>随机初始化模型参数$\theta$的初值$\theta_0$。</li><li>E步：计算联合分布的条件概率期望$Q$</li><li>M步：<strong>极大化似然函数</strong>$L(\theta)$，得到新的$\theta$</li><li>重复E、M步骤直到$\theta$收敛</li></ol><p>这里说的比较简略，从极大似然估计到EM算法的推导大家可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/7-hmm-em/main.pdf" target="_blank" rel="noopener">李老师的课件</a>以及这篇知乎上的文章<a href="https://zhuanlan.zhihu.com/p/36331115" target="_blank" rel="noopener">人人都懂EM算法</a>。</p><p>如果你有机器学习的基础，那你很可能学习过<strong>K-Means算法</strong>，这是一种无监督的聚类算法。它本质上就是一种EM算法。对于给定的许多个无标签的样本点，K-Means可以将他们聚成任意n个类别。具体的做法是先随机选取数据集中的n个点作为聚类的质心点，计算每个点到每个质心点的距离，将他们归类到距离最小的类别下；然后对于每一个类别，重新计算其质心点；我们反复迭代进行上述的归类和质心计算的步骤，直到质心不再变化。<strong>随机初始化和重置质心的过程其实就是EM算法的E步，计算样本点到质心的距离并将其聚类到最近的质心的过程其实就是EM算法的M步。</strong></p><p>K-Means算法直接对样本点进行归类，而不是计算每个类别的概率，所以属于<strong>Hard EM</strong>。Hard EM和 Soft EM的区别和我之前在吴恩达的深度学习课程上看到的 SoftMax和HardMax的区别很像，个人感觉本质是一样。</p><p><strong>总结一下，当我们的样本没有给定标注数据，即只有句子没有词性时，我们可以对需要学习的三个参数矩阵进行随机初始化（np.rand），初步确定模型，然后极大化数据的某种似然，调整得到新的参数矩阵，通过不断地迭代，参数矩阵将逐渐收敛，当它们的变化范围缩小到某个可以被接受的阈值时，我们可以停止迭代，将当前的参数矩阵用于预测。</strong></p><p><strong>EM算法的收敛性可以使用Jensen不等式来证明</strong>，具体过程非常精妙，详细内容可以参考<a href="https://www.cnblogs.com/jerrylead/archive/2011/04/06/2006936.html" target="_blank" rel="noopener">吴恩达的讲义</a>。</p><p>需要注意的是，<strong>EM算法无法保证全局最优解</strong>，和梯度下降算法非常类似，他们能够稳定达到全局最优的条件都是似然函数（损失函数）是一个凸函数。（PS：似然函数和损失函数的关系我个人认为非常紧密，后面会专门写一篇blog说一下这个问题）</p><p><strong>前向后向算法</strong>的使用，主要是因为对于网格中的每一个状态，它既计算到达此状态的“前向”概率（给定当前模型的近似估计），又计算到达此状态的“后向”概率（给定当前模型的近似估计）。 这些都可以通过利用递归进行加速计算。<strong>使用前向算法和后向算法的相互合作，我们可以得到很多有用的信息，并可以将它们运用在EM算法过程中的极大化似然估计上</strong>。（<strong>PS：这里的Forward算法和后面Viterbi算法中的Forward算法并不完全相同，这里是 sum-product ，你可以看作是神经网络中的正向传播过程，对于传至当前状态的概率进行求和；而后者是 max-product，对于传至当前状态的概率取最大值</strong> ）</p><p>这里顺带说一句，前向算法还可以用于计算序列的概率，从而选择模型。如果我们训练了多个词性标注的HMM模型，那么对于一个需要标注的句子，我们可以通过前向算法计算它在不同模型中可能出现的概率，然后选取最大概率的模型用于预测。</p><h2 id="隐马尔可夫模型的预测（解码）过程"><a href="#隐马尔可夫模型的预测（解码）过程" class="headerlink" title="隐马尔可夫模型的预测（解码）过程"></a>隐马尔可夫模型的预测（解码）过程</h2><p>学习完隐马尔可夫模型的参数后，便可以使用这三个参数矩阵对我们输入的句子进行词性预测了。在这里，我们使用一种叫做<strong>维特比（viterbi）算法</strong>的动态规划算法进行状态序列的解码，也就是词性序列的预测。</p><p>维特比算法是一种<strong>动态规划求解篱笆网络（Lattice）的最优路径问题的方法</strong>。此处，我依然不会给出详细的公式，具体公式大家可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/7-hmm-em/main.pdf" target="_blank" rel="noopener">李老师的课件</a>，我仅以通俗的语言简单地解释一下维特比算法的原理。</p><p><img src="5.png" alt="篱笆网络（Lattice）的最短路径问题"></p><p>维特比算法可以应用在任何<strong>有向无环图的最优路径计算</strong>上，这里它恰巧符合隐马尔可夫算法的解码需求。它主要分为两个步骤：</p><ol><li>前向传播计算序列的最大概率。</li><li>反向回溯确定最大概率序列的路径。</li></ol><p>维特比算法前向传播的过程主要采用了动态规划思想，因为在上述有向无环图中，同一个节点可以被多次访问，所以如果采用穷举法计算所有序列，会产生对子问题的大量重复计算。我们自然想到采用动态规划的方法来降低时间复杂度，因为这里满足动态规划的三个基本要求：（1）重叠子问题（2）最优子结构（3）无后效性。</p><p>这个算法并不难理解，我也就不一步步推给大家看了，感兴趣的同学可以看一下这个问题<a href="https://www.zhihu.com/question/20136144" target="_blank" rel="noopener">如何通俗地讲解 viterbi 算法？</a>。简单阐述一下就是：<strong>状态矩阵中，当前节点的值等于上一层各节点的值乘以对应的转移路径的权值所得结果中的最优值（max-product），同时，我们还建立一个回溯矩阵，保存状态矩阵中每个节点的值是由上一层的哪个节点转移而来。当前向传播计算到最后一层时，我们选取最后一层的节点中的最优值，并通过回溯矩阵反向回溯得到对应的最优序列。特别地，在隐马尔可夫模型中，我们在前向传播计算每个节点最优值的时候，还需要考虑发射概率。</strong></p><p>通过维特比算法，我们可以较快的利用训练好的模型去预测一个句子的最大概率词性序列，并输出。</p><p>在实际运用模型的过程中，我们还会发现这样的一个问题：训练得到的参数矩阵很可能是较为稀疏的，例如从一个词性从未发射到某个单词过。同时，训练集的规模有限，不可能包含所有的词和词性。由于状态矩阵的转移涉及概率的累乘，上述未登录的情况将导致发射或转移或初始概率为0，进而使得前向传播计算出的整条序列地概率为0。<strong>为了解决零概率问题，我们需要还引入平滑方法，例如Laplace平滑等</strong>。更多方法可以参考<a href="https://www.jianshu.com/p/a28acdc32b56" target="_blank" rel="noopener">NLP系列学习:数据平滑</a>。<br>$$<br>a_{ij}=\frac{count(y_i,y_j)+\lambda}{\sum_{k=1}^N[{count(y_i,y_k)+\lambda}]}<br>$$<br>特别注意的是，如果你使用Laplace平滑，下方的$\lambda$一定不要忘记加，我曾经写模型的时候就犯过这样的错误。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我学习隐马尔可夫模型过程中的笔记和思考，接下来我将继续介绍序列标注概率图模型中的最大熵马尔可夫模型（MEMM）和条件随机场模型（CRF），并阐明他们之间的关系。</p><h2 id="参考资料（部分）"><a href="#参考资料（部分）" class="headerlink" title="参考资料（部分）"></a>参考资料（部分）</h2><ul><li><a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/7-hmm-tagging/main.pdf" target="_blank" rel="noopener">李正华老师的课件</a></li><li>李航老师的《统计学习方法》第10章</li><li><a href="http://www.comp.leeds.ac.uk/roger/HiddenMarkovModels/html_dev/main.html" target="_blank" rel="noopener"> HMM学习最佳范例 </a></li><li><a href="https://blog.csdn.net/lukabruce/article/details/82380511" target="_blank" rel="noopener">隐马尔科夫模型（Hidden Markov Model，HMM）</a></li><li><a href="https://zhuanlan.zhihu.com/p/85454896" target="_blank" rel="noopener">一站式解决：隐马尔可夫模型（HMM）全过程推导及实现</a></li><li><a href="https://www.zhihu.com/question/35866596" target="_blank" rel="noopener">如何用简单易懂的例子解释条件随机场（CRF）模型？它和HMM有什么区别？</a></li><li><a href="https://www.zhihu.com/question/20962240" target="_blank" rel="noopener">如何用简单易懂的例子解释隐马尔可夫模型？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2020/03/17/kmp-suan-fa/"/>
      <url>/2020/03/17/kmp-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文整理了KMP算法的原理及代码，可以使用LEETCODE上的题目进行测试：<a href="https://leetcode-cn.com/problems/implement-strstr/submissions/" title="28. 实现 strStr()" target="_blank" rel="noopener">28. 实现 strStr()</a>。</p><h2 id="从Brute-Force算法说起"><a href="#从Brute-Force算法说起" class="headerlink" title="从Brute-Force算法说起"></a>从Brute-Force算法说起</h2><p>BF算法是最为简单的一种字符串匹配算法，它采用纯暴力匹配的思想。对于目标串S和模式串P，其基本匹配思路如下：</p><ul><li>枚举 i = 0, 1, 2 … , len（S）-len（P）</li><li>将 S[i : i+len（P）] 与 P 作比较。如果一致，则找到了一个匹配。</li></ul><p><img src="1.jpg" alt="BF算法匹配流程"></p><p>BF算法的缺点在于每一次都是将目标串中的指针直接回溯为i+1。</p><p>我们记 n = |S| 为串 S 的长度，m = |P| 为串 P 的长度。不难想到，最坏情况下其时间复杂度为$O(MN)$。</p><p><img src="2.jpg" alt="BF算法python实现"></p><h2 id="KMP算法：Brute-Force算法的优化"><a href="#KMP算法：Brute-Force算法的优化" class="headerlink" title="KMP算法：Brute-Force算法的优化"></a>KMP算法：Brute-Force算法的优化</h2><p>为了优化BF算法，我们需要尽可能地减少匹配的趟数。那么，我们如何达到这一目的呢？</p><p>如果把模式串视为一把标尺，在主串上移动，那么 Brute-Force 就是每次失配之后只右移一位；改进算法则是每次失配之后，移很多位，跳过那些不可能匹配成功的位置。为了减少重复匹配，我们需要在失配处计算移动的位数，而不是单纯的回退目标串和模式串中的指针。通过一个名叫“部分匹配表”的东西，我们可以跳过绝不可能匹配成功的字符串比较，从而实现算法的优化。</p><h3 id="部分匹配表"><a href="#部分匹配表" class="headerlink" title="部分匹配表"></a>部分匹配表</h3><p>部分匹配表（Partial Match Table）的含义为：</p><ul><li><p>对于长度为m的字符串P，部分匹配表是与之对应的长度为m的一个数组PMT。</p></li><li><p>PMT[i]的值等于：字符串P的前i位字符组成的子字符串中，前缀集合和后缀集合中公共子串（前缀和后缀不包括自身）的最大长度。</p></li></ul><p>对于字符串“abababca”，它的PMT如下表所示：</p><p><img src="3.png" alt="PMT"></p><p>例如，对于”aba”，它的前缀集合为{”a”, ”ab”}，后缀 集合为{”ba”, ”a”}。两个集合的交集为{”a”}，那么长度最长的元素就是字符串”a”了，长 度为1，所以对于”aba”而言，它在PMT表中对应的值就是1。再比如，对于字符串”ababa”，它的前缀集合为{”a”, ”ab”, ”aba”, ”abab”}，它的后缀集合为{”baba”, ”aba”, ”ba”, ”a”}， 两个集合的交集为{”a”, ”aba”}，其中最长的元素为”aba”，长度为3。</p><h3 id="如何使用部分匹配表进行优化"><a href="#如何使用部分匹配表进行优化" class="headerlink" title="如何使用部分匹配表进行优化"></a>如何使用部分匹配表进行优化</h3><p><img src="4.png" alt="KMT算法示意图"></p><p>我们以上图为例进行说明。当目标串S的指针为i，模式串P的指针为j时，此时匹配失败了。按照BF算法，我们会将i回退至下标为1处，j回退至下标为0处继续匹配。这显然是很笨拙的。</p><p>通过观察，我们可以发现， S[:i] 和 P[:j] 是成功匹配的，只是 S[i] 和 P[j] 不相同。</p><p>这时，我们在上一节所得的模式串的部分匹配表就派上了用场。通过 PMT[j-1] ，我们可以得知，P[:j] 这一子串中前后缀公共子串的最大长度为4。又因为 S[:i] 和 P[:j] 是相等的，所以 P[:j] 的后缀也就是 S[:i] 的后缀。那么，我们可以推知目标串i之前的4位和模式串开头的4位是相同的。就是图中的灰色部分。那这部分就不用再比较了。</p><p>有了上面的思路，我们就可以使用PMT加速字符串的查找了。我们看到如果是在 j 位 失配，那么影响 j 指针回溯的位置的其实是第 j −1 位的 PMT 值。</p><p>以上其实就是KMP算法的基本思想了，我们总结一下：KMP算法的目的是使用部分匹配表，来跳过必不可能成功的匹配，减少匹配的趟数。</p><h3 id="KMP算法的流程"><a href="#KMP算法的流程" class="headerlink" title="KMP算法的流程"></a>KMP算法的流程</h3><p>我们现在来总结一下KMP算法主程序的基本流程：</p><p>假设现在文本串 S 匹配到 tar 位置，模式串 P 匹配到 pos 位置：</p><ol><li><p>如果当前字符匹配成功，则tar++，pos++，继续匹配二者的下个字符。若当前的pos等于模式串的长度，则说明全部匹配成功，此时可以返回tar减去pos的值，即模式串在目标串中出现的首个字符的下标。</p></li><li><p>如果当前匹配失败，且pos大于0，说明此时模式串已经成功匹配了部分字符，可以尝试利用部分匹配表跳过必然无法匹配成功的子串，令pos=PMT[pos-1]。</p></li><li><p>如果匹配失败，且pos等于0，说明此时模式串的第一个字符就无法匹配，则tar++，尝试与目标串的下个字符匹配。</p></li></ol><p>根据上述的流程，我们可以编写KMP算法主体函数如下：</p><pre class="line-numbers language-python"><code class="language-python">        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span>pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>            tar<span class="token operator">=</span><span class="token number">0</span>            pos<span class="token operator">=</span><span class="token number">0</span>            PMT<span class="token operator">=</span>getPMT<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>tar<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>st<span class="token punctuation">[</span>tar<span class="token punctuation">]</span><span class="token operator">==</span>pattern<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    tar<span class="token operator">+=</span><span class="token number">1</span>                    pos<span class="token operator">+=</span><span class="token number">1</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token operator">==</span>len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> tar<span class="token operator">-</span>pos                <span class="token keyword">elif</span> <span class="token punctuation">(</span>pos<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    pos<span class="token operator">=</span>PMT<span class="token punctuation">[</span>pos<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    tar<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="KMP算法的难点：获取部分匹配表"><a href="#KMP算法的难点：获取部分匹配表" class="headerlink" title="KMP算法的难点：获取部分匹配表"></a>KMP算法的难点：获取部分匹配表</h3><p>KMP算法的基本思想其实并不难，但KMP算法主要的难点在于如何求解模式串的PMT数组。这里我们可以采取<strong>动态规划</strong>的方式求解。</p><ul><li>问题：对于模式串P，已知PMT[0],PMT[1],PMT[2]…PMT[x-1]，求解PMT[x]。</li></ul><p>观察上述问题，我们发现，该问题符合最优子结构和重叠子问题的动态规划要求，动态规划具体的转移情况我们进行分类讨论。</p><ul><li>情况一：已知now=PMT[x-1]，若P[x]==P[now]，则PMT[x]=now+1。如下图所示，因为我们已知前x-1个字符中有长度为now的公共前后缀，如果当前前缀的后一位P[now]等于当前后缀的后一位P[x]，则公共前后缀长度自然可以加1。</li></ul><p><img src="4.jpg" alt="情况1"></p><ul><li>情况二： 若P[x]!=P[now]，则令now=PMT[now-1]，再次尝试比较P[x]和P[now]，如果相等则PMT[x]=now+1，如果不相等再重复之前的过程，直到now等于0。如下图所示，此时由于子串A必然与子串B相等，则子串A的后缀与子串B的后缀必然相同，所以子串A的最大公共前后缀即为前x-1个字符中第二长的公共前后缀。</li></ul><p><img src="5.jpg" alt="情况2"></p><p>根据上述分析，我们可以编写获取模式串PMT数组的代码如下：</p><pre class="line-numbers language-python"><code class="language-python">        <span class="token keyword">def</span> <span class="token function">getPMT</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>            PMT<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#PMT[0]必定为0</span>            x<span class="token operator">=</span><span class="token number">1</span>            now<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">==</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    now<span class="token operator">+=</span><span class="token number">1</span>                    PMT<span class="token punctuation">.</span>append<span class="token punctuation">(</span>now<span class="token punctuation">)</span>                    x<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">elif</span> now<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                    now<span class="token operator">=</span>PMT<span class="token punctuation">[</span>now<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    PMT<span class="token punctuation">.</span>append<span class="token punctuation">(</span>now<span class="token punctuation">)</span>                    x<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">return</span> PMT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，KMP算法介绍完毕。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>KMP算法在我看来，主要有两方面的内容，一是通过动态规划求解模式串的部分匹配表；二是通过部分匹配表来跳过必不可能的情况，提升匹配的速度。其核心难点在于PMT动态规划的转移方程，需要静下心来自己推导一遍。</p><p>我们不难看出，对于长度为M的目标串S和长度为N的模式串P，KMP算法的时间复杂度由两部分组成：一是match函数中需要让指针遍历目标串S的每一个位置，需要耗费$O(M)$的时间，二是getPMT函数中计算部分匹配表，这一部分我们采用均摊时间复杂度分析，可以发现耗费的时间为$O(N)$。</p><p>利用KMP算法，我们将BF算法的时间复杂度$O(MN)$成功降为$O(M+N)$，使速度大大提升。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日两题</title>
      <link href="/2020/03/13/leetcode-ti-jie-chi-xu-geng-xin/"/>
      <url>/2020/03/13/leetcode-ti-jie-chi-xu-geng-xin/</url>
      
        <content type="html"><![CDATA[<h1 id="每日算法-LEETCODE-PYTHON3"><a href="#每日算法-LEETCODE-PYTHON3" class="headerlink" title="每日算法(LEETCODE,PYTHON3)"></a>每日算法(LEETCODE,PYTHON3)</h1><h2 id="2020-3-2-（2-medium）"><a href="#2020-3-2-（2-medium）" class="headerlink" title="2020.3.2 （2 medium）"></a>2020.3.2 （2 medium）</h2><h3 id="第3题-无重复的字符的最长字串"><a href="#第3题-无重复的字符的最长字串" class="headerlink" title="第3题 无重复的字符的最长字串"></a>第3题 无重复的字符的最长字串</h3><p><img src="3.png" alt="第3题 无重复的字符的最长字串"></p><h4 id="思路1-动态规划"><a href="#思路1-动态规划" class="headerlink" title="思路1 动态规划"></a>思路1 动态规划</h4><p>我的最初思路：可以采用动态规划法（区间DP），从区间为2的子串开始计算无重复字符的长度，接着计算下个更大的区间，依次类推，直到区间长度等于字符串长度。</p><ul><li><p>空间复杂度优化：这道题的动态规划状态矩阵中，可以发现有一半的空间（对角线以下）全部为0，所以可以压缩。</p></li><li><p>时间复杂度优化：分析后发现，这道题其实不需要动态规划，因为本质上没有重叠子问题。我尝试了两层循环遍历字符串的所有子串，一旦出现重复就可以跳出与当前最大长度比较，后面的子串不用再比较了，必有重复的字符。时间复杂度$O(N^2)$</p></li></ul><h4 id="思路2-滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）"><a href="#思路2-滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）" class="headerlink" title="思路2 滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）"></a>思路2 滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）</h4><p>使用左右两个指针维护一个无重复字符的窗口，两个指针初始都在0处。通过右指针不断向右延伸添加新的字符，并记录当前窗口大小，每次与当前最大值比较，如果大于当前最大值，则可以更新。当窗口延伸至新字符已存在于窗口内时。把窗口左侧的字符不断移除（左指针收缩），直到当前窗口无重复子串。继续滑动窗口，直到右指针触及字符串尾部，此时可以输出当前最大长度即可。</p><p>滑动窗口法减少了对字符串的重复遍历。</p><pre><code>class Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        if not s:return 0 #字符串为空的处理        left = 0        lookup = []        n = len(s)        max_len = 0        cur_len = 0        for i in range(n):            cur_len += 1            if s[i] in lookup:                pos=len(lookup)-lookup[::-1].index(s[i]) #寻找重复字符出现在窗口内的最后一次位置，直接将左指针移动到该位置后面即可。                lookup=lookup[pos:]                left += pos                cur_len -= pos            if cur_len &gt; max_len:max_len = cur_len            lookup.append(s[i])        return max_len</code></pre><h3 id="第4题-寻找两个有序数组的中位数"><a href="#第4题-寻找两个有序数组的中位数" class="headerlink" title="第4题 寻找两个有序数组的中位数"></a>第4题 寻找两个有序数组的中位数</h3><p><img src="4.png" alt="第4题 寻找两个有序数组的中位数"></p><h4 id="思路1-指针遍历"><a href="#思路1-指针遍历" class="headerlink" title="思路1 指针遍历"></a>思路1 指针遍历</h4><p>我的方法：归并排序的思想，通过设置两个指针对两个有序数组进行归并排序，若已排序到中位数位置，则输入当前指针指向的数。</p><p>缺点：时间复杂度$O(M+N)$，较高。空间复杂度可以优化至$O(1)$，即只存当前数和前一个数。</p><p>要想获得log级别的时间复杂度，需要使用二分法或者堆。</p><pre><code>class Solution:    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:        mid_pos=(len(nums1)+len(nums2)-1)/2        p=0        q=0        li=[]        count=-1        while (p!=len(nums1))and(q!=len(nums2)):            if (nums1[p]&lt;=nums2[q]):                li.append(nums1[p])                count+=1                p+=1                if (count&gt;=mid_pos):                    if mid_pos%1!=0:                        return (li[-1]+li[-2])/2                    else:                        return li[-1]            else:                li.append(nums2[q])                count+=1                q+=1                if (count&gt;=mid_pos):                    if mid_pos%1!=0:                        return (li[-1]+li[-2])/2                    else:                        return li[-1]        if (p==len(nums1)):            for i in range(q,len(nums2)):                li.append(nums2[i])                count+=1                if (count&gt;=mid_pos):                    if mid_pos%1!=0:                        return (li[-1]+li[-2])/2                    else:                        return li[-1]        elif (q==len(nums2)):            for i in range(p,len(nums1)):                li.append(nums1[i])                count+=1                if (count&gt;=mid_pos):                    if mid_pos%1!=0:                        return (li[-1]+li[-2])/2                    else:                        return li[-1]</code></pre><h4 id="思路2-递归二分"><a href="#思路2-递归二分" class="headerlink" title="思路2 递归二分"></a>思路2 递归二分</h4><p>为了使时间复杂度指数倍地下降，我们以数组[1，3，4，9]和[1，2，3，4，5，6，7，8，9，10]为例。计算得知：（1+14）/2=7.5，所以二者合并后的中位数为：第7小数和第8小数的平均值。</p><p>首先，我们学习一种二分法求解两个有序数组合并后第k小的数的方法，我们以第7小数为例：</p><p>1.先计算7整除2的商为3，然后比较第一个数组和第二个数组的第3个数（如果某个数组的元素不足3个，则比较它的最后一个数）。将较小的那个数及之前所有的数从所在的数组中去除。（此时它们必在合并后前6小的数中，具体证明可以自己推导一遍）。</p><p>2.此时，求解第7小的数变为：在更新后的两个数组中求解第4小的数（因为已经确定了3个）。</p><p>3.计算4整除2的商为2，然后比较两个数组的第2个数，与第1步中类似，将较小的数及之前的所有数从所在数组中删除。</p><p>4.此时，求解第4小的数变为：在更新后的两个数组中求解第2小的数（因为又确定了2个）。</p><p>5.重复以上过程，直到问题变为求解第1小的数，这时比较两个数组中的第1个数，返回较小值即可。</p><p>通过以上算法，我们可以用二分删除法计算出合并后第7小数和第8小数，然后便可计算中位数。</p><ul><li>时间复杂度:每进行一次循环，我们就减少 k/2 个元素，所以时间复杂度是 $O(log(k))$，而 k=（m+n）/2，所以最终的复杂也就是 O（log（m+n））。</li></ul><pre><code>class Solution:    def findk(self,nums1,nums2,k):#求解合并后第k小数        m=k//2        if (len(nums1)&gt;len(nums2)):#保证第一个数组较小            return self.findk(nums2,nums1,k)        if (len(nums1)==0):#如果第一个数组为空，直接返回第二个数组的第k个数即可            return nums2[k-1]        i=min(len(nums1),m)#防止第一个数组长度不足m        if (k==1):#如果求解第1小数，则直接比较二者第1个数即可            return min(nums1[0],nums2[0])        if (nums1[i-1]&gt;nums2[m-1]):#删除第二个数组的前m个数，再递归查找            return self.findk(nums1,nums2[m:],k-m)        else:#删除第一个数组的前i个数，再递归查找            return self.findk(nums1[i:],nums2,k-i)    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:        if (len(nums1)+len(nums2)+1)%2!=0:#数组总长为偶数            return (self.findk(nums1,nums2,int((len(nums1)+len(nums2)+1)/2))+self.findk(nums1,nums2,int((len(nums1)+len(nums2)+1)/2)+1))/2        else:#数组总长为奇数            return self.findk(nums1,nums2,int((len(nums1)+len(nums2)+1)/2))</code></pre><ul><li>空间复杂度:O（1）。<strong>因为这里使用了尾递归！</strong></li></ul><h4 id="什么是尾递归"><a href="#什么是尾递归" class="headerlink" title="什么是尾递归"></a>什么是尾递归</h4><p>以递归方式实现阶乘函数的实现：</p><pre><code>int recsum(int n) {    if (n &lt; 0)        return 0;    else if(n == 0 || n == 1)        return 1;    else        return n * fact(n - 1);}</code></pre><p>以尾递归方式实现阶乘函数的实现：</p><pre><code>int tailrecsum(int n, int res=0){    if (n &lt; 0)        return 0;    else if(n == 0)        return res;    else        return facttail(n - 1, n + res);}</code></pre><p>非尾递归，下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。</p><p>尾递归，进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。</p><p><strong>尾递归的判断标准是函数运行最后一步是否调用自身，而不是是否在函数的最后一行调用自身。</strong></p><p>上述例子中：</p><ul><li><p>递归方式的倒数第二步是调用自身求解recsum（n-1），而最后一步是将recsum（n-1）的结果与n相乘并返回，所以rescum(n)的运算依赖于rescum（n-1）的运算。需要将本层函数压栈保存，当计算完最后一层后，再进行层层返回，得出结果。</p></li><li><p>尾递归方式的最后一步就是调用自身求解n-1时的结果，并将当前层的结果作为参数传入下一层，不需要再返回当前层进行运算。下层计算结果对上层“无用”（上一层运算已经做完，不依赖后续的递归），为了效率，可以直接将下一层需要的空间覆盖在上一层上。</p></li></ul><p>总结：</p><ul><li><p>尾递归，比线性递归多一个参数，这个参数是上一次调用函数得到的结果；所以，关键点在于，尾递归每次调用都在收集结果，避免了线性递归不收集结果只能依次展开消耗内存的坏处。</p></li><li><p>使用尾递归可以带来一个好处：因为进入最后一步后不再需要参考外层函数（caller）的信息，因此没必要保存外层函数的stack，递归需要用的stack只有目前这层函数的，因此避免了栈溢出风险。 </p></li></ul><p><strong>本题中，所有递归调用都是当前层递归的最后一步，所以不需要额外的栈空间保存当前层，时间复杂度为O（1）。</strong></p><h2 id="2020-3-3-（2-medium）"><a href="#2020-3-3-（2-medium）" class="headerlink" title="2020.3.3 （2 medium）"></a>2020.3.3 （2 medium）</h2><h3 id="第5题-最长回文子串"><a href="#第5题-最长回文子串" class="headerlink" title="第5题 最长回文子串"></a>第5题 最长回文子串</h3><p><img src="5.png" alt="第5题 最长回文子串"></p><h4 id="思路1："><a href="#思路1：" class="headerlink" title="思路1："></a>思路1：</h4><p>区间动态规划+状态空间压缩，利用区间首尾字符是否相等，且去除首尾字符后的子串是否为回文串，来判断当前区间是否为回文子串。</p><ul><li><p>时间复杂度：$O(N^2)$</p></li><li><p>空间复杂度：$O(N^2)$（可以压缩一半）</p></li></ul><h4 id="思路2："><a href="#思路2：" class="headerlink" title="思路2："></a>思路2：</h4><p>中心扩展法，不需要额外的状态矩阵。对于一个长度为n的字符串，有2n-1个中心（奇偶回文串分类讨论）可以选取，由中心向两侧扩散寻找该中心所能构成的最长回文子串，若大于当前最大值，则将最大值替换为当前长度。</p><ul><li><p>时间复杂度：$O(N^2)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><pre><code>class Solution:    def longestPalindrome(self, s: str) -&gt; str:        max_length=&#39;&#39;        for i in range(len(s)):            if (i!=len(s)-1):                if len(self.expandcenter(s,i,i))&gt;len(max_length):                    max_length=self.expandcenter(s,i,i)                if len(self.expandcenter(s,i,i+1))&gt;len(max_length):                    max_length=self.expandcenter(s,i,i+1)            else:                if len(self.expandcenter(s,i,i))&gt;len(max_length):                    max_length=self.expandcenter(s,i,i)        return max_length    def expandcenter(self,s,l,r):#中心扩展法向两侧搜索判断        if (l==r):#奇回文串            length=1            while True:                l-=1                r+=1                if (l&gt;=0)and(r&lt;=len(s)-1)and(s[l]==s[r]):                    length+=2                else:                    return s[l+1:r]        else:#偶回文串            length=0            while True:                if (l&gt;=0)and(r&lt;=len(s)-1)and(s[l]==s[r]):                    length+=2                else:                    return s[l+1:r]                l-=1                r+=1</code></pre><h4 id="进阶算法："><a href="#进阶算法：" class="headerlink" title="进阶算法："></a>进阶算法：</h4><p>Manacher算法，时间复杂度只有$O(N)$，但比较复杂。可以参考<a href="https://www.jianshu.com/p/392172762e55" target="_blank" rel="noopener">https://www.jianshu.com/p/392172762e55</a></p><h3 id="第6题-Z-字形变换"><a href="#第6题-Z-字形变换" class="headerlink" title="第6题 Z 字形变换"></a>第6题 Z 字形变换</h3><p><img src="6.png" alt="第6题 Z 字形变换"></p><h4 id="思路1：-1"><a href="#思路1：-1" class="headerlink" title="思路1："></a>思路1：</h4><p>通过观察变换前后的字符串，利用规律求解，直接使用下标运算。</p><pre><code>class Solution:    def convert(self, s: str, numRows: int) -&gt; str:        a=2*numRows-2        result=&#39;&#39;        if (a==0):            return s        for i in range(numRows):            t=i            while(t&lt;len(s)):                result+=s[t]                delta=2*(numRows-i-1)                if (i!=0) and (t+delta&lt;len(s)) and(delta&gt;0):                    result+=s[t+delta]                t+=a        return result</code></pre><ul><li><p>时间复杂度：$O(N)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><h4 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h4><p>按顺序遍历字符串，并设置与行数相等的数组。遍历时，按照Z字形变化的格式放入对应的数组（行数先加1，遍历到底部再减1，遍历到顶部再加1，直到遍历完）</p><pre><code>class Solution:    def convert(self, s: str, numRows: int) -&gt; str:        if numRows &lt; 2: return s        res = [&quot;&quot; for _ in range(numRows)]        i, flag = 0, -1        for c in s:            res[i] += c            if i == 0 or i == numRows - 1: flag = -flag            i += flag        return &quot;&quot;.join(res)</code></pre><h2 id="2020-3-4-（1-hard-1-medium）"><a href="#2020-3-4-（1-hard-1-medium）" class="headerlink" title="2020.3.4 （1 hard 1 medium）"></a>2020.3.4 （1 hard 1 medium）</h2><h3 id="第10题-正则表达式匹配"><a href="#第10题-正则表达式匹配" class="headerlink" title="第10题 正则表达式匹配"></a>第10题 正则表达式匹配</h3><p><img src="10.png" alt="第10题 正则表达式匹配"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>本题可以用递归求解，但时空复杂度很高。</p><p>考虑到本题符合动态规划的两个基本要求：（1）重叠子问题，（2）最优子结构。所以本题可以使用动态规划来求解。</p><p>解决可递归问题的三种方法：</p><ul><li>递归：自顶向下，代码简单，但是复杂度高，可能会进行重复的计算，同时会使用大量的栈空间。</li><li>备忘录：自顶向下，将递归中的子问题求解结果保存起来，防止重复计算，降低了时间复杂度，但栈空间的消耗依然存在。</li><li>动态规划：自底向上，使用状态矩阵，由子问题通过状态转移方程递推出最后的结果。</li></ul><p>本题中，可以使用状态矩阵$dp(i,j)$表示text[i:]和pattern[j:]是否能匹配。我们可以用更短的字符串匹配问题来表示原本的问题。</p><ul><li><p>当首字母匹配且第二个字母为”*”时，可以尝试转移到匹配0次（目标串不变，模式串变）或1次（目标串变，模式串不变，因为此时可以多次匹配）的状态矩阵。</p></li><li><p>当首字母不匹配且第二个字母为”*”时，转移到匹配0次（目标串不变，模式串变）的状态矩阵。</p></li><li><p>首字母匹配且第二个字母不为”*”时，转移到首字母匹配1次（目标串和模式串都变）的状态矩阵。</p></li><li><p>否则，当前状态为False，即无法匹配。</p></li><li><p>$dp(-1,-1)$说明此时模式串和目标串完成了全匹配，可以成功，默认为True。</p></li></ul><pre><code>class Solution(object):    def isMatch(self, text, pattern):        dp=[[False for x in range(len(pattern)+1)] for x in range(len(text)+1)]        dp[-1][-1]=True #两个字符串都为空必然匹配        for i in range(len(text),-1,-1): #为什么i从len(text))开始，而j从len(pattern)-1开始：字符串为空，正则表达式不为空，可能匹配成功（存在*），而正则表达式为空，字符串不为空，必然不可能匹配成功            for j in range(len(pattern)-1,-1,-1):                f_match=(i&lt;len(text))and(pattern[j] in [text[i],&#39;.&#39;]) #第一个对i的限制条件是为了防止后面访问text[i]时数组越界                if (j+1&lt;len(pattern))and(pattern[j+1]==&#39;*&#39;):                    if f_match:                        dp[i][j]=dp[i][j+2] or dp[i+1][j]                    else:                        dp[i][j]=dp[i][j+2]                else:                    if f_match:                        dp[i][j]=dp[i+1][j+1]        return dp[0][0]</code></pre><h3 id="第11题-盛最多水的容器"><a href="#第11题-盛最多水的容器" class="headerlink" title="第11题 盛最多水的容器"></a>第11题 盛最多水的容器</h3><p><img src="11.png" alt="第11题 盛最多水的容器"></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h4><p>双指针法（这种从两端向内收缩的双指针我叫做双侧指针，如第3题中滑动窗口的同一侧出发的指针我叫做快慢指针）。</p><p>由于容器的容积只与短板有关，我们可以使用两个指针从数组的两侧每一次向内收缩短板，计算当前的容积，直到两个指针相交。</p><p>为什么只收缩短板：如果收缩长板，那么移动后的板长要么小于移动前的短板长度，要么大于短板长度，前者会使容积变小，后者会使容积不变，所以我们只有移动短板才可能使容积变大。</p><ul><li><p>时间复杂度：$O(N)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><pre><code>class Solution:    def maxArea(self, height: List[int]) -&gt; int:        max_v=0        left=0        right=len(height)-1        while (left&lt;right):            v=min(height[left],height[right])*(right-left)            if v&gt;max_v:                max_v=v            if (height[left]&lt;height[right]):                left+=1            else:                right-=1        return max_v</code></pre><h2 id="2020-3-5-（4-medium）"><a href="#2020-3-5-（4-medium）" class="headerlink" title="2020.3.5 （4 medium）"></a>2020.3.5 （4 medium）</h2><h3 id="第12题-整数转罗马数字"><a href="#第12题-整数转罗马数字" class="headerlink" title="第12题 整数转罗马数字"></a>第12题 整数转罗马数字</h3><p><img src="12.png" alt="第12题 整数转罗马数字"></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路:"></a>思路:</h4><p>贪心算法，每次取当前能够匹配的最大罗马数字进行选择。类似于用最少的纸币凑出整数。</p><pre><code>class Solution:    def intToRoman(self, num: int) -&gt; str:        # 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中        # 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想        nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]        romans = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]        index = 0        res = &#39;&#39;        while index &lt; 13:            # 注意：这里是等于号，表示尽量使用大的&quot;面值&quot;            while num &gt;= nums[index]:                res += romans[index]                num -= nums[index]            index += 1        return res</code></pre><h3 id="第15题-三数之和"><a href="#第15题-三数之和" class="headerlink" title="第15题 三数之和"></a>第15题 三数之和</h3><p><img src="15.png" alt="第15题 三数之和"></p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路:"></a>思路:</h4><p>在一个有序数组中求解两个数之和，可以使用暴力遍历的方法，但时间复杂度很高。在这里，我们可以使用双侧指针法，先在数组两端各固定一个指针。当两数之和小于target时，左指针加1（由于是有序数组，会使和变大），当两数之和大于target时，右指针减1，等于target时，保存结果，并左右指针同时向内收缩。</p><p>那么，知道了两数之和问题的解决方案后，我们可以求解三数之和（本质上，任意n数之和都可以采取相同的方法）。我们先对数组进行排序，然后固定一个数，便可将问题转化为两数之和，接着对于该数之后的所有数进行两数之和的求解。求解完成后，我们可以接着固定下一个数，直到求出所有结果。</p><p>要注意的问题：</p><ul><li><p>结果的去重（求解两数之和时，相同的数字不应重复使用。同时，固定的数若等于上个数，则他的所有情况都被上个数的遍历所包含，也可以跳过）。</p></li><li><p>性能的提升（剪枝，当右指针的数小于0时或者固定的数大于0时，三数之和必定不等于0，因为此时三个数都大于0或者都小于0）</p></li><li><p>时间复杂度：$O(N^2)+O(NlogN)=O(N^2)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><pre><code>class Solution {    public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList();        Arrays.sort(nums); # 排序        int len = nums.length;        if(nums == null || len &lt; 3) return ans;        for (int i = 0; i &lt; len ; i++) {            if(nums[i] &gt; 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; // 去重            int L = i+1;            int R = len-1;            while(L &lt; R){                if (nums[R]&lt;0){                    break;                }                int sum = nums[i] + nums[L] + nums[R];                if(sum == 0){                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));                    while (L&lt;R &amp;&amp; nums[L] == nums[L+1]) L++; // 去重                    while (L&lt;R &amp;&amp; nums[R] == nums[R-1]) R--; // 去重                    L++;                    R--;                }                else if (sum &lt; 0){                    while (L&lt;R &amp;&amp; nums[L] == nums[L+1]){                        L++; // 去重;                    }                    L++;                }                else if (sum &gt; 0) {                    while (L&lt;R &amp;&amp; nums[R] == nums[R-1]){                        R--; // 去重                    } // 去重                    R--;                }            }        }                return ans;    }}</code></pre><h3 id="第16题-最接近的三数之和"><a href="#第16题-最接近的三数之和" class="headerlink" title="第16题 最接近的三数之和"></a>第16题 最接近的三数之和</h3><p><img src="16.png" alt="第16题 最接近的三数之和"></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路:"></a>思路:</h4><p>与第15题几乎没有区别，只是双指针收缩时，每次记录当前的三数之和，看与结果的差值是否为当前最小，最小则修改当前的最接近的三数之和。当差值为0时可以直接返回。</p><pre><code>class Solution:    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:        nums.sort()        closest=nums[0]+nums[1]+nums[2]        diff=abs(closest-target)        for i in range(len(nums)-2):            if i&gt;0 and nums[i]==nums[i-1]:                continue            L=i+1            R=len(nums)-1            while (L&lt;R):                summa=nums[i]+nums[L]+nums[R]                if abs(summa-target)&lt;diff:                    closest=summa                    diff=abs(closest-target)                if (summa&gt;target):                    R-=1                elif (summa&lt;target):                    L+=1                else:                    return summa        return closest</code></pre><h3 id="第18题-四数之和"><a href="#第18题-四数之和" class="headerlink" title="第18题 四数之和"></a>第18题 四数之和</h3><p><img src="18.png" alt="第18题 四数之和"></p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路:"></a>思路:</h4><p>任意n数之和都求解，都可以先固定一个数，转化为n-1数之和问题，逐步转化，直到最后变为求解二数之和。这里的四数之和也是类似的道理，其去重的思想与三数之和也是一样的。</p><pre><code>class Solution {    public static List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums,int target) {        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList();        Arrays.sort(nums); // 排序        int len = nums.length;        if(nums == null || len &lt; 4) return ans;        for (int i = 0; i &lt; len-3 ; i++) {//多固定了一个数，将问题转化为内部的三数之和            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; // 去重            for (int j =i+1;j&lt;len-2;j++){                if(j &gt; i+1 &amp;&amp; nums[j] == nums[j-1]) continue; // 去重                int L = j+1;                int R = len-1;                while(L &lt; R){                    int sum = nums[i] + nums[j]+nums[L] + nums[R];                    if(sum == target){                        ans.add(Arrays.asList(nums[i],nums[j],nums[L],nums[R]));                        while (L&lt;R &amp;&amp; nums[L] == nums[L+1]) L++; // 去重                        while (L&lt;R &amp;&amp; nums[R] == nums[R-1]) R--; // 去重                        L++;                        R--;                    }                    else if (sum &lt; target) L++;                    else if (sum &gt; target) R--;                }            }        }                return ans;    }}</code></pre><h2 id="2020-3-6-（2-medium）"><a href="#2020-3-6-（2-medium）" class="headerlink" title="2020.3.6 （2 medium）"></a>2020.3.6 （2 medium）</h2><h3 id="第17题-电话号码的字母组合"><a href="#第17题-电话号码的字母组合" class="headerlink" title="第17题 电话号码的字母组合"></a>第17题 电话号码的字母组合</h3><p><img src="17.png" alt="第17题 电话号码的字母组合"></p><h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1:"></a>思路1:</h4><p>打表+队列，类似于BFS。</p><pre><code>class Solution:    def letterCombinations(self, digits: str) -&gt; List[str]:        dic={&#39;2&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],&#39;3&#39;:[&#39;d&#39;,&#39;e&#39;,&#39;f&#39;],&#39;4&#39;:[&#39;g&#39;,&#39;h&#39;,&#39;i&#39;],&#39;5&#39;:[&#39;j&#39;,&#39;k&#39;,&#39;l&#39;],&#39;6&#39;:[&#39;m&#39;,&#39;n&#39;,&#39;o&#39;],&#39;7&#39;:[&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;],&#39;8&#39;:[&#39;t&#39;,&#39;u&#39;,&#39;v&#39;],&#39;9&#39;:[&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]}        result=[]        for char in digits:            if result==[]:                result=dic[char]            else:                l=len(result)                for i in range(l):                    st=result[0]                    result=result[1:]#出队                    for c in dic[char]:                        result.append(st+c)#入队        return result</code></pre><p>时间复杂度:$O(3^M+4^N)$</p><h4 id="思路2-1"><a href="#思路2-1" class="headerlink" title="思路2:"></a>思路2:</h4><p>这里也可以使用回溯+递归的方法，将其看作是一个类似于全排列的问题。</p><pre><code>class Solution:    def letterCombinations(self, digits):        &quot;&quot;&quot;        :type digits: str        :rtype: List[str]        &quot;&quot;&quot;        phone = {&#39;2&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],                 &#39;3&#39;: [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;],                 &#39;4&#39;: [&#39;g&#39;, &#39;h&#39;, &#39;i&#39;],                 &#39;5&#39;: [&#39;j&#39;, &#39;k&#39;, &#39;l&#39;],                 &#39;6&#39;: [&#39;m&#39;, &#39;n&#39;, &#39;o&#39;],                 &#39;7&#39;: [&#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;],                 &#39;8&#39;: [&#39;t&#39;, &#39;u&#39;, &#39;v&#39;],                 &#39;9&#39;: [&#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;]}        def backtrack(combination, next_digits):            # if there is no more digits to check            if len(next_digits) == 0:                # the combination is done                output.append(combination)            # if there are still digits to check            else:                # iterate over all letters which map                 # the next available digit                for letter in phone[next_digits[0]]:                    # append the current letter to the combination                    # and proceed to the next digits                    backtrack(combination + letter, next_digits[1:])//这里可以看作是进行了回溯，因为直接使用了新的字符串，所以不用恢复状态         output = []        if digits:            backtrack(&quot;&quot;, digits)        return output</code></pre><h3 id="第19题-删除链表的倒数第N个节点"><a href="#第19题-删除链表的倒数第N个节点" class="headerlink" title="第19题 删除链表的倒数第N个节点"></a>第19题 删除链表的倒数第N个节点</h3><p><img src="19.png" alt="第19题 删除链表的倒数第N个节点"></p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>快慢指针法+dummy head。</p><p>快指针在前遍历链表，慢指针在后用于保存快指针的前第N个节点。当快指针遍历到链表的尾部，则可以使用慢指针删除节点。这里需要注意，当要删除的节点是第一个节点时，若使用题目中给出的头指针，需要分类讨论进行操作。为了不进行分类讨论，我们在链表开头处添加一个空的头结点（dummy head）。</p><ul><li><p>时间复杂度:$O(N)$</p></li><li><p>空间复杂度:$O(1)$</p></li></ul><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:        fore_head=ListNode(0)        fore_head.next=head        p=fore_head        back_n=fore_head        while (p.next!=None):            p=p.next            if (n&gt;0):                n-=1            elif (n==0)://n减到0时，才能移动慢指针，否则说明前第n个元素越界                back_n=back_n.next        back_n.next=back_n.next.next        return fore_head.next</code></pre><h2 id="2020-3-7-（1-medium-1-hard）"><a href="#2020-3-7-（1-medium-1-hard）" class="headerlink" title="2020.3.7 （1 medium 1 hard）"></a>2020.3.7 （1 medium 1 hard）</h2><h3 id="第22题-括号生成"><a href="#第22题-括号生成" class="headerlink" title="第22题 括号生成"></a>第22题 括号生成</h3><p><img src="22.png" alt="第22题 括号生成"></p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路:"></a>思路:</h4><p>二叉树的先根遍历+剪枝。使用count记录当前字符串内左括号个数减去右括号个数的值，当count&lt;0或者count&gt;n，n为剩余的目标括号对数时，进行剪枝。</p><pre><code>class Solution:    def generateParenthesis(self, n: int) -&gt; List[str]:        count=0        st=&#39;&#39;        result=[]        def dp(count,n,st):            if (0&lt;=count&lt;=n):#剪枝                if (n==0):#满足要求                    result.append(st)                else:#先根遍历                    dp(count-1,n-1,st+&#39;)&#39;)                    dp(count+1,n,st+&#39;(&#39;)        dp(count,n,st)        return result</code></pre><h3 id="第23题-合并K个排序链表"><a href="#第23题-合并K个排序链表" class="headerlink" title="第23题 合并K个排序链表"></a>第23题 合并K个排序链表</h3><p><img src="23.png" alt="第23题 合并K个排序链表"></p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路:"></a>思路:</h4><p>分治法，类似于标准归并排序的思想。先将相邻的链表两两合并，得到个数为原来一半的新链表，接着继续两两合并，重复直到只剩下最后一个链表，即为最终的结果。</p><p>两两合并的方法，采用的是双指针法，即两个链表各设置一个指针，用于比较和插入结果链表。</p><ul><li>时间复杂度：$O(NlogK)$，N是所有链表中元素的总和，K是链表个数。</li></ul><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        def merge(list1,list2):#两两合并            p=list1            q=list2            head=ListNode(0)            m=head            while (p!=None) and (q!=None):                if p.val&lt;q.val:                    m.next=p                    m=m.next                    p=p.next                else:                    m.next=q                    m=m.next                    q=q.next            if (p==None):                m.next=q            elif (q==None):                m.next=p            return head.next        amount = len(lists)        interval = 1        while interval &lt; amount:#两两合并            for i in range(0, amount - interval, interval * 2):                lists[i] = merge(lists[i], lists[i + interval])            interval *= 2        return lists[0] if amount &gt; 0 else lists</code></pre><p>为什么不使用逐一合并的算法呢？那样合并的过程写起来会很简单？</p><ul><li><p>逐一合并的时间复杂度：$O(NK)$</p></li><li><p>因为这里的两两排序实际上运用了分治法的思想，逐一合并的话，每一次合并在最坏的情况下都需要比较N个节点，而两两合并，每一轮合并的最坏情况才需要比较N个节点。逐一合并需要进行（K-1）次，而两两合并仅需要进行（logN）轮，所以时间复杂度大大降低。</p></li></ul><p><img src="23-2.png" alt="分治法"></p><h2 id="2020-3-8-（1-hard-1-medium）"><a href="#2020-3-8-（1-hard-1-medium）" class="headerlink" title="2020.3.8 （1 hard 1 medium）"></a>2020.3.8 （1 hard 1 medium）</h2><h3 id="第24题-两两交换链表中的节点"><a href="#第24题-两两交换链表中的节点" class="headerlink" title="第24题 两两交换链表中的节点"></a>第24题 两两交换链表中的节点</h3><p><img src="24.png" alt="第24题 两两交换链表中的节点"></p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路:"></a>思路:</h4><p>本质上就是两个一组翻转链表。可以使用头插法+dummy head。使用三个指针pre、p、q，将q结点插入至p结点之前，即完成了一次交换。然后移动指针至下两个节点处，继续交换。</p><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def swapPairs(self, head: ListNode) -&gt; ListNode:        h=ListNode(0)#dummy head         h.next=head        pre=h        p=head        if (head==None):            return head        else:            q=p.next            while (p!=None)and(q!=None):                p.next=q.next                q.next=p                pre.next=q                #两个一组翻转链表                pre=p                p=p.next                if p!=None:                    q=p.next                #移动至下两个节点进行操作           return h.next</code></pre><h3 id="第25题-K-个一组翻转链表"><a href="#第25题-K-个一组翻转链表" class="headerlink" title="第25题  K 个一组翻转链表"></a>第25题  K 个一组翻转链表</h3><p><img src="25.png" alt="第25题  K 个一组翻转链表"></p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路:"></a>思路:</h4><p>上一题的扩展，使用dummy head+头插法即可。</p><ul><li>pre指针：当前组的第一个节点的前一个节点，用于插入元素。</li><li>q指针： 要插到头部的那个节点。</li><li>p指针： q节点的前一个节点，用于删除q节点。</li></ul><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode:        h=ListNode(0)        h.next=head        pre=h        p=head        count=0        t=pre.next        while(t!=None):#统计当前链表的长度            count+=1            t=t.next        if (head==None):            return head        else:            q=p.next            while (pre!=None) and (p!=None) and (q!=None):                if (count&lt;k):#当前链表的剩余长度是否可以进行翻转                    return h.next                for i in range(k-1):                    p.next=q.next                    q.next=pre.next                    pre.next=q                     q=p.next                      #当前组内的节点进行头插法翻转                pre=p                p=pre.next                if p==None:                    return h.next                q=p.next                count-=k                #指针移动至下一组开始处        return h.next</code></pre><h2 id="2020-3-9-（3-easy）"><a href="#2020-3-9-（3-easy）" class="headerlink" title="2020.3.9 （3 easy）"></a>2020.3.9 （3 easy）</h2><h3 id="第26题-删除排序数组中的重复项"><a href="#第26题-删除排序数组中的重复项" class="headerlink" title="第26题 删除排序数组中的重复项"></a>第26题 删除排序数组中的重复项</h3><p><img src="26.png" alt="第26题 删除排序数组中的重复项"></p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路:"></a>思路:</h4><p>快慢指针法，慢指针指向当前数组内无重复的子序列的最后一项，快指针用于遍历整个数组。</p><ul><li>当快指针指向的元素与慢指针指向的元素不相等时，将该元素加入至慢指针维护的无重复子序列中，慢指针和快指针都加1。</li><li>当元素相等时，快指针直接遍历下一个元素。</li><li>时间复杂度：$O(N)$</li></ul><pre><code>class Solution:    def removeDuplicates(self, nums: List[int]) -&gt; int:        slow=0        for fast in range(1,len(nums)):            if (nums[slow]!=nums[fast]):                slow+=1                nums[slow]=nums[fast]        return slow+1#由于慢指针指向的是子序列最后一项的下标，子序列长度需要加1</code></pre><h3 id="第27题-移除元素"><a href="#第27题-移除元素" class="headerlink" title="第27题 移除元素"></a>第27题 移除元素</h3><p><img src="27.png" alt="第27题 移除元素"></p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路:"></a>思路:</h4><p>同样使用快慢指针法，快指针用于遍历，慢指针维护一个没有target元素的子序列，指向该子序列末尾的后一个元素。</p><pre><code>class Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        slow=0        for fast in range(len(nums)):            if (nums[fast]!=val):                nums[slow]=nums[fast]                slow+=1        return slow</code></pre><p>这里，慢指针与26题有一些区别，27题的慢指针指向的是符合要求的子序列的后一项，而26题是最后一项。这是因为26题中，单个元素不可能重复，而27题中，单个元素也可能是需要被移除的。</p><h3 id="第28题-实现-strStr"><a href="#第28题-实现-strStr" class="headerlink" title="第28题 实现 strStr()"></a>第28题 实现 strStr()</h3><p><img src="27.png" alt="第28题 实现 strStr()"></p><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路:"></a>思路:</h4><p>KMP算法，具体可以看这里：<a href="/2020/03/17/kmp-suan-fa">KMP算法总结</a></p><h2 id="2020-3-10-（1-hard-1-medium）"><a href="#2020-3-10-（1-hard-1-medium）" class="headerlink" title="2020.3.10 （1 hard 1 medium）"></a>2020.3.10 （1 hard 1 medium）</h2><h3 id="第29题-两数相除"><a href="#第29题-两数相除" class="headerlink" title="第29题 两数相除"></a>第29题 两数相除</h3><p><img src="29.png" alt="第29题 两数相除"></p><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路:"></a>思路:</h4><p>我们最初很容易可以想到使用累减法来解决除法问题，但这会很慢，所以我们需要使用递归方法加速累减。</p><p>递归的具体过程是，在递归函数内部，我们在保证当前除数不大于被除数的情况下，使除数不断翻倍，并记录倍数。当除数即将大于当前被除数时，我们停止翻倍，并记录下当前的倍数，加到商上。此时，我们将除数减去当前的被除数，剩余的结果重复之前的过程，直到剩余的数小于原始的除数。</p><p>本质上，这题的思想类似于快速幂算法，都是使用翻倍来加速，利用二分思想优化至logN级别的时间复杂度。因为一个一个减肯定不如翻倍翻倍减快速。</p><p>特别的，这道题还需要考虑补码的机制问题，当被除数等于$-2^31$时，商最大只能等于$2^31-1$。</p><pre><code>class Solution:    def divide(self, dividend: int, divisor: int) -&gt; int:        if dividend==0:#防止除数为0            return 0        if divisor==1:#除数为1，直接返回结果，加速运算            return dividend        if divisor==-1:#除数为-1，直接返回结果的负数，加速运算            if dividend==-2**31:#考虑integer的溢出                return 2**31-1            else:                return -dividend        flag=-1        if ((dividend&gt;0) and (divisor&gt;0)) or ((dividend&lt;0) and (divisor&lt;0)):#考虑符号            flag=1        dividend=abs(dividend)        divisor=abs(divisor)        def div(result,a):#递归求解            if (a&lt;divisor):                return result            count=1            result+=count            b=divisor            a-=b            while (b+b)&lt;=a:#翻倍累减                count+=count                result+=count                b+=b                a-=b            return div(result,a)#尾递归，减少栈空间调用        return flag*(div(0,dividend))</code></pre><h3 id="第30题-串联所有单词的子串"><a href="#第30题-串联所有单词的子串" class="headerlink" title="第30题 串联所有单词的子串"></a>第30题 串联所有单词的子串</h3><p><img src="30.png" alt="第30题 串联所有单词的子串"></p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路:"></a>思路:</h4><p>滑动窗口法+哈希表。</p><p>由于题目中提到了所有单词等长，那么我们对于n个长度为k的单词可以维护一个长度为k*n的滑动窗口。接着，我们利用哈希表建立words列表中的单词和单词数目的映射。然后，我们可以使用滑动窗口进行滑动匹配，每次移动一个单词的长度。对于窗口内部，我们统计每k长度的字符串，若出现了不在哈希表的键中的字符串，或者字符串出现的次数大于哈希表中对应的值时，说明此窗口失配，进行下一次匹配，否则，记录下窗口起始位置。</p><pre><code>class Solution:    def findSubstring(self, s: str, words: List[str]) -&gt; List[int]:        dic={}        result=[]        if s==&quot;&quot; or words==[]:#目标串或者待匹配列表为空            return []        for w in words:#建哈希表（字典）            if w in dic.keys():                dic[w]+=1            else:                dic[w]=1        l=len(words[0])        window=l*len(words)        for i in range(len(s)-window+1):#滑动匹配            end=i+window            tmp=dic.copy()            flag=1            for j in range(i,end,l):                w=s[j:j+l]                if w not in tmp.keys():                    flag=0                    break                tmp[w]-=1                if tmp[w]&lt;0:                    flag=0                    break            if flag:                result.append(i)        return result</code></pre><h2 id="2020-3-11-（2-medium-1-hard）"><a href="#2020-3-11-（2-medium-1-hard）" class="headerlink" title="2020.3.11 （2 medium 1 hard）"></a>2020.3.11 （2 medium 1 hard）</h2><h3 id="第31题-下一个排列"><a href="#第31题-下一个排列" class="headerlink" title="第31题 下一个排列"></a>第31题 下一个排列</h3><p><img src="31.png" alt="第31题 下一个排列"></p><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路:"></a>思路:</h4><p>核心思想：</p><ul><li>我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。</li><li>我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：</li></ul><ol><li>在尽可能靠右的低位进行交换，需要从后向前查找</li><li>将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换</li><li>将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列</li></ol><pre><code>class Solution:    def nextPermutation(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        def swap(a,b):#交换数组中的两个元素            temp=nums[a]            nums[a]=nums[b]            nums[b]=temp        p=len(nums)-1        while (p&gt;0):            if (nums[p]&gt;nums[p-1]):从后向前遍历，找到从后向前看的第一个下降的位置                min_pos=p                for i in range(len(nums)-1,p,-1):#搜索最小的大数并交换                    if (nums[i]&gt;nums[p-1]):                        min_pos=i                        break                swap(min_pos,p-1)                for i in range(int((len(nums)-p)/2)):#原地翻转，将大数后所有数重置为升序                    swap(p+i,len(nums)-i-1)                break            else:                p-=1        if (p&lt;=0):#如果为降序数组，则重置为升序数组            nums.sort()        return nums</code></pre><p><strong>这类题一定要把情况自己模拟一遍，寻找下一个转移的规律。</strong></p><h3 id="第32题-最长有效括号"><a href="#第32题-最长有效括号" class="headerlink" title="第32题 最长有效括号"></a>第32题 最长有效括号</h3><p><img src="32.png" alt="第32题 最长有效括号"></p><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路:"></a>思路:</h4><p>双向滑动窗口。</p><p>使用双指针维护一个滑动窗口。先从左向右滑动窗口，左右指针初始为0，使用一个变量count来存储当前窗口内左括号数量减去右括号数量的值。右指针不断向前遍历，当遍历到当前窗口内count&lt;0时，将左右指针都移动到当前右指针的下一个位置，重置窗口，当count==0时，使用当前窗口长度比较并尝试更新最大长度，当count&gt;0时，右指针继续向前遍历。</p><p>上述滑动完成后，再反向从右往左滑动一次窗口。此时的结果即为最大长度。</p><pre><code>class Solution:    def longestValidParentheses(self, s: str) -&gt; int:        p=0        q=0        count=0        max_len=0        if (len(s)&lt;2):            return 0        while (q&lt;len(s)):            if (s[q]==&quot;(&quot;):                count+=1            elif (s[q]==&quot;)&quot;):                count-=1            if (count&lt;0):                q+=1                p=q                count=0            else:                if (count==0):                    if (q-p+1)&gt;max_len:                        max_len=q-p+1                q+=1        #从左向右滑动        p=len(s)-1        q=len(s)-1        count=0        while (p &gt;=0):            if (s[p] == &quot;(&quot;):                count += 1            elif (s[p] == &quot;)&quot;):                count -= 1            if (count &gt; 0):                p-= 1                q = p                count = 0            else:                if (count == 0):                    if (q - p + 1) &gt; max_len:                        max_len = q - p + 1                p-= 1        #从右向左滑动        return max_len</code></pre><h3 id="第33题-搜索旋转排序数组"><a href="#第33题-搜索旋转排序数组" class="headerlink" title="第33题 搜索旋转排序数组"></a>第33题 搜索旋转排序数组</h3><p><img src="33.png" alt="第33题 搜索旋转排序数组"></p><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路:"></a>思路:</h4><p>由于题目要求时间复杂度在logN级别，所以必须是用二分法进行查找。但我们知道二分查找只适用于有序数组，所以我们需要使用嵌套二分。</p><p>首先，我们将数组从中间一分为二，根据旋转排序数组的性质，必然至少有一半有序。我们先判断左半数组是否有序，若有序，判断目标是否在它的范围内，若在，则在左半数组中二分查找，而不在，则去右半数组中二分查找。否则，即为右半数组有序，若目标在范围内，则在右半数组中二分，否则去左半数组中二分。</p><pre><code>class Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left=0        right=len(nums)-1        while (left&lt;=right):            mid=(left+right)//2            if nums[mid]==target:#中间数为目标                return mid            if (nums[left]&lt;=nums[mid]):#左半数组有序                if (nums[left]&lt;=target&lt;=nums[mid]):#目标在左半数组中                    right=mid-1                else:                    left=mid+1            else:#右半数组有序                if (nums[mid]&lt;=target&lt;=nums[right]):#目标在右半数组中                    left=mid+1                else:                    right=mid-1        return -1</code></pre><h2 id="2020-3-12-（2-medium-1-hard）"><a href="#2020-3-12-（2-medium-1-hard）" class="headerlink" title="2020.3.12 （2 medium 1 hard）"></a>2020.3.12 （2 medium 1 hard）</h2><h3 id="第34题-在排序数组中查找元素的第一个和最后一个位置"><a href="#第34题-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="第34题 在排序数组中查找元素的第一个和最后一个位置"></a>第34题 在排序数组中查找元素的第一个和最后一个位置</h3><p><img src="41.png" alt="第34题 在排序数组中查找元素的第一个和最后一个位置"></p><h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路:"></a>思路:</h4><p>由于时间复杂度控制在logN级别，所以很明显需要使用二分查找。</p><p>我们以二分查找获取左边界为例进行说明。首先，我们使用的是常规二分查找的框架，即比较目标与当前区间的中位数。不过常规二分查找是当目标大于中位数时进入右区间查找，小于中位数时进入左区间查找，等于中位数时返回当前中位数的位置。不同的是，此时我们需要查找的是元素的第一个位置。所以，我们需要进行这样的修改：当中位数等于目标时，目标元素的起始位置很明显要么在中位数处，要么在中位数左侧区间，此时我们直接进入左区间查找即可，其余的做法和常规二分查找一样。你可能会疑惑万一第一个位置就是中位数怎么办。不用担心，当遍历完左区间后无法再次找到目标元素，此时会在左区间的末尾尝试进入右区间，又回到了我们原先的中位数处。</p><p>二分查找右边界的方法同理，只是将中位数等于目标时改为进入右区间查找即可。</p><p>注意，当得到左右边界后还要判定是否合法。</p><p>通过两次二分，我们可以在$O(logN)$的时间复杂度内完成查找。</p><pre><code>class Solution:    def searchRange(self, nums: List[int], target: int) -&gt; List[int]:        if nums==[]:            return [-1,-1]        def getLeftBound(nums,target):#查找左边界            left=0            right=len(nums)-1            while (left&lt;=right):                mid=(left+right)//2                if (nums[mid]&gt;=target):                    right=mid-1                else:                    left=mid+1            if (left&gt;=0) and (left&lt;len(nums)) and (nums[left]==target):#左边界合法                return left            return -1        def getRightBound(nums,target):#查找右边界            left=0            right=len(nums)-1            while (left&lt;=right):                mid=(left+right)//2                if (nums[mid]&lt;=target):                    left=mid+1                else:                    right=mid-1            if (right&gt;=0) and (right&lt;len(nums)) and (nums[right]==target):#右边界合法                return right            return -1        return [getLeftBound(nums,target),getRightBound(nums,target)]</code></pre><h3 id="第36题-有效的数独"><a href="#第36题-有效的数独" class="headerlink" title="第36题 有效的数独"></a>第36题 有效的数独</h3><p><img src="36.png" alt="第36题 有效的数独"></p><h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路:"></a>思路:</h4><p>使用三个二维数组，分别存放每一行、每一列、每一个子数独当前放置的值。依次遍历这81个格子，每次遍历时将非空格子中的数放入对应的行、列、子数独的列表中。若出现了重复，则说明当前数独无效。</p><ul><li>时间复杂度：$O(1)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code>class Solution:    def isValidSudoku(self, board: List[List[str]]) -&gt; bool:        cols=[[] for x in range(9)]        rows=[[] for x in range(9)]        sons=[[] for x in range(9)]        for i in range(9):            for j in range(9):                if board[i][j]!=&#39;.&#39;:                    if (board[i][j] in cols[j]) or (board[i][j] in rows[i]) or (board[i][j] in sons[(i//3)*3+j//3]):                        return False                    else:                        cols[j].append(board[i][j])                        rows[i].append(board[i][j])                        sons[(i//3)*3+j//3].append(board[i][j])        return True</code></pre><h3 id="第37题-解数独"><a href="#第37题-解数独" class="headerlink" title="第37题 解数独"></a>第37题 解数独</h3><p><img src="37.png" alt="第37题 解数独"></p><h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路:"></a>思路:</h4><p>递归+回溯。类似的问题还有走迷宫、皇后问题、全排列等，本质的思路都是去使用回溯算法递归的尝试每种可能的情况。</p><p>回溯算法模板如下：</p><blockquote><p>def backtrack(…):<br> if (符合结束条件):<br>      保存结果<br>  else:<br>      for 选择 in 选择列表：<br>          if 选择合法：<br>              进行选择<br>              backtrack(…)#递归进入下一个位置进行选择<br>              撤销选择</p></blockquote><p>本题中，我们对每一个格子进行遍历，如果当前格子非空，我们便在“1”到“9”中选择合法的数字填入当前格子，并进入下一个格子继续选择。如果一直到最后一个格子都可以成功填入数字，则说明解完了数独，可以返回真。如果当前格子无法填入任何数字，则需要回溯至上一层递归函数，去恢复数独的状态，并选择下一个数字尝试填入。</p><p>判定当前数独矩阵是否合法，参考第36题即可。</p><pre><code>class Solution:    def solveSudoku(self, board) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify board in-place instead.        &quot;&quot;&quot;        cols=[[] for x in range(9)]        rows=[[] for x in range(9)]        sons=[[] for x in range(9)]        def could_place(i,j,value):#是否可以在当前格子放置value数字            if (value in cols[j]) or (value in rows[i]) or (value in sons[(i//3)*3+j//3]):                return False            return True        def place(i,j,value):#放置数字            cols[j].append(value)            rows[i].append(value)            sons[(i//3)*3+j//3].append(value)            board[i][j]=value        def remove(i,j,value):#移除数字            cols[j].remove(value)            rows[i].remove(value)            sons[(i//3)*3+j//3].remove(value)            board[i][j]=&quot;.&quot;        def DFS(i,j):#回溯函数            if i&gt;8:#结束递归条件               return True            if board[i][j]==&quot;.&quot;:#当前格子是否为空                for value in range(1,10):#遍历选择                    value=str(value)                    if (could_place(i,j,value)):#如果选择合法                        place(i,j,value)#进行选择                        if (j==8):#判断是否走到行尾                            if not(DFS(i+1,0)):#如果当前可以递归找到解，那么直接返回真，不需要再继续选择，否则回溯继续选择。                                remove(i,j,value)                            else:                                return True                        else:                            if not(DFS(i,j+1)):                                remove(i,j,value)                            else:                                return True            else:                if (j==8):                    return DFS(i+1,0)                else:                    return DFS(i,j+1)            return False        for i in range(9):#统计已经存在的数            for j in range(9):                if board[i][j]!=&#39;.&#39;:                    if (board[i][j] in cols[j]) or (board[i][j] in rows[i]) or (board[i][j] in sons[(i//3)*3+j//3]):                        return                    else:                        cols[j].append(board[i][j])                        rows[i].append(board[i][j])                        sons[(i//3)*3+j//3].append(board[i][j])        DFS(0,0)</code></pre><h2 id="2020-3-13-（2-medium）"><a href="#2020-3-13-（2-medium）" class="headerlink" title="2020.3.13 （2 medium）"></a>2020.3.13 （2 medium）</h2><h3 id="第39题-组合总和"><a href="#第39题-组合总和" class="headerlink" title="第39题 组合总和"></a>第39题 组合总和</h3><p><img src="39.png" alt="第39题 组合总和"></p><h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路:"></a>思路:</h4><p>递归回溯算法+剪枝</p><p>递归组合分解，每次选择候选数组中的一个元素，用目标值减去它。</p><ul><li>若得到的结果大于0，说明还可以继续分解，将当前选择的元素加入至路径列表，并尝试继续分解。</li><li>如果当前结果等于0，说明分解成功，将当前选择的元素加入至路径列表，并将当前路径列表加入至结果列表。</li><li>如果当前结果小于0，说明无法再分解，特别地，当候选数组升序时，后面的元素很明显也无法分解，需要跳出循环。</li></ul><p><img src="39-1.png" alt="回溯法"><br>此外，有可能出现重复的结果，即虽然路径不同，但元素相同。考虑到这一问题，尝试进行剪枝：</p><ul><li>记录下当前选择的元素的下标，下一次选择元素从该下标开始。<br><img src="39-2.png" alt="剪枝"></li></ul><pre><code>class Solution:    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:        result=[]        candidates.sort()        def back(re,index,target):            for i in range(index,len(candidates)):#遍历选择                num=candidates[i]                target_now=target-num                if target_now&lt;0:                    break                re.append(num)#选择                if target_now==0:                    res=re[:]                    result.append(res)                else:                    back(re,i,target_now)                re.pop()#回溯恢复        back([],0,target)        return result</code></pre><h3 id="第40题-组合总和2"><a href="#第40题-组合总和2" class="headerlink" title="第40题 组合总和2"></a>第40题 组合总和2</h3><p><img src="40.png" alt="第40题 组合总和2"></p><h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路:"></a>思路:</h4><p>和上一题类似，依然使用剪枝+递归回溯的思路来做。</p><p>有两个区别，一个是候选数组可能会出现重复，我们采用三数之和问题里类似的剪枝思路进行去重。第二个区别是数字不能重复使用，所以递归进行下一次元素的选择时，要从当前元素下标的下一个开始。</p><p><img src="40-1.png" alt="剪枝过程"></p><pre><code>class Solution:    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:        result=[]        candidates.sort()        def back(re,index,target):            if (index&lt;len(candidates)):                for i in range(index,len(candidates)):                    if i!=index and (candidates[i]==candidates[i-1]):#去重                        continue                    target_now=target-candidates[i]                    if (target_now&lt;0):                        break                    re.append(candidates[i])                    if (target_now==0):                        result.append(re[:])                    else:                        back(re,i+1,target_now)#从下一元素开始遍历，防止数字重复使用                    re.pop()        back([],0,target)        return result</code></pre><h2 id="2020-3-14-（2-hard-1-medium）"><a href="#2020-3-14-（2-hard-1-medium）" class="headerlink" title="2020.3.14 （2 hard 1 medium）"></a>2020.3.14 （2 hard 1 medium）</h2><h3 id="第41题-缺失的第一个正数"><a href="#第41题-缺失的第一个正数" class="headerlink" title="第41题 缺失的第一个正数"></a>第41题 缺失的第一个正数</h3><p><img src="41.png" alt="第41题 缺失的第一个正数"></p><h4 id="思路-23"><a href="#思路-23" class="headerlink" title="思路:"></a>思路:</h4><p>我们很容易想到利用哈希表（即字典）进行统计，然后去寻找第一个缺失的正数。但是考虑到题目的要求为时间复杂度$O(N)$以及常数级别的空间复杂度，我们可以考虑将数组自身作为一个哈希表，对应的哈希函数为:</p><p>$$f(nums[i])=nums[i]-1$$</p><p>通过哈希函数，将可以进行映射的数组元素映射到对应位置上，然后依次遍历寻找第一个映射不正确的位置即可。</p><p>复杂度分析：</p><ul><li><p>时间复杂度：$O(N)$，这里$N$是数组的长度。<br>说明：while 循环不会每一次都把数组里面的所有元素都看一遍。如果有一些元素在这一次的循环中被交换到了它们应该在的位置，那么在后续的遍历中，由于它们已经在正确的位置上了，代码再执行到它们的时候，就会被跳过。最极端的一种情况是，在第 1 个位置经过这个 while 就把所有的元素都看了一遍，这个所有的元素都被放置在它们应该在的位置，那么 for 循环后面的部分的 while 的循环体都不会被执行。平均下来，每个数只需要看一次就可以了，while 循环体被执行很多次的情况不会每次都发生。这样的复杂度分析的方法叫做<strong>均摊复杂度分析</strong>。</p></li><li><p>空间复杂度：$O(1)$。</p></li></ul><pre><code>class Solution:    def firstMissingPositive(self, nums: List[int]) -&gt; int:        def swap(pos1,pos2):            nums[pos1],nums[pos2]=nums[pos2],nums[pos1]        size=len(nums)        for i in range(size):            while (0&lt;nums[i]&lt;=size)and (nums[i]!=nums[nums[i]-1]):#当当前位置的数字可以进行哈希映射，并且不在对应位置时，与对应位置的数字交换。如果重复了或者无法映射（不在范围内），则不映射。                swap(i,nums[i]-1)        for i in range(size):#寻找第一个不符合映射规则的位置            if nums[i]!=i+1:                return i+1        return size+1#都符合，那么就输出下一个正数</code></pre><p>注:为什么使用nums[i]!=nums[nums[i]-1]来判断而不是i!=nums[i]-1？</p><p>因为后者无法处理重复的数字。</p><h3 id="第42题-接雨水"><a href="#第42题-接雨水" class="headerlink" title="第42题 接雨水"></a>第42题 接雨水</h3><p><img src="42.png" alt="第42题 接雨水"></p><h4 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h4><p>双指针+左右各一次遍历。从左向右遍历时，保证左指针指向的是短板。右指针不断向前遍历，每次右指针遇到长板后，计算此时所形成的容器的容积，再将左指针移到右指针处，右指针继续向前遍历。直到右指针遍历到数组末尾。然后再用相同的方式反向搜索一遍即可。将所有容积相加即为答案。</p><ul><li><p>时间复杂度:两次遍历，$O(N)$。</p></li><li><p>空间复杂度：$O(1)$。</p></li></ul><pre><code>class Solution:    def trap(self, height: List[int]) -&gt; int:        left=0        right=left+1        water=0        while (right&lt;len(height)):#从左向右            if height[right]&gt;=height[left]:                width=right-left-1                tmp=0                for i in range(left+1,right):#减去被柱子占用的体积                    tmp-=height[i]                tmp+=width*height[left]                water+=tmp                left=right            right+=1        right=len(height)-1        left=right-1        while (left&gt;=0):#从右向左            if height[left]&gt;height[right]:                width=right-left-1                tmp=0                for i in range(left+1,right):                    tmp-=height[i]                tmp+=width*height[right]                water+=tmp                right=left            left-=1        return water</code></pre><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>实际上，这里并不需要两次遍历，因为从左向右和从右向左的遍历都会在最高的柱子处停下。所以我们可以同时从两侧开始逼近，每次让左右指针较小的那个移动。</p><p>同时，我们可以维护一个left_max和right_max，即左右指针当前遍历到的最高柱。利用它们可以计算当前格子的积水。</p><pre><code>class Solution:    def trap(self, height: List[int]) -&gt; int:        left_max=0        right_max=0        left=0        right=len(height)-1        water=0        while left&lt;=right:            if height[left]&lt;height[right]:#确保不会越过山顶                if (height[left]&gt;=left_max):                    left_max=height[left]                else:                    water+=left_max-height[left]#利用max变量求解当前格的积水                left+=1            else:                if (height[right]&gt;=right_max):                    right_max=height[right]                else:                    water+=right_max-height[right]                right-=1        return water</code></pre><p>数组必有一个 ”山顶“（若有多个高度相同山顶，任取一个即可）。</p><p>根据”木桶原理“，山顶左侧的元素的盛水量 ，由左侧最大值决定；山顶右侧元素的盛水量，由右侧最大值决定。</p><p>双指针法的两个指针最终会停在 “山顶” 处。</p><h3 id="第43题-字符串相乘"><a href="#第43题-字符串相乘" class="headerlink" title="第43题 字符串相乘"></a>第43题 字符串相乘</h3><p><img src="43.png" alt="第43题 字符串相乘"><br>大数乘法问题，采取模拟竖式计算的方式求解。使用两个数组来存放两个数字字符串，数组的低位存数字字符串的低位。将第1个数组的第i位与第2个数组的第j位相乘，放入结果数组的第i+j位上。计算完成后，遍历结果数组，将所有大于9的进行进位操作。再反向遍历去掉最末尾的0。最后反向拼接成字符串输出即可。</p><pre><code>class Solution:    def multiply(self, num1: str, num2: str) -&gt; str:        numLi1=[int(x) for x in num1[::-1]]        numLi2=[int(x) for x in num2[::-1]]        len1=len(numLi1)        len2=len(numLi2)        res=[0 for x in range(len1+len2)]        for i in range(len1):#模拟两个数字的每一位相乘            for j in range(len2):                res[i+j]+=numLi1[i]*numLi2[j]        for i in range(len1+len2):#进位操作            if res[i]&gt;9:                res[i+1]+=res[i]#10                res[i]%=10          for i in range(len(res)-1,0,-1):#去除结果开头的0            if res[i]==0 :                res.pop()            else:                break        res=[str(x) for x in res[::-1]]        return &quot;&quot;.join(res)</code></pre><ul><li>时间复杂度:$O(MN)$</li><li>空间复杂度:$O(M+N)$</li></ul><h2 id="2020-3-15-（2-hard）"><a href="#2020-3-15-（2-hard）" class="headerlink" title="2020.3.15 （2 hard）"></a>2020.3.15 （2 hard）</h2><h3 id="第44题-通配符匹配"><a href="#第44题-通配符匹配" class="headerlink" title="第44题 通配符匹配"></a>第44题 通配符匹配</h3><p><img src="44.png" alt="第44题 通配符匹配"></p><h4 id="思路-25"><a href="#思路-25" class="headerlink" title="思路:"></a>思路:</h4><p>类似于第十题，可以采用相同的动态规划方法处理，甚至比第十题简单一些。由子串的匹配转移到当前串的匹配，直到转移至目标串和模式串的匹配。</p><pre><code>class Solution:    def isMatch(self, s: str, p: str) -&gt; bool:        dp=[[False for x in range(len(p)+1)] for x in range(len(s)+1)]        dp[-1][-1]=True        for i in range(len(s),-1,-1):#动态规划            for j in range(len(p)-1,-1,-1):                if p[j]==&quot;*&quot;:                    if i&lt;len(s):                        dp[i][j]=dp[i+1][j] or dp[i][j+1]                    else:                        dp[i][j]=dp[i][j+1]                else:                    if i&lt;len(s) and(p[j]==&quot;?&quot; or p[j]==s[i]):                        dp[i][j]=dp[i+1][j+1]        return dp[0][0]</code></pre><ul><li>时间复杂度:$O(MN)$</li><li>空间复杂度:$O(MN)$</li></ul><h4 id="更好的思路："><a href="#更好的思路：" class="headerlink" title="更好的思路："></a>更好的思路：</h4><p>有一种更好的思路来进行匹配，降低了时空复杂度，使用的是回溯和贪心的思想。具体看这里:<a href="https://leetcode-cn.com/problems/wildcard-matching/solution/tong-pei-fu-pi-pei-by-leetcode/" target="_blank" rel="noopener">40题解</a></p><h3 id="第45题-跳跃游戏2"><a href="#第45题-跳跃游戏2" class="headerlink" title="第45题 跳跃游戏2"></a>第45题 跳跃游戏2</h3><p><img src="45.png" alt="第45题 跳跃游戏2"></p><h4 id="思路-26"><a href="#思路-26" class="headerlink" title="思路:"></a>思路:</h4><p>贪心思路。在当前可以跳到的下一跳候选位置中，选择继续跳跃能够到达最远位置的候选位置，贪心地进行跳跃。当即将跳到数组末尾或者超过数组末尾时，返回当前步数加1，否则继续跳跃。</p><pre><code>class Solution:    def jump(self, nums: List[int]) -&gt; int:        now=0#当前位置        count=0#步数        l=len(nums)-1#数组末尾位置        if l==0:            return count        while True:            if now+nums[now]&gt;=l:#即将到达末尾                return count+1            farthest=0            next=0            for i in range(now+1,now+nums[now]+1):#贪心地选择能够抵达更远地方的下一跳位置                farthest_now=i+nums[i]                if farthest_now&gt;farthest:                    farthest=farthest_now                    next=i            now=next            count+=1</code></pre><h2 id="2020-3-16-（4-medium）"><a href="#2020-3-16-（4-medium）" class="headerlink" title="2020.3.16 （4 medium）"></a>2020.3.16 （4 medium）</h2><h3 id="第46题-全排列"><a href="#第46题-全排列" class="headerlink" title="第46题 全排列"></a>第46题 全排列</h3><p><img src="46.png" alt="第46题 全排列"></p><h4 id="思路-27"><a href="#思路-27" class="headerlink" title="思路:"></a>思路:</h4><p>深度优先搜索+回溯。</p><p>为了防止重复遍历数字，使用一个已访问矩阵来存储数字是否已被访问。</p><pre><code>class Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        result=[]        visited=[False for x in nums]        def dfs(re):            if (len(re)==len(nums)):                result.append(re)            else:                for i in range(len(nums)):                    if (visited[i]==False):                        re.append(nums[i])                        visited[i]=True                        dfs(re[:])                        re.pop()                        visited[i]=False        dfs([])        return result</code></pre><p>需要注意的是，一般回溯法中将路径列表添加至结果时，需要添加一个深拷贝，而不能是引用。否则它将跟随回溯变化。</p><h3 id="第47题-全排列2"><a href="#第47题-全排列2" class="headerlink" title="第47题 全排列2"></a>第47题 全排列2</h3><p><img src="47.png" alt="第47题 全排列2"></p><h4 id="思路-28"><a href="#思路-28" class="headerlink" title="思路:"></a>思路:</h4><p>与上一题基础的全排列类似，我们依然使用的是DFS+backtrack算法，但是在这里我们需要进行剪枝处理，去重。</p><p>去重的思路是：先排序，对于多个未访问的连续的相同数字，我们每次只选择第一个进行深度优先搜索，防止重复的搜索。</p><pre><code>class Solution:    def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:        result=[]        visited=[False for x in nums]        nums.sort()        def dfs(re):            if (len(re)==len(nums)):                result.append(re)            else:                for i in range(len(nums)):                    if (i!=0 and nums[i]==nums[i-1] and visited[i-1]==False):#剪枝处理                        continue                    if (visited[i]==False):                        re.append(nums[i])                        visited[i]=True                        dfs(re[:])                        re.pop()                        visited[i]=False        dfs([])        return result</code></pre><h3 id="第48题-旋转图像"><a href="#第48题-旋转图像" class="headerlink" title="第48题 旋转图像"></a>第48题 旋转图像</h3><p><img src="48.png" alt="第48题 旋转图像"></p><h4 id="思路-29"><a href="#思路-29" class="headerlink" title="思路:"></a>思路:</h4><p>先对数组进行转置，再对其进行左右翻转。</p><p>需要进行原地修改。</p><pre><code>class Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify matrix in-place instead.        &quot;&quot;&quot;        for i in range(len(matrix)):            for j in range(i+1,len(matrix[0])):                tmp=matrix[i][j]                matrix[i][j]=matrix[j][i]                matrix[j][i]=tmp        for i in range(len(matrix)):            for j in range(len(matrix[0])//2):                tmp=matrix[i][j]                matrix[i][j]=matrix[i][len(matrix)-j-1]                matrix[i][len(matrix)-j-1]=tmp        return matrix</code></pre><h3 id="第49题-字母异位词分组"><a href="#第49题-字母异位词分组" class="headerlink" title="第49题 字母异位词分组"></a>第49题 字母异位词分组</h3><p><img src="49.png" alt="第49题 旋转图像"></p><h4 id="思路-30"><a href="#思路-30" class="headerlink" title="思路:"></a>思路:</h4><p>使用哈希表进行求解。将每个单词的字母按照字典序进行排序，作为哈希表的key，那么字母异位词必然会放入同一个key中。哈希表的value为对应key的字母异位词组成的列表。在最后输出values组成的列表即可。</p><pre><code>class Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        dic={}        for word in strs:            tmp=tuple(sorted(word))            if tmp not in dic.keys():                dic[tmp]=[word]            else:                dic[tmp].append(word)        return list(dic.values())</code></pre><p>实际上，还可以不用对单词进行排序，仅统计二十六个字母出现的次数，也能达到相同的效果，将时间复杂度由$O(NKlogK)$降为$O(NK)$</p><pre><code>class Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        dic={}        for word in strs:            tmp=[0 for x in range(26)]            for ch in word:                tmp[ord(ch)-ord(&#39;a&#39;)]+=1            tmp=tuple(tmp)            if tmp not in dic.keys():                dic[tmp]=[word]            else:                dic[tmp].append(word)        return list(dic.values())</code></pre><h2 id="2020-3-17-（1-medium-1-hard）"><a href="#2020-3-17-（1-medium-1-hard）" class="headerlink" title="2020.3.17 （1 medium 1 hard）"></a>2020.3.17 （1 medium 1 hard）</h2><h3 id="第50题-Pow（x-n）"><a href="#第50题-Pow（x-n）" class="headerlink" title="第50题 Pow（x,n）"></a>第50题 Pow（x,n）</h3><p><img src="50.png" alt="第50题 Pow（x,n）"></p><h4 id="思路-31"><a href="#思路-31" class="headerlink" title="思路:"></a>思路:</h4><p>快速幂算法，采用递归的思路，通过二分法进行加速，将时间复杂度从累乘法的$O(N)$减少到$O(logN)$。基本思想是将$X^n$用两个$X^/frac{n}{2}$表示，这里需要对n的奇偶性进行分类讨论，如果是奇数，无法被2整除的话，还需要再乘以一个x。不断向下二分递归求解，直到将问题转化为求解$X^1$和$X^0$，再层层回退求解结果。</p><p>具体思路有些类似于第29题两数相除，本质思想都是使用递归二分进行加速。</p><p>特别地，当n为负数时，可以将$X^n$转化为$/frac{1}{X}^{-n}$求解。</p><pre><code>class Solution:    def myPow(self, x: float, n: int) -&gt; float:        def fastpow(x,n):            if n==0:                return 1            if n&gt;0:                half=fastpow(x,n//2)                if n%2==0:                    return half*half                else:                    return x*half*half        if n&lt;0:            x=1/x            n=-n        return fastpow(x,n)</code></pre><p>特别地，需要注意Integer类型的补码机制问题，必要时可以采用long，不过python没有这个烦恼。</p><p>也可以使用非递归方式进行求解。</p><pre><code>class Solution:    def myPow(self, x: float, n: int) -&gt; float:        if n&lt;0:            x=1/x            n=-n        result=1        if n==0:            return 1.0        while (n&gt;0):            if n%2==0:                result*=2            else:                result=result*result*x            n//=2        return result</code></pre><h3 id="第51题-N皇后"><a href="#第51题-N皇后" class="headerlink" title="第51题 N皇后"></a>第51题 N皇后</h3><p><img src="51.png" alt="第51题 N皇后"></p><h4 id="思路-32"><a href="#思路-32" class="headerlink" title="思路:"></a>思路:</h4><p>和解数独和全排列等题目类似，依然是使用回溯算法进行递归求解。</p><p>在这个问题中，我们将棋盘看作是一个二维数组，按行进行递归，按列进行选择，每行选择一列放置皇后。如果每一行都能放置一个皇后，则可以将当前棋盘加入至结果数组。</p><p>特别地，我们需要判断当前位置是否可以放置一个皇后。由于皇后会攻击同行、同列、四个对角线上的棋子，所以我们需要保证当前行、当前列、当前四个对角线上没有别的皇后。前两个很好判断，对角线可以使用两个皇后的横坐标与纵坐标的差值绝对值是否相等来判断。</p><pre><code>class Solution:    def solveNQueens(self, n: int) -&gt; List[List[str]]:        def couldplace(chessboard,row,col):#是否可以放置            for i in range(row):                if chessboard[i]==col or abs(i-row)==abs(chessboard[i]-col):                    return False            return True        def trans(li):#将棋盘转化为输出格式            result=[]            for i in li:                result.append(&#39;.&#39;*(i)+&#39;Q&#39;+&#39;.&#39;*(n-i-1))            return result        result=[]        def back(chessboard,row):#递归回溯            if row&gt;=n:#当前行数若超过棋盘范围，则已放置完，可将当前棋盘加入结果数组                result.append(chessboard[:])            else:                for i in range(n):#进行选择                    if (couldplace(chessboard,row,i)):                        chessboard[row]=i                        back(chessboard,row+1)                        chessboard[row]=-1#回溯        chessboard=[-1 for i in range(n)]        back(chessboard,0)        for i in range(len(result)):            result[i]=trans(result[i])        return result</code></pre><p>这里，我使用了一种优化方法，每一次并没有存储真实的棋盘，而是开了一个二维数组，每个数组放置当前行的皇后位置。最后将其转化为输出格式即可。</p><h2 id="2020-3-18-（1-easy-2-medium）"><a href="#2020-3-18-（1-easy-2-medium）" class="headerlink" title="2020.3.18 （1 easy 2 medium）"></a>2020.3.18 （1 easy 2 medium）</h2><h3 id="第53题-最大子序和"><a href="#第53题-最大子序和" class="headerlink" title="第53题 最大子序和"></a>第53题 最大子序和</h3><p><img src="53.png" alt="第53题 最大子序和"></p><h4 id="思路-33"><a href="#思路-33" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划，状态矩阵dp[i]为以元素nums[i]结尾的子数组的最大连续和，转移方程为dp[i]=（1）nums[i]（if dp[i-1]&lt;=0） （2）dp[i-1]+nums[i]（if dp[i-1]&gt;0）。因为当前只有前面的连续子数组最大和为正数，才能对当前连续子数组最大和产生正贡献，否则只会使其变小。</p><p>特别地，为了节约空间，我们可以将nums列表原地修改为dp列表。</p><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code>class Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        max_sum=nums[0]        for i in range(1,len(nums)):            if nums[i-1]&gt;0:                nums[i]+=nums[i-1]            max_sum=max(nums[i],max_sum)#比较当前连续子数组和是否大于全局最大值        return max_sum</code></pre><h3 id="第54题-螺旋矩阵"><a href="#第54题-螺旋矩阵" class="headerlink" title="第54题 螺旋矩阵"></a>第54题 螺旋矩阵</h3><p><img src="54.png" alt="第54题 螺旋矩阵"></p><h4 id="思路-34"><a href="#思路-34" class="headerlink" title="思路:"></a>思路:</h4><p>按圈模拟指针的变化。这一类题目需要自己寻找一下指针变化的规律。</p><pre><code>class Solution:    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:        level=0#圈数        row=0        col=0        if matrix==[]:            return []        result=[matrix[row][col]]        count=1#步数        row_nums=len(matrix)        col_nums=len(matrix[0])        size=row_nums*col_nums        while count&lt;size:            for i in range(level+1,col_nums-level):                col+=1                result.append(matrix[row][col])                count+=1                if count&gt;=size:                    return result            for i in range(level+1,row_nums-level):                row+=1                result.append(matrix[row][col])                count+=1                if count&gt;=size:                    return result            for i in range(level+1,col_nums-level):                col-=1                result.append(matrix[row][col])                count+=1                if count&gt;=size:                    return result            for i in range(level+1,row_nums-level-1):                row-=1                result.append(matrix[row][col])                count+=1                if count&gt;=size:                    return result            #模拟顺时针的遍历，这里写的比较冗余，实际上可以使用列表+取余的方式简化增量的计算。            level+=1            col+=1            result.append(matrix[row][col])            count+=1        return result</code></pre><h3 id="第55题-跳跃游戏"><a href="#第55题-跳跃游戏" class="headerlink" title="第55题 跳跃游戏"></a>第55题 跳跃游戏</h3><p><img src="55.png" alt="第55题 跳跃游戏"></p><h4 id="思路-35"><a href="#思路-35" class="headerlink" title="思路:"></a>思路:</h4><p>我们基于这样的一个假设：如果能跳到位置i，那么位置i之前的所有位置0，1…i-1都能跳到。</p><p>那么问题已经迎刃而解了，我们遍历每一个位置，如果当前位置无法被跳到（大于当前所能到达的最远位置），则说明后面的所有位置都无法跳到，自然也就无法到达数组的末尾。如果当前位置可以跳到，将其所能到达的最远位置与当前最远位置比较，取最大值进行更新当前最远位置。</p><p>时间复杂度：$O(N)$</p><p>空间复杂度: $O(1)$</p><pre><code>class Solution:    def canJump(self, nums: List[int]) -&gt; bool:        farthest=0        for i in range(len(nums)):            if i&gt;farthest:                return False            farthest=max(farthest,i+nums[i])        return True</code></pre><p>也可以和跳跃游戏2一样采用贪心算法求解，不过时间复杂度会高一些。</p><h2 id="2020-3-19-（2-medium-1-hard）"><a href="#2020-3-19-（2-medium-1-hard）" class="headerlink" title="2020.3.19 （2 medium 1 hard）"></a>2020.3.19 （2 medium 1 hard）</h2><h3 id="第56题-合并区间"><a href="#第56题-合并区间" class="headerlink" title="第56题 合并区间"></a>第56题 合并区间</h3><p><img src="56.png" alt="第56题 合并区间"></p><h4 id="思路-36"><a href="#思路-36" class="headerlink" title="思路:"></a>思路:</h4><p>先按每个区间的左边界，为所有区间进行升序排序。接着，遍历每个区间，若当前区间的右边界大于或等于下一区间的左边界，那么说明二者有重复，可以进行合并。合并后，新区间的左边界为当前区间的左边界（升序排序），有边界为两个区间右边界的最大值（两种情况）。将下一区间原地修改为合并后的新区间，可以节约空间，并将当前区间置空。完成后，继续向前遍历。</p><p>最后，将所有空列表进行删除处理，返回最终的列表即可。</p><p>时间复杂度：$O(N)$</p><p>空间复杂度：$O(1)$</p><pre><code>class Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        if len(intervals)&gt;1:            intervals.sort()            for i in range(len(intervals)-1):                if intervals[i][1]&gt;=intervals[i+1][0]:                    intervals[i+1][0]=intervals[i][0]                    intervals[i+1][1]=max(intervals[i][1],intervals[i+1][1])                    intervals[i]=[]            for i in range(len(intervals)-1,-1,-1):                if intervals[i]==[]:                    intervals.remove([])        return intervals</code></pre><h3 id="第57题-插入区间"><a href="#第57题-插入区间" class="headerlink" title="第57题 插入区间"></a>第57题 插入区间</h3><p><img src="57.png" alt="第57题 插入区间"></p><h4 id="思路-37"><a href="#思路-37" class="headerlink" title="思路:"></a>思路:</h4><p>二分查找插入位置，插入新区间，然后采用上一题的思路进行合并。插入需要耗费$O(logN)$，合并需要耗费$O(N)$，总时间复杂度为$O(NlogN)$。</p><pre><code>class Solution:    def insert(self, intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:        def search(target):            left=0            right=len(intervals)-1            while (left&lt;=right):                mid=(left+right)//2                if (intervals[mid][0]==target):                    return mid                elif (intervals[mid][0]&gt;target):                    right=mid-1                else:                    left=mid+1            return left        insert_pos=search(newInterval[0])        intervals.insert(insert_pos,newInterval)        if len(intervals)&gt;1:            for i in range(len(intervals)-1):                if intervals[i][1]&gt;=intervals[i+1][0]:                    intervals[i+1][0]=intervals[i][0]                    intervals[i+1][1]=max(intervals[i][1],intervals[i+1][1])                    intervals[i]=[]            for i in range(len(intervals)-1,-1,-1):                if intervals[i]==[]:                    intervals.remove([])        return intervals</code></pre><p>还可以使用贪心算法，先将新区间插入至插入位置，并将其与前一个区间尝试合并。再向后遍历，尝试合并，直到无法进行合并。</p><h3 id="第60题-第k个排列"><a href="#第60题-第k个排列" class="headerlink" title="第60题 第k个排列"></a>第60题 第k个排列</h3><p><img src="60.png" alt="第60题 第k个排列"></p><h4 id="思路-38"><a href="#思路-38" class="headerlink" title="思路:"></a>思路:</h4><p>DFS算法，因为n！种排列本质是由n组n-1！排列组合而成，根据这一性质，我们可以得知当前的偏移值在哪一组n-1！中，从而计算得到当前位置上应填入的数字，接着取余数获取新的偏移值，不断递归，直到获取最终结果。</p><p>这里的DFS不需要进行回溯，因为每一位数字只有一个是符合条件的，不需要恢复状态去进行下一个选择。</p><pre><code>class Solution:    def getPermutation(self, n: int, k: int) -&gt; str:        def factorial(n):#求解n!            result=1            for i in range(2,n+1):                result*=i            return result        visited=[False for _ in range(n)]        def dfs(n,k,result):            if n==0:                return result            f=factorial(n-1)            base=k//f            offset=k%f            for i in range(len(visited)):                if visited[i]==False:                    if base&lt;=0:#第base个未访问过的严肃，即为当前位置上应该填入的数字                        result+=str(i+1)                        visited[i]=True                        return dfs(n-1,offset,result)                    else:                        base-=1        return dfs(n,k-1,&quot;&quot;)#这里数组从0开始，需要将k减1</code></pre><h2 id="2020-3-20-（4-medium）"><a href="#2020-3-20-（4-medium）" class="headerlink" title="2020.3.20 （4 medium）"></a>2020.3.20 （4 medium）</h2><h3 id="第61题-旋转链表"><a href="#第61题-旋转链表" class="headerlink" title="第61题 旋转链表"></a>第61题 旋转链表</h3><p><img src="61.png" alt="第61题 旋转链表"></p><h4 id="思路-39"><a href="#思路-39" class="headerlink" title="思路:"></a>思路:</h4><p>快慢指针法+头插法。</p><p>先统计链表的长度L，令K=K%L，放置进行重复的旋转。再使用快慢指针定位链表最后K个元素的起始位置和终止位置，并将这K个元素插入至链表头部即可。</p><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def rotateRight(self, head: ListNode, k: int) -&gt; ListNode:        dummyhead=ListNode(0)        dummyhead.next=head        fast=slow=dummyhead        l=0        p=dummyhead        if head!=None:            while (p.next!=None):                p=p.next                l+=1            k%=l            while (fast.next!=None):                if (k&gt;0):                    fast=fast.next                    k-=1                else:                    slow=slow.next                    fast=fast.next            fast.next=dummyhead.next            dummyhead.next=slow.next            slow.next=None        return dummyhead.next</code></pre><p>也可以将原先的链表修改成一个环，再从原倒数第K%L个元素处断开环，新得到的链表即为旋转后链表。</p><h3 id="第62题-不同路径"><a href="#第62题-不同路径" class="headerlink" title="第62题 不同路径"></a>第62题 不同路径</h3><p><img src="62.png" alt="第62题 不同路径"></p><h4 id="思路-40"><a href="#思路-40" class="headerlink" title="思路:"></a>思路:</h4><p>我的最初思路想当然地考虑到了DFS+回溯算法，这也是这一类走迷宫问题的常用算法。</p><p>但是，我很快观察到，这道题里有重叠的子问题，那么使用递归将非常缓慢。例如，从位置（0，1）和位置（1，0）都可以走到位置（1，1），如果我们使用递归，将重复从位置（1，1）向下搜索可行解两次，导致了不必要的时间消耗。</p><p>解决重叠子问题的方法就是动态规划。这道题里，我们的状态矩阵dp[i][j]为到达网格中（i，j）位置的路径数目，转移方程为：</p><ol><li>dp[i][j]=1,if i==0 and j==0;</li><li>dp[i][j]=dp[i-1][j],if i&gt;0 and j==0;</li><li>dp[i][j]=dp[i][j-1],if j&gt;0 and i==0;</li><li>dp[i][j]=dp[i-1][j]+dp[i][j-1],if i&gt;0 and j&gt;0.</li></ol><pre><code>class Solution:    def uniquePaths(self, m: int, n: int) -&gt; int:        dp=[[0 for _ in range(m)] for _ in range(n)]#状态矩阵        dp[0][0]=1        for i in range(n):#状态转移            for j in range(m):                if i&gt;0 and j==0:                    dp[i][j]=dp[i-1][j]                elif i==0 and j&gt;0:                    dp[i][j]=dp[i][j-1]                elif i&gt;0 and j==0:                    dp[i][j]=dp[i-1][j]                elif i&gt;0 and j&gt;0:                    dp[i][j]=dp[i][j-1]+dp[i-1][j]        return dp[n-1][m-1]</code></pre><h3 id="第63题-不同路径2"><a href="#第63题-不同路径2" class="headerlink" title="第63题 不同路径2"></a>第63题 不同路径2</h3><p><img src="63.png" alt="第63题 不同路径"></p><h4 id="思路-41"><a href="#思路-41" class="headerlink" title="思路:"></a>思路:</h4><p>思路与上一题基本一致，唯一的区别在于当状态矩阵转移到有障碍物的位置时，应将状态矩阵该位置修改为0.因为很明显该位置有了障碍物后不可达。</p><p>特别地，我们可以将题目提供的数组原地修改为状态矩阵，便可只适用常数级别的额外空间。</p><pre><code>class Solution:    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:        if obstacleGrid[0][0]==1:#初始位置有障碍物，并不可能到达终点            return 0        obstacleGrid[0][0]=1        for i in range(len(obstacleGrid)):            for j in range(len(obstacleGrid[0])):                if obstacleGrid[i][j]==1 and (i&gt;0 or j&gt;0):#将有障碍物的位值设为不可达                    obstacleGrid[i][j]=0                else:#状态转移                    if i&gt;0 and j==0:                        obstacleGrid[i][j]=obstacleGrid[i-1][j]                    elif i==0 and j&gt;0:                        obstacleGrid[i][j]=obstacleGrid[i][j-1]                    elif i&gt;0 and j&gt;0:                        obstacleGrid[i][j]=obstacleGrid[i][j-1]+obstacleGrid[i-1][j]        return obstacleGrid[-1][-1]</code></pre><h3 id="第64题-最小路径和"><a href="#第64题-最小路径和" class="headerlink" title="第64题 最小路径和"></a>第64题 最小路径和</h3><p><img src="64.png" alt="第64题 最小路径和"></p><h4 id="思路-42"><a href="#思路-42" class="headerlink" title="思路:"></a>思路:</h4><p>与62、63题思路基本一致，仍然是动态规划的思想。转移方程略有不同，核心是当前位置上的数字加上上方位置和左侧位置的路径和的最小值。</p><pre><code>class Solution:    def minPathSum(self, grid: List[List[int]]) -&gt; int:        for i in range(len(grid)):            for j in range(len(grid[0])):                if i&gt;0 and j==0:                    grid[i][j]+=grid[i-1][j]                elif i==0 and j&gt;0:                    grid[i][j]+=grid[i][j-1]                elif i&gt;0 and j&gt;0:                    grid[i][j]+=min(grid[i][j-1],grid[i-1][j])        return grid[-1][-1]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法整理汇总（附代码）</title>
      <link href="/2020/02/16/sort-algorithms/"/>
      <url>/2020/02/16/sort-algorithms/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。</p><p><strong>本文并不会详细讲解每种排序算法的原理</strong>，网上有很多很好的教程，大家可以自己去搜了看。</p><p>最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 <a href="https://leetcode-cn.com/problems/sort-an-array/" title="LeetCode 912. 排序数组" target="_blank" rel="noopener">LeetCode 912. 排序数组</a> 这道题。</p><h2 id="性质汇总"><a href="#性质汇总" class="headerlink" title="性质汇总"></a>性质汇总</h2><blockquote><p>如果发现表中有错误，请留言告知。</p></blockquote><table><thead><tr><th>算法</th><th>最好</th><th>最坏</th><th>平均</th><th>空间</th><th align="center">稳定性</th><th align="center">是否基于比较</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>插入排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>快速排序</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(n\log n)$</td><td>$O(\log n)$~$O(n)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>归并排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>希尔排序</td><td>$O(n^{1.3})$</td><td>$O(n^2)$</td><td>$O(n\log n)$~$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>基数排序</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>桶排序</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n+m)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>堆排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr></tbody></table><blockquote><p>如果表格显示有问题的话，还可以直接看下面的汇总图：</p></blockquote><p><img src="1.png" alt="十大经典排序算法性质汇总"></p><h3 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h3><p>我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。</p><p><strong>冒泡排序</strong><br><a href="https://en.wikipedia.org/wiki/Bubble_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bubble_sort</a></p><p><strong>选择排序</strong><br><a href="https://en.wikipedia.org/wiki/Selection_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Selection_sort</a></p><p><strong>插入排序</strong><br><a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Insertion_sort</a></p><p><strong>快速排序</strong><br><a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Quicksort</a></p><p><strong>归并排序</strong><br><a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Merge_sort</a></p><p><strong>希尔排序</strong><br><a href="https://en.wikipedia.org/wiki/Shellsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Shellsort</a></p><p><strong>计数排序</strong><br><a href="https://en.wikipedia.org/wiki/Counting_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Counting_sort</a></p><p><strong>基数排序</strong><br><a href="https://en.wikipedia.org/wiki/Radix_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Radix_sort</a></p><p><strong>桶排序</strong><br><a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bucket_sort</a></p><p><strong>堆排序</strong><br><a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heapsort</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>所有的排序算法接口都是相同的，也就是 <code>vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums)</code> 。只需要你传入一个 <code>vector&lt;int&gt;</code> 类型的数组，就能返回排序后的结果。</p><p>运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sortArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 冒泡排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> i<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 选择排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">selectSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    idx <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 插入排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">insertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 快速排序（24 ms）</span>    <span class="token keyword">void</span> <span class="token function">qSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序（192 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rnums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序 + 非递归（80 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSortNR</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> len <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> n<span class="token operator">-</span>len<span class="token punctuation">;</span> l <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span>len<span class="token number">-1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> l<span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>len<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token operator">-</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 希尔排序（40 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">shellSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j<span class="token operator">-</span>gap <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">-</span><span class="token operator">=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计数排序（32 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">countSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> maxv<span class="token operator">-</span>minv<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token operator">+</span>minv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 基数排序（不适用于负数）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">radixSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxv <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxv <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>            maxd<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rank</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxd <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> count<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rank<span class="token punctuation">[</span><span class="token operator">--</span>count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            maxd<span class="token operator">--</span><span class="token punctuation">;</span>            base <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 桶排序 (20 ms)</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> bs <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>maxv<span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">bucket</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bucket<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sz <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 堆排序（32 ms）</span>    <span class="token keyword">void</span> <span class="token function">adjust</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> c1 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c2 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>c2<span class="token operator">&lt;</span>s <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>c2<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> c2 <span class="token operator">:</span> c1<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
