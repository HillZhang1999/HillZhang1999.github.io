<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《程序员面试金典》题解</title>
      <link href="/2020/04/22/cheng-xu-yuan-mian-shi-jin-dian-ti-jie/"/>
      <url>/2020/04/22/cheng-xu-yuan-mian-shi-jin-dian-ti-jie/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上的题库《程序员面试金典》的刷题总结。</p><h2 id="数组与字符串"><a href="#数组与字符串" class="headerlink" title="数组与字符串"></a>数组与字符串</h2><h3 id="面试题-01-01-判定字符是否唯一"><a href="#面试题-01-01-判定字符是否唯一" class="headerlink" title="面试题 01.01. 判定字符是否唯一"></a><a href="https://leetcode-cn.com/problems/is-unique-lcci/" target="_blank" rel="noopener">面试题 01.01. 判定字符是否唯一</a></h3><p>简单做法：暴力法，两次循环。时间复杂度：$O(n^2)$，空间复杂度：$O(1)$。</p><p>使用额外数据结构的方法：哈希集合法，将出现过的字符放入一个set中。时间复杂度：$O(n)$，空间复杂度：$O(n)$。</p><p>不使用额外数据结构的方法：</p><ul><li>排序法。根据字符的ASCII码进行排序，然后判断两两字符是否有相等。时间复杂度：$O(nlogn)$，空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isUnique</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> astr<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        s<span class="token operator">=</span>sorted<span class="token punctuation">(</span>astr<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>位运算法。我们使用26个比特位来存放所有字符的访问情况。每次访问到一个字符，获取它的ASCII并减去97，就可以得知它是第几个字母。然后通过左移操作，获取该字符的位数，即x。n用于存放已访问过的字符情况，如果x和n与运算的结果不等于0，说明该字符所在比特位出现了重复，即可返回False。否则，更新n，继续遍历。时间复杂度：$O(n)$，空间复杂度：$O(1)$。（类似于OS中的<strong>位示图</strong>）</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isUnique</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> astr<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        n<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> astr<span class="token punctuation">:</span>            x<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>ord<span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">97</span>            <span class="token keyword">if</span> n<span class="token operator">&amp;</span>x<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            n<span class="token operator">|</span><span class="token operator">=</span>x        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-01-02-判定是否互为字符重排"><a href="#面试题-01-02-判定是否互为字符重排" class="headerlink" title="面试题 01.02. 判定是否互为字符重排"></a><a href="https://leetcode-cn.com/problems/check-permutation-lcci/" target="_blank" rel="noopener">面试题 01.02. 判定是否互为字符重排</a></h3><p>简单方法：ASCII码排序，将两个字符串进行sorted操作，再看是否相等即可。时间复杂度：$O(nlogn)$，空间复杂度：$O(1)$。</p><p>还可以使用哈希表，存放字符串内的字符和出现字符串，进行比较。时间复杂度：$O(n)$，空间复杂度：$O(n)$。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">CheckPermutation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s1<span class="token punctuation">:</span> str<span class="token punctuation">,</span> s2<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dic1<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        dic2<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> s1<span class="token punctuation">:</span>            dic1<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">=</span> dic1<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">if</span> ch <span class="token keyword">in</span> dic1<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">1</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> s2<span class="token punctuation">:</span>            dic2<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">=</span> dic2<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">if</span> ch <span class="token keyword">in</span> dic2<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">1</span>        <span class="token keyword">return</span> dic1<span class="token operator">==</span>dic2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-01-03-URL化"><a href="#面试题-01-03-URL化" class="headerlink" title="面试题 01.03. URL化"></a><a href="https://leetcode-cn.com/problems/string-to-url-lcci/" target="_blank" rel="noopener">面试题 01.03. URL化</a></h3><p>简单方法：可以调用python的库，但很明显不是题目想要我们做的。</p><p>我们可以倒序遍历，对S进行替换。使用双指针i和j，i用于遍历原字符串的真实长度，j用于控制新字符串的生成。具体代码如下所示：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">replaceSpaces</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> S<span class="token punctuation">:</span> str<span class="token punctuation">,</span> length<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        i<span class="token operator">=</span>length<span class="token number">-1</span>        j<span class="token operator">=</span>len<span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        S<span class="token operator">=</span>list<span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#Python要先替换为字符列表，才能按位修改</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">" "</span><span class="token punctuation">:</span>                S<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>S<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>S<span class="token punctuation">[</span>j<span class="token number">-2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"0"</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"%"</span>                j<span class="token operator">-=</span><span class="token number">3</span>                i<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                S<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>S<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                j<span class="token operator">-=</span><span class="token number">1</span>                i<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>S<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么要倒序？防止正序遍历替换空格时可能将尚未遍历的字符替换掉。</p><p>这题貌似有点问题，不知道为什么替换后的字符串无法正好填满字符数组，所以要用j指针的最后位置来返回。</p><ul><li>时间复杂度：$O(n)$</li></ul><h3 id="面试题-01-04-回文排列"><a href="#面试题-01-04-回文排列" class="headerlink" title="面试题 01.04. 回文排列"></a><a href="https://leetcode-cn.com/problems/palindrome-permutation-lcci/" target="_blank" rel="noopener">面试题 01.04. 回文排列</a></h3><p>回文排列的条件是：仅有1个或0个字符出现的次数为奇数次，其余都是偶数次，这样才能实现两两匹配。</p><p>所以，我们可以使用哈希表统计一下字符串内字符出现的次数，看是否符合上述条件即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canPermutePalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>            dic<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">=</span>dic<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">if</span> ch <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">1</span>        count<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> key <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                count<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> count<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-01-05-一次编辑"><a href="#面试题-01-05-一次编辑" class="headerlink" title="面试题 01.05. 一次编辑"></a><a href="https://leetcode-cn.com/problems/one-away-lcci/" target="_blank" rel="noopener">面试题 01.05. 一次编辑</a></h3><p>这道题是一道经典的动态规划题目，叫做编辑距离，在我的LeetCode笔记中有详细的介绍。我们可以通过动态规划转移的方法，计算出从first到second最少需要转移的次数，看其是否小于等于1即可。</p><ul><li>时间复杂度：$O(MN)$。</li><li>空间复杂度：$O(MN)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">oneEditAway</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> first<span class="token punctuation">:</span> str<span class="token punctuation">,</span> second<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>j                <span class="token keyword">elif</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> first<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span>second<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，这道题不需要求解具体的最小编辑次数，所以我们可以使用更为简单的解法。</p><p>我们保证first字符串的长度大于等于second字符串。然后将二者的字符两两比较，如果在位置 i 处出现了不相等的字符，那么：</p><ul><li>如果二者长度相等，就比较first[i+1:]和second[i+1:]（假设当前为替换操作，如果二者后面的字符串相等，则可以仅编辑一次），如 leetcode 与 leetkode。 </li><li>如果二者长度不等，就比较first[i+1:]和second[i:]（假设当前为删除操作），如 leetcode 与 leetode。 </li></ul><p>如果上述比较没有返回结果，说明second是first的子串，此时我们只需要比较二者的长度差是否小于等于1，即可知道编辑距离是否小于等于1。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">oneEditAway</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> first<span class="token punctuation">:</span> str<span class="token punctuation">,</span> second<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">:</span>            first<span class="token punctuation">,</span>second<span class="token operator">=</span>second<span class="token punctuation">,</span>first        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> first<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>second<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> len<span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token operator">==</span>len<span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> first<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">==</span>second<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> first<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">==</span>second<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token operator">-</span>len<span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-01-06-字符串压缩"><a href="#面试题-01-06-字符串压缩" class="headerlink" title="面试题 01.06. 字符串压缩"></a><a href="https://leetcode-cn.com/problems/compress-string-lcci/" target="_blank" rel="noopener">面试题 01.06. 字符串压缩</a></h3><p>我的做法是采用双指针法，r指针用于遍历原字符串，l用于确定重复字符区间的开头。每次遍历到不在当前重复字符区间内的字符，就将当前重复区间进行压缩，并移动 l 指针至当前字符。</p><ul><li>时间复杂度：$O(n)$.</li><li>空间复杂度：$O(n)$.</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">compressString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> S<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">if</span> S<span class="token operator">==</span><span class="token string">""</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> S        l<span class="token operator">=</span><span class="token number">0</span>        r<span class="token operator">=</span><span class="token number">0</span>        res<span class="token operator">=</span><span class="token string">""</span>        <span class="token keyword">while</span> r<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> S<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">!=</span>S<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">:</span>                res<span class="token operator">+=</span>S<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+</span>str<span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span>                l<span class="token operator">=</span>r            <span class="token keyword">else</span><span class="token punctuation">:</span>                r<span class="token operator">+=</span><span class="token number">1</span>        res<span class="token operator">+=</span>S<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+</span>str<span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span>        <span class="token keyword">return</span> res <span class="token keyword">if</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token keyword">else</span> S<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-01-07-旋转矩阵"><a href="#面试题-01-07-旋转矩阵" class="headerlink" title="面试题 01.07. 旋转矩阵"></a><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/" target="_blank" rel="noopener">面试题 01.07. 旋转矩阵</a></h3><p>这题是矩阵操作的经典题目，主站也有。需要一定的数学知识。基本思路是：先对当前矩阵求转置，接着求左右翻转即可。</p><ul><li>时间复杂度：$O(n^2)$.</li><li>空间复杂度：$O(1)$.</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify matrix in-place instead.        """</span>        rowLen<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span>        colLen<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>rowLen<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>colLen<span class="token punctuation">)</span><span class="token punctuation">:</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>rowLen<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>colLen<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>colLen<span class="token operator">-</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">=</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>colLen<span class="token operator">-</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-01-08-零矩阵"><a href="#面试题-01-08-零矩阵" class="headerlink" title="面试题 01.08. 零矩阵"></a><a href="https://leetcode-cn.com/problems/zero-matrix-lcci/" target="_blank" rel="noopener">面试题 01.08. 零矩阵</a></h3><p>这道题我们可以使用两个集合标记一下需要被清零的行和列，进行两次遍历即可。</p><ul><li>时间复杂度：$O(n^2)$.</li><li>空间复杂度：$O(n)$.</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">setZeroes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify matrix in-place instead.        """</span>        row<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        col<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    row<span class="token punctuation">.</span>add<span class="token punctuation">(</span>i<span class="token punctuation">)</span>                    col<span class="token punctuation">.</span>add<span class="token punctuation">(</span>j<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i <span class="token keyword">in</span> row <span class="token operator">or</span> j <span class="token keyword">in</span> col<span class="token punctuation">:</span>                    matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-01-09-字符串轮转"><a href="#面试题-01-09-字符串轮转" class="headerlink" title="面试题 01.09. 字符串轮转"></a><a href="https://leetcode-cn.com/problems/string-rotation-lcci/" target="_blank" rel="noopener">面试题 01.09. 字符串轮转</a></h3><p>这道题的思路，我们可以借鉴主站中的字符串轮转题目。我们可以采用数组实现队列的方式，当需要进行轮转时，将指针重新转移到字符串的开头即可。</p><p>所以，我们对s1进行重复地拼接，如果s2在拼接后的s1中，且s2与s1的原长相等，则说明s2可以由s1轮转而来。</p><p>例如：</p><p>s1“waterbottle”重复拼接后得到“wat<strong>erbottlewat</strong>erbottle”，而s2“erbottlewat”在其中，且二者原长相等。则可以返回True。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isFlipedString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s1<span class="token punctuation">:</span> str<span class="token punctuation">,</span> s2<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> s1<span class="token operator">==</span><span class="token string">""</span> <span class="token operator">and</span> s2<span class="token operator">==</span><span class="token string">""</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">if</span> s1<span class="token operator">==</span><span class="token string">""</span> <span class="token operator">or</span> s2<span class="token operator">==</span><span class="token string">""</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        tmp<span class="token operator">=</span>len<span class="token punctuation">(</span>s1<span class="token punctuation">)</span>        s1<span class="token operator">+=</span>s1        <span class="token keyword">return</span> s2 <span class="token keyword">in</span> s1 <span class="token operator">and</span> len<span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token operator">==</span>tmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="面试题-02-01-移除重复节点"><a href="#面试题-02-01-移除重复节点" class="headerlink" title="面试题 02.01. 移除重复节点"></a><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/" target="_blank" rel="noopener">面试题 02.01. 移除重复节点</a></h3><p>我的做法是采用哈希集合来存放已出现过的节点值，然后使用指针遍历链表。对值已经出现过的链表进行删除处理。</p><p>因为链表中删除节点需要使用的是前一个节点，所以我们通过判断当前节点的下一节点是否重复，来进行删除。如果重复，那么就删除，并且再次判断新的next节点；如果不重复，那么就移动指针继续向后遍历。</p><ul><li>时间复杂度：$O(n)$.</li><li>空间复杂度：$O(n)$.</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeDuplicateNodes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head<span class="token operator">!=</span>None<span class="token punctuation">:</span>            hs<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>            hs<span class="token punctuation">.</span>add<span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            p<span class="token operator">=</span>head            <span class="token keyword">while</span> p<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span>                <span class="token keyword">if</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">not</span> <span class="token keyword">in</span> hs<span class="token punctuation">:</span>                    hs<span class="token punctuation">.</span>add<span class="token punctuation">(</span>p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                    p<span class="token operator">=</span>p<span class="token punctuation">.</span>next                <span class="token keyword">else</span><span class="token punctuation">:</span>                    p<span class="token punctuation">.</span>next<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-02-02-返回倒数第-k-个节点"><a href="#面试题-02-02-返回倒数第-k-个节点" class="headerlink" title="面试题 02.02. 返回倒数第 k 个节点"></a><a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/" target="_blank" rel="noopener">面试题 02.02. 返回倒数第 k 个节点</a></h3><p>双指针法。通过一个间隔为k的快慢指针进行返回。当快指针遍历到链表尾部时，返回此时慢指针的节点值即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">kthToLast</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        slow<span class="token operator">=</span>head        fast<span class="token operator">=</span>head        count<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> fast<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">if</span> count<span class="token operator">==</span>k<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当快指针走出k步后，慢指针开始行动</span>                slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next                fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next            <span class="token keyword">elif</span> count<span class="token operator">&lt;</span>k<span class="token punctuation">:</span>                fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next                count<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> slow<span class="token punctuation">.</span>val<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-02-03-删除中间节点"><a href="#面试题-02-03-删除中间节点" class="headerlink" title="面试题 02.03. 删除中间节点"></a><a href="https://leetcode-cn.com/problems/delete-middle-node-lcci/" target="_blank" rel="noopener">面试题 02.03. 删除中间节点</a></h3><p>主站原题，这道题比较有意思，无法通过修改前一个节点的next指针来删除当前节点。所以我们需要将当前节点与下一个节点进行交换，将删除当前节点转变为删除下一个节点。即可通过修改当前节点的next指针进行删除。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type node: ListNode        :rtype: void Do not return anything, modify node in-place instead.        """</span>        node<span class="token punctuation">.</span>val<span class="token operator">=</span>node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val        node<span class="token punctuation">.</span>next<span class="token operator">=</span>node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但其实我觉得题目出得不好，这样并没有真正删除节点，只是删除了值。</p><h3 id="面试题-02-04-分割链表"><a href="#面试题-02-04-分割链表" class="headerlink" title="面试题 02.04. 分割链表"></a><a href="https://leetcode-cn.com/problems/partition-list-lcci/" target="_blank" rel="noopener">面试题 02.04. 分割链表</a></h3><p>这道题出题人的语文没学好，讲的很混乱。但是基本意思就是给定一个值，让链表中小于这个值的数字都位于大于等于这个值的数字之前。</p><p>我们使用头插法进行操作，当遍历到的值小于x时，将其插入到链表头部即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        p<span class="token operator">=</span>head        <span class="token keyword">while</span> p<span class="token operator">!=</span>None <span class="token operator">and</span> p<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>x<span class="token punctuation">:</span>                tmp<span class="token operator">=</span>p<span class="token punctuation">.</span>next                p<span class="token punctuation">.</span>next<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next                tmp<span class="token punctuation">.</span>next<span class="token operator">=</span>head                head<span class="token operator">=</span>tmp            <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#与之前2.1的删除节点方法类似，删除节点后不能移动指针p，因为无法保证删除后的下一节点没问题。</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-02-05-链表求和"><a href="#面试题-02-05-链表求和" class="headerlink" title="面试题 02.05. 链表求和"></a><a href="https://leetcode-cn.com/problems/sum-lists-lcci/" target="_blank" rel="noopener">面试题 02.05. 链表求和</a></h3><p>大数加法的链表形式。一次遍历用于相加，一次遍历用于进位。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> l2<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        n<span class="token operator">=</span><span class="token number">0</span>        p<span class="token operator">=</span>l1        q<span class="token operator">=</span>l2        dummyhead<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        r<span class="token operator">=</span>dummyhead        <span class="token keyword">while</span> p<span class="token operator">!=</span>None <span class="token operator">and</span> q<span class="token operator">!=</span>None<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#按位相加</span>            now<span class="token operator">=</span>p<span class="token punctuation">.</span>val<span class="token operator">+</span>q<span class="token punctuation">.</span>val<span class="token operator">+</span>n            node<span class="token operator">=</span>ListNode<span class="token punctuation">(</span>now<span class="token punctuation">)</span>            r<span class="token punctuation">.</span>next<span class="token operator">=</span>node            p<span class="token punctuation">,</span>q<span class="token punctuation">,</span>r<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">,</span>q<span class="token punctuation">.</span>next<span class="token punctuation">,</span>r<span class="token punctuation">.</span>next        <span class="token keyword">if</span> p<span class="token operator">==</span>None <span class="token operator">and</span> q<span class="token operator">!=</span>None<span class="token punctuation">:</span>            r<span class="token punctuation">.</span>next<span class="token operator">=</span>q        <span class="token keyword">if</span> q<span class="token operator">==</span>None <span class="token operator">and</span> p<span class="token operator">!=</span>None<span class="token punctuation">:</span>            r<span class="token punctuation">.</span>next<span class="token operator">=</span>p        r<span class="token operator">=</span>dummyhead        <span class="token keyword">while</span> r<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#进位</span>            now<span class="token operator">=</span>r<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token operator">+</span>n            n<span class="token operator">=</span>now<span class="token operator">//</span><span class="token number">10</span>            r<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token operator">=</span>now<span class="token operator">%</span><span class="token number">10</span>            r<span class="token operator">=</span>r<span class="token punctuation">.</span>next        <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>           r<span class="token punctuation">.</span>next<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-02-06-回文链表"><a href="#面试题-02-06-回文链表" class="headerlink" title="面试题 02.06. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/" target="_blank" rel="noopener">面试题 02.06. 回文链表</a></h3><p>主站原题。最简单的方法是遍历一次后将链表中的数据存入数组中，再判断是否为回文数组，但那样需要使用额外的空间。</p><p>如果不想使用额外空间，可以用如下的方法：</p><ol><li>快慢指针法找到链表的中间点。</li><li>翻转后一半链表。</li><li>双指针法，从两头开始向内遍历，比较是否完全相等。</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> head<span class="token operator">==</span>None <span class="token operator">or</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        p<span class="token operator">=</span>head        q<span class="token operator">=</span>head<span class="token punctuation">.</span>next        <span class="token keyword">while</span> q<span class="token operator">!=</span>None <span class="token operator">and</span> q<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#寻找链表中点</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next            q<span class="token operator">=</span>q<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        q<span class="token operator">=</span>p<span class="token punctuation">.</span>next        p<span class="token operator">=</span>None        <span class="token keyword">while</span> q<span class="token operator">!=</span>None<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#翻转后半链表</span>            tmp<span class="token operator">=</span>q<span class="token punctuation">.</span>next            q<span class="token punctuation">.</span>next<span class="token operator">=</span>p            p<span class="token punctuation">,</span>q<span class="token operator">=</span>q<span class="token punctuation">,</span>tmp        q<span class="token operator">=</span>head        <span class="token keyword">while</span> p<span class="token operator">!=</span>None<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#双指针比较</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>val<span class="token operator">!=</span>q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            p<span class="token punctuation">,</span>q<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">,</span>q<span class="token punctuation">.</span>next        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/" target="_blank" rel="noopener">面试题 02.07. 链表相交</a></h3><p>剑指Offer的原题，如下图所示：我们只需要让两个指针p、q各自从A、B出发，走到C点后，p转移至B，q转移至A，这样，两个指针在o点处走的路程分别为：AO+OC+BO和BO+OC+AO。所以，假设存在交点，二者必然在O点相交。如果不存在交点，二者将同时走到尽头。</p><p><img src="2-7.png" alt> </p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> headA<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> headB<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> headA<span class="token operator">==</span>None <span class="token operator">or</span> headB<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        p<span class="token operator">=</span>headA        q<span class="token operator">=</span>headB        <span class="token keyword">while</span> p<span class="token operator">!=</span>q<span class="token punctuation">:</span>            p<span class="token punctuation">,</span>q<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">,</span>q<span class="token punctuation">.</span>next            <span class="token keyword">if</span> p<span class="token operator">==</span>None <span class="token operator">and</span> q<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> None            <span class="token keyword">if</span> p<span class="token operator">==</span>None<span class="token punctuation">:</span>                p<span class="token operator">=</span>headB            <span class="token keyword">if</span> q<span class="token operator">==</span>None<span class="token punctuation">:</span>                q<span class="token operator">=</span>headA        <span class="token keyword">return</span> p<span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-02-08-环路检测"><a href="#面试题-02-08-环路检测" class="headerlink" title="面试题 02.08. 环路检测"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-lcci/" target="_blank" rel="noopener">面试题 02.08. 环路检测</a></h3><p>剑指Offer原题，之前已经细致地推导过了。我们只需要让一对快慢指针同时出发，快指针每次走两步，慢指针每次走一步。二者最终必然在环路中相遇。此时，慢指针走过的路程为s，快指针的路程为f，则f=2s且f=s+nb，b为环路的长度，nb表示快指针比慢指针多走了n圈环路。所以，s=nb。</p><p>此时，我们将快指针移回链表头部，和慢指针同步移动。最终，二者必然在环路入口处相遇。因为a+nb与a必然相遇。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        p<span class="token operator">=</span>head        q<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> q<span class="token operator">==</span>None <span class="token operator">or</span> q<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> None            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next            q<span class="token operator">=</span>q<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            <span class="token keyword">if</span> p<span class="token operator">==</span>q<span class="token punctuation">:</span>                <span class="token keyword">break</span>        q<span class="token operator">=</span>head        <span class="token keyword">while</span> p<span class="token operator">!=</span>q<span class="token punctuation">:</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next            q<span class="token operator">=</span>q<span class="token punctuation">.</span>next        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-03-01-三合一"><a href="#面试题-03-01-三合一" class="headerlink" title="面试题 03.01. 三合一"></a><a href="https://leetcode-cn.com/problems/three-in-one-lcci/" target="_blank" rel="noopener">面试题 03.01. 三合一</a></h3><p>简单的数据结构类题目，使用数组模拟栈，并用一个列表存放三个栈各自的curlen指针。</p><p>使用下标运算的方式存取元素。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TripleInOne</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stackSize<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stack<span class="token operator">=</span><span class="token punctuation">[</span>None <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>stackSize<span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>curlen<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>stackSize<span class="token operator">=</span>stackSize    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stackNum<span class="token punctuation">:</span> int<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>curlen<span class="token punctuation">[</span>stackNum<span class="token punctuation">]</span><span class="token operator">&lt;</span>self<span class="token punctuation">.</span>stackSize<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stack<span class="token punctuation">[</span>stackNum<span class="token operator">*</span>self<span class="token punctuation">.</span>stackSize<span class="token operator">+</span>self<span class="token punctuation">.</span>curlen<span class="token punctuation">[</span>stackNum<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>value            self<span class="token punctuation">.</span>curlen<span class="token punctuation">[</span>stackNum<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stackNum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>curlen<span class="token punctuation">[</span>stackNum<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>curlen<span class="token punctuation">[</span>stackNum<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack<span class="token punctuation">[</span>stackNum<span class="token operator">*</span>self<span class="token punctuation">.</span>stackSize<span class="token operator">+</span>self<span class="token punctuation">.</span>curlen<span class="token punctuation">[</span>stackNum<span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">peek</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stackNum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>curlen<span class="token punctuation">[</span>stackNum<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>           <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack<span class="token punctuation">[</span>stackNum<span class="token operator">*</span>self<span class="token punctuation">.</span>stackSize<span class="token operator">+</span>self<span class="token punctuation">.</span>curlen<span class="token punctuation">[</span>stackNum<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stackNum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>curlen<span class="token punctuation">[</span>stackNum<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token comment" spellcheck="true"># Your TripleInOne object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = TripleInOne(stackSize)</span><span class="token comment" spellcheck="true"># obj.push(stackNum,value)</span><span class="token comment" spellcheck="true"># param_2 = obj.pop(stackNum)</span><span class="token comment" spellcheck="true"># param_3 = obj.peek(stackNum)</span><span class="token comment" spellcheck="true"># param_4 = obj.isEmpty(stackNum)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-03-02-栈的最小值"><a href="#面试题-03-02-栈的最小值" class="headerlink" title="面试题 03.02. 栈的最小值"></a><a href="https://leetcode-cn.com/problems/min-stack-lcci/" target="_blank" rel="noopener">面试题 03.02. 栈的最小值</a></h3><p>剑指Offer原题，时间换空间，用一个辅助栈存放当前栈内某个数及其之前所有数对应的最小值。每次有元素入栈、出栈时，都需要更新最小栈。这样就实现了常数级别的时间复杂度。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MinStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>mini<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>mini<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>mini<span class="token punctuation">.</span>append<span class="token punctuation">(</span>min<span class="token punctuation">(</span>x<span class="token punctuation">,</span>self<span class="token punctuation">.</span>mini<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>mini<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">getMin</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>mini<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your MinStack object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MinStack()</span><span class="token comment" spellcheck="true"># obj.push(x)</span><span class="token comment" spellcheck="true"># obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.top()</span><span class="token comment" spellcheck="true"># param_4 = obj.getMin()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-03-03-堆盘子"><a href="#面试题-03-03-堆盘子" class="headerlink" title="面试题 03.03. 堆盘子"></a><a href="https://leetcode-cn.com/problems/stack-of-plates-lcci/" target="_blank" rel="noopener">面试题 03.03. 堆盘子</a></h3><p>这题不是很难，但要考虑的情况较多。python中可以直接使用二维列表来模拟题目中所说的栈，按照题目要求进行操作即可，当pop后某一堆盘子为空时，需要将其栈进行删除操作。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">StackOfPlates</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> cap<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stackLi<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>cap<span class="token operator">=</span>cap    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>cap<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>         <span class="token keyword">if</span> self<span class="token punctuation">.</span>stackLi<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">or</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stackLi<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span>self<span class="token punctuation">.</span>cap<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stackLi<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>             self<span class="token punctuation">.</span>stackLi<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stackLi<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        res<span class="token operator">=</span>self<span class="token punctuation">.</span>stackLi<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stackLi<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stackLi<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">popAt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> index<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stackLi<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token operator">=</span>self<span class="token punctuation">.</span>stackLi<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>stackLi<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>stackLi<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>index<span class="token punctuation">)</span>            <span class="token keyword">return</span> res        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token comment" spellcheck="true"># Your StackOfPlates object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = StackOfPlates(cap)</span><span class="token comment" spellcheck="true"># obj.push(val)</span><span class="token comment" spellcheck="true"># param_2 = obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.popAt(index)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-03-04-化栈为队"><a href="#面试题-03-04-化栈为队" class="headerlink" title="面试题 03.04. 化栈为队"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/" target="_blank" rel="noopener">面试题 03.04. 化栈为队</a></h3><p>主站经典原题。我们使用两个栈来模拟队列。由于栈和队列都是从尾部加入元素，所以我们只需要通过一个辅助栈来模拟出队操作。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>stack1<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>stack2<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Push element x to the back of queue.        """</span>        self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Removes the element from in front of queue and returns that element.        """</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>empty<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack2<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> self<span class="token punctuation">.</span>stack1<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">peek</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Get the front element.        """</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>empty<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack2<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> self<span class="token punctuation">.</span>stack1<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Returns whether the queue is empty.        """</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>stack1<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your MyQueue object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MyQueue()</span><span class="token comment" spellcheck="true"># obj.push(x)</span><span class="token comment" spellcheck="true"># param_2 = obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.peek()</span><span class="token comment" spellcheck="true"># param_4 = obj.empty()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-03-05-栈排序"><a href="#面试题-03-05-栈排序" class="headerlink" title="面试题 03.05. 栈排序"></a><a href="https://leetcode-cn.com/problems/sort-of-stacks-lcci/" target="_blank" rel="noopener">面试题 03.05. 栈排序</a></h3><p>使用一个辅助栈进行插入排序即可。维护主栈单调递减，每次新push一个元素时，将栈顶大于该元素的值入辅助栈保存，插入新元素，再从辅助栈中将元素重新入主栈即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">SortedStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stack1<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>stack2<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack1<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> self<span class="token punctuation">.</span>stack1<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> val<span class="token operator">></span>self<span class="token punctuation">.</span>stack1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>            <span class="token keyword">while</span> self<span class="token punctuation">.</span>stack2<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack1<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">peek</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack1<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack1<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your SortedStack object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = SortedStack()</span><span class="token comment" spellcheck="true"># obj.push(val)</span><span class="token comment" spellcheck="true"># obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.peek()</span><span class="token comment" spellcheck="true"># param_4 = obj.isEmpty()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-03-06-动物收容所"><a href="#面试题-03-06-动物收容所" class="headerlink" title="面试题 03.06. 动物收容所"></a><a href="https://leetcode-cn.com/problems/animal-shelter-lcci/" target="_blank" rel="noopener">面试题 03.06. 动物收容所</a></h3><p>使用三个队列进行模拟即可，没有什么难度。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">AnimalShelf</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>queueDog<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>queueCat<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>queueAny<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> animal<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> animal<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>queueCat<span class="token punctuation">.</span>append<span class="token punctuation">(</span>animal<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> animal<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>queueDog<span class="token punctuation">.</span>append<span class="token punctuation">(</span>animal<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>queueAny<span class="token punctuation">.</span>append<span class="token punctuation">(</span>animal<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">dequeueAny</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>queueAny<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>queueAny<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>queueCat<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>queueDog<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queueAny<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">dequeueDog</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>queueDog<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>queueAny<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>queueDog<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>queueDog<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">dequeueCat</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>queueCat<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>queueAny<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>queueCat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>queueCat<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your AnimalShelf object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = AnimalShelf()</span><span class="token comment" spellcheck="true"># obj.enqueue(animal)</span><span class="token comment" spellcheck="true"># param_2 = obj.dequeueAny()</span><span class="token comment" spellcheck="true"># param_3 = obj.dequeueDog()</span><span class="token comment" spellcheck="true"># param_4 = obj.dequeueCat()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="树、图"><a href="#树、图" class="headerlink" title="树、图"></a>树、图</h2><h3 id="面试题-04-01-节点间通路"><a href="#面试题-04-01-节点间通路" class="headerlink" title="面试题 04.01. 节点间通路"></a><a href="https://leetcode-cn.com/problems/route-between-nodes-lcci/" target="_blank" rel="noopener">面试题 04.01. 节点间通路</a></h3><p>这道题使用临接表存储图，然后进行基本的DFS即可，不需要回溯，因为只需要访问每个节点一次就行了。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findWhetherExistsPath</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> graph<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> start<span class="token punctuation">:</span> int<span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>v<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>set<span class="token punctuation">)</span>        <span class="token keyword">for</span> e <span class="token keyword">in</span> graph<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>v<span class="token punctuation">[</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>e<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        visited<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> nextV <span class="token keyword">in</span> self<span class="token punctuation">.</span>v<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nextV <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>                    <span class="token keyword">if</span> nextV<span class="token operator">==</span>target<span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">True</span>                    visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>nextV<span class="token punctuation">)</span>                    <span class="token keyword">if</span> dfs<span class="token punctuation">(</span>nextV<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>start<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-04-02-最小高度树"><a href="#面试题-04-02-最小高度树" class="headerlink" title="面试题 04.02. 最小高度树"></a><a href="https://leetcode-cn.com/problems/minimum-height-tree-lcci/" target="_blank" rel="noopener">面试题 04.02. 最小高度树</a></h3><p>我们使用递归的方式创建最小高度的二叉搜索树。由于列表有序，我们可以每次选取列表中间的节点作为根节点，然后分别利用左半列表和右半列表生成左右子树。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> li<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> None            mid<span class="token operator">=</span>len<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>li<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>left<span class="token operator">=</span>build<span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token punctuation">:</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>build<span class="token punctuation">(</span>li<span class="token punctuation">[</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token keyword">return</span> build<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-04-03-特定深度节点链表"><a href="#面试题-04-03-特定深度节点链表" class="headerlink" title="面试题 04.03. 特定深度节点链表"></a><a href="https://leetcode-cn.com/problems/list-of-depth-lcci/" target="_blank" rel="noopener">面试题 04.03. 特定深度节点链表</a></h3><p>简单的层次遍历，用队列可以模拟。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">listOfDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tree<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">:</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span>tree<span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            dummyhead<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            p<span class="token operator">=</span>dummyhead            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                now<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                p<span class="token punctuation">.</span>next<span class="token operator">=</span>ListNode<span class="token punctuation">(</span>now<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>next                <span class="token keyword">if</span> now<span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>now<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> now<span class="token punctuation">.</span>right<span class="token operator">!=</span>None<span class="token punctuation">:</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>now<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>dummyhead<span class="token punctuation">.</span>next<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-04-04-检查平衡性"><a href="#面试题-04-04-检查平衡性" class="headerlink" title="面试题 04.04. 检查平衡性"></a><a href="https://leetcode-cn.com/problems/check-balance-lcci/" target="_blank" rel="noopener">面试题 04.04. 检查平衡性</a></h3><p>剑指Offer原题，我们不是直接返回True或者False，而是当当前子树平衡时直接返回高度，这样就可以减少递归时为了求高度而进行的重复遍历了。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            leftHeight<span class="token operator">=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> leftHeight<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            rightHeight<span class="token operator">=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> rightHeight<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">if</span> abs<span class="token punctuation">(</span>leftHeight<span class="token operator">-</span>rightHeight<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> max<span class="token punctuation">(</span>leftHeight<span class="token punctuation">,</span>rightHeight<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token boolean">False</span> <span class="token keyword">if</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">else</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-04-05-合法二叉搜索树"><a href="#面试题-04-05-合法二叉搜索树" class="headerlink" title="面试题 04.05. 合法二叉搜索树"></a><a href="https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/" target="_blank" rel="noopener">面试题 04.05. 合法二叉搜索树</a></h3><p>递归中序遍历二叉搜索树，要求所得的序列递增即可。这里我们不需要存储整个序列，只需要存储最后一次遍历得到的值，当前值只要大于该值，即说明序列递增。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>tail<span class="token operator">=</span>None        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            left<span class="token operator">=</span>inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>tail<span class="token operator">==</span>None<span class="token punctuation">:</span>                now<span class="token operator">=</span><span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                now<span class="token operator">=</span>root<span class="token punctuation">.</span>val<span class="token operator">></span>self<span class="token punctuation">.</span>tail            self<span class="token punctuation">.</span>tail<span class="token operator">=</span>root<span class="token punctuation">.</span>val            right<span class="token operator">=</span>inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">return</span> left <span class="token operator">and</span> now <span class="token operator">and</span> right        <span class="token keyword">return</span> inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-04-06-后继者"><a href="#面试题-04-06-后继者" class="headerlink" title="面试题 04.06. 后继者"></a><a href="https://leetcode-cn.com/problems/successor-lcci/" target="_blank" rel="noopener">面试题 04.06. 后继者</a></h3><p>依然是中序遍历，每次用一个成员变量self.tail记录下当前节点前遍历到的最后一个节点，如果当前的tail指针指向p，则说明当前节点即为目标结果。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inorderSuccessor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>tail<span class="token operator">=</span>None        self<span class="token punctuation">.</span>res<span class="token operator">=</span>None        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>res<span class="token operator">!=</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>tail<span class="token operator">==</span>p<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>res<span class="token operator">=</span>root                <span class="token keyword">return</span>            self<span class="token punctuation">.</span>tail<span class="token operator">=</span>root            inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-04-08-首个共同祖先"><a href="#面试题-04-08-首个共同祖先" class="headerlink" title="面试题 04.08. 首个共同祖先"></a><a href="https://leetcode-cn.com/problems/first-common-ancestor-lcci/" target="_blank" rel="noopener">面试题 04.08. 首个共同祖先</a></h3><p>剑指Offer经典题目，题解可参考我的剑指Offer博客。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> q<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        <span class="token keyword">if</span> root<span class="token operator">==</span>p <span class="token operator">or</span> root<span class="token operator">==</span>q<span class="token punctuation">:</span>            <span class="token keyword">return</span> root        left<span class="token operator">=</span>self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>        right<span class="token operator">=</span>self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>        <span class="token keyword">if</span> left<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> right        <span class="token keyword">if</span> right<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> left        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-04-09-二叉搜索树序列"><a href="#面试题-04-09-二叉搜索树序列" class="headerlink" title="面试题 04.09. 二叉搜索树序列"></a><a href="https://leetcode-cn.com/problems/bst-sequences-lcci/" target="_blank" rel="noopener">面试题 04.09. 二叉搜索树序列</a></h3><p>这个题库里的第一道难题，还是比较有价值的。我们需要得出给定的BST的所有可能的生成序列。</p><p>我们只需要递归访问二叉搜索树即可。但是，这里的递归并不是传统的先序、中序或者后序，而是每次在候选的可访问节点中选取任意的一个进行访问，访问完某个节点后将其非空左右节点放入候选中。根据观察，我们还发现一定是从根节点开始递归。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">BSTSequences</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>candidate<span class="token punctuation">,</span>path<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                candidate<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                candidate<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> candidate<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">)</span>            <span class="token keyword">for</span> i<span class="token punctuation">,</span>node <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>candidate<span class="token punctuation">)</span><span class="token punctuation">:</span>                recur<span class="token punctuation">(</span>candidate<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token operator">+</span>candidate<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>path<span class="token operator">+</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#本质上进行了回溯</span>        <span class="token keyword">if</span> root<span class="token punctuation">:</span>            recur<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">,</span>root<span class="token punctuation">)</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>res        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意，由于这里递归访问候选节点时需要进行回溯，如果我们直接原地修改candidate列表的话，时间复杂度会比较高。这里，我们可以直接新建一个列表candidate[:i]+candidate[i+1:]作为递归的候选节点，这样无需再对当前列表进行修改和回溯，以空间节省时间。</p><h3 id="面试题-04-10-检查子树"><a href="#面试题-04-10-检查子树" class="headerlink" title="面试题 04.10. 检查子树"></a><a href="https://leetcode-cn.com/problems/check-subtree-lcci/" target="_blank" rel="noopener">面试题 04.10. 检查子树</a></h3><p>双层DFS即可。测试用例太弱！</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">checkSubTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> t1<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> t2<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">:</span>                <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>target<span class="token punctuation">.</span>val <span class="token operator">and</span> preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>target<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>target<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>                <span class="token keyword">if</span> preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>                <span class="token keyword">if</span> preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">return</span> <span class="token boolean">False</span> <span class="token keyword">if</span> target<span class="token operator">!=</span>None <span class="token keyword">else</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> preorder<span class="token punctuation">(</span>t1<span class="token punctuation">,</span>t2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-04-12-求和路径"><a href="#面试题-04-12-求和路径" class="headerlink" title="面试题 04.12. 求和路径"></a><a href="https://leetcode-cn.com/problems/paths-with-sum-lcci/" target="_blank" rel="noopener">面试题 04.12. 求和路径</a></h3><p>剑指Offer原题。双重DFS时间复杂度太高，我们可以使用前缀和求解二叉树中的任意一段路径和。进行回溯的DFS即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        prefixSum<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">:</span>                now_prefixSum<span class="token operator">=</span>prefixSum<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>root<span class="token punctuation">.</span>val                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>prefixSum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> now_prefixSum<span class="token operator">-</span>prefixSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>sum<span class="token punctuation">:</span>                        self<span class="token punctuation">.</span>res<span class="token operator">+=</span><span class="token number">1</span>                prefixSum<span class="token punctuation">.</span>append<span class="token punctuation">(</span>now_prefixSum<span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                prefixSum<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        preorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="面试题-05-01-插入"><a href="#面试题-05-01-插入" class="headerlink" title="面试题 05.01. 插入"></a><a href="https://leetcode-cn.com/problems/insert-into-bits-lcci/" target="_blank" rel="noopener">面试题 05.01. 插入</a></h3><p>题意表述不清，当j-i超过M的位数后，应该以0填充。</p><p>我们可以通过位运算，先将N的i到j位全部置为0，接着再与上M左移i位的结果即可。</p><p>需要重点说明的是将N的i到j位全部置为0的过程：</p><ul><li>我们以j=6，i=2为例，先将1左移j-i+1即5位，得到100000</li><li>再将100000减1，得到011111</li><li>将011111左移i位，得到01111100</li><li>再将01111100取反，得到10000011</li><li>将其与N进行与运算，即可将想要置0的区间置0.</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">insertBits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> N<span class="token punctuation">:</span> int<span class="token punctuation">,</span> M<span class="token punctuation">:</span> int<span class="token punctuation">,</span> i<span class="token punctuation">:</span> int<span class="token punctuation">,</span> j<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        N<span class="token operator">&amp;</span><span class="token operator">=</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>j<span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> N<span class="token operator">|</span><span class="token punctuation">(</span>M<span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-05-02-二进制数转字符串"><a href="#面试题-05-02-二进制数转字符串" class="headerlink" title="面试题 05.02. 二进制数转字符串"></a><a href="https://leetcode-cn.com/problems/bianry-number-to-string-lcci/" target="_blank" rel="noopener">面试题 05.02. 二进制数转字符串</a></h3><p>经典的十进制小数转二进制小数，采用累乘法，并正序输出结果。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">printBin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> float<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">if</span> num<span class="token operator">&lt;=</span><span class="token number">0</span> <span class="token operator">or</span> num<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"ERROR"</span>        res<span class="token operator">=</span><span class="token string">""</span>        <span class="token keyword">while</span> num<span class="token operator">!=</span><span class="token number">0.0</span> <span class="token punctuation">:</span>            num<span class="token operator">*=</span><span class="token number">2</span>            res<span class="token operator">+=</span>str<span class="token punctuation">(</span>int<span class="token punctuation">(</span>num<span class="token operator">//</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            num<span class="token operator">=</span>num<span class="token operator">%</span><span class="token number">1</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">32</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token string">"ERROR"</span>        <span class="token keyword">return</span> <span class="token string">"0."</span><span class="token operator">+</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题-05-03-翻转数位"><a href="#面试题-05-03-翻转数位" class="headerlink" title="面试题 05.03. 翻转数位"></a><a href="https://leetcode-cn.com/problems/reverse-bits-lcci/" target="_blank" rel="noopener">面试题 05.03. 翻转数位</a></h3><p>这题虽然看上去是简单题，但个人认为思路还是挺难想的。</p><p>我们需要用一个数组来存放二进制数中连续的1的个数。 如果遇见一段连续的 1，那么会在数组中同一个位置进行累加。 如果遇见了 0，数组下标指针加 1。 稍微思考一下，不难明白此时本题就转换为数组中最大的相邻元素之和。 </p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseBits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        li<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        index<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> num<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> num<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                li<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                index<span class="token operator">+=</span><span class="token number">1</span>            num<span class="token operator">//=</span><span class="token number">2</span>        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token operator">=</span>max<span class="token punctuation">(</span>res<span class="token punctuation">,</span>li<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>li<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 程序员面试金典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上下位关系获取：论文阅读笔记</title>
      <link href="/2020/04/15/shang-xia-wei-guan-xi-huo-qu-lun-wen-yue-du-bi-ji/"/>
      <url>/2020/04/15/shang-xia-wei-guan-xi-huo-qu-lun-wen-yue-du-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>上下位关系</strong>在自然语言知识体系中占有非常重要的地位，它是描述事物层次关系的基础，可以作为词语关系网络的核心骨架。根据 WordNet的定义，<strong>给定两个词语x和y，如果句子“x是一种|类|个|…|y”可接受，则称y是x的上位词(hypernym)，x是y的下位词 (hyponym)，上下位关系记为hyponymy(x,y)</strong>。例如，句子“苹果是一种水果”是可以接受的，因此“苹果”和“水果”具有上下位关系hyponymy(苹果，水果)。很显然，上下位关系是非对称的，如果x是y的上位词，则y一定不是x的上位词。</p><p>本文是我阅读国内外对于上下位关系获取的相关论文的笔记，目前学术界主要采用的获取方法是<strong>基于模板的方法和基于词嵌入投影的方法</strong>。我将对上下位相关经典论文进行解读，并分析它们各自方法存在的优缺点。</p><h2 id="Automatic-acquisition-of-hyponyms-from-large-text-corpora（Hearst-M-A，ACL）"><a href="#Automatic-acquisition-of-hyponyms-from-large-text-corpora（Hearst-M-A，ACL）" class="headerlink" title="Automatic acquisition of hyponyms from large text corpora（Hearst M A，ACL）"></a>Automatic acquisition of hyponyms from large text corpora（Hearst M A，ACL）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>上下位关系获取的开山之作，提出了基于模式匹配的方式获取上下位关系的方法。</p><p>在这篇文章中，作者定义了能够揭示上下位关系的一些常用英文模板（pattern），这里的模板指的都是<strong>语法规则（grammar rule）</strong>，例如：</p><ul><li>NP such as NP。</li><li>NP，especially NP。</li><li>…….</li></ul><p>根据上述词法-句法模板，就可以使用最简单的<strong>正则表达式</strong>对上下位关系进行自动获取。例如：</p><ul><li>…more European countries，especially England，France…</li></ul><p>从上述句子中可以得到上下位关系（England，Country）和（France，Country）。</p><p>Hearst设计了一套简单的模式匹配抽取算法，在百科全书文本中进行了上下位关系抽取，并与人工构建的知识库WordNet内包含的上下位关系进行对比，所得结果的准确率为61/106（57.55%）。</p><p>此外，在这篇文章中，Hearst也提出了手工定义模板困难的缺陷，她通过观察已有的上下位关系，认为可以将已有的上下位关系作为种子集迭代抽取模板。这一思想后来被称作是<strong>BootSrapping的半监督抽取方法</strong>。</p><h3 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h3><p>最早进行上下位关系研究的工作之一，提出的方法非常简单易行，是后续基于模板的上下位关系获取方法的基础。但是，在这篇文章里Hearst没有给出抽取的具体方法，同时，基于模板的方法还存在着以下的缺陷：</p><ul><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 综述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 自然语言处理 </tag>
            
            <tag> 上下位关系 </tag>
            
            <tag> 综述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：Attention、Transformer和BERT</title>
      <link href="/2020/04/11/nlp-zi-xue-bi-ji-attention-transformer-he-bert/"/>
      <url>/2020/04/11/nlp-zi-xue-bi-ji-attention-transformer-he-bert/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由谷歌团队提出的<strong>预训练语言模型BERT</strong>近年来正在各大自然语言处理任务中屠榜（话说学者们也挺有意思的，模型名都强行凑个芝麻街的人物名，哈哈哈）。 BERT算法的最重要的部分便是<strong>Transformer</strong>的概念，它本质上是Transformer的编码器部分。 而Transformer中使用了<strong>Self-Attention</strong>机制，所以本文会从<strong>Attention机制</strong>说起。</p><p>本文是我对Attention、Transformer和BERT的学习总结。同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己的理解，如有错误欢迎在评论区指出，非常感谢！ </p><h2 id="Attention机制"><a href="#Attention机制" class="headerlink" title="Attention机制"></a>Attention机制</h2><p> <strong>注意力模型（Attention Model）</strong> 是深度学习领域最有影响力的思想之一。 它模仿了人类观察文本或图像时的注意力，解决了<strong>长序列问题</strong>，尤其在<strong>机器翻译</strong>等领域应用广泛。</p><h3 id="RNN模型如何解决机器翻译问题"><a href="#RNN模型如何解决机器翻译问题" class="headerlink" title="RNN模型如何解决机器翻译问题"></a>RNN模型如何解决机器翻译问题</h3><p>我们以机器翻译问题作为基础，逐步讲解注意力机制及它的优缺点。首先，我们来看RNN模型是如何解决机器翻译问题的。事实上，这在我之前的RNN博客中已经提到过了，这是<strong>一个Many to Many（$T_x!=T_y$）的Seq2Seq序列标注问题。</strong></p><p><img src="2.png" alt="机器翻译问题"></p><p>下图为RNN解决这一类输入序列和输出序列长度不等的序列标注问题的常用模型结构：</p><p><img src="1.png" alt="RNN模型"></p><p>可以看到，RNN模型此时被分为了两个部分：<strong>编码器部分（Encoder）和解码器部分（Decoder）。</strong></p><p>编码器部分没有Softmax层预测输出，它的作用仅仅是<strong>将源语言文本传入到一个RNN网络（具体可以是GRU、LSTM等），然后在网络的出口处提取最后一个时间步的激活值输出，并且传入解码器。</strong>编码器最后一个时间步的激活值输出因为走过了整个源文本序列，所以可以认为<strong>它蕴含了需要翻译的整个句子的信息</strong>。它的维度与RNN单元的隐藏层神经元数目一致。当然了，这里的RNN可以是深层的，但我们只以单隐藏层的RNN进行讲解。</p><p>解码器部分可以看作是一个条件语言模型（Language Model，例如我们常见的AI写诗模型）。它的作用是<strong>通过编码器输入的激活值，生成当前条件下最大概率的目标语言句子</strong>。它与常规的语言模型有两点不同：</p><ol><li>语言模型零时刻的激活值为<strong>零向量</strong>，而机器翻译模型解码器的零时刻的激活值为<strong>编码器结尾的时间步激活输出。</strong></li><li>语言模型为了保证生成句子的多样性，所以每个时间步的输出都是<strong>按照概率分布随机生成</strong>的。而机器翻译模型很明显需要翻译出最准确的结果，所以输出的序列应是<strong>全局最大概率的序列。</strong></li></ol><p>这个语言模型中，每个RNN单元的输出来自两个方面：</p><ul><li>前一个时间步RNN单元的激活值输出。</li><li>前一个时间步Softmax层预测的输出$\hat y_{t-1}$。</li></ul><p>顺便提一下，机器翻译问题中的全局最优解问题和CRF、HMM等常规机器学习的序列标注模型中类似，可以使用<strong>维特比算法</strong>来解，在对应的博客中都可以找到相应的说明。如果我们使用贪心算法，将可能陷入局部最优解中。</p><p>特别地，我们发现，当词汇表规模很大时，即使是动态规划的维特比算法，其时空复杂度也会很高（时间复杂度：$O(MN^2)$，$Ｍ$为时序数，$N$为词汇表大小）。为了降低计算量，科学家们提出了<strong>集束搜索（Beam Search）</strong>的方法，即第一次输出时选取概率最高的$B$个单词，并将它们作为输入投入第二个时间步，第二次输出时仍然只选概率最高的$B$个单词……以此类推，到最后只会产生$B$条预测序列，我们选取概率最大的的作为最终的结果。<strong>这样做，其实就是在贪心搜索和维特比算法之间进行平衡，当$B=1$时，集束搜索退化成贪心算法，当$B=N$时，集束搜索演变成维特比算法。</strong></p><h3 id="RNN-Attention解决机器翻译问题"><a href="#RNN-Attention解决机器翻译问题" class="headerlink" title="RNN+Attention解决机器翻译问题"></a>RNN+Attention解决机器翻译问题</h3><p>上述RNN架构存在着一些问题，例如：<em><em>我们用编码器的最后一个时序的激活值输出作为解码器的初始激活值，也就是说编码器的最后一个激活值向量需要承载源句子的所有信息，这在输入的句子长度变长时，容易成为整个模型的“信息”瓶颈。 </em></em></p><p>如下图所示，一个最基本的RNN机器翻译模型，当句子长度变长时，翻译的效果（Bleu得分）将逐渐降低：</p><p><img src="3.png" alt="朴素RNN机器翻译模型的缺陷"></p><p>为了解决这个问题，科学家们提出了Attention模型，<strong>它将编码器的每个时序隐藏层直接与解码器每个时序的隐藏层相连接，相等于提供了捷径，解码器的预测可以直接利用编码器在每个源文本单词处的编码结果，从而解决了“信息”瓶颈问题。</strong></p><p>首先，我们使用一个BRNN来做编码器，每个时序的输出都是该处源文本单词丰富的特征。BRNN可以充分的利用上下文全部的信息。如下图所示，$\hat y_t’$为$t’$时刻RNN单元前向后向激活的向量拼接。</p><p><img src="4.png" alt="RNN+Attention的编码器"></p><p>接着，我们使用一个RNN来做解码器。RNN的输入除了上一时刻的激活输出向量、上一时刻的预测结果向量，还要加入<strong>注意力输出（Attention Output）</strong>。为了计算解码器在第$t$时刻需要输入的Attention Output，<strong>我们通过给编码器各时序的输出$\hat y_{t’}$一个注意力权重（Attention Weight）$\alpha_{t,t’}$，来对它们进行加权求和。</strong>如下图所示：</p><p><img src="5.png" alt="Attention机制"></p><p>我们可以将解码器的每个时刻单独拎出来：</p><p><img src="6.png" alt="Attention的每个时刻"></p><p>那么，如何计算注意力权重呢？一种比较常用的方法是利用解码器RNN上一时刻的激活向量$s_{t-1}$和编码器此时刻的输出向量$a_{t’}$做<strong>点积（dot product）操作</strong>，所得结果记为注意力得分（Attention Score）$e_{t,t’}$。<br>$$<br>e_{t,t’}=s_{t-1}^Ta_{t’}<br>$$<br>显然，注意力权重$\alpha_{t,t’}$需要满足值域在[0,1]，且各时刻$t’$的注意力权重之和为1。所以，我们需要使用Softmax非线性函数进行转化：<br>$$<br>\alpha_{t,t’}=Softmax(e_{t,t’})<br>$$<br>具体流程可以参考cs224n上的这页ppt：</p><p><img src="7.png" alt="Attention机制的运算过程"></p><p>上面讲解的只是最基本的点积注意力，还有其他几种Attention，本质都是一样的：</p><p><img src="8.png" alt="Attention变种"></p><p>Attention机制的优点如下：</p><ul><li>解决了传统RNN架构的<strong>“信息“瓶颈问题</strong>。</li><li>让解码器<strong>有选择性地注意</strong>与当前翻译相关的源句子中的词。</li><li>通过使编码器的各时序隐藏层和解码器各时序隐藏层<strong>直接相连</strong>，使梯度可以更加直接地进行反向传播，<strong>缓解了梯度消失问题</strong>。</li><li>增加了机器翻译模型的<strong>可解释性</strong>。</li></ul><h2 id="Transformer模型"><a href="#Transformer模型" class="headerlink" title="Transformer模型"></a>Transformer模型</h2><p>尽管RNN+Attention的模型非常有效，但它同时也存在着一些缺陷。RNN最主要的缺陷在于：<strong>它的计算是有时序依赖的，需要用到前一个时间步或者后一个时间步的信息，这导致它难以并行计算，只能串行计算。</strong>而当今时代，GPU的并行化能够大大加速计算过程，如果不能够并行计算，会导致运算速度很低。</p><p>为了解决这个问题，科学家们首先提出了使用CNN代替RNN做特征抽取器。通过多层卷积运算，CNN的上层将能够完整地考虑整个时序的信息：</p><p><img src="9.png" alt="CNN特征提取"></p><p>CNN的优势在于可以并行计算，没有时序依赖。但同时它也有一个缺陷：<strong>CNN需要经过多层计算才能获取长序列的资讯，下层CNN只能看到较小的范围。</strong></p><p>为了能够进行并行计算，又不需要多层迭代，科学家们提出了Transformer模型。它的论文题目很霸气《Attention is All You Need》。正如题目所说，<strong>Transformer模型通过采用Self-Attention自注意力机制，完全抛弃了传统RNN在水平方向的传播，只在垂直方向上传播，只需要不断叠加Self-Attention层即可。</strong>这样，每一层的计算都可以并行进行，可以使用GPU进行加速。</p><p>你可以使用Self-Attention层来完成任何RNN层可以做到的事情：</p><p><img src="10.png" alt="Self-Attention层"></p><h3 id="Self-Attention机制"><a href="#Self-Attention机制" class="headerlink" title="Self-Attention机制"></a>Self-Attention机制</h3><p>Self-Attention层的基本结构如下图所示：</p><p><img src="11.png" alt="Self-Attention层基本结构"></p><p>我们以Self-Attention层的第一个输出$b_1$的计算为例。Self-Attention层计算的流程如下：</p><ol><li>首先，我们以第一个单词的Word2Vec等词向量作为输入$x_1$。通过与一个参数矩阵$W_a$相乘，我们对$x_1$又进行了一次嵌入，得到了$a_1$向量（这里相当于是一个全连接层）。</li><li>接着，我们需要给定三个参数矩阵，分别为$W_q$、$W_k$、和$W_v$，通过三次矩阵乘法，我们从$a_1$计算得到$q_1$、$k_1$、$v_1$三个向量。（相当于三个分开的全连接层）。（需要注意，所有时序的计算共享上述四个参数矩阵）其中，$q$向量称为query向量，用于匹配其它时序的$k$向量；$k$向量称为match向量，用于被其他时序的$q$向量匹配；$v$向量即为当前时序的要被抽取的信息。</li><li>然后，与上一节所说的Attention权重计算方式类似。我们先计算输出时序 1 对各输入时序 i 注意力得分$\alpha_{1,i}$，它是由时序1处的query向量$q$和各处的key向量$k$做点积操作后得到：</li></ol><p>$$<br>\alpha_{1,i}=q_1^Tk_i<br>$$</p><p>​     为了保持梯度稳定，我们还要除以向量$q$和向量$k$共同的维度$d$的平方根，这一步叫做Score归一化。<br>$$<br>\alpha_{1,i}=\frac{q_1^Tk_i}{\sqrt{d}}<br>$$</p><ol start="4"><li><p>接着，我们需要使用非线性函数Softmax对注意力分数进行概率转化，得到注意力权重$\hat \alpha_{1,i}$。<br>$$<br>\hat \alpha_{1,i}=\frac{e^{\alpha_{1,i}}}{\sum_{j=1}^{n}e^{\alpha_{1,j}}}<br>$$</p></li><li><p>最后，我们使用计算得到的注意力权重对各时序的信息向量$v_i$进行加权求和运算，即可得到输出$b_1$。</p></li></ol><p>$$<br>b_1=\sum_{i=1}^n\hat \alpha_{1,i}v_i<br>$$</p><p>以上就是Self-Attention层计算的全过程。可以看到，Self-Attention层在水平方向上不会进行任何计算，也就可以使用矩阵进行并行化：<br>$$<br>B=\hat A V=Softmax(\frac{Q^TK}{\sqrt{d}})V<br>$$<br>Self-Attention的优点：</p><ul><li>因为每个词都和周围所有词做attention，所以任意两个位置都相当于有直连线路，<strong>可捕获长距离依赖。</strong></li><li>而且Attention的<strong>可解释性更好</strong>，根据Attention score可以知道一个词和哪些词的关系比较大。</li><li><strong>易于并行化</strong>，当前层的Attention计算只和前一层的值有关，所以一层的所有节点可并行执行self-attention操作。</li><li>计算效率高，一次Self-Attention只需要<strong>两次矩阵运算，速度很快</strong>。 </li></ul><p>特别地，如果我们每次产生多组$q$、$k$、$v$向量，这样的Self-Attention层叫做Multi-Head Self-Attention，即多头自注意力机制：</p><p><img src="12.png" alt="Multi-Head Self-Attention"></p><p>Multi-Head Self-Attention的优点：<strong>不同的head可以关注不同的重点，通过多个head可以关注到更多的信息。</strong>这有些相当于CNN中的不同filter。</p><p>此时，Self-Attention层还存在着一个问题：虽然此时通过注意力机制，可以有针对性地捕捉整个句子的信息，但是<strong>没有位置信息</strong>。 也就是说无论句子的结构怎么打乱，Transformer都会得到类似的结果。换句话说，<strong>Transformer只是一个功能更强大的词袋模型而已</strong>。 </p><p>为了解决这个问题，研究人员中在编码词向量时引入了<strong>位置编码（Position Embedding）的特征</strong>。具体地说，位置编码会在词向量中加入了单词的位置信息，这样Transformer就能区分不同位置的单词了。 </p><p><img src="13.png" alt="Position Embedding"></p><p>上述$e_i$即为第 i 时刻输入的位置信息。它可以是学习而来的，也可以手工设置。</p><h3 id="Transformer的架构"><a href="#Transformer的架构" class="headerlink" title="Transformer的架构"></a>Transformer的架构</h3><p>介绍完了Self-Attention机制，我们就可以来看Transformer模型的基本架构了。其结构如下图所示：</p><p><img src="14.png" alt="Transformer模型结构"></p><p>与传统RNN类似，它由编码器和解码器两部分组成。上面的结构有几点需要解释：</p><ul><li>Transformer中使用了ResNet中的 residual connection ，即<strong>残差连接</strong>，方便梯度的反向传播。</li><li>Add&amp;Norm指的是将残差路径上传来的向量和Self-Attention计算得到的向量相加后进行<strong>Layer-Normalization</strong>，即层标准化。Layer Norm对同一个样本同一层的所有神经元进行标准化，使它们满足标准正态分布，而Batch Norm则是对Batch内不同样本的同一个神经元所有值进行标准化。</li><li>编码器输出的两个箭头分别是<strong>输入给解码器第二个Multi-Head Self-Attention层的$k$和$v$，且$k=v$</strong>。相当于提供给解码器源文本信息。</li><li>解码器的Masked Multi-Head Self-Attention层之所以叫Masked，是因为由于语言模型的性质，<strong>生成当前词总是需要利用已生成的序列结果，相当于把后面的结果Masked掉了。</strong>所以Transformer解码时，仍然需要按照时序逐个递推计算，只不过大多数内部的计算可以并行化了。</li><li>Feed-Forward层就是一个基本的<strong>全连接前馈层</strong>，一般使用<strong>ReLu激活函数</strong>。</li></ul><p>通过上述架构，我们便可以构建Transformer模型，并且用于各种序列问题。Transformer模型中的注意力机制为翻译模型带来了可解释性，可视化如下：</p><p><img src="15.png" alt="Attention可视化"></p><h3 id="Transformer的优劣"><a href="#Transformer的优劣" class="headerlink" title="Transformer的优劣"></a>Transformer的优劣</h3><p><strong>优点</strong>：</p><ol><li>虽然Transformer最终也没有逃脱传统学习的套路，Transformer也只是一个全连接（或者是一维卷积）加Attention的结合体。但是其设计已经足够有创新，因为其抛弃了在NLP中最根本的RNN或者CNN并且取得了非常不错的效果，算法的设计非常精彩，值得每个深度学习的相关人员仔细研究和品位。</li><li>Transformer的设计最大的带来性能提升的关键是将任意两个单词的距离是1，这对解决NLP中棘手的长期依赖问题是非常有效的。</li><li>Transformer不仅仅可以应用在NLP的机器翻译领域，甚至可以不局限于NLP领域，是非常有科研潜力的一个方向。</li><li>算法的并行性非常好，符合目前的硬件（主要指GPU）环境。</li></ol><p><strong>缺点</strong>：</p><ol><li>粗暴的抛弃RNN和CNN虽然非常炫技，但是它也使模型丧失了捕捉局部特征的能力，RNN + CNN + Transformer的结合可能会带来更好的效果。</li><li>Transformer失去的位置信息其实在NLP中非常重要，而论文中在特征向量中加入Position Embedding也只是一个权宜之计，并没有改变Transformer结构上的固有缺陷。</li></ol><h2 id="BERT模型"><a href="#BERT模型" class="headerlink" title="BERT模型"></a>BERT模型</h2><h3 id="BERT模型介绍"><a href="#BERT模型介绍" class="headerlink" title="BERT模型介绍"></a>BERT模型介绍</h3><p>BERT模型的全名叫做<strong>Bidirectional Encoder Representation from Transformers</strong>。从名称上就可以看出，BERT模型和Transformer模型联系紧密，事实上，它就是Transformer模型的编码器部分。</p><p><img src="16.png" alt="BERT模型的结构"></p><p>BERT模型本质上是一个<strong>自编码语言模型（Autoencoder LM）</strong>，并且其设计了两个任务来预训练该模型：</p><ul><li><strong>Masked Language Model</strong>：这个方式的灵感很大程度上来自于Word2Vec模型中的<strong>连续词袋模型CBOW</strong>。与完型填空类似，该方法<strong>在句子中随机遮盖住15%的单词（ 80%的概率替换成[MASK] 、 10%的概率替换成随机的一个词 、10%的概率替换成它本身 ），并且用剩下的单词去预测它们</strong>。如下图所示，我们将需要预测的单词的BERT词向量输出传入一个线性分类器（如Softmax BPNN），即可用交叉熵损失函数训练模型。</li></ul><p><img src="17.png" alt="Masked LM"></p><ul><li><strong>Next Sentence Prediction</strong>：该方法的描述是：<strong>给定一篇文章中的两句话，判断第二句话在文本中是否紧跟在第一句话之后，如下图所示</strong>。我们插入[SEP]标志表示句子的分隔符，插入[CLS]表示开始预测的位置。通过预测两个句子正确的连接，即可训练模型。</li></ul><p><img src="18.png" alt="Next Sentence Prediction"></p><p>BERT模型的主要输入是<strong>文本中各个字/词(或者称为token)的原始词向量，该向量既可以随机初始化，也可以利用Word2Vec等算法进行预训练以作为初始值</strong>；输出是<strong>文本中各个字/词融合了全文语义信息后的向量表示 。</strong></p><p>此外，BERT模型的输入还有以下两个向量：</p><ol><li>Transformer模型要求的<strong>位置编码向量（ Position Embeddings ）</strong>：刻画词在句子中的位置信息。</li><li><strong>文本向量（Segment Embeddings）</strong>： 该向量的取值在模型训练过程中自动学习，用于刻画文本的全局语义信息，并与单字/词的语义信息相融合 </li></ol><h3 id="BERT模型的使用"><a href="#BERT模型的使用" class="headerlink" title="BERT模型的使用"></a>BERT模型的使用</h3><p>Word2Vec、GloVe、ELMo等模型是通过语言模型任务得到句子中单词的embedding表示，以此作为补充的新特征给下游任务使用。因为给下游提供的是<strong>每个单词的特征形式</strong>，所以这一类预训练的方法被称为<strong>“Feature-based Pre-Training”</strong>。而BERT模型是“基于<strong>Fine-tuning</strong>的模式”，这种做法和图像领域基于Fine-tuning（微调）的方式基本一致，下游任务需要将模型<strong>改造成BERT模型，才可利用BERT模型预训练好的参数</strong>。 </p><p>尽管我们可以从网上下载别人训练好的BERT模型，但是在实际应用在下游任务时，BERT模型的参数依然会不断进行自动微调。不过好处是不需要从头训练了，需要从头开始训练的只有我们下游任务自己的网络参数。</p><p>这里，李宏毅老师给出了BERT模型应用在常见的四种下游任务中的模型结构：</p><p><img src="19.png" alt="输入是句子，输出是类别"></p><p><img src="20.png" alt="输入是句子，输出是句子中每个词的标签"></p><p><img src="21.png" alt="输入是两个句子，输出是类别"></p><p><img src="22.png" alt="基于抽取的QA"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我对Attention、Transformer和BERT模型的一些学习笔记，目前学的还是比较浅显，日后看到论文或者需要使用的时候再进一步加深理解。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 预训练模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：Word2Vec、Glove和ELMO</title>
      <link href="/2020/04/08/nlp-zi-xue-bi-ji-word2vec-glove-he-elmo/"/>
      <url>/2020/04/08/nlp-zi-xue-bi-ji-word2vec-glove-he-elmo/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>词汇表示（Word Representation）一直是自然语言处理中最基础也是最重要的任务之一。 深度学习已经给这一领域带来了革命性的变革。其中一个很关键的概念就是词嵌入（<strong>word embeddings</strong>），这是语言表示的一种方式，可以让算法自动的理解一些类似的词，比如男人对女人，比如国王对王后，还有其他很多的例子。 </p><p>本文是我在学习吴恩达深度学习课程中的词汇表示一章的总结与思考，同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己的理解，如有错误欢迎在评论区指出，非常感谢！</p><h2 id="one-hot表示法"><a href="#one-hot表示法" class="headerlink" title="one-hot表示法"></a>one-hot表示法</h2><p>one-hot表示法是机器学习中表示<strong>离散化特征</strong>的一种重要方法，在NLP任务中，我们同样可以使用它来表示词。在神经网络序列模型的博客中，我已经介绍了使用one-hot向量表示单词的步骤，这里我再简单说明一下：</p><ul><li>建立一个向量，包含常用的词汇，形成一个<strong>词汇表（vocabulary）</strong> 。词汇表的大小是人为设定的，这里，我们使用10,000个单词来构建我们的词汇表。 对于一般规模的商业应用来说30,000到50,000词大小的词典比较常见，但是100,000词的也不是没有，而且有些大型互联网公司会用百万词，甚至更大的词典。</li><li>接下来，我们为单词建立one-hot向量，假如一个词在词汇表中的序号为1234，那么它的one-hot向量就是在1234行为1，其余行均为0的10000维列向量。</li><li>特别地，我们需要考虑<strong>未登录词、开始标记、结尾标记</strong>等情况。未登录词指的是不在词汇表中的单词，我们需要在词汇表添加标记\UNK来表示它们。此外，在构建语言模型、进行机器翻译等过程中，我们还需要使用到开始标记、结尾标记，它们表示的是句子的开始、结尾位置。例如，一旦语言模型生成了结尾标记，我们就可以认为句子生成完毕。我们在词汇表中添加\BOS和\EOS来表示他们。</li></ul><p><img src="1.png" alt="one-hot表示法"></p><p> 这种表示方法的一大缺点就是它把每个词孤立起来，这样使得算法对相关词的泛化能力不强。  <strong>每个one-hot只是为了表示单词自己而已，无法让算法很容易的跨单词泛化，即它无法表示任何两个单词之间的关系</strong>，因为任何两个单词one-hot向量的内积为都是0。 </p><p>例如，我们需要建立一个语言模型来生成句子，假设我们已经学习了下面这个句子：</p><blockquote><p>I want a glass of orange juice.  </p></blockquote><p>在另一个任务中，我们已经预测了如下的句子：</p><blockquote><p>I want a glass of apple <em>__</em>. </p></blockquote><p><strong>由于在one-hot表示法中，单词orange和单词apple间没有任何关联，所以即使模型知道了orange juice是比较常见的搭配，也无法学习到apple juice也是一种常见的情况。所以，空格处无法正确填入单词juice。</strong></p><p>此外，<strong>one-hot向量通常维度很高（与词汇表的大小一致），同时它又是非常稀疏的（只在一个位置为1），所以使用one-hot向量表示词将会使模型的参数变多，难以训练。</strong></p><h2 id="词嵌入表示法"><a href="#词嵌入表示法" class="headerlink" title="词嵌入表示法"></a>词嵌入表示法</h2><p>有没有方法可以更好的表示词，能够捕捉词义以及词间的关联呢？答案是有的，我们可以使用<strong>特征化</strong>的方法来表示一个单词。</p><p>比如下图所示，一共有4个属性（实际应用会更多）：性别、是否为皇室、年龄、是否为食品。每个单词分别从这4个属性给出与这些属性的相关度。<strong>那么任何一个单词就可以用一个4维的特征向量表示</strong>，比如Man表示为(-1, 0.01, 0.03, 0.09)。 </p><p><img src="2.png" alt="词嵌入表示法"></p><p>此时，可以清晰的看到Apple和Orange极为相似，上面的例子就很容易使得算法在第二句话也填入单词juice。 </p><p>当我们将单词使用这种高维特征表示时，就叫做<strong>词嵌入（word embedding）</strong>。之所以叫做embedding，可以想象成每个单词被嵌入（embed）到了一个高维空间内。词嵌入是NLP最重要的思想之一。 </p><p>需要说明的是，上面的特征只是直观的举例，实际上的特征并不是手工设计的，而是算法（即word embedding）学习而来；而且这些学习的特征，<strong>可能并不具有良好的解释性</strong>，但不管怎样，算法都可以快速哪些单词是相似的。 </p><p>此外，词嵌入向量的维度通常情况下远远小于词汇表中单词的数目，所以一定程度上<strong>减少了参数数量，减轻了训练的负担。</strong></p><p>我们可以使用<strong>t-SNE</strong>算法进行高维词向量的可视化，可以看到，词义相近的单词在经过词嵌入后被聚在了一起：</p><p><img src="3.png" alt="词嵌入可视化"></p><h2 id="词嵌入的作用"><a href="#词嵌入的作用" class="headerlink" title="词嵌入的作用"></a>词嵌入的作用</h2><h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><p>我们以一个命名实体识别（NER）的任务为例，假设训练集中存在着这么一句话：</p><blockquote><p> Sally Johnson is an orange farmer. </p></blockquote><p>我们在这里使用一个BRNN模型，并使用词嵌入向量来表示单词，作为BRNN的输入。BRNN可以根据orange farmer判断出Sally Johnson是一个人名。</p><p>当我们遇到了新的输入，如：</p><blockquote><p> Robert Lin is an apple farmer. </p></blockquote><p>由于apple的词嵌入和orange的词嵌入是相似的，所以模型也可以容易的识别Robert Lin是一个人名 。 </p><p>假如我们的输入中含有冷僻词，如：</p><blockquote><p> Robert Lin is a durian cultivator. </p></blockquote><p>durian（榴莲）和cultivator（培育家）是较为少见的单词，很可能在我们的训练集中没有出现过。使用我们传统的one-hot向量表示，将难以预测出 Robert Lin是一个人名。而如果我们使用词嵌入表示法，那么durian和orange将拥有相似的向量，cultivator和farmer将拥有相似的向量，模型能够依据orange farmer和人名的关系，推断出durian cultivator和人名的关系，进而预测出 Robert Lin是一个人名。</p><p>为什么词嵌入能够学习到没有在当前训练集文本中出现过的词的关联呢？这是因为：<strong>词嵌入向量的训练通常是在海量无标签文本上进行的，后面我们会介绍它的训练方法。</strong></p><p><strong>当训练集数量较小时，词嵌入效果往往会很明显</strong>，因为它能够大大丰富输入模型的信息量，提供了词义信息。 在其他的迁移学习情形中也一样，如果你从某一任务<strong>A</strong>迁移到某个任务<strong>B</strong>，只有<strong>A</strong>中有大量数据，而<strong>B</strong>中数据少时，迁移的过程才有用。所以对于很多<strong>NLP</strong>任务词嵌入效果明显，而对于一些语言模型和机器翻译则不然，因为他们本身数据量就很庞大。</p><h3 id="类比推理"><a href="#类比推理" class="headerlink" title="类比推理"></a>类比推理</h3><p> 词嵌入还可以帮助实现<strong>类比推理（analogy reasoning）</strong>。还是以之前的数据为例： </p><p><img src="4.png" alt="词嵌入"></p><p>使用词嵌入，我们可以发现一个有趣的性质：已知 <strong>man</strong>如果对应<strong>woman</strong>，我们可以使用<strong>词嵌入投影</strong>自动得到 <strong>king</strong>对应<strong>queen</strong> 。</p><p>我们使用man的词嵌入向量$e_{man}$减去woman的词嵌入向量$e_{woman}$，可以得到：</p><p><img src="5.png" alt="man减去woman"></p><p>我们使用king的词嵌入向量$e_{king}$减去queen的词嵌入向量$e_{queen}$，可以得到：</p><p><img src="6.png" alt="king减去queen"></p><p>可以发现，二者的差值是非常接近的。这是因为： <strong>man</strong>和<strong>woman</strong>主要的差异是<strong>gender</strong>（<strong>性别</strong>）上的差异，而<strong>king</strong>和<strong>queen</strong>之间的主要差异，根据向量的表示，也是<strong>gender</strong>（<strong>性别</strong>）上的差异 ，所以两个差值会很相近。</p><p>通过这一性质，<strong>我们可以通过某个已知词对的关系，推导出与另一个词最符合该关系的词是什么。</strong>例如，已知man和woman的关系，想要知道哪个词和king也符合该关系，只需要找到能够最大化$e_{king}-e_w$与$e_{man}-e_{woman}$的相似度的单词$w$即可。<br>$$<br>Find\ word\ w:argmax\ Sim(e_w,e_{king}-e_{man}+e_{woman})<br>$$<br>通常来说，我们在这里选用<strong>余弦相似度</strong>，即计算两个向量的余弦值，来度量两个向量$u$和$v$的相似程度：<br>$$<br>Sim(u,v)=\frac{u·v}{||u||_2||v||_2}<br>$$<br><img src="7.png" alt="余弦相似度"></p><h2 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h2><p>为了训练出词嵌入向量，我们可以使用Word2Vec模型。 Word2Vec是一种简单并且计算高效的学习词嵌入的算法。 </p><p>Word2Vec的核心思想是<strong>学习一个神经网络语言模型来训练词向量。</strong>它基于这样的一个假设：<strong>上下文相似的词，其词嵌入向量也是相似的。</strong>例如，存在以下两个句子：</p><blockquote><ol><li><p>我喜欢吃苹果。</p></li><li><p>我喜欢吃梨子。</p></li></ol></blockquote><p>我们知道，苹果和梨子的语义是非常接近的，在上述例子中，苹果和梨子的上下文也非常相似，所以我们的模型将训练得到苹果和梨子相似的词嵌入向量。</p><p>Word2Vec采用了<strong>分布式语义</strong>的方法来表示一个词的含义。本质上，一个词的含义就是这个词所处的上下文语境。回想一下我们高中做英语完形填空时，一篇短文，挖了好多空，让我们根据空缺词的上下文语境选择合适的词。也就是说上下文语境已经能够确定这个词的含义了，如果选词正确，也就意味着我们理解了这个空缺词的含义。 </p><p>Word2Vec使用的语言模型分为两类，也就是说有两种学习词嵌入的方式，分别为：</p><ul><li>如果是用一个词语作为输入，来预测它周围的上下文，那这个模型叫做<strong>『Skip-gram 模型』</strong>。</li><li>而如果是拿一个词语的上下文作为输入，来预测这个词语本身，则是 <strong>『CBOW 模型』</strong>。（就是上面完形填空的例子）</li></ul><h3 id="Skip-gram模型"><a href="#Skip-gram模型" class="headerlink" title="Skip-gram模型"></a>Skip-gram模型</h3><p>首先，我们介绍Word2Vec中的Skip-gram模型。它<strong>是用一个词语作为输入，来预测它周围的上下文。</strong></p><p>假设在训练集中给定了一个这样的句子： </p><blockquote><p><strong>I want a glass of orange juice to go along with my cereal.</strong> </p></blockquote><p>在<strong>Skip-Gram</strong>模型中，我们要做的是抽取上下文和目标词配对，来构造一个监督学习问题。我们要的做的是随机选一个词作为上下文词，比如选<strong>orange</strong>这个词，然后我们要做的是随机在一定词距（即窗口，window）内选另一个词，比如在上下文词前后5个词内或者前后10个词内，我们就在这个范围内选择目标词。<strong>于是我们将构造一个监督学习问题，它给定上下文词，要求你预测在这个词正负10个词距或者正负5个词距内随机选择的某个目标词，构造这个监督学习问题的目标并不是想要解决这个监督学习问题本身，而是想要使用这个学习问题来构造出一个好的词嵌入模型 。</strong></p><p>Skip-gram的字面含义是跳跃掉某些元，也就是在上下文窗口内随机选择某个词作为目标词，而不用考虑是否连续。</p><p>当然，我们也可以不使用随机选取目标词的做法，而是选择窗口内的<strong>每一个词</strong>作为目标词，和当前上下文词组成样本投入模型进行训练，如下图所示。这种做法的代价相应地也较高。为了解决这个问题，可以使用<em><em>subsampling </em></em>的方法，通过计算每个样本的一个保留概率，以这个概率决定是否删掉对应的样本。（实际上和随机选取窗口内的某个单词本质是一样的）</p><p><img src="8.png" alt="训练样本"></p><p>接着，我们使用一个简单的<strong>单隐藏层基本神经网络</strong>来训练出我们想要的词嵌入向量。网络的结构如下图所示：</p><p><img src="9.png" alt="Skip-gram的网络结构"></p><p>可以看到网络有以下几个细节：</p><ul><li>输入层是我们之前选择的上下文词的<strong>one-hot向量</strong>，即单词的原始表示。</li><li>隐藏层维度是<strong>自定义</strong>的，我们想要得到多少维的词嵌入向量，就可以把隐藏层设置为多少层。<strong>并且，隐藏层是线性的，没有使用非线性的激活函数，可以做到简化语言模型的目的，这也是Word2Vec的优势。</strong></li><li>输出层的维度与词汇表维度一致，使用<strong>Softmax激活函数</strong>作为分类器，输出词汇表中每一个词作为目标词的概率。</li><li>输入层、输出层、隐藏层全连接。</li></ul><p>神经网络的训练方式我已经在之前的博客中有所介绍。这里，考虑到是一个有监督的多分类问题，我们可以<strong>使用交叉熵损失函数作为模型的优化目标，并通过梯度下降法拟合模型的参数。</strong></p><p>经过训练，我们得到了模型的权重矩阵$V$和$U$。其中，从输入层到隐藏层的权重矩阵$V$中，由于输入的是one-hot向量，所以<strong>只有对应上下文词所在位置$x$的权重向量$V_x$被激活</strong>，它的维度与隐藏层单元个数是相等的，我们称其为<strong>输入向量</strong>，因为每个单词在one-hot向量中的位置不相同，使用$V_x$可以唯一地表示$x$。</p><p>从隐藏层到输出层的权重矩阵$U$中，我们也可以<strong>使用输出层中上下文词所在位置$x$的权重向量$U_x$表示$x$。</strong>同样，它的维度和隐藏层单元个数相等，我们称之为<strong>输出向量</strong>，他也可以唯一的表示$x$。</p><p>一般情况下，我们更常使用<strong>输入向量</strong>作为单词$x$的词嵌入表示。</p><p>此外，Skip-gram还可以选择多个单词作为当前上下文词的目标词，网络结构仅需微调即可，依然可以选择相同的输入向量和输出向量作为上下文词的词嵌入表示。</p><p><img src="10.png" alt="多目标词的Skip-gram的网络结构"></p><h3 id="CBOW模型"><a href="#CBOW模型" class="headerlink" title="CBOW模型"></a>CBOW模型</h3><p>CBOW模型，即<strong>连续词袋模型</strong> （Continuous Bag-Of-Words Model） ，它的预测方式和Skip-gram模型正好相反，<strong>使用一个词语的上下文作为输入，来预测这个词语本身。</strong></p><p><img src="11.png" alt="CBOW模型的网络结构"></p><p>可以看到，CBOW模型和Skip-gram模型的网络结构几乎一致，我们只需要将上述多目标词的Skip-gram的网络结构的计算反过来即可。我们依然可以<strong>使用交叉熵损失函数作为模型的优化目标，并通过梯度下降法拟合模型的参数。</strong></p><p>顺便说一下，CBOW模型的原理有些类似于Bert中的Mask，不过Bert中的Mask是在一个句子中随机遮住一些单词，用剩下的单词去预测它们，从而训练词嵌入。而CBOW模型需要预测句子中的每个词。</p><h3 id="Word2Vec的优化"><a href="#Word2Vec的优化" class="headerlink" title="Word2Vec的优化"></a>Word2Vec的优化</h3><h4 id="分级softmax分类器"><a href="#分级softmax分类器" class="headerlink" title="分级softmax分类器"></a>分级softmax分类器</h4><p>Word2Vec模型中有一个比较大的缺陷就是<strong>Softmax层的计算量太大</strong>，尤其当词汇表中的单词很多的时候。我们需要对Softmax层的所有单元计算得到的分数求指数并且求和，事实上当词汇数量达到百万、千万级别，这是很缓慢的。</p><p>针对这个问题，学者们提出了一种优化方法，叫做分级（<strong>hierarchical</strong>）softmax分类器。</p><p>分级softmax分类器的基本思想和<strong>二叉查找树</strong>有一些相近，它将原先的softmax层更换成以下的结构：</p><p><img src="12.png" alt="分级softmax分类器"></p><p>上述结构很像一个二叉查找树，树上的每一个节点都是一个sigmoid二分类器。假设我们有10000个词，即输出层有10000个单元。根节点的第一个二分类器会告诉我们结果是否在前5000个，是则进入左子树，否则进入右子树。依次类推，最终我们将定位到叶子节点，即结果是第几个单词。</p><p>根据上述方法，我们将线性时间复杂度$O(n)$降成对数时间复杂度$O(logn)$，从而加速输出层的运算。</p><p>特别地， 在实践中分级<strong>softmax</strong>分类器不会使用一棵完美平衡的分类树或者说一棵左边和右边分支的词数相同的对称树（上图编号1所示的分类树）。<strong>实际上，分级的softmax分类器会被构造成常用词在顶部，然而不常用的词像durian会在树的更深处（上图编号2所示的分类树）。</strong>具体实现通常采用数据结构中的常用结构<strong>哈夫曼树</strong>。</p><h4 id="负采样"><a href="#负采样" class="headerlink" title="负采样"></a>负采样</h4><p>Word2Vec模型的训练样本很多，如果对于每一个训练样本，都更新所有参数，那么训练速度将会很慢。为此，学者们提出了<strong>负采样（Negative Sampling）</strong>的方法，来减少每次训练所更新的样本个数。</p><p>我们将定义新的监督学习问题：<strong>给定一个单词对（比如orange和juice），预测这两个单词是否是context-target对。</strong>也就是<strong>将原先的softmax多分类转化为了逻辑回归的sigmoid多分类（one vs all）。假设词汇表中有10000个单词，相当于我们构造了10000个独立的逻辑回归模型。</strong></p><ul><li>首先我们产生一个正样本（Positive Example），正样本的生成方法和skip-gram中类似，选择一个context单词，在一个windows大小附近随机选择一个target单词。比如上例语句中的orange和juice，我们把正样本标记为1。</li><li>然后使用相同的context，生成负样本（Negative Example），负样本的对应的单词从词汇表里随机选取，比如生成一个负样本orange-king，并将负样本标记为0。同样的方法，生成更多更多的负样本，可能是：orange-book, orange-the, orange-or。由于是随机选择的，我们总认为是负样本，<strong>因此即便上面的orange-of的例子，of其实是Orange的target，我们依然标记为0</strong>。最终形成如下记录： </li></ul><p><img src="13.png" alt="负采样"></p><p> 一个正样本，会选择多个负样本，其个数记为k，<strong>在较小数据集下k通常推荐取5-20，如果数据集较大，则k取值较小，比如2-5</strong>。 </p><p>我们为10000个词分别构建独立的逻辑回归模型（也就是one vs all的多分类方法），然后每次训练时更新正负样本的模型参数。<strong>这样，我们每次迭代并不需要训练原先10000维softmax层那么多的参数（300万个参数），而是只需要训练5个逻辑回归模型的参数（1500个参数），训练的计算量大大降低。</strong></p><p>怎样选择负样本？ 这个算法有个重要细节是如何选择负样本，一种办法是根据每个单词在语料库中的经验概率进行采样，但会导致常用词被采样的频率很高；还有一种是均匀分布的采样，完全不考虑单词的实际频率。负采样中，<strong>负样本被选中的概率和词频成正比</strong>，词频越大的词被选中的概率越大。概率公式如下:<br>$$<br>p(w_i)=\frac{f(w_i)^{3/4}}{\sum_{j=1}^{10000}f(w_j)^{3/4}}<br>$$<br>其中$f(w_i)$是一个单词在语料库中的观测频率。通过取3/4次方，使得既考虑到单词的语料库频率，又能增加低频单词被选取的概率。 </p><h2 id="GloVe"><a href="#GloVe" class="headerlink" title="GloVe"></a>GloVe</h2><p>之前已介绍了几个词嵌入的算法，NLP领域还有一个有一定势头的算法<strong>GloVe（global vectors for word representation）</strong>，虽然并不如Word2Vec或skip-gram常用，但足够简单。</p><h4 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h4><p><strong>我们使用$X_{ij}$代表单词i出现在单词j的上下文的次数</strong>。因此$X_{ij}$，就表示单词i和j一起出现的<strong>频繁程度。</strong>使用窗口将整个训练文本遍历一遍，即可得到共现矩阵$X$。</p><p>如果定义上下文的含义是在10个单词前后范围内，显然可以得出$X_{ij}=X_{ji}$，即<strong>对称性</strong>。如果定义上下文是紧挨着的前一个单词，则没有对称性。但对于GloVe，我们一般选择前者的定义。</p><p>我们定义模型的优化目标为（具体推导参见<a href="https://blog.csdn.net/coderTC/article/details/73864097" target="_blank" rel="noopener"> https://blog.csdn.net/coderTC/article/details/73864097 </a>）：<br>$$<br>J=\sum_i^n\sum_j^nf(X_{ij})(θ^t_ie_j+b_i+b_j−log(X_{ij}))^2<br>$$<br>通过最小化上式，可以学习到一些向量，能够对两个单词同时出现的频率进行预测。另外，式中的$f(X_{ij})$有两个作用：</p><ul><li>当$X_{ij}=0$时，$log(X_{ij})$为无穷大，无法计算。此时定义$f(X_{ij})=0$，即对这样的情况不纳入计算。换句话说，<strong>至少要求两个词同时出现过一次。</strong></li><li>另外，<strong>作为权重，调节常用和非常用单词的计算权重</strong>。既不给常用词过大的权重，也不给非常用词过小的权重。这一块详细参考GloVe的论文。</li></ul><p>另外，由于GloVe的对称性，所以$\theta$和$e$是对称的，或者说在优化目标中起的作用是一样的，因此最终我们通常将它们的均值作为最终的词向量，即：<br>$$<br>e_w^{final}=\frac{e_w+\theta_w}{2}<br>$$<br>虽然GloVe算法的优化函数非常简单（仅是一个二次代价函数），但结果确实奏效，可以学习到良好的词嵌入。</p><h2 id="ELMO"><a href="#ELMO" class="headerlink" title="ELMO"></a>ELMO</h2><p>Word2Vec和GloVe虽然是最常用的几种词嵌入模型之一，但他们也存在着一个严重的缺陷，<strong>即假设每个单词只有一个词义。</strong>换句话说，Word2Vec<strong>无法针对每个单词的不同词义分类讨论。</strong>而多义词往往是非常常见的，我们仅以一个词嵌入向量来描述它不够合理。例如，我们有一个单词“包袱”，存在着以下的句子：</p><blockquote><p>他背起包袱向远方走去。</p></blockquote><p>以及另一个句子：</p><blockquote><p>他的相声说的很好，经常都抖出有趣的包袱。</p></blockquote><p>可以看到，同一个词“包袱”在不同的语境下，含义迥然不同。上述例子中，我们称不同句子中的“包袱”为同一个Type，却是不同的Token。</p><p><strong>为了解决上述缺陷，学者们提出了ELMO模型（Embedding from Language Model），从而实现了上下文化的词嵌入（Contextual Word Embedding），也就是针对Token进行词嵌入。这样，即使是同一个单词，所在的上下文语境不同，其词嵌入向量也不同，解决了Word2Vec对多义词处理的不足。</strong></p><p>ELMO模型的训练方法是采用基于RNN（循环神经网络）的语言模型。更详细一些，<strong>是使用双向LSTM语言模型，并采用Word2Vec词嵌入向量作为模型的输入，训练得到ELMO词嵌入。</strong></p><p>ELMO模型的架构如下图所示：</p><p><img src="14.png" alt="ELMO模型"></p><p>BRNN和LSTM的知识在我的神经网络序列模型的博客中已经有所介绍。<strong>这个Bi-LSTM语言模型就是通过已知的前面所有的单词和后面所有的单词，预测出当前位置正确的单词，即最大化当前位置正确单词的条件概率。这个最优化问题可以使用softmax的交叉熵损失函数求解。</strong></p><p>需要注意的是，这里使用的Bi-LSTM-LM是多层的，即为Deep-Bi-LSTM-LM。<strong>我们选取第k个时间步每一层的LSTM单元输出，加权求和，最后乘以当前句子的权重，即为当前句子第k个词的ELMO词嵌入向量，其维度与LSTM单元隐藏层的维度的两倍一致（每层LSTM单元激活值输出是对前向和后向传播来的激活值的拼接，所以是两倍）。</strong>示意图可以参考李宏毅老师的PPT：</p><p><img src="15.png" alt="ELMO词嵌入计算"></p><p>具体计算公式如下图所示：<br>$$<br>ELMO^{task}_k=\alpha^{task}\sum_{j=0}^LS_j^{task}h^{LM}_{k,j}<br>$$<br>对于第task句子的第k个词，其ELMO向量表达为：每个句子独特的权重$\alpha^{task}$乘以从0到$L$层每层的权重$S_j^{task}$乘以该层的激活值输出$h^{LM}_{k,j}$的总和。</p><p>这里，$h^{LM}_{k,j}$在第0层即为模型输入的Word2Vec词嵌入向量。第1到$L$层的$h^{LM}_{k,j}$为该位置前向和后向传播而来的激活值的拼接。</p><p>为什么需要对不同层的输出乘以不同的权重呢？因为研究人员发现：<strong>不同层的Embedding适用于不同的任务。 总体而言，ELMO模型每层学到的东西是不一样的，所以将他们叠加起来，对任务有较好的的提升</strong>。 试验结果表明：<strong>上层Embedding对语义理解更好，而下层对词性、词法理解更好</strong>。$S_j^{task}$可以根据不同的任务自己设定。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是常规的预训练语言模型Word2Vec、GloVe和ELMO的基本知识了，我在这里粗略的对他们进行了总结。事实上，目前最好的预训练模型是谷歌的BERT模型，我即将在下一篇博客介绍它的原理。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 预训练模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：神经网络序列模型</title>
      <link href="/2020/04/05/nlp-zi-xue-bi-ji-shen-jing-wang-luo-xu-lie-mo-xing/"/>
      <url>/2020/04/05/nlp-zi-xue-bi-ji-shen-jing-wang-luo-xu-lie-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>序列模型（Sequence Model）是深度学习最令人激动的领域之一。循环神经网络（Recurrent Neural Network, RNN）也已变革了语音识别（Speech Recognition）、自然语言处理（Natural Language Process, NLP）等领域。</p><p>本文是我在学习吴恩达深度学习课程中的序列模型一章的总结与思考，同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己对于该模型的理解，如有错误欢迎在评论区指出，非常感谢！</p><h2 id="从问题出发"><a href="#从问题出发" class="headerlink" title="从问题出发"></a>从问题出发</h2><p>与之前的讲解类似，我们在这里依旧围绕自然语言处理中的经典问题<strong>词性标注问题</strong>进行讨论和解释。</p><ul><li>给定一个句子X，输出句子中每一个单词对应的词性。</li></ul><p><img src="1.png" alt="词性标注任务"></p><h2 id="什么是序列模型"><a href="#什么是序列模型" class="headerlink" title="什么是序列模型"></a>什么是序列模型</h2><p>序列模型（Sequence Model）的相关知识我已经在之前的博客中有所介绍，常规机器学习方法中的隐马尔可夫模型和条件随机场模型都可以用来解决序列标注问题，它们其实就是一类序列模型。<strong>深度学习的序列模型近年来已经成为自然语言处理的最重要模型之一，主要包括循环神经网络（RNN）以及它的一些变体（LSTM、GRU等）。</strong></p><p>序列模型指的是<strong>模型的输入X或者输出Y是一个序列</strong>，例如：词性标注任务中，输入可以是连续的单词组成的句子，而输出可以是句子各单词的词性序列。</p><p>下面是一些序列模型适用的例子，可以看到，它不仅适用于自然语言处理的相关任务，还在计算机视觉、语音识别等领域应用广泛。</p><p><img src="1.jpg" alt="常用序列模型"></p><p>这些问题都可以通过有监督的学习（Supervised Learning），通过给定样本的特征向量X和标签Y进行训练。<strong>这几个例子的区别是，有些是X和Y都是序列数据，有些只有X或Y是序列数据，另外有些X和Y虽然都是序列数据，但序列的长度并不相等</strong>。 </p><p><img src="2.jpg" alt="序列模型的分类"></p><p>可以看到：</p><ul><li>语音识别、DNA序列分析和命名实体识别任务的输入X和输出Y都是序列数据，且序列长度相等。</li><li>机器翻译的输入X和输出Y都是序列数据，但序列长度不一定相等。因为一句英文文本经过翻译后，所得到的中文文本所含单词数不一定是一样的。</li><li>情感分析和视频行为识别的输入X是序列数据，而输出Y只有一个维度，即情感的类别或者行为的类别。</li><li>音乐生成任务的输出Y是序列数据（一段音乐），而输入X 可以是空集，也可以是个单一的整数，这个数可能指代你想要生成的音乐风格，也可能是你想要生成的那首曲子的头几个音符。 </li></ul><p>后面我们将知道，<strong>这些不同类别的序列模型都可以使用同一个深度学习模型来解决，那就是循环神经网络模型（RNN），我们只需要对它进行一些结构上的调整即可。</strong></p><h2 id="什么是循环神经网络"><a href="#什么是循环神经网络" class="headerlink" title="什么是循环神经网络"></a>什么是循环神经网络</h2><h3 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h3><p>首先，我们定义一些接下来的讲解中需要使用到的符号：</p><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">$x^{(i)\langle t \rangle}$</td><td align="center">第$i$个输入序列的第$t$个序列元素，即第$i$个输入句子的第$t$个单词</td></tr><tr><td align="center">$y^{(i)\langle t \rangle}$</td><td align="center">第$i$个输出序列的第$t$个序列元素，即第$i$个句子的词性标注结果的第$t$个词性</td></tr><tr><td align="center">$T_x^{(i)}$</td><td align="center">第$i$个输入序列的长度 ，即第$i$个句子的单词数目（每条数据的序列长度可以不一样）</td></tr><tr><td align="center">$T_y^{(i)}$</td><td align="center">第$i$个输出序列的长度 ，即第$i$个句子的词性数目（词性标注任务中：$T_x^{(i)}=T_y^{(i)}$）</td></tr></tbody></table><p>以词性标注任务为例，上述符号的含义如下图所示：</p><p><img src="2.png" alt="符号示意"></p><h3 id="如何表示词"><a href="#如何表示词" class="headerlink" title="如何表示词"></a>如何表示词</h3><p>接下来，我们需要考虑的问题是<strong>怎么表示输入序列（也就是句子）中的词</strong>。在这里，我们先使用一种最为简单的方法，也就是<strong>one-hot表示法</strong>，来表示句子中的词。这个方法无法捕捉词语本身丰富的语义信息。日后，我将介绍一些预训练的语言模型，如<strong>Word2Vec和Bert</strong>等，<strong>它们通过词嵌入（Word Embedding）的方法使用词嵌入向量表示词，捕捉了词语的含义和词间的关系，替换one-hot向量作为深度学习模型的输入，刷新了NLP中许多任务的最佳表现。</strong></p><p>one-hot表示法在我的对数线性模型博客中有所介绍，它是表示离散特征的一种方法。使用它来表示单词，我们需要进行以下几步：</p><ol><li>建立一个向量，包含常用的词汇，形成一个<strong>词汇表（vocabulary）</strong> 。词汇表的大小是人为设定的，这里，我们使用10,000个单词来构建我们的词汇表。 对于一般规模的商业应用来说30,000到50,000词大小的词典比较常见，但是100,000词的也不是没有，而且有些大型互联网公司会用百万词，甚至更大的词典。 </li><li>接下来，我们为单词建立one-hot向量，假如一个词在词汇表中的序号为1234，那么它的one-hot向量就是在1234行为1，其余行均为0的10000维列向量。</li><li>特别地，我们需要考虑<strong>未登录词、开始标记、结尾标记</strong>等情况。未登录词指的是不在词汇表中的单词，我们需要在词汇表添加标记\UNK来表示它们。此外，在构建语言模型、进行机器翻译等过程中，我们还需要使用到开始标记、结尾标记，它们表示的是句子的开始、结尾位置。例如，一旦语言模型生成了结尾标记，我们就可以认为句子生成完毕。我们在词汇表中添加\Start和\End来表示他们。</li></ol><p>下图是吴恩达老师课件中的例子：</p><p><img src="3.png" alt="词的one-hot表示"></p><h3 id="循环神经网络模型的基本结构"><a href="#循环神经网络模型的基本结构" class="headerlink" title="循环神经网络模型的基本结构"></a>循环神经网络模型的基本结构</h3><p>在介绍循环神经网络之前，我们尝试利用最简单的标准神经网络——反向传播神经网络（BPNN）来进行序列标注。我们可以将句子中的所有词的one-hot向量拼接作为标准神经网络的输入，经过若干隐藏层后输出词性标注结果，如下图所示：</p><p><img src="4.png" alt="标准神经网络"></p><p>但这个神经网络只适用于单个词的词性标注（分类问题），而不适用于整个句子的词性标注（序列标注，结构化分类问题），主要原因有以下几种：</p><ul><li>不同的句子的长度不一样，意味着<strong>BPNN的输入层和输出层维度需要不断地改变。</strong></li><li>更重要的是，<strong>BPNN无法共享从文本的不同位置上学到的特征。</strong> 比如网络学习到Harry在第一个位置可能是名词，但在其他位置却无法识别了。我们希望模型能够像卷积神经网络一样，在图像上某一个位置检测到的边缘特征能够应用到其他位置上。 </li><li>还有一点是<strong>模型的参数过于庞大，计算量太大</strong>。因为每个单词都是10000维的one-hot向量，输入层和输出层的单元太多。</li></ul><p><strong>为了解决BPNN在序列化标注问题中的缺陷，科学家们提出了一种神经网络的序列模型：循环神经网络模型（Recurrent Neural Network Model）</strong>。</p><p><img src="5.png" alt="循环神经网络"></p><p>其中，每个时间步（time step，也就是序列的每个状态）的RNN单元如下图所示：</p><p><img src="6.png" alt="基本的RNN单元"></p><p>可以看到：<strong>每个时间步的RNN单元，其实都是一个简单的单隐藏层BPNN。为了增强模型的表示能力，隐藏层使用tanh激活函数（Activation Function）增加非线性（这里有个疑问：为什么RNN中tanh比ReLU更常用呢）；为了计算当前时间步各词性的概率进行分类预测，输出层使用softmax激活函数进行概率归一化。</strong>上图右侧的公式即为RNN的前向传播公式（ Forward Propagation）。 </p><p>RNN的特别之处在于：当$x^{\langle t \rangle}$输入到当前时间步对应的RNN单元时，同时会将上一个时间步RNN单元的隐藏层的激活值$a^{\langle t-1 \rangle}$加入计算。特别的，第一层的激活值输入$a^{\langle 0 \rangle}$一般是定义为0向量。 也就是说，<strong>对于每一个时间步的预测，其输入信息不仅来自于当前序列元素$x^{\langle t \rangle}$，还间接来自于之前的所有序列元素（因为输入了$a^{\langle t-1 \rangle}$）</strong>。</p><p>上述RNN解决了BPNN用于序列标注的缺陷：</p><ul><li><strong>每个时间步的RNN单元，其输入、输出的维度都是一致的。</strong>例如我们使用单隐藏层RNN单元，隐藏层的神经元数目设为100，则$a^{\langle t-1 \rangle}$为100维列向量，$x^{\langle t \rangle}$为10000维的one-hot向量，每个RNN单元的输入固定为10100维，输出的维度与训练集中的词性数目相等。对于不同长度的输入序列，我们只需要修改RNN单元的个数即可。</li><li><strong>每一个时间步的RNN单元共享参数，即可以共享从文本的不同位置上学到的特征</strong>，也就是上面循环神经网络示意图中的三个参数矩阵$W_{aa}$,$W_{ax}$,$W_{ya}$和对应的偏差项（bias）。</li><li><strong>模型的参数量减少了。</strong>RNN中我们只有三组固定大小的参数，而原先的BPNN光是输入层和第一个隐藏层之间的全连接都需要大量参数，因为BPNN输入的每个词的one-hot向量之间不共享参数矩阵。</li></ul><p>需要注意的是，这里只是画了一个最基本的RNN，只有一个隐藏层，实际上，我们可以加大隐藏层数量，形成深度RNN（Deep RNN）。 对于标准CNN来说，可以有很多层，比如100个隐藏层，<strong>但对RNN来说3层就已经很深了</strong>，因为RNN还有很长的时间维度（temporal dimension），即便3层RNN的训练难度也很大。  </p><p><img src="7.png" alt="深度RNN"></p><h3 id="循环神经网络模型的反向传播"><a href="#循环神经网络模型的反向传播" class="headerlink" title="循环神经网络模型的反向传播"></a>循环神经网络模型的反向传播</h3><p>在上一节，我们已经介绍了RNN前向传播的基本流程。<strong>每一个时间步的RNN单元使用上一个时间步传来的激活值和当前序列元素的输入进行一次或多次全连接层运算，最后所得的激活值，一方面继续传给下一个时间步，另一方面输入softmax层计算当前序列元素的标注输出。</strong>具体过程如下图所示：</p><p><img src="8.png" alt="RNN前向传播示意图"></p><p>接下来，我们需要定义模型的损失函数，以便进行梯度下降优化，拟合出特征权重参数。</p><p>与常规的Softmax输出层的BPNN类似，我们在这里定义第$t$个时间步的损失函数为<strong>交叉熵损失函数</strong>（Cross Entropy Loss）：<br>$$<br>Loss^{\langle t \rangle}(\hat y^{(i)\langle t \rangle},y^{(i)\langle t \rangle})=- y^{(i)\langle t \rangle}log (\hat y^{(i)\langle t \rangle})<br>$$<br>整个序列的损失函数定义为<strong>各时间步损失函数之和</strong>：<br>$$<br>Loss(\hat y^{(i)},y^{(i)})=\sum_{t=1}^{T_x^{(i)}}Loss^{\langle t \rangle}(\hat y^{(i)\langle t \rangle},y^{(i)\langle t \rangle})<br>$$<br>接下来，便可以使用各种凸优化方法进行迭代计算，求解最优参数。假设我们使用梯度下降算法进行参数拟合，那么各参数的梯度反向传播计算如下所示：</p><p><img src="9.png" alt="RNN反向传播示意图"></p><p>上述反向传播可以自己推导一遍，加深印象。<strong>反向传播的推导并不复杂，它其实就是一种动态规划算法，状态转移方程中使用了求导的链式法则而已。</strong></p><p>具体的梯度计算公式<strong>（我推的不是最简形式，最简形式可以参考前向传播公式自己化简）</strong>如下：<br>$$<br>\frac{dLoss^{(i)}}{dW_{ya}}=\sum_{t=1}^{T_x^{(i)}}\frac{dLoss^{(i)\langle t \rangle}}{d \hat y^{(i)\langle t \rangle}}\frac{d \hat y^{(i)\langle t \rangle}}{dW_{ya}}……(1)<br>$$</p><p>$$<br>\frac{dLoss^{(i)}}{dW_{aa}}=\sum_{t=1}^{T_x^{(i)}}\sum_{k=1}^{t}\frac{dLoss^{(i)\langle t \rangle}}{d \hat y^{(i)\langle t \rangle}}\frac{d \hat y^{(i)\langle t \rangle}}{da^{\langle t \rangle}}(\prod_{j=k+1}^t\frac{da^{\langle j \rangle}}{da^{\langle j-1 \rangle}})\frac{da^{\langle k \rangle}}{dW_{aa}}……(2)<br>$$</p><p>$$<br>\frac{dLoss^{(i)}}{dW_{ax}}=\sum_{t=1}^{T_x^{(i)}}\sum_{k=1}^{t}\frac{dLoss^{(i)\langle t \rangle}}{d \hat y^{(i)\langle t \rangle}}\frac{d \hat y^{(i)\langle t \rangle}}{da^{\langle t \rangle}}(\prod_{j=k+1}^t\frac{da^{\langle j \rangle}}{da^{\langle j-1 \rangle}})\frac{da^{\langle k \rangle}}{dW_{aa}}……(2)<br>$$</p><h2 id="循环神经网络的不同架构"><a href="#循环神经网络的不同架构" class="headerlink" title="循环神经网络的不同架构"></a>循环神经网络的不同架构</h2><p>我们在之前提到了许多不同的序列任务都可以使用RNN来完成，我们只需要调整RNN的结构。自然语言处理中，主要的序列任务可以分为以下几类：</p><ol><li>One to many：一对多，如语言模型（Language Model），主要用于文本生成，如AI写诗等，我们通常只给出一个开头的字或词，让语言模型帮我们生成完整的句子序列。</li><li>Many to one：多对一，如文本分类，我们通常给出一个句子序列，让语言模型输出其类别。</li><li>Many to Many（$T_x=T_y$）：输入输出序列长度相等的多对多，如词性标注任务。</li><li>Many to Many（$T_x!=T_y$）：输入输出序列长度不相等的多对多，如机器翻译。</li></ol><p>在前面的几节，我们以词性标注为例，给出了输入输出序列长度相等的多对多RNN模型的基本结构，更多的结构如下图所示：</p><p><img src="10.png" alt="不同类型的RNN"></p><ul><li>左下角就是之前接触的最基本的RNN，Many to many并且$T_x=T_y$。</li><li>Many to one结构，与标准结构相比，<strong>将每个时间步的输出都去除，只保留最后一步的输出。</strong></li><li>One to one结构，就是标准神经网络。</li><li>One to many结构，<strong>仅在第一个时间步输入唯一的序列数据，接下来每一个时间步的输入都来自上一步的输出（Ngram语言模型）。</strong></li><li>Many to many并且$T_x!=T_y$。则将输入时间步和输出时间步完全拆分。前半部分称之为<strong>编码器（encoder）</strong>，后半部分称之为<strong>解码器（decoder）</strong>。例如，机器翻译任务中，前半部分将源文本进行编码，并将编码所得结果输入后半部分的解码器。后半部分的解码器其实就是一个语言模型，采用集束搜索（Beam Search）等方式选择出生成的最大概率序列作为翻译的结果。</li></ul><h2 id="双向循环神经网络"><a href="#双向循环神经网络" class="headerlink" title="双向循环神经网络"></a>双向循环神经网络</h2><p>在实际预测中，我们可能<strong>不仅需要当前时间步之前的信息，也需要当前时间步之后的信息。</strong>例如，一个单词被预测为名词，可能不仅与前一个单词是什么有关，也与后一个单词是什么有关。我们在之前提出的RNN架构，只能使用到之前时间步的信息，为了解决这个缺陷，我们可以使用双向循环神经网络（BRNN）。</p><p>我在这里借用吴恩达的PPT：</p><p><img src="11.png" alt="BRNN"></p><p>如上图所示，BRNN首先包含了前向RNN的基本架构，接着为每个时间步添加反向循环单元。最后，每个时间步的预测输出，需要同时考虑前向激活函数和反向激活函数。</p><p>BRNN中，每个时间步的预测输出要等所有序列扫描结束后才能输出。但这也造成了一个弱点，比如语音识别，需要等用户说完一整句才开始识别，所以真正的实时语音识别，会使用更为复杂的模块，而不是仅使用BRNN。 </p><h2 id="循环神经网络中的梯度消失和梯度爆炸"><a href="#循环神经网络中的梯度消失和梯度爆炸" class="headerlink" title="循环神经网络中的梯度消失和梯度爆炸"></a>循环神经网络中的梯度消失和梯度爆炸</h2><p>我们在之前已经介绍了RNN中的梯度反向传播计算，与其他深度学习的神经网络一样， <strong>RNN也面临梯度消失（vanishing gradients）和梯度爆炸（exploding gradients）</strong> 的问题，尤其是梯度消失的问题，更难解决。 </p><p>首先，我们来看RNN单元隐藏层中最为常用的激活函数tanh的函数曲线以及它的导数曲线：</p><p><img src="12.png" alt="tanh函数曲线和导数曲线"></p><p>可以看到，<strong>tanh的导数值取值范围位于闭区间[0,1]上</strong>。</p><p>在一个最基本的BPNN中，反向传播计算各参数的梯度时，需要使用到权重值、激活函数的导数以及预测值和真实值的误差。 如果我们使用正态分布初始化权重w，那么w都是0-1之间的小数，而tanh激活函数的导数也是0-1之间的数，<strong>经过反向传播的连乘后，随着相距的层数增加，连乘的次数也将被多，结果会变的很小，导致梯度消失</strong>。若我们初始化的w是很大的数，大到乘以激活函数的导数都大于1，那么经过多次连乘后，可能会导致求偏导的结果很大，形成<strong>梯度爆炸</strong>。 </p><p>事实上，tanh激活函数已经算比较好了，如果你使用sigmoid激活函数，那么它的导数值取值范围为[0,0.25]，更容易造成<strong>梯度消失问题</strong>。事实上，比较好的一种激活函数为ReLu激活函数（修正线性单元），它的导数值永远只有0或者1，所以可以很好地解决梯度消失问题。（疑问： RNN 中一个经典的问题是如何避免梯度消失。造成这个问题的一个很重要原因是采用了 tanh 作为激活函数，很容易造成梯度消失问题。所以为什么不换成ReLU呢？）</p><p>我们再回头看一看RNN的反向传播公式：</p><p><img src="9.png" alt="RNN反向传播示意图"></p><p>RNN 中的梯度消失/梯度爆炸和普通的 MLP 或者深层 CNN 中梯度消失/梯度爆炸的含义不一样。MLP/CNN 中不同的层有不同的参数，各是各的梯度；而 RNN 中同样的权重在各个时间步共享，最终的梯度为各个时间步的梯度的和。 所以，<strong>RNN 中总的梯度是不会消失的。即便因为连乘的原因梯度越传越弱，那也只是远距离的梯度消失，由于近距离的梯度不会消失，所有梯度之和便不会消失。RNN 所谓梯度消失的真正含义是，梯度被近距离梯度主导，导致模型难以学到远距离的依赖关系。（可以参考反向传播那一节的式（2）和式（3）理解，当k和t距离越远时，连乘的次数将越多）</strong> </p><p>梯度爆炸比较容易解决，我们可以使<strong>用梯度剪切（gradient clipping）</strong>，即梯度如果超过一定阈值，则缩放梯度。 </p><p><img src="13.png" alt="梯度剪切"></p><p><strong>相对而言，梯度消失问题很难解决，这导致后面的时间步的输出很难通过反向传播影响到前面的参数计算，从而使RNN难以捕捉长距离的依赖。而在自然语言处理任务中，长距离依赖通常是比较重要的，能够很大地影响模型的性能。</strong></p><p>为了解决梯度消失问题，科学家们在基本RNN的基础上提出了改进，<strong>将基本的RNN单元修改为使用了门（Gate)来控制记忆的长短期记忆单元（LSTM）和门控循环单元（GRU）</strong>。</p><h2 id="门控循环单元"><a href="#门控循环单元" class="headerlink" title="门控循环单元"></a>门控循环单元</h2><p>门控循环单元（Gated Recurrent Unit，GRU），<strong>是在基本RNN单元的基础上改进，帮助RNN缓解（无法解决）梯度消失问题，从而更好的捕捉长距离依赖</strong>。 它其实是长短期记忆单元的简化版，这里我们先介绍简单的版本。</p><p>我们以一个语言模型为例，假设我们需要构建一个语言模型根据训练文本自动生成句子，有如下两个句子：</p><blockquote><p>The ==cat==, which already ate …., ==was== full. The ==cats==, which already ate …., ==were== full. </p></blockquote><p> 中间是一个很长的从句，结尾处谓语（be）的形式要根据最开始的主语（cat）的单复数决定。这说明语言中经常会有<strong>长距离的依赖</strong>。但基本的RNN对这种问题的处理效果并不好，它无法捕捉到这种长距离依赖。 </p><p>首先，我们给出吴恩达老师画出的基本RNN单元（这里的$W_a$和$b_a$由原先的$W_{ax}$、$W_{aa}$和$b_{ax}$、$b_{aa}$堆叠而成，方便表述）： </p><p><img src="14.png" alt="基本RNN单元"></p><p>GRU经引入一个新的变量$c$，作为<strong>记忆细胞（Memory Cell）</strong>，其作用是提供一定比特的记忆，比如上例中记忆cat是单数还是负数。在时间$t$，记忆细胞的值记为$c^{\langle t \rangle}$。在GRU中，虽然输出的激活函数$a^{\langle t \rangle}$总是和$c^{\langle t \rangle}$相等，但我们还是提供两个标记区别，主要是为了和后面LSTM保持标记的统一性。 </p><p>接下来是GRU的公式：</p><p>首先是$\widetilde{c}$，代表将用于替换$c^{\langle t \rangle}$的候选（candidate）值：<br>$$<br>\widetilde{c}^{\langle t \rangle}=tanh(W_c[c^{\langle t-1 \rangle},x^{\langle t \rangle}]+b_c)<br>$$<br>接着，我们引入GRU的重要思想——门（Gate），我们用$Γ_u$表示 ：<br>$$<br>Γ_u=\sigma(W_u[c^{\langle t-1 \rangle},x^{\langle t \rangle}]+b_u)<br>$$<br>这里的$Γ_u$代表的是<strong>更新门（update Gate），激活函数$\sigma$使用sigmoid函数，从而使更新门的取值缩放到[0,1]，它表示的是当前时间步更新记忆细胞$c^{\langle t \rangle}$的程度</strong>，越接近1，表示更新的程度越大，具体公式如下：<br>$$<br>c^{\langle t \rangle}=Γ_u \times \widetilde{c}+(1-Γ_u) \times c^{\langle t-1 \rangle}<br>$$<br>上述公式究竟有什么用呢？ 前面说$\widetilde{c}$只是候选，是因为决定权在于$Γ_u$，$Γ_u$决定了什么时候去更新$c^{\langle t \rangle}$。对应上面的例子，<em><em>这个机制可能就是，从读取到cat开始，就一直在$c^{\langle t \rangle}$记录着主语是单数，直到遇到谓语was，$c^{\langle t \rangle}$认为就没必要再记录下去了，即开始更新$c^{\langle t \rangle}$。 </em></em></p><p><img src="15.png" alt="更新门的作用"></p><p> 把上述GRU单元的公式，它的结构用图表示如下： </p><p><img src="16.png" alt="基本GRU"></p><p>可以看到，<strong>GRU仅仅使用了一个门就实现了更新记忆细胞和遗忘记忆细胞，也就是让$(1-Γ_u)$控制遗忘的程度。而LSTM中使用了独立的遗忘门（forget gate）来控制遗忘，所以参数更多一些，训练起来也更慢。</strong></p><p>通过使用更新门，我们可以<strong>选择性的更新记忆细胞</strong>（在GRU中就是上一个时间步的隐藏层激活值输出，包含了前面所有时间步内的信息）。<em><em>当更新门$Γ_u$的值总为0时，相当于保持了记忆，在我们的例子中，就是在谓语was的时间步和主语cat的时间步之间开辟了一条直达的远距离路径。 梯度在这条路径上可以无损地传递，从而不会消失。这有些类似于CNN的 ResNet 中的跳跃连接（short cut）。 </em></em></p><p>此外，完整的GRU单元还设置了一个相关门 （Relevance Gate，也叫重置门Reset Gate） $Γ_r$，用于表示$\widetilde{c}$和$c^{\langle t -1 \rangle}$的相关性：<br>$$<br>Γ_r=\sigma(W_r[c^{\langle t-1 \rangle},x^{\langle t \rangle}]+b_r)<br>$$<br>候选值$\widetilde{c}$的计算公式修改为：<br>$$<br>\widetilde{c}^{\langle t \rangle}=tanh(W_c[Γ_r \times c^{\langle t-1 \rangle},x^{\langle t \rangle}]+b_c)<br>$$<br> 完整的GRU内部结构如下图所示：</p><p><img src="17.png" alt="完整GRU"></p><h2 id="长短期记忆单元"><a href="#长短期记忆单元" class="headerlink" title="长短期记忆单元"></a>长短期记忆单元</h2><p><strong>长短期记忆单元（Long Short Term Memory）可以看作是门控循环单元GRU的复杂版</strong>。事实上， 在深度学习的历史上，<strong>LSTM</strong>也是更早出现的，而<strong>GRU</strong>是最近才发明出来的，它可能源于<strong>Pavia</strong>在更加复杂的<strong>LSTM</strong>模型中做出的简化。 </p><p>以下为GRU和LSTM二者的公式对比：</p><p><img src="18.png" alt="GRU和LSTM"></p><p>可以看到，GRU的主要特点在于：</p><ul><li><p>$a^{\langle t \rangle}$总是和$c^{\langle t \rangle}$相等。</p></li><li><p>使用了两个门，即更新门$Γ_u$和相关门$Γ_r$。</p></li></ul><p>而LSTM相对于GRU的变化在于：</p><ul><li>$a^{\langle t \rangle}$和$c^{\langle t \rangle}$不相等。</li><li>使用了三个门：<ul><li>去掉了用于计算候选值$\widetilde{c}$的相关门$Γ_r$。</li><li>增加了用于控制遗忘的遗忘门（Forget Gate）$Γ_f$，替换了GRU中的$1-Γ_r$。</li><li>增加了用于计算$a^{\langle t \rangle}$的输出门$Γ_o$。</li></ul></li></ul><p>完整的LSTM单元如下图所示：</p><p><img src="19.png" alt="完整LSTM单元"></p><p>完整的LSTM网络如下图所示：</p><p><img src="20.png" alt="完整LSTM网络"></p><p>可以看到，LSTM网络中，梯度的传播相较于基本RNN多了许多路径。其中，<strong>有一条贯穿$c^{\langle t \rangle}$的”高速公路“</strong>。与CNN的 ResNet 中的跳跃连接（short cut）类似，在这条路径上，<strong>假设遗忘门$Γ_f$保持等于1，那么梯度将无损地在需要进行远距离依赖的时间步间传输</strong>。 由于总的远距离梯度 = 各条路径的远距离梯度之和，即便其他远距离路径梯度消失了，只要保证有一条远距离路径梯度不消失，总的远距离梯度就不会消失（正常梯度 + 消失梯度 = 正常梯度）。因此 LSTM 通过改善<strong>一条路径</strong>上的梯度问题拯救了<strong>总体的远距离梯度</strong>。 </p><p><strong>另外需要强调的是</strong>，LSTM除了在结构上天然地克服了梯度消失的问题，更重要的是具有更多的参数来控制模型；通过四倍于RNN的参数量，可以更加精细地预测时间序列变量。 </p><h2 id="GRU与LSTM的比较"><a href="#GRU与LSTM的比较" class="headerlink" title="GRU与LSTM的比较"></a>GRU与LSTM的比较</h2><p>吴恩达老师的原话：</p><blockquote><p><strong>GRU</strong>的优点是这是个更加简单的模型，所以更容易创建一个更大的网络，而且它只有两个门，在计算性上也运行得更快，然后它可以扩大模型的规模。</p></blockquote><blockquote><p>但是<strong>LSTM</strong>更加强大和灵活，因为它有三个门而不是两个。如果你想选一个使用，我认为<strong>LSTM</strong>在历史进程上是个更优先的选择，所以如果你必须选一个，我感觉今天大部分的人还是会把<strong>LSTM</strong>作为默认的选择来尝试。虽然我认为最近几年<strong>GRU</strong>获得了很多支持，而且我感觉越来越多的团队也正在使用<strong>GRU</strong>，因为它更加简单，而且还效果还不错，它更容易适应规模更加大的问题。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我对循环神经网络（RNN）进行学习时的总结了。RNN是NLP深度学习最重要的模型之一，许多开创性的工作就是在它的基础上完成的，包括我的大创课题上下位网络构建的SOTA目前也是由LSTM保持着。接下来，我将介绍常见的预训练模型的基本原理（word2vec，bert等），未来还将介绍NLP深度学习中的Attention机制以及常用的优化、调参算法。</p><h2 id="参考文献（部分）"><a href="#参考文献（部分）" class="headerlink" title="参考文献（部分）"></a>参考文献（部分）</h2><ul><li><p><a href="http://www.ai-start.com/dl2017/html/lesson5-week1.html" target="_blank" rel="noopener">吴恩达深度学习课件</a></p></li><li><p><a href="http://dl-notes.imshuai.com/#/c5w1?id=_110-long-short-term-memory-lstm" target="_blank" rel="noopener">吴恩达深度学习笔记</a></p></li><li><p>台大李宏毅教授的深度学习视频 </p></li><li><p><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks</a> </p></li><li><p><a href="https://www.researchgate.net/publication/13853244_Long_Short-term_Memory" target="_blank" rel="noopener">Hochreiter &amp; Schmidhuber 1997. Long short-term memory</a> </p></li><li><p><a href="https://arxiv.org/pdf/1409.1259.pdf" target="_blank" rel="noopener">Cho et al., 2014. On the properties of neural machine translation: Encoder-decoder approaches</a></p></li><li><p><a href="https://arxiv.org/pdf/1412.3555.pdf" target="_blank" rel="noopener">Chung et al., 2014. Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling</a> </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：条件随机场模型</title>
      <link href="/2020/04/04/nlp-zi-xue-bi-ji-tiao-jian-sui-ji-chang-mo-xing/"/>
      <url>/2020/04/04/nlp-zi-xue-bi-ji-tiao-jian-sui-ji-chang-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是我在学习苏州大学李正华老师的中文信息处理课程（<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">中文信息处理（Chinese Information Processing）Course Resources</a>）时，对于条件随机场模型（Condition Random Field Model）的一些个人见解和思考，同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己对于该模型的理解，如有错误欢迎在评论区指出，非常感谢！</p><h2 id="从问题出发"><a href="#从问题出发" class="headerlink" title="从问题出发"></a>从问题出发</h2><p>与之前的讲解类似，我们在这里依旧围绕自然语言处理中的经典问题<strong>词性标注问题</strong>进行讨论和解释。</p><ul><li>给定一个句子X，输出句子中每一个单词对应的词性。</li></ul><p><img src="1.png" alt="词性标注任务"></p><h2 id="条件随机场模型的由来"><a href="#条件随机场模型的由来" class="headerlink" title="条件随机场模型的由来"></a>条件随机场模型的由来</h2><p>我在之前已经讨论过了隐马尔可夫模型（HMM）和对数线性模型（Log-Linear Model），我觉得，有了之前的过程基础，我们接下来对于条件随机场模型的学习将变得非常轻松，因为<strong>实际上条件随机场模型只是隐马尔可夫模型和对数线性模型的结合。</strong>当我们打好了基础，剩下来的只有细微的调整和修补。</p><p>首先，我们来看下面这张图，它阐述了我们要学习的条件随机场模型和之前的两个模型的关系。<strong>顺便说一下，本文讨论的条件随机场模型都是线性链条件随机场（ Linear-chain CRF），这是NLP中常用的CRF形式，此外还有全连接条件随机场（Generl Graph CRF），一般用在CV中，这里就不多叙述。</strong></p><p><img src="2.png" alt="HMM、Log-Linear Model、LC-CRF的关系"></p><p>这张图将三者的关系描述的很清楚。你可以这样去理解LC-CRF的由来：</p><ul><li>LC-CRF可以看作是<strong>分类模型Log-Linear Model加入了HMM中的转移特征（齐次马尔可夫假设）从而转变成为的结构化分类模型</strong>，从而可以进行Seq2Seq的标注。也就是说，对于样本的预测不再是相互独立的，对于某个样本的预测需要考虑前面（Forward）或者后面（Backward）样本预测的结果。</li><li>LC-CRF也可以看作是<strong>生成模型HMM中引入了Log-Linear Model中的自定义特征函数，把它变成了一个判别模型，解决了HMM的输出独立性假设问题和有限元马尔可夫假设问题</strong>， 不仅可以表达观测之间的依赖，还可表示当前观测与前后多个状态之间的复杂依赖。 </li></ul><p>LC-CRF本质上结合了HMM和Log-Linear Model的优点，从而效果更好，更加强大。也就是说，<strong>LC-CRF是Log-Linear Model的序列扩展，是Global Log-Linear Model！</strong></p><p>其实介绍到这里，我觉得CRF已经没有多少要说得了，如果你深入地理解了对数线性模型和隐马尔可夫模型，那么CRF的训练和预测过程你一定能够轻松学会。</p><h2 id="LC-CRF的训练"><a href="#LC-CRF的训练" class="headerlink" title="LC-CRF的训练"></a>LC-CRF的训练</h2><p><strong>LC-CRF是一个判别模型</strong>，所以它的训练过程和Log-Linear Model非常类似。</p><h3 id="构建特征空间"><a href="#构建特征空间" class="headerlink" title="构建特征空间"></a>构建特征空间</h3><p>与Log-Linear Model类似，首先，我们需要为LC-CRF构建<strong>特征空间（Feature Space）</strong>。构建特征空间的方法也与之前类似，<strong>我们采用预先定义好的特征模板（Feature Template）对训练集中的每一个词进行特征抽取</strong>。这里，我们使用如下的特征模板：</p><p><img src="3.png" alt="LC-CRF的特征模板"></p><p>你可能会发现：02-15号特征和我们之前在Log-Linear Model中定义的特征模板是一致。这些特征我们称之为<strong>Unigram特征</strong>，也就是一元特征，包含了词特征、字特征，例如当前词是什么，上一个词是什么，当前词的前缀后缀等。它考虑的是当前词的特征信息，也就是说只考虑了一元隐状态。</p><p>需要特别注意，<strong>我们新加入了01号特征，考虑了当前词性和上一个词性的关系（二元隐状态），这称为Bigram特征，也就是二元特征。</strong>正是因为有了二元特征，我们才可以考虑不同时间步输出之间的关系，将Log-Linear Model序列化，并且使用Viterbi算法进行全局动态规划解码。<strong>二元特征的定义符合了HMM中的一阶马尔可夫假设，其实就是HMM模型中的状态转移矩阵</strong>。下面这张图简单地描述了Unigram特征和Bigram特征。</p><p><img src="4.png" alt="Unigram特征和Bigram特征"></p><p>与Log-Linear Model类似，这里的特征使用One-hot表示，特征抽取可以进行“段+偏移”优化。具体细节可以参考我的对数线性模型博客。</p><h3 id="定义假设函数"><a href="#定义假设函数" class="headerlink" title="定义假设函数"></a>定义假设函数</h3><p>LC-CRF与Log-Linear Model的假设函数并不相同，<strong>因为它是序列模型，所以输出的是预测的整个序列的概率。</strong></p><p>我们先定义一个长度为$n$的句子$S$标注为词性序列$Y$的分值为：<br>$$<br>Score(S,Y)=\sum_{i=1}^{n}w_i^T x_i<br>$$<br>其中，$w_i$是这个句子第$i$个词的特征权重向量，$x_i$是它的特征向量。这里它们都是列向量，需要对$w_i$进行转置处理，然后进行矩阵相乘。将所有词的分值进行相加，得到的是整个句子的总分。</p><p>如果我们对这个句子的所有可能的词性序列求解最大分值，并将最大分值的词性序列作为当前句子的标注结果，你会发现这种做法其实也是Work的。<strong>这其实就是将我们之前提到的Linear Model的全局化，也就是Global Linear Model。</strong>有关线性模型的更多知识可以参考我的上一篇博客，训练的方法依然可以使用我们在Linear Model的在线学习法。</p><p><strong>为了将Global Linear Model转化为Global Log-Linear Model，也就是我们的LC-CRF模型，我们还需要对所得的分值Score进行Softmax函数运算，从而将所得的分值归一化为概率Probability</strong>。从线性模型到对数线性模型的转化也可以看我的上一篇博客。这里，我们使用Softmax函数，得到长度为$n$的句子$S$标注为词性序列$Y$的条件概率，也就是我们模型的假设函数为：<br>$$<br>P(Y|S)=\frac{e^{Score(S,Y)}}{\sum_{Y^{‘}\in{T^n}}e^{Score(S,Y^{‘})}}<br>$$<br>其中，$T^n$为当前句子所有可能的词性标注序列集合。<strong>可以看到，我们使用一个Softmax指数模型来表示整个标签序列的联合概率, 这个概率条件依赖于给定的完整观察序列。 这是一种全局归一化的方式。</strong></p><p>特别地，HMM模型和Log-Linear Model的结合其实还有另外一种方式，即<strong>最大熵隐马尔可夫模型（MEMM）</strong>，这个模型和LC-CRF非常类似，唯一的区别在于，<strong>它的概率归一化的时刻在于每一个时间步（Local归一化），而LC-CRF的概率归一化时刻在整个序列计算完成后（全局归一化）。</strong>虽然MEMM也是Work的，但它存在着<strong>标注偏置</strong>的缺陷，导致其无法在维特比算法的解码过程中确保全局最优。具体为什么会这样，可以看<a href="https://blog.csdn.net/yzxnuaa/article/details/79626265" target="_blank" rel="noopener">这篇博客</a>，我就不过多的进行说明。</p><h3 id="参数训练"><a href="#参数训练" class="headerlink" title="参数训练"></a>参数训练</h3><p>与Log-Linear Model一样，我们对于LC-CRF的参数拟合依然是可以通过<strong>梯度下降法</strong>进行的。这里，我们选用<strong>交叉熵损失函数</strong>作为优化的目标函数，从最大熵模型和极大似然估计法推导出交叉熵损失函数的过程可以参考我的上一篇博客。</p><p>各权重梯度的求解需要使用到前向后向算法的合作，具体计算过程的推导大家可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/12-crf/main.pdf" target="_blank" rel="noopener">李老师的讲义</a>，这里就不进行叙述了，可以自己动手推导一遍。<strong>特别注意的是，当你对Softmax的交叉熵损失函数求$w_i$的梯度时，条件概率$P(Y|S)$的分母上也含有$w_i$，不能忘记求偏导，这导致我一开始怎么也无法推导出正确的梯度。</strong></p><p>至于梯度下降过程中的细节，如正则化、学习率下降等，均在我的上一篇博客中有说明。大家可以动手自己实践一下，仅需要在Log-Linear Model的基础上进行一些修改即可。</p><h2 id="LC-CRF的预测"><a href="#LC-CRF的预测" class="headerlink" title="LC-CRF的预测"></a>LC-CRF的预测</h2><p>LC-CRF跟HMM一样，一般预测用的都是<strong>维特比（Viterbi）算法</strong>。这个算法是一个简单的动态规划，在我的HMM博客有详细的说明。</p><p><strong>需要注意的是，LC-CRF是全局归一化，即分值和概率的转化放在最后一步进行，所以在维特比算法的动态规划状态矩阵中计算的是当前词性序列的累计得分，使用的是累加。而在HMM中，状态矩阵中计算的是概率，使用的是发射概率和转移概率的累乘。</strong></p><p><img src="5.png" alt="维特比算法示意图"></p><h2 id="HMM和CRF的关系"><a href="#HMM和CRF的关系" class="headerlink" title="HMM和CRF的关系"></a>HMM和CRF的关系</h2><p><strong>与HMM相比，CRF其实是它的泛化，添加了不受限制的特征模板，从而可以不仅仅局限在HMM的观测独立性假设和齐次马尔可夫假设上。</strong>如果你对HMM的核心概率公式，即已知观测序列$s$，求解生成观测序列$l$的概率的概率公式（HMM是生成模型，这里是联合概率），求对数后，将得到：<br>$$<br>logP(l,s)=log(P(l_0)\prod_{i=1}^nP(l_i|l_{i-1})P(s_i|l_i))<br>\\\\=logP(l_0)+\sum_{i=1}^nlogP(l_i|l_{i-1})+\sum_{i=1}^nlogP(s_i|l_i)<br>$$<br> 我们可以将HMM的这个式子和我们的CRF的分值计算公式进行对比：<br>$$<br>Score(l,s)=\sum_{i=1}^{n}\sum_{j=1}^{m}\lambda_jf_j(s,i,l_i,l_{i-1})<br>$$</p><p>其中，$f_j$表示第$j$个特征，$\lambda_j$表示它的特征权重。</p><p>由于CRF需要使用Bigram特征，这里的特征还需要考虑前面一个隐状态$l_{i-1}$是什么。</p><p>由于$f_j$的取值总为0或1，我们可以发现： <strong>如果我们把第一个HMM式子中的log形式的概率看做是第二个CRF式子中的特征函数的权重的话，其实，CRF和HMM具有相同的形式。换句话说，我们可以构造一个CRF，使它与HMM的对数形式相同 ，只需要将特征模板限定为初始特征、转移特征和发射特征。也就是说 ，每一个HMM模型其实都等价于某个CRF！</strong></p><p> 但是，CRF要比HMM更加强大，原因主要有两点： </p><ul><li><strong>CRF可以定义数量更多，种类更丰富的特征函数</strong>。  HMM模型具有天然具有局部性，就是说，在HMM模型中，当前的单词只依赖于当前的标签，当前的标签只依赖于前一个标签。这样的局部性限制了HMM只能定义相应类型的特征函数，而CRF的特征模板不受限制，可以考虑各种类型的特征。</li><li><strong>CRF可以使用任意的特征权重</strong> 。HMM的特征权重是对数概率，也就是说它必须取负值，也只能取负值。而且既然是概率那么它一定要满足概率完备性条件才可以，但是CRF的特征权重你是可以随意取值的。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我对NLP中的CRF模型的学习笔记，由于很多知识在前面的两篇博客——HMM模型和Log-Linear模型中已经讲解过，所以本文写的比较简略。但只要认真的学习了前面两个模型，其实CRF已经迎刃而解了。</p><p>接下来，我将继续学习NLP的相关知识，并尝试练习使用深度学习模型。</p><h2 id="参考资料（部分）"><a href="#参考资料（部分）" class="headerlink" title="参考资料（部分）"></a>参考资料（部分）</h2><p><a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">苏州大学李正华老师的课件</a></p><p><a href="https://www.jianshu.com/p/55755fc649b1" target="_blank" rel="noopener">如何轻松愉快地理解条件随机场（CRF）？</a></p><p><a href="https://www.zhihu.com/question/35866596" target="_blank" rel="noopener">如何用简单易懂的例子解释条件随机场（CRF）模型？它和HMM有什么区别？</a></p><p><a href="https://www.cnblogs.com/kerwins-AC/p/9584862.html" target="_blank" rel="noopener">条件随机场</a></p><p>李航老师《统计学习方法》</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer题解</title>
      <link href="/2020/03/21/jian-zhi-offer-ti-jie/"/>
      <url>/2020/03/21/jian-zhi-offer-ti-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近随便投了字节跳动的暑期实习生，没想到简历过关了，4.12日先去笔试。考虑到Leetcode上面的题目比较多，决定先把《剑指Offer》上的所有题目都刷一遍。</p><h2 id="1-数组中重复的数字"><a href="#1-数组中重复的数字" class="headerlink" title="1. 数组中重复的数字"></a>1. <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中重复的数字</a></h2><p>思路：使用<strong>哈希表或者集合</strong>等数据结构，遍历数组中的数字，当数字没有出现在集合中时，将其加入集合，当数字已经出现在集合中时，说明其重复了，直接返回。</p><p>时间复杂度：$O(n)$，n为数组大小。</p><p>空间复杂度:  $O(n)$</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dic<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-二维数组中的查找"><a href="#2-二维数组中的查找" class="headerlink" title="2.  二维数组中的查找"></a>2. <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener"> 二维数组中的查找</a></h2><p>思路：有些类似于<strong>二叉查找树</strong>的思路，从右上角开始搜索，左侧的数字都比当前数小，下方的数字都比当前数大。如果当前数小于目标，则向下移动一格，大于目标，则向左移动一格，等于目标返回True，超出边界时需要返回False。</p><p>时间复杂度：$O(m+n)$，这是从右上角搜索到左下角的最坏情况，m为行数，n为列数。</p><p>空间复杂度:  $O(1)$</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findNumberIn2DArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> matrix<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            row<span class="token operator">=</span><span class="token number">0</span>            col<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>                    col<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">elif</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>                    row<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-替换空格"><a href="#3-替换空格" class="headerlink" title="3.替换空格"></a>3.<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">替换空格</a></h2><p>思路：将字符串转换为字符列表进行遍历替换即可。（也可以直接调用字符串的replace函数）</p><p><strong>注意：Python中常见的不可变类型有数字、字符串和元组，可变类型有列表和字典。区别主要是： 当不可变数据类型的对应变量的值发生了改变，那么它对应的内存地址也会发生改变。 而可变数据类型可以在不改变内存地址的前提下修改对应内存的值。所以，如果我们要原地修改字符串的内容，需要将其转换为列表。</strong></p><p>时间复杂度：$O(n)$，n为原字符串长度。</p><p>空间复杂度:  $O(m)$，m为替换空格后字符串长度。</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">replaceSpace</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        stLi<span class="token operator">=</span>list<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>stLi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> stLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">' '</span><span class="token punctuation">:</span>                stLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'%20'</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>stLi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-从尾到头打印链表"><a href="#4-从尾到头打印链表" class="headerlink" title="4.从尾到头打印链表"></a>4.<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">从尾到头打印链表</a></h2><p>思路1：递归法，递归结束条件为当前指针为None，利用递归的机制进行求解。<strong>（非尾递归，会先将当前层递归函数保存在栈空间中，等待下层递归函数执行完返回）</strong></p><p>时间复杂度：$O(n)$，n为链表长度。</p><p>空间复杂度:  $O(n)$。</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reversePrint</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>reversePrint<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">[</span>head<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token keyword">if</span> head<span class="token operator">!=</span>None <span class="token keyword">else</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：值 A if 条件语句 else 值B，如果条件满足则值A，否则值B。</p><p>思路2：<strong>辅助栈</strong>，利用栈的性质（先进后出）求解。</p><p>时间复杂度：$O(n)$，n为链表长度。</p><p>空间复杂度:  $O(n)$。</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reversePrint</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        p<span class="token operator">=</span>head        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> result<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-重建二叉树"><a href="#5-重建二叉树" class="headerlink" title="5. 重建二叉树"></a>5. <a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">重建二叉树</a></h2><p>思路：我们生成二叉树主要有两种做法，一是利用标记了空节点的层次遍历序列，二是利用前序（后序）遍历加上中序遍历。后者的具体做法是<strong>分治法</strong>：</p><ul><li><strong>前序遍历的第 1 个结点一定是二叉树的根结点</strong>；</li><li>在中序遍历中，根结点把中序遍历序列分成了两个部分，左边部分构成了二叉树的根结点的左子树，右边部分构成了二叉树的根结点的右子树。</li><li>查找根结点在中序遍历序列中的位置，可以遍历，也可以在一开始就记录下来。</li></ul><p><img src="5.png" alt="分治法"></p><p>通过分治，我们可以递归求解。</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>preL<span class="token punctuation">,</span>preR<span class="token punctuation">,</span>inL<span class="token punctuation">,</span>inR<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> preL<span class="token operator">></span>preR <span class="token operator">or</span> inL<span class="token operator">></span>inR<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当前子树为空</span>                <span class="token keyword">return</span> None            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preL<span class="token punctuation">]</span><span class="token punctuation">)</span>            inPos<span class="token operator">=</span>inorder<span class="token punctuation">.</span>index<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            leftLen<span class="token operator">=</span>inPos<span class="token operator">-</span>inL            root<span class="token punctuation">.</span>left<span class="token operator">=</span>build<span class="token punctuation">(</span>preL<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>preL<span class="token operator">+</span>leftLen<span class="token punctuation">,</span>inL<span class="token punctuation">,</span>inPos<span class="token number">-1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#分治，划分左子树和右子树的序列</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>build<span class="token punctuation">(</span>preL<span class="token operator">+</span>leftLen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>preR<span class="token punctuation">,</span>inPos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>inR<span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token keyword">if</span> preorder<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> build<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>preorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>inorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-用两个栈实现队列"><a href="#6-用两个栈实现队列" class="headerlink" title="6. 用两个栈实现队列"></a>6. <a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">用两个栈实现队列</a></h2><p>思路： 我们可以设计栈A用于入队操作，栈B用于将元素倒序，从而实现出队操作。 </p><ul><li><p><strong>加入队尾 <code>appendTail()</code>函数：</strong> 将数字 <code>val</code> 加入栈 <code>A</code> 即可。</p></li><li><p>删除队首<code>deleteHead()</code>函数：</p><p>有以下三种情况。</p><ol><li><strong>当栈 <code>B</code> 不为空：</strong> <code>B</code>中仍有已完成倒序的元素，因此直接返回 <code>B</code> 的栈顶元素。</li><li><strong>否则，当 <code>A</code> 为空：</strong> 即两个栈都为空，无元素，因此返回 -1 。</li><li><strong>否则：</strong> 将栈 <code>A</code> 元素全部转移至栈 <code>B</code> 中，实现元素倒序，并返回栈 <code>B</code> 的栈顶元素。</li></ol></li></ul><p>时间复杂度：入队$O(1)$，出队$O(n)$</p><p>空间复杂度：$O(n)$</p><p>这个思路只需要保证入队、出队操作的正确返回即可，不需要维护一个真正的用栈模拟的队列。还可以用栈A模拟队列，辅助栈B用于模拟队列的入队或者出队操作，不过那样会比较慢，因为每一次使用辅助栈B都会涉及倒序操作。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">CQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>A<span class="token punctuation">,</span> self<span class="token punctuation">.</span>B <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">appendTail</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>A<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">deleteHead</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>B<span class="token punctuation">:</span>             <span class="token keyword">return</span> self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>A<span class="token punctuation">:</span>             <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>A<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>A<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7.斐波那契数列"></a>7.<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">斐波那契数列</a></h2><p>思路：经典题，<strong>动态规划</strong>求解，相较于递归节约时间和空间。</p><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        fib<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            fib<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>fib<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>fib<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">1000000007</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#实际上python只需要在return时取余即可，这里是向java等语言看齐，防止越界</span>        <span class="token keyword">return</span> fib<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事实上，这道题的DP状态矩阵还可以进一步优化，仅<strong>使用两个变量存储</strong>，降为$O(1)$。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a <span class="token operator">+</span> b        <span class="token keyword">return</span> a <span class="token operator">%</span> <span class="token number">1000000007</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-青蛙跳台阶问题"><a href="#8-青蛙跳台阶问题" class="headerlink" title="8.青蛙跳台阶问题"></a>8.<a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">青蛙跳台阶问题</a></h2><p>思路：依然是<strong>动态规划</strong>问题，青蛙跳到第1级台阶只有一个路径，第2级台阶只有两个路径，第n级台阶的路径为跳到第n-2级台阶的路径数加上跳到第n-1级台阶的路径数之和。    </p><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numWays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        a<span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span>        <span class="token keyword">if</span> n<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> a        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            a<span class="token punctuation">,</span>b<span class="token operator">=</span>b<span class="token punctuation">,</span>a<span class="token operator">+</span>b        <span class="token keyword">return</span> b<span class="token operator">%</span><span class="token number">1000000007</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-旋转数组的最小数字"><a href="#9-旋转数组的最小数字" class="headerlink" title="9.旋转数组的最小数字"></a>9.<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">旋转数组的最小数字</a></h2><p>思路：这种类型的题目，如果我们直接使用线性级别的时间复杂度肯定能做，但没啥意思。查找、排序的题目如果想达到对数级别的时间复杂度，一定要尝试<strong>二分法（减治思想）</strong>。</p><ul><li>本题的思路是通过二分法减治<strong>排除必不可能是最小值的元素</strong>。<ul><li>首先，与常规二分法一样，我们设置两个指针left和right指向数组的左右边界。mid=（left+right）//2</li><li>我们比较numbers[mid]与numbers[right]的值，分为以下三种情况:<ul><li>numbers[mid]&lt;numbers[right]：根据旋转数组的性质，说明从numbers[mid]到numbers[right]必然是升序序列，所以mid+1到right的数字必然大于mid位置的数字，所以它们都不可能是最小值，可以排除，进入[left，mid]闭区间查找最小值。</li><li>numbers[mid]&gt;numbers[right]：根据旋转数组的性质，说明旋转点必然在numbers[mid+1]到numbers[right]之间，进入[mid+1，right]闭区间查找最小值。</li><li>numbers[mid]==numbers[right]：此时，我们不知道最小值在[left，mid]闭区间还是[mid+1，right]闭区间中， 例 [1, 0, 1, 1, 1]中，最小值在[left，mid]，例[1, 1, 1, 0, 1]中，最小值在[mid+1，right]中。虽然我们无法进行二分减治，但是此时我们确定了两个相等的数，并且我们知道删除其中一个不影响最终寻找最小值，我们可以将right减1，缩小区间，再次尝试二分。</li><li>迭代二分后，最终left将超过right，此时left的位置即为最小值的位置。</li></ul></li></ul></li><li>为什么不比较numbers[mid]与numbers[left]的值？<ul><li>例子[1,2,3,4,5]中，numbers[mid]&gt;numbers[left]，最小值在[left，mid]中，但在例子[3,4,5,1,2]中，numbers[mid]&gt;numbers[left]，最小值却在[mid+1，right]中，考虑到未旋转的特殊情况，我们不能使用中间数与首个数比较。</li></ul></li></ul><p>时间复杂度：$O(logn)$</p><p>空间复杂度：$O(1)$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> numbers<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#二分查找这里是小于等于，因为二分查找需要比较最后一个长度为1的区间的值与目标是否相等，这里仅需找到最后一个长度为1的区间即可</span>            mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">if</span> numbers<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>numbers<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">elif</span> numbers<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>numbers<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                right<span class="token operator">=</span>mid            <span class="token keyword">else</span><span class="token punctuation">:</span>                right<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> numbers<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-矩阵中的路径"><a href="#10-矩阵中的路径" class="headerlink" title="10.矩阵中的路径"></a>10.<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">矩阵中的路径</a></h2><p>思路：这类走迷宫问题，我们首先很容易想到的就是<strong>DFS+回溯算法</strong>。类似的题目还有解数独、全排列、皇后问题等。基本的思路就是尝试从矩阵中的每个位置出发，如果当前位置的字符等于目标字符串的首字符，那么继续向左、右、上、下四个方向尝试匹配，目前字符串的指针加1。如果目标字符串的指针到达其长度，说明已经完成匹配，可以返回True。特别地，在这里，同一位置的字符不能重复选择，我们需要设置一个visited矩阵。</p><p><img src="10.png" alt="复杂度分析"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exist</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> board<span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index<span class="token operator">==</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span>word<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">and</span> visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">:</span>                    visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                    res<span class="token operator">=</span>backtrack<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token number">-1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token number">-1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#这里不能直接return，否则无法回溯</span>                    visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">False</span><span class="token comment" spellcheck="true">#回溯已访问矩阵</span>                    <span class="token keyword">return</span> res        <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">##尝试每个位置出发</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PS：这里的visited矩阵可以不用开，直接原地修改board矩阵的元素为False即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exist</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index<span class="token operator">==</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span>word<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>                    tmp<span class="token punctuation">,</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token boolean">False</span>                    res<span class="token operator">=</span>backtrack<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token number">-1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token number">-1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                    board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span>tmp                    <span class="token keyword">return</span> res        <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> backtrack<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-机器人的运动范围"><a href="#11-机器人的运动范围" class="headerlink" title="11. 机器人的运动范围"></a>11.<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener"> 机器人的运动范围</a></h2><p>思路：DFS，有点类似于二叉树的节点数统计。判断当前位置是否可以到达的条件是：</p><ol><li>没有越界；</li><li>数位和小于k；</li><li>未访问过。</li></ol><p>一旦该位置不可到达，立刻返回0；如果该位置可达，那么返回1+dfs(row+1,col)+dfs(row,col+1)，表示当前节点可达且继续向右、下方遍历。</p><p>注意，此处机器人虽然可以向上、下、左、右进行遍历，但是我们发现一个地图上所有的格子都可以通过向右走和向下走到达，那么为了防止重复的判断，我们只向下和向右走。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">movingCount</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;</span>m <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;</span>n <span class="token operator">and</span> <span class="token punctuation">(</span>row<span class="token operator">//</span><span class="token number">10</span><span class="token operator">+</span>row<span class="token operator">%</span><span class="token number">10</span><span class="token operator">+</span>col<span class="token operator">//</span><span class="token number">10</span><span class="token operator">+</span>col<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span>k <span class="token operator">and</span> visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">:</span>                visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>dfs<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token operator">+</span>dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：$O(mn)$</p><p>空间复杂度：$O(mn)$</p><h2 id="12-剪绳子"><a href="#12-剪绳子" class="headerlink" title="12.剪绳子"></a>12.<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">剪绳子</a></h2><p>思路：动态规划，dp[i]为整数i可以拆分得到的最大乘积。转移方程为：从1到i-1遍历分解因子j，选择分解后乘积最大的结果，作为当前的状态值。需要注意的是max(dp[i-j],i-j)这一步，因为整数i拆分后的最大乘积不一定大于i，所以要进行比较，例如dp[2]=1&lt;2，所以2并不需要拆分。</p><ul><li>时间复杂度：$O(N^2)$，两侧 <code>for</code> 循环。</li><li>空间复杂度：$O(N)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">integerBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token operator">-</span>j<span class="token punctuation">)</span><span class="token operator">*</span>j<span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，我们通过<a href="https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-shu-xue-fang-fa-han-wan-zheng-t/" target="_blank" rel="noopener">数学证明</a>可以得知，只要尽量把整数i分解为更多的3或2即可，省去了许多分解因子的比较。</p><p>同时，我们还可以使用滚动数组的方法减少状态矩阵的空间占用。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">integerBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            <span class="token number">3</span> <span class="token operator">*</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><h2 id="13-剪绳子-II"><a href="#13-剪绳子-II" class="headerlink" title="13.剪绳子 II"></a>13.<a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/" target="_blank" rel="noopener">剪绳子 II</a></h2><p>思路：和上一题一样，由于我们求导得到的极大值点为e，所以我们要尽量把整数分解为更多的3或者2。最后结果取余1000000007即可（python没有溢出的问题），否则要用快速幂取余法求余数。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">integerBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            <span class="token number">3</span> <span class="token operator">*</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">1000000007</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-二进制中1的个数"><a href="#14-二进制中1的个数" class="headerlink" title="14.二进制中1的个数"></a>14.<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">二进制中1的个数</a></h2><p>思路：根据十进制数与二进制数进行转换的方法，按位判断。</p><ul><li>时间复杂度：$O(logN)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hammingWeight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        count<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                count<span class="token operator">+=</span><span class="token number">1</span>            n<span class="token operator">//=</span><span class="token number">2</span>        <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化的思路：根据以下事实：</p><ul><li>一个数 n与一个比它小 1 的数（n - 1）进行与运算（&amp;）之后，得到的结果会消除 n中最低位的 1.</li></ul><pre><code>示例1: 7 &amp; 600111      &amp;   =》 0011000110示例2: 8 &amp; 701000      &amp;   =》 0000000111</code></pre><p>可以看到，通过与运算不断地消去1，直到 n==0 即可。统计消去的次数，即为n中1的个数。</p><ul><li>时间复杂度：$O(M)$。M为1的个数。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hammingWeight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        count<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            n<span class="token operator">&amp;</span><span class="token operator">=</span>n<span class="token number">-1</span>            count<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="15-数值的整数次方"><a href="#15-数值的整数次方" class="headerlink" title="15.数值的整数次方"></a>15.<a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">数值的整数次方</a></h2><p>思路：快速幂算法，曾经在我的另一篇博客中有提到，第50题。基本思想是二分递归。</p><ul><li>时间复杂度：$O(logN)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">myPow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> float<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">fastpow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">1</span>            half<span class="token operator">=</span>fastpow<span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> half<span class="token operator">*</span>half            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> x<span class="token operator">*</span>half<span class="token operator">*</span>half        <span class="token keyword">if</span> n<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>            n<span class="token operator">=</span><span class="token operator">-</span>n            x<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span>x        <span class="token keyword">return</span> fastpow<span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="16-打印从1到最大的n位数"><a href="#16-打印从1到最大的n位数" class="headerlink" title="16.打印从1到最大的n位数"></a>16.<a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">打印从1到最大的n位数</a></h2><p>思路：这道题没什么好说的，如果用python的列表很好做。但如果是其他语言的话，数字可能在后期会溢出。当可能溢出时，需要把问题转化为大数加法，应考虑进位和最高位是否进位的问题。此外，还可以将其转化为0-9在n个位置上的全排列问题。后两种解法都需要考虑怎么去除最前面的0。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">printNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>pow<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="17-删除链表的节点"><a href="#17-删除链表的节点" class="headerlink" title="17.删除链表的节点"></a>17.<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">删除链表的节点</a></h2><p>思路：数据结构中单链表的最基础操作，使用一个指针，当其next节点的值为需要删除的值时，通过移动next指针指向next节点的next指针，完成删除操作。</p><p>特别地，为了不讨论在链表头部删除节点的特殊情况，我们额外添加一个空的头节点。</p><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def deleteNode(self, head: ListNode, val: int) -&gt; ListNode:        dummyhead=ListNode(0)        dummyhead.next=head        p=dummyhead        while (p.next!=None):            if p.next.val==val:                p.next=p.next.next                break            p=p.next        return dummyhead.next</code></pre><h2 id="18-正则表达式匹配"><a href="#18-正则表达式匹配" class="headerlink" title="18.正则表达式匹配"></a>18.<a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">正则表达式匹配</a></h2><p>思路：动态规划求解，这道题我在我的另一篇博客里有提及。</p><ul><li>时间复杂度：$O(MN)$。</li><li>空间复杂度：$O(MN)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> p<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                first_match<span class="token operator">=</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">or</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'.'</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">and</span> p<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'*'</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">or</span> <span class="token punctuation">(</span>first_match <span class="token operator">and</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>first_match <span class="token operator">and</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="19-表示数值的字符串"><a href="#19-表示数值的字符串" class="headerlink" title="19. 表示数值的字符串"></a>19.<a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener"> 表示数值的字符串</a></h2><p>这道题个人感觉纯靠耐心，利用判断慢慢做，暂时先不做了</p><h2 id="20-调整数组顺序使奇数位于偶数前面"><a href="#20-调整数组顺序使奇数位于偶数前面" class="headerlink" title="20. 调整数组顺序使奇数位于偶数前面"></a>20. <a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">调整数组顺序使奇数位于偶数前面</a></h2><p>思路：双指针法，我的思路来自于快速排序。指针left指向数组最左侧，指针right指向数组最右侧，如果left处的数字是一个奇数，说明该位置上的数字没问题，我们将left加1；如果是一个偶数，则将其与right处的数字交换，此时right处的数字必为偶数，我们可以将right减1。接着，我们看right处的数字，如果它是一个偶数，说明right处数字没问题，可以将right减1，否则，我们将其与left处的数字交换，此时left处必是奇数，我们可以将left+1.</p><p>由于数组中必然一半是奇数，一半是偶数，上述算法当left==right时跳出即可，说明所有数字已成功移动。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exchange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp<span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>tmp        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                swap<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>                right<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                left<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                right<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                swap<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>                left<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="21-链表中倒数第k个节点"><a href="#21-链表中倒数第k个节点" class="headerlink" title="21.链表中倒数第k个节点"></a>21.<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">链表中倒数第k个节点</a></h2><p>思路：快慢指针法，构建一前一后间隔为k的两个指针，当前方的指针指向None时，返回后方指针。特别地，要讨论一下当快指针到达正数第k个节点之前，慢指针将不会出发。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getKthFromEnd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        p<span class="token operator">=</span>head        q<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>k<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>next                q<span class="token operator">=</span>q<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                k<span class="token operator">-=</span><span class="token number">1</span>                q<span class="token operator">=</span>q<span class="token punctuation">.</span>next        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="22-反转链表"><a href="#22-反转链表" class="headerlink" title="22.反转链表"></a>22.<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">反转链表</a></h2><p>思路：有点类似于主站的k个一组反转链表，简化版，可以用头插法或者尾插法实现翻转。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        p<span class="token operator">=</span>head        q<span class="token operator">=</span>head<span class="token punctuation">.</span>next        <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            p<span class="token punctuation">.</span>next<span class="token operator">=</span>q<span class="token punctuation">.</span>next            q<span class="token punctuation">.</span>next<span class="token operator">=</span>head            head<span class="token operator">=</span>q            q<span class="token operator">=</span>p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这道题由于所有插入均在头部，所以不需要使用dummy head。</p><p>另一种方案是使用双指针进行翻转。通过两个间隔为1节点的快慢指针，不断修改快指针的节点的next指针为慢指针的节点，并使他们不断向前移动即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        p<span class="token operator">=</span>None        q<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp<span class="token punctuation">,</span>q<span class="token punctuation">.</span>next<span class="token operator">=</span>q<span class="token punctuation">.</span>next<span class="token punctuation">,</span>p            p<span class="token punctuation">,</span>q<span class="token operator">=</span>q<span class="token punctuation">,</span>tmp        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="23-合并两个排序的链表"><a href="#23-合并两个排序的链表" class="headerlink" title="23. 合并两个排序的链表"></a>23. <a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">合并两个排序的链表</a></h2><p>思路：这题类似于主站的第21题，我曾在另一篇博客里详细说过，主要的思路是用两个指针比较两个链表中的元素，并选取较小的放入新链表。</p><ul><li>时间复杂度：$O(M+N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> l2<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        dummyhead<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        p<span class="token punctuation">,</span>q<span class="token operator">=</span>l1<span class="token punctuation">,</span>l2        r<span class="token operator">=</span>dummyhead        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None <span class="token operator">and</span> q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>                r<span class="token punctuation">.</span>next<span class="token operator">=</span>p                p<span class="token operator">=</span>p<span class="token punctuation">.</span>next                r<span class="token operator">=</span>r<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                r<span class="token punctuation">.</span>next<span class="token operator">=</span>q                q<span class="token operator">=</span>q<span class="token punctuation">.</span>next                r<span class="token operator">=</span>r<span class="token punctuation">.</span>next        <span class="token keyword">if</span> p<span class="token operator">==</span>None<span class="token punctuation">:</span>            r<span class="token punctuation">.</span>next<span class="token operator">=</span>q        <span class="token keyword">else</span><span class="token punctuation">:</span>            r<span class="token punctuation">.</span>next<span class="token operator">=</span>p        <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>归并排序中合并相邻链表的常规做法，需要注意的是当插入空链表时需要分类讨论，为了减少判断，我们可以使用一个伪头结点。</p><h2 id="24-树的子结构"><a href="#24-树的子结构" class="headerlink" title="24.树的子结构"></a>24.<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">树的子结构</a></h2><p>思路：我们先使用先序遍历，遍历树A。然后调用另一个函数，判断A的当前子树是否与B匹配。如果当前子树与B匹配，返回True，否则继续尝试遍历A当前子树的左子树和右子树，看它们与B是否匹配。</p><p>匹配的函数：</p><ol><li>如果当前节点B为空，说明树B已经匹配至越过叶子节点，返回True</li><li>如果当前节点A为空，说明树A已经匹配至越过叶子节点，但树B还没有匹配完，失配了，返回False</li><li>如果当前节点A和节点B均非空，且A的值与B的值相等，则继续尝试匹配A、B节点的左节点和右节点。</li><li>如果A的值与B的值不等，说明失配，返回False。</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSubStructure</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> B<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>B<span class="token operator">==</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token operator">==</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">.</span>val<span class="token operator">==</span>B<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> match<span class="token punctuation">(</span>A<span class="token punctuation">.</span>left<span class="token punctuation">,</span>B<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> match<span class="token punctuation">(</span>A<span class="token punctuation">.</span>right<span class="token punctuation">,</span>B<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> A<span class="token operator">==</span>None <span class="token operator">or</span> B<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> match<span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>isSubStructure<span class="token punctuation">(</span>A<span class="token punctuation">.</span>left<span class="token punctuation">,</span>B<span class="token punctuation">)</span> <span class="token operator">or</span> self<span class="token punctuation">.</span>isSubStructure<span class="token punctuation">(</span>A<span class="token punctuation">.</span>right<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="25-二叉树的镜像"><a href="#25-二叉树的镜像" class="headerlink" title="25.二叉树的镜像"></a>25.<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">二叉树的镜像</a></h2><p>思路：观察镜像翻转后的二叉树可知，我们可以从上向下进行递归翻转。对于每一个节点，我们将其左子树和右子树交换，然后递归进入左子树和右子树的根节点，继续交换它们的左右子树。你会发现，如果你将当前层调整至镜像后，下一层节点其实已经被两个一组翻转了，只需要交换两个一组内部的节点即可完成翻转。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(N)$。递归要占用栈空间。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token operator">=</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>root<span class="token punctuation">.</span>left            self<span class="token punctuation">.</span>mirrorTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>mirrorTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="26-对称的二叉树"><a href="#26-对称的二叉树" class="headerlink" title="26.对称的二叉树"></a>26.<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">对称的二叉树</a></h2><p>思路：</p><ul><li>对称二叉树规律：<ul><li>对于树中任意两个对称节点A和B，一定有：<ul><li>A.val = B.val：即此两对称节点值相等。</li><li>A 的 左子节点 和 B的 右子节点 对称；</li><li>A 的 右子节点 和 B的 左子节点 对称。</li><li>如果A、B均为空，我们认为它们是对称的。</li><li>如果A、B中一个空一个非空，则必然不对称。</li></ul></li></ul></li><li>根据以上规律，考虑从顶至底递归判断每对节点是否对称，从而判断树是否为对称二叉树。</li></ul><p><img src="26.png" alt="规律"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> A<span class="token operator">==</span>None <span class="token operator">and</span> B<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> A<span class="token operator">==</span>None <span class="token operator">or</span> B<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> A<span class="token punctuation">.</span>val<span class="token operator">==</span>B<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> match<span class="token punctuation">(</span>A<span class="token punctuation">.</span>left<span class="token punctuation">,</span>B<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token operator">and</span> match<span class="token punctuation">(</span>A<span class="token punctuation">.</span>right<span class="token punctuation">,</span>B<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> match<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">if</span> root <span class="token keyword">else</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(N)$。递归要占用栈空间。</li></ul><h2 id="27-顺时针打印矩阵"><a href="#27-顺时针打印矩阵" class="headerlink" title="27.顺时针打印矩阵"></a>27.<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">顺时针打印矩阵</a></h2><p>思路：螺旋矩阵，模拟题，做过很多次了。主站第54题，可以看我的另一篇博客。</p><ul><li>时间复杂度：$O(MN)$。</li><li>空间复杂度：$O(N)$。递归要占用栈空间。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        level<span class="token operator">=</span><span class="token number">0</span>        row<span class="token operator">=</span><span class="token number">0</span>        col<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">if</span> matrix<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        result<span class="token operator">=</span><span class="token punctuation">[</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">]</span>        count<span class="token operator">=</span><span class="token number">1</span>        row_nums<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span>        col_nums<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        size<span class="token operator">=</span>row_nums<span class="token operator">*</span>col_nums        <span class="token keyword">while</span> count<span class="token operator">&lt;</span>size<span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col_nums<span class="token operator">-</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>                col<span class="token operator">+=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>row_nums<span class="token operator">-</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>                row<span class="token operator">+=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col_nums<span class="token operator">-</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>                col<span class="token operator">-=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>row_nums<span class="token operator">-</span>level<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                row<span class="token operator">-=</span><span class="token number">1</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>                    <span class="token keyword">return</span> result            level<span class="token operator">+=</span><span class="token number">1</span>            col<span class="token operator">+=</span><span class="token number">1</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>            count<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="28-包含min函数的栈"><a href="#28-包含min函数的栈" class="headerlink" title="28.包含min函数的栈"></a>28.<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">包含min函数的栈</a></h2><p>思路：入栈、出栈、取栈顶元素的操作都很简单，Java中可以用数组或者链表来模拟，而python中可以直接用列表来模拟。唯一的难点在于如何找到当前最小值。如果取最小值的时候遍历整个栈，时间复杂度会是线性的，比较高。我们可以以空间换时间，通过建立一个辅助栈，记录当前栈中的某个元素及其之前的所有元素中的最小值。</p><ul><li>时间复杂度：$O(1)$。</li><li>空间复杂度：$O(N)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MinStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>A<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>B<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>A<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> x<span class="token operator">&lt;</span>self<span class="token punctuation">.</span>B<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">else</span> self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>B<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>A<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>A<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>B<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your MinStack object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MinStack()</span><span class="token comment" spellcheck="true"># obj.push(x)</span><span class="token comment" spellcheck="true"># obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.top()</span><span class="token comment" spellcheck="true"># param_4 = obj.min()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="29-栈的压入、弹出序列"><a href="#29-栈的压入、弹出序列" class="headerlink" title="29.栈的压入、弹出序列"></a>29.<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">栈的压入、弹出序列</a></h2><p>思路：辅助栈模拟法。通过采用一个辅助栈模拟压入、弹出的过程。按照压入序列，每次往辅助栈中压入一个数字，同时查看弹出序列中的第 i 个元素是否为辅助栈的栈顶元素（i初始为0），是则从辅助栈中弹出该元素，并将 i 加1，尝试弹出下一个元素，否则继续压入数字。如果最终辅助栈为空，说明弹出序列在当前压入序列下合法。</p><ul><li>时间复杂度：$O(N)$。将所有元素一遍入栈，一遍出栈，需要 $O(2N)$。</li><li>空间复杂度：$O(N)$。使用了辅助栈 <code>st</code>。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">validateStackSequences</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pushed<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> popped<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        i<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> pushed<span class="token punctuation">:</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>popped<span class="token punctuation">)</span> <span class="token operator">and</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>popped<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                i<span class="token operator">+=</span><span class="token number">1</span>         <span class="token keyword">return</span> <span class="token boolean">True</span> <span class="token keyword">if</span> stack<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="30-I-从上到下打印二叉树"><a href="#30-I-从上到下打印二叉树" class="headerlink" title="30. I. 从上到下打印二叉树"></a>30.<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener"> I. 从上到下打印二叉树</a></h2><p>思路：基本的BFS，队列实现。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            i<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">while</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>None<span class="token punctuation">:</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span>                i<span class="token operator">+=</span><span class="token number">1</span>            queue<span class="token operator">=</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">]</span>        <span class="token keyword">return</span> queue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="31-II-从上到下打印二叉树-II"><a href="#31-II-从上到下打印二叉树-II" class="headerlink" title="31.II. 从上到下打印二叉树 II"></a>31.<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">II. 从上到下打印二叉树 II</a></h2><p>思路：依然是BFS的基本题，采用队列的方式。每一层开始时记录下当前队列中的节点数目 L，并开始让父节点出队，左右子节点非空入队，共重复L次，即完成了一层的遍历，将当前队列中的节点添加至结果数组中。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">]</span><span class="token punctuation">)</span>                l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span>                    queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="32-III-从上到下打印二叉树-III"><a href="#32-III-从上到下打印二叉树-III" class="headerlink" title="32. III. 从上到下打印二叉树 III"></a>32.<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener"> III. 从上到下打印二叉树 III</a></h2><p>思路：依然是BFS的基本题，使用一个level变量记录一下当前的层数即可。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        level<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> level<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span>                    <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token operator">!=</span>None<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span>                    queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                level<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> result   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33.二叉搜索树的后序遍历序列"></a>33.<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">二叉搜索树的后序遍历序列</a></h2><p>思路：这道题就是看数组是否满足某一个二叉搜索树的后序遍历。我们知道：</p><ul><li>后序遍历的最后一个节点都是根节点。数组顺序为： [ 左子树 | 右子树 | 根节点 ] 。</li><li>对于二叉搜索树的任意一个节点，左子树的所有节点必然小于它，右子树的所有节点必然大于它。</li></ul><p>根据上述两个性质，我们可以进行递归分治判断，我们先判断根节点的的左子树是否均比他小，右子树是否均比他大，若成立，则继续判断左子树和右子树是否符合二叉搜索树的定义。至于如何划分子树，可以根据根节点来划分，如果出现了比根节点大的值，则该节点及其后在根节点之前的所有节点均为右子树的节点。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">verifyPostorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> postorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> left<span class="token operator">>=</span>right<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            p<span class="token operator">=</span>left            <span class="token keyword">while</span> <span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">&lt;</span>postorder<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                p<span class="token operator">+=</span><span class="token number">1</span>            pos<span class="token operator">=</span>p            <span class="token keyword">while</span> <span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">></span>postorder<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                p<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> p<span class="token operator">==</span>right<span class="token punctuation">:</span>                <span class="token keyword">return</span> match<span class="token punctuation">(</span>left<span class="token punctuation">,</span>pos<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">and</span> match<span class="token punctuation">(</span>pos<span class="token punctuation">,</span>right<span class="token number">-1</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> match<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>postorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>时间复杂度：$O(N^2)$。最坏情况下是当二叉树退化为链表。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><h2 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34.二叉树中和为某一值的路径"></a>34.<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">二叉树中和为某一值的路径</a></h2><p>思路：递归搜索+回溯。类似于组合数的问题，我在另一篇博客中有提到过，基本做法是从根节点向下递归搜索，如果当前节点为空，则直接返回，如果当前节点不为空，则将当前节点加入至当前路径列表，并将它的值加入至当前路径和中。接着讨论两种情况：（1）当前节点为叶子节点且当前路径和为0，那么将当前路径加入至结果列表中；（2）否则，继续搜索左孩子节点和右孩子节点。讨论完成后，回溯至最初的状态。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>re<span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            re<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            sum<span class="token operator">-=</span>root<span class="token punctuation">.</span>val            <span class="token keyword">if</span> sum<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> root<span class="token punctuation">.</span>left<span class="token operator">==</span>None <span class="token operator">and</span> root<span class="token punctuation">.</span>right<span class="token operator">==</span>None<span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>re<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>re<span class="token punctuation">,</span>sum<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>re<span class="token punctuation">,</span>sum<span class="token punctuation">)</span>            re<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>root<span class="token punctuation">)</span>            sum<span class="token operator">+=</span>root<span class="token punctuation">.</span>val        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val <span class="token keyword">for</span> node <span class="token keyword">in</span> re<span class="token punctuation">]</span> <span class="token keyword">for</span> re <span class="token keyword">in</span> result<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>时间复杂度：$O(N)$。本质上就是一次先序遍历加上判断的过程。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35.复杂链表的复制"></a>35.<a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">复杂链表的复制</a></h2><p>思路：这题本质上是模拟复杂链表的深拷贝。既然是深拷贝，我们就不能直接引用，而是应该使用新建值相同的节点类的方式进行拷贝。但是这道题有一个问题，就是存在random指针指向链表中的任意节点或者 <code>null</code>。 所以如何保证拷贝random指针的节点和拷贝next指针的节点的一致性，是我们需要解决的问题。也就是说，如果我们按照next指针顺序进行拷贝节点的话，如果需要拷贝的节点已经因为之前被某个节点的random指针指向，而已经被拷贝过了，如何知道它已经拷贝且正确指向他呢？</p><p>我的思路是使用一个哈希表，哈希表的key是原链表中的节点，哈希表的value是新拷贝得到的节点。当我们进行拷贝时，如果需要拷贝的节点尚且不在哈希表的key中，则我们可以进行拷贝，并将原节点-新节点的键值对保存进哈希表中，当我们再次拷贝某节点，会发现它已被拷贝过，直接将next或random指针指向它即可。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。哈希表使用了额外的空间。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""# Definition for a Node.class Node:    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):        self.val = int(x)        self.next = next        self.random = random"""</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">copyRandomList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Node'</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> head<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        copyhead<span class="token operator">=</span>Node<span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token operator">=</span>copyhead        q<span class="token operator">=</span>head        visited<span class="token operator">=</span><span class="token punctuation">{</span>head<span class="token punctuation">:</span>copyhead<span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> q<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span>                <span class="token keyword">if</span> q<span class="token punctuation">.</span>next <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    visited<span class="token punctuation">[</span>q<span class="token punctuation">.</span>next<span class="token punctuation">]</span><span class="token operator">=</span>Node<span class="token punctuation">(</span>q<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                p<span class="token punctuation">.</span>next<span class="token operator">=</span>visited<span class="token punctuation">[</span>q<span class="token punctuation">.</span>next<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                p<span class="token punctuation">.</span>next<span class="token operator">=</span>None            <span class="token keyword">if</span> q<span class="token punctuation">.</span>random<span class="token operator">!=</span>None<span class="token punctuation">:</span>                <span class="token keyword">if</span> q<span class="token punctuation">.</span>random <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    visited<span class="token punctuation">[</span>q<span class="token punctuation">.</span>random<span class="token punctuation">]</span><span class="token operator">=</span>Node<span class="token punctuation">(</span>q<span class="token punctuation">.</span>random<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                p<span class="token punctuation">.</span>random<span class="token operator">=</span>visited<span class="token punctuation">[</span>q<span class="token punctuation">.</span>random<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                p<span class="token punctuation">.</span>random<span class="token operator">=</span>None            p<span class="token punctuation">,</span>q<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">,</span>q<span class="token punctuation">.</span>next        <span class="token keyword">return</span> copyhead<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他思路：</p><p><img src="35.png" alt></p><ul><li>我们可以将链表看成是graph，利用BFS或者DFS+哈希表进行求解。本质思想和直接迭代按照单链表的next指针顺序复制是一样的。</li></ul><h2 id="35-二叉搜索树与双向链表"><a href="#35-二叉搜索树与双向链表" class="headerlink" title="35.二叉搜索树与双向链表"></a>35.<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">二叉搜索树与双向链表</a></h2><p>思路：首先，我们知道，二叉搜索树的性质有一条是中序遍历所得到的结果是升序排序的序列。恰好，我们要构造的双向链表也是升序排序的，所以我们会想到使用中序遍历来进行原地转换。</p><p>具体算法如下：</p><ul><li><p>设置全局变量head，tail指针，指向当前链表的头尾节点，初始均为None。（为什么一定要全局节点，因为这里的指针是不可变类型，所以在内部函数中对其修改不会改变外层的值，如果是可变类型则会产生改变）</p></li><li><p>开始中序遍历，如果当前节点为空，那么什么也不做，直接返回。如果当前节点非空，先递归遍历左子树。如果当前head指针非空，说明当前节点是二叉搜索树的第一个节点，即最小值，自然也就是双向链表的head节点，那么让head指向他。如果当前tail非空，说明左子树的遍历已经为双向链表加入了节点，且tail指向的是当前双向链表的尾部节点，那么进行如下修改：（1）让当前节点的left指针指向当前tail（2）让当前tail的right指针指向当前节点。接下来，无论tail是否为空，让它指向当前节点。上述三个操作相当于把当前节点加入至双向链表尾部，并让tail指向他。接下来，递归遍历右子树。简而言之，上述过程就是按照中序遍历的顺序不断原地修改二叉搜索树，tail指针始终指向当前节点的前一个节点。</p></li><li><p>完成中序遍历后，我们获得了一个头尾尚未连接的双向链表，此时我们将头节点和尾节点连接即可。</p></li><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(1)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""# Definition for a Node.class Node:    def __init__(self, val, left=None, right=None):        self.val = val        self.left = left        self.right = right"""</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>head<span class="token operator">=</span>None        self<span class="token punctuation">.</span>tail<span class="token operator">=</span>None    <span class="token keyword">def</span> <span class="token function">treeToDoublyList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Node'</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>             inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>head<span class="token operator">==</span>None<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>head<span class="token operator">=</span>root            <span class="token keyword">if</span> self<span class="token punctuation">.</span>tail<span class="token operator">!=</span>None<span class="token punctuation">:</span>                root<span class="token punctuation">.</span>left<span class="token operator">=</span>self<span class="token punctuation">.</span>tail                self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>right<span class="token operator">=</span>root            self<span class="token punctuation">.</span>tail<span class="token operator">=</span>root            inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>left<span class="token operator">=</span>self<span class="token punctuation">.</span>tail        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>head        <span class="token keyword">return</span> self<span class="token punctuation">.</span>head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="36-序列化二叉树"><a href="#36-序列化二叉树" class="headerlink" title="36.序列化二叉树"></a>36.<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">序列化二叉树</a></h2><p>思路：这道题我曾经在大二的数据结构课上做过，可以用两种方式来解决。这里我们先说层次遍历的解法。</p><p>BFS的解法：</p><ul><li>序列化：BFS的序列化按照常规做法，依然是使用队列来完成。先将根节点加入队列。每次从队首取出一个节点，如果当前节点为空，那么向序列化的字符串中添加一个”*”作为占位符，否则将它的value添加进字符串，中间用“，”隔开。然后，将其左右孩子节点均加入队列中。重复上述过程直到队列为空。</li></ul><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Encodes a tree to a single string.        :type root: TreeNode        :rtype: str        """</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span>        data<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token operator">==</span>None<span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>node<span class="token punctuation">.</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">","</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>反序列化：BFS的反序列化较为复杂，由于不是完全二叉树，不可以直接用下标运算求解子节点位置，需要使用一个辅助队列来存放当前剩余的需要处理的节点，并使用一个指针来遍历序列化字符串中逗号隔开的每个元素。</li></ul><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Decodes your encoded data to tree.        :type data: str        :rtype: TreeNode        """</span>        data<span class="token operator">=</span>data<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"*"</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None        root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span>        i<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">"*"</span><span class="token punctuation">:</span>                leftNode<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                node<span class="token punctuation">.</span>left<span class="token operator">=</span>leftNode                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>leftNode<span class="token punctuation">)</span>            i<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">"*"</span><span class="token punctuation">:</span>                rightNode<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                node<span class="token punctuation">.</span>right<span class="token operator">=</span>rightNode                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>rightNode<span class="token punctuation">)</span>            i<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一种更为简单直观的方式是DFS的做法，直接使用先序遍历求解。</p><ul><li>序列化：先序遍历，每次将当前节点加入至序列化字符串中，如果当前节点为空，则加入“*”占位符，否则加入value，然后递归遍历左子树和右子树。</li></ul><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Encodes a tree to a single string.        :type root: TreeNode        :rtype: str        """</span>        data<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        preorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">","</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>反序列化：依然是先序遍历的方式递归重建二叉树。</li></ul><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Decodes your encoded data to tree.        :type data: str        :rtype: TreeNode        """</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">:</span>            now<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> now<span class="token operator">==</span><span class="token string">"*"</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> None            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>left<span class="token operator">=</span>build<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>build<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            <span class="token keyword">return</span> root        queue<span class="token operator">=</span>data<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> build<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="37-字符串的排列"><a href="#37-字符串的排列" class="headerlink" title="37.字符串的排列"></a>37.<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">字符串的排列</a></h2><p>思路：全排列问题，采用DFS+递归的方式解决。需要注意的是这里应该进行去重，去重的思路有两种：</p><ul><li>哈希表或者集合的方式去重。</li><li>先对字符串进行字典序排序（字符串没有sort函数，必须调用全局函数sorted（）），如果当前序号的字符等于前一个字符，且前一个字符尚未被访问，则可以跳过对他的搜索。因为它的所有组合已经被前一个字符的搜索所覆盖了。具体可以参考主站的第47题<a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">全排列 II</a>。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">permutation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        s<span class="token operator">=</span>sorted<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">DFS</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token operator">==</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token boolean">True</span> <span class="token operator">and</span> <span class="token operator">not</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">and</span> visited<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                        DFS<span class="token punctuation">(</span>st<span class="token operator">+</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">False</span>        DFS<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(N*N!)$。N为字符串长度</li><li>空间复杂度：$O(N*N!)$。</li></ul><h2 id="38-数组中出现次数超过一半的数字"><a href="#38-数组中出现次数超过一半的数字" class="headerlink" title="38.数组中出现次数超过一半的数字"></a>38.<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中出现次数超过一半的数字</a></h2><p>思路：排序然后取中位数即可。因为假如某个数字出现次数超过一半，则排序后必然出现在中间位置上。</p><ul><li>时间复杂度：$O(NlogN)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="39-最小的k个数"><a href="#39-最小的k个数" class="headerlink" title="39.最小的k个数"></a>39.<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">最小的k个数</a></h2><p>思路：经典的TOP K问题！常规的做法是直接排序一下，用快排的话是$O(NlogN)$。为了能更快，主要思路有有两种，分别是使用堆（优先队列）或者快速选择。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li>基本思路：使用一个大顶堆来存储数组中前k小的元素。一开始，先使用数组中前K个元素建大顶堆，此时，堆顶的元素为前K个元素中的最大值。然后从K+1个元素向后依次遍历，如果当前元素小于大顶堆的堆顶元素，说明堆顶元素不仅大于堆中的K-1个元素，且大于当前元素，必不可能是前K小的元素。所以，我们将当前元素加入至堆中，并调整堆至继续符合大顶堆。继续向后遍历，维护大顶堆，直到遍历到数组末尾，此时堆中的元素即为数组的前K小的值。</li><li>时间复杂度：$O(nlogk)$，因为元素出堆和入队平均都需要$O(logk)$的时间复杂度，与此同时，最坏的情况下（降序排列），需要对所有的元素进行插入操作，所以时间复杂度为$O(nlogk)$。</li><li>空间复杂度：$O(k)$，使用了一个大小为k的堆。</li><li>Python中提供了高级数据结构heapq，详情可以看这篇博客<a href="https://blog.csdn.net/jamfiy/article/details/88185512" target="_blank" rel="noopener">python高级（堆heapq模块）</a>，它以列表为基础提供了小顶堆的操作。为了使用大顶堆，我们对堆中所有的元素进行取反操作，并再返回结果时恢复符号。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getLeastNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        heap<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>heap<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#将列表转换为堆</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token operator">-</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#前K个数字入堆</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token operator">-</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#这个函数的意思是，如果当前数比堆顶元素大，那么入堆并将堆顶元素出堆，否则不变</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> heap<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><ul><li><p>基本思路：在数组中找第K小（大）的元素，或者前K小（大）的元素，可以使用快速排序变形的算法，我们称之为快速选择（quick select），都是分治法。</p></li><li><p>让我们回顾快速排序的思路。快速排序中有一步很重要的操作是 partition（划分），从数组中随机选取一个枢纽元素 v，然后原地移动数组中的元素，使得比 v 小的元素在 v 的左边，比 v 大的元素在 v 的右边，如下图所示：</p><p><img src="39.jpg" alt="快速排序"></p><p>这个 partition 操作是原地进行的，需要 $O(n)$ 的时间，接下来，快速排序会递归地排序左右两侧的数组。而快速选择（quick select）算法的不同之处在于，接下来只需要递归地选择一侧的数组。快速选择算法想当于一个“不完全”的快速排序，因为我们只需要知道最小的 k 个数是哪些，并不需要知道它们的顺序。</p><p>我们的目的是寻找最小的 k 个数。假设经过一次 partition 操作，枢纽元素位于下标 m，也就是说，左侧的数组有 m 个元素，是原数组中最小的 m 个数。那么：</p><ul><li>若 k = m，我们就找到了最小的 k 个数，就是左侧的数组；</li><li>若 k&lt;m ，则最小的 k 个数一定都在左侧数组中，我们只需要对左侧数组递归地 parition 即可；</li><li>若 k&gt;m，则左侧数组中的 m 个数都属于最小的 k 个数，我们还需要在右侧数组中寻找最小的 k-m个数，对右侧数组递归地 partition 即可。</li></ul></li><li><p>复杂度分析比较麻烦：</p><p><img src="39.png" alt="快速选择的复杂度分析"></p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getLeastNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#和快速排序中的分治一样，将当前区间首部的枢纽元素调整至正确的位置</span>            i<span class="token operator">=</span>left<span class="token operator">+</span><span class="token number">1</span>            j<span class="token operator">=</span>right            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>right <span class="token operator">and</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    i<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j<span class="token operator">></span>left <span class="token operator">and</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">>=</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    j<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">if</span> i<span class="token operator">&lt;</span>j<span class="token punctuation">:</span>                    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                    <span class="token keyword">break</span>            <span class="token keyword">return</span> j        <span class="token keyword">def</span> <span class="token function">quickSelect</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#快速选择算法</span>            m<span class="token operator">=</span>partition<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> m<span class="token operator">==</span>k<span class="token punctuation">:</span>                <span class="token keyword">return</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">elif</span> m<span class="token operator">></span>k<span class="token punctuation">:</span>                <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span>left<span class="token punctuation">,</span>m<span class="token number">-1</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span>        <span class="token keyword">if</span> k<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> k<span class="token operator">></span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> arr        <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="40-数据流中的中位数"><a href="#40-数据流中的中位数" class="headerlink" title="40.数据流中的中位数"></a>40.<a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">数据流中的中位数</a></h2><p>思路：这道题我们可以将插入的数字保存在一个数组中，然后排序数组输出中位数。很明显，这样做很低效。较好的一种思路是使用二分法查找插入的位置，保证每次插入后数组是有序的。但是这样做还不够好，我们可以通过使用两个堆来解决这一问题。</p><ul><li>我们使用一个大顶堆用于存放当前所有数据中的前一半数据（下标由0到len//2），使用一个小顶堆存放当前数组的后一半数据（下标由len//2+1到len-1）。当总长度为奇数时，我们取大顶堆中的堆顶元素作为中位数，否则取两个堆堆顶元素求平均。</li><li>由于中位数在大顶堆中，所以当前数据总数为奇数时，大顶堆规模比小顶堆大1，当数据总数为偶数时，大顶堆规模和小顶堆相等。所以插入后数据总数为奇数时，新的数先插入小顶堆，再从小顶堆堆顶取出元素插入大顶堆，使小顶堆规模不变，大顶堆规模加1，从而保证了前述的性质。插入后数据总数为偶数时，新的数先插入大顶堆，再从大顶堆堆顶取出元素插入小顶堆，使大顶堆规模不变，小顶堆规模加1。</li><li>时间复杂度：插入元素：$O(logk)$，求中位数：$O(log1)$。</li><li>Python中只有小顶堆，所以大顶堆需要用负数来模拟。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MedianFinder</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>largeHeap<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>smallHeap<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>count<span class="token operator">=</span><span class="token number">0</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>self<span class="token punctuation">.</span>largeHeap<span class="token punctuation">)</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>self<span class="token punctuation">.</span>smallHeap<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">addNum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>count<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>self<span class="token punctuation">.</span>largeHeap<span class="token punctuation">,</span><span class="token operator">-</span>heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>self<span class="token punctuation">.</span>smallHeap<span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>self<span class="token punctuation">.</span>smallHeap<span class="token punctuation">,</span><span class="token operator">-</span>heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>self<span class="token punctuation">.</span>largeHeap<span class="token punctuation">,</span><span class="token operator">-</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>count<span class="token operator">+=</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">findMedian</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None        <span class="token keyword">if</span> self<span class="token punctuation">.</span>count<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">-</span>self<span class="token punctuation">.</span>largeHeap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>self<span class="token punctuation">.</span>smallHeap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span>self<span class="token punctuation">.</span>largeHeap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your MedianFinder object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MedianFinder()</span><span class="token comment" spellcheck="true"># obj.addNum(num)</span><span class="token comment" spellcheck="true"># param_2 = obj.findMedian()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="41-连续子数组的最大和"><a href="#41-连续子数组的最大和" class="headerlink" title="41.连续子数组的最大和"></a>41.<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">连续子数组的最大和</a></h2><p>思路：动态规划，与主站53题相同。状态矩阵DP[i]表示以第i个数结尾的连续子数组的最大和。转移方程为：DP[i]=（1）nums[i]（if DP[i-1]&lt;=0） （2）DP[i-1]+nums[i]（else），转移过程中记录最大值。特别地，我们可以原地修改Nums矩阵作为DP矩阵。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> nums<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None        maxSum<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>            maxSum<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>maxSum<span class="token punctuation">)</span>        <span class="token keyword">return</span> maxSum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="42-数字-1-的个数"><a href="#42-数字-1-的个数" class="headerlink" title="42.数字 1 的个数"></a>42.<a href="https://leetcode-cn.com/problems/number-of-digit-one/" target="_blank" rel="noopener">数字 1 的个数</a></h2><p>思路：数学规律题，需要慢慢分析。个人认为面试题的可能性不大，以后再做。</p><h2 id="43-数字序列中某一位的数字"><a href="#43-数字序列中某一位的数字" class="headerlink" title="43.数字序列中某一位的数字"></a>43.<a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">数字序列中某一位的数字</a></h2><p>思路：依然是数学规律题，一位数从0到9，共10个，总占位数10位，两位数从10到99，共90个，总占位数180位…..以此类推，m位数所占位数为$(10^m-10^{m-1})*m$。从而可以推出某一位的数字是哪个数字的哪一位。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findNthDigit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">cal</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> m<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">10</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">**</span>m<span class="token number">-10</span><span class="token operator">**</span><span class="token punctuation">(</span>m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span>m        m<span class="token operator">=</span><span class="token number">0</span>        s<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> n<span class="token operator">>=</span>s<span class="token punctuation">:</span>            m<span class="token operator">+=</span><span class="token number">1</span>            s<span class="token operator">+=</span>cal<span class="token punctuation">(</span>m<span class="token punctuation">)</span>        s<span class="token operator">-=</span>cal<span class="token punctuation">(</span>m<span class="token punctuation">)</span>        <span class="token keyword">if</span> m<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>n<span class="token operator">-</span>s<span class="token punctuation">)</span><span class="token operator">//</span>m        <span class="token keyword">else</span><span class="token punctuation">:</span>            num<span class="token operator">=</span> str<span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">**</span><span class="token punctuation">(</span>m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>n<span class="token operator">-</span>s<span class="token punctuation">)</span><span class="token operator">//</span>m<span class="token punctuation">)</span>            offset<span class="token operator">=</span><span class="token punctuation">(</span>n<span class="token operator">-</span>s<span class="token punctuation">)</span><span class="token operator">%</span>m            <span class="token keyword">return</span> int<span class="token punctuation">(</span>num<span class="token punctuation">[</span>offset<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="44-把数组排成最小的数"><a href="#44-把数组排成最小的数" class="headerlink" title="44.把数组排成最小的数"></a>44.<a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">把数组排成最小的数</a></h2><p>思路：这道题主要的思路是这样的，我们需要对当前数组进行排序，排序的规则需要我们重新定义。我们比较两个字符串，如果A+B的字典序小于B+A，那么A一定在B之前。重写排序规则的方法，在Java中可以重写Comparator，Python中新建一个类，重写它的lt方法，并将其传入sorted函数的key中。</p><ul><li>时间复杂度：$O(NlogN)$。排序的时间复杂度。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">cmpSmaller</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__lt__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self <span class="token operator">+</span> y <span class="token operator">&lt;</span> y <span class="token operator">+</span> self  <span class="token comment" spellcheck="true"># 字符串拼接比较(两两比较)</span>    <span class="token comment" spellcheck="true"># 按由小到大来排列</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        res<span class="token operator">=</span>sorted<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">,</span>key<span class="token operator">=</span>cmpSmaller<span class="token punctuation">)</span>        smallest <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>res<span class="token punctuation">)</span>        <span class="token keyword">return</span> smallest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="45-把数字翻译成字符串"><a href="#45-把数字翻译成字符串" class="headerlink" title="45.把数字翻译成字符串"></a>45.<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">把数字翻译成字符串</a></h2><p>思路：先将数字转字符串便于直接获取某一位，再动态规划，状态矩阵dp[i]为前i个字符的翻译方法数目。转移时，要注意：由于单个数字必然可以转为字母，如果前一个数字字符和当前数字字符组成的新数字在[10，25]间，说明它们可以组成一个英文字母（此处，含有前缀0的数字不可以被翻译成字母，如“01”等），那么dp[i]=dp[i-1]+dp[i-2]，否则dp[i]=dp[i-1]。特别地，对于i==1时要特殊判断一下，因为涉及到字符串的初始化。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(N)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">translateNum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        num<span class="token operator">=</span>str<span class="token punctuation">(</span>num<span class="token punctuation">)</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp<span class="token operator">=</span>int<span class="token punctuation">(</span>num<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>tmp<span class="token operator">&lt;=</span><span class="token number">25</span> <span class="token operator">and</span> num<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'0'</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，像这种只用到前两个状态的动态规划，还可以使用滚动数组的方式降低空间复杂度。</p><h2 id="46-礼物的最大价值"><a href="#46-礼物的最大价值" class="headerlink" title="46.礼物的最大价值"></a>46.<a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">礼物的最大价值</a></h2><p>思路：有些类似于主站的机器人走迷宫问题，一开始这种题目我们很容易想到DFS，但是我们发现会超时，因为对许多路径进行了重复的遍历，产生了重叠子问题。很明显，这里我们要使用动态规划，dp[i] [j]为走到（i，j）格子时的最大礼物数目，转移方程见程序，选取上方或者左侧的状态中的最大值加上当前格子礼物价值作为当前状态。特别地，我们还可以原地修改grid作为我们的状态矩阵dp，不使用额外空间。</p><ul><li>时间复杂度：$O(MN)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxValue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> row<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> col<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">+=</span>grid<span class="token punctuation">[</span>row<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span>                <span class="token keyword">elif</span> row<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> col<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                    grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">+=</span>grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token keyword">elif</span> row<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> col<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                    grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">+=</span>max<span class="token punctuation">(</span>grid<span class="token punctuation">[</span>row<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">,</span>grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> grid<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="47-最长不含重复字符的子字符串"><a href="#47-最长不含重复字符的子字符串" class="headerlink" title="47.最长不含重复字符的子字符串"></a>47.<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">最长不含重复字符的子字符串</a></h2><p>思路：与主站第3题类似，采用双指针维护一个不含重复字符的滑动窗口。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span><span class="token number">1</span>        max_len<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token keyword">in</span> s<span class="token punctuation">[</span>left<span class="token punctuation">:</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                left<span class="token operator">+=</span><span class="token number">1</span>            now_len<span class="token operator">=</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">if</span> now_len<span class="token operator">></span>max_len<span class="token punctuation">:</span>                max_len<span class="token operator">=</span>now_len            right<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> max_len<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="48-丑数"><a href="#48-丑数" class="headerlink" title="48.丑数"></a>48.<a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">丑数</a></h2><p>思路：这道题我曾经在蓝桥杯上做过，基本思路就是动态规划，dp[i]为第i个丑数。具体做法是使用三个指针，分别指向2、3、5所要乘以的丑数因子，每次从三个指针指向的丑数分别乘以2、3、5所得乘积中选取最小值添加到当前丑数数组中，并将最小值对应的指针加1，继续比较。（需要注意的是，这里的最小值可能不止一个）</p><p>当然，这道题还可以用一个小顶堆来做，基本的思路是小顶堆堆顶存放当前最小丑数，每次取出最小丑数，并将它乘2、3、5的积加入堆中，继续取最小丑数，取n次。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">nthUglyNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>      dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>      p2<span class="token punctuation">,</span>p3<span class="token punctuation">,</span>p5<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>          dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>p3<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>p5<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>dp<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">:</span>              p2<span class="token operator">+=</span><span class="token number">1</span>          <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>dp<span class="token punctuation">[</span>p3<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">:</span>              p3<span class="token operator">+=</span><span class="token number">1</span>          <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>dp<span class="token punctuation">[</span>p5<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">:</span>              p5<span class="token operator">+=</span><span class="token number">1</span>      <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="49-第一个只出现一次的字符"><a href="#49-第一个只出现一次的字符" class="headerlink" title="49.第一个只出现一次的字符"></a>49.<a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/" target="_blank" rel="noopener">第一个只出现一次的字符</a></h2><p>思路：简单题，使用哈希表来存放每个字符出现的次数，输出第一个出现次数为1的字符。</p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(N)$。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">if</span> s<span class="token punctuation">:</span>            dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>            <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>                <span class="token keyword">if</span> ch <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    dic<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dic<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">for</span> key <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> key        <span class="token keyword">return</span> <span class="token string">" "</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="50-数组中的逆序对"><a href="#50-数组中的逆序对" class="headerlink" title="50.数组中的逆序对"></a>50.<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">数组中的逆序对</a></h2><p>思路：这道题的思路很难想到，需要慢慢分析。最简单的做法是暴力遍历，时间复杂度为$O(N^2)$。但很明显，时间复杂度过高，会很慢。在这里，我们使用一种归并排序的思想进行优化。</p><ul><li>正常进行归并排序。</li><li>只用添加一行代码，就是使用双指针归并两个有序数组时，如果前一个数组的指针p指向的数大于后一个数组的指针q指向的数，说明前面的数组中，自p到最后一个下标的数都大于q下标的数，都为逆序对，所以需要在全局变量count中加上len（nums1）-p。（相较于直接暴力破解，这样做可以一次确定多个逆序对）</li><li>时间复杂度：$O(NlogN)$。本质上还是归并排序</li><li>空间复杂度：$O(N)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>sum<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">mergeTwoList</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span>nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>            p<span class="token operator">=</span><span class="token number">0</span>            q<span class="token operator">=</span><span class="token number">0</span>            result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span> <span class="token operator">and</span> q<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">:</span>                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span>                    p<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>sum<span class="token operator">+=</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">-</span>p                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span>                    q<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> p<span class="token operator">==</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">:</span>                result<span class="token operator">+=</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">:</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                result<span class="token operator">+=</span>nums1<span class="token punctuation">[</span>p<span class="token punctuation">:</span><span class="token punctuation">]</span>            <span class="token keyword">return</span> result        <span class="token keyword">def</span> <span class="token function">mergesort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> nums            mid<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">return</span> mergeTwoList<span class="token punctuation">(</span>mergesort<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token punctuation">:</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>mergesort<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        mergesort<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>sum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="51-两个链表的第一个公共节点"><a href="#51-两个链表的第一个公共节点" class="headerlink" title="51.两个链表的第一个公共节点"></a>51.<a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">两个链表的第一个公共节点</a></h2><p>思路：最简单的方法是暴力比较，时间复杂度较高。可以考虑哈希表辅助比较，但是空间复杂度较高。最好的办法是双指针法，指针P指向headA，指针Q指向headB，二者同时向后遍历，如果P到达终点，那么让他重新从headB开始；如果Q到达终点，那么让他重新从headA开始，最终二者必然相遇。</p><p>双指针法原理是： 若相交，链表A： a+c, 链表B : b+c。 a+c+b+c = b+c+a+c ，则会在公共处c起点相遇。若不相交，a +b = b+a 。因此相遇处是NULL 。</p><ul><li>时间复杂度：$O(m+n)$。</li><li>空间复杂度：$O(1)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> headA<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> headB<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        p<span class="token operator">=</span>headA        q<span class="token operator">=</span>headB        <span class="token keyword">while</span> p<span class="token operator">!=</span>q<span class="token punctuation">:</span>            p<span class="token operator">=</span>headB <span class="token keyword">if</span> p<span class="token operator">==</span>None <span class="token keyword">else</span> p<span class="token punctuation">.</span>next            q<span class="token operator">=</span>headA <span class="token keyword">if</span> q<span class="token operator">==</span>None <span class="token keyword">else</span> q<span class="token punctuation">.</span>next        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="52-I-在排序数组中查找数字-I"><a href="#52-I-在排序数组中查找数字-I" class="headerlink" title="52.I. 在排序数组中查找数字 I"></a>52.<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">I. 在排序数组中查找数字 I</a></h2><p>思路：我们首先肯定想到的是顺序遍历数组，但那样无法获取log级别的时间复杂度。为了优化，我们使用二分的思想，与主站34题类似，先二分查找该数字第一次出现的位置，再二分查找其最后一次出现的位置，最后返回差值即可。</p><ul><li>时间复杂度：$O(logN)$。</li><li>空间复杂度：$O(1)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">searchLeftBound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            left<span class="token operator">=</span><span class="token number">0</span>            right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>                mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">>=</span>target<span class="token punctuation">:</span>                    right<span class="token operator">=</span>mid<span class="token number">-1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>left<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> left            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">def</span> <span class="token function">searchRightBound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            left<span class="token operator">=</span><span class="token number">0</span>            right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>                mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token punctuation">:</span>                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    right<span class="token operator">=</span>mid<span class="token number">-1</span>            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> right            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        leftBound<span class="token operator">=</span>searchLeftBound<span class="token punctuation">(</span><span class="token punctuation">)</span>        rightBound<span class="token operator">=</span>searchRightBound<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> leftBound<span class="token operator">></span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> rightBound<span class="token operator">-</span>leftBound<span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="53-II-0～n-1中缺失的数字"><a href="#53-II-0～n-1中缺失的数字" class="headerlink" title="53.II. 0～n-1中缺失的数字"></a>53.<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">II. 0～n-1中缺失的数字</a></h2><p>思路：首先我们想到的是顺序遍历检查下标，但这样依然是线性的时间复杂度。为了优化至对数级别的时间复杂度，我们还是使用二分的方法，如果中位数与下标相等，说明它及它之前的所有数都不缺失，进入右区间查找缺失的数字，否则进入左区间查找。最后返回Left，为什么是left可以自己模拟一下。当最后的left等于len（nums）时，说明当前数组所有的数字均不缺失。</p><ul><li>时间复杂度：$O(logN)$。</li><li>空间复杂度：$O(1)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>mid<span class="token punctuation">:</span>                left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                right<span class="token operator">=</span>mid<span class="token number">-1</span>        <span class="token keyword">return</span> left<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54.二叉搜索树的第k大节点"></a>54.<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">二叉搜索树的第k大节点</a></h2><p>思路：与数组中求第（前）k大（小）是一样的，两种思路：（1）堆，（2）快速选择。这里我们由于事先没有完整的数据，需要进行二叉树的遍历，所以使用堆更好。在这里我们使用大小为k的小顶堆存放前k大的数。</p><ul><li>时间复杂度：$O(NlogK)$。</li><li>空间复杂度：$O(K)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">kthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>k<span class="token operator">=</span>k        heap<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>heap<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>k<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>k<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            preOrder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            preOrder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        preOrder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> heap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，我们发现这棵树是二叉查找树，即每个节点的左子树都小于它，右子树都大于它，中序遍历得到的序列为所有元素的升序排列。我们可以稍加修改，中序遍历从左-根-右修改成右-根-左，即把遍历的结果变为所有元素的降序排列。然后我们使用一个计数变量，当遍历k次时，输出结果即可。</p><ul><li>时间复杂度：$O(K)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">kthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>k<span class="token operator">=</span>k        self<span class="token punctuation">.</span>res<span class="token operator">=</span>None        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None <span class="token operator">and</span> self<span class="token punctuation">.</span>res<span class="token operator">==</span>None<span class="token punctuation">:</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>k<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>k<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>res<span class="token operator">=</span>root<span class="token punctuation">.</span>val                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="55-I-二叉树的深度"><a href="#55-I-二叉树的深度" class="headerlink" title="55.I. 二叉树的深度"></a>55.<a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">I. 二叉树的深度</a></h2><p>思路：二叉树操作中的基本题目，递归求解，如果当前节点为空，那么当前深度为0，否则当前深度为1加上左右子树的深度的最大值。层层返回深度，根节点的深度即为二叉树的深度。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(N)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="56-II-平衡二叉树"><a href="#56-II-平衡二叉树" class="headerlink" title="56.II. 平衡二叉树"></a>56.<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">II. 平衡二叉树</a></h2><p>思路：DFS，同时使用辅助函数计算当前深度，如果当前左右子树均平衡，且他们的深度之差小于等于1，则说明当前二叉树平衡。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> match<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> match<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">and</span> abs<span class="token punctuation">(</span>depth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token operator">-</span>depth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">1</span>        <span class="token keyword">def</span> <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>max<span class="token punctuation">(</span>depth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span>depth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> match<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化：上述算法求解子树深度时会出现很多重复的计算，可以进行优化。</p><ul><li>当前节点为空：当前树满足平衡二叉树的要求，且深度为0，返回0。</li><li>当前节点左子树或右子树不是平衡二叉树：返回-1。</li><li>否则：如果左子树和右子树深度差小于等于1，说明当前树是平衡二叉树，返回当前树的深度，否则，返回-1。</li></ul><p>减少了对树深度的重复求解，使子树可以返回深度信息，不用重新遍历整个树求深度了。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>            left <span class="token operator">=</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> left <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            right <span class="token operator">=</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> right <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">return</span> max<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> abs<span class="token punctuation">(</span>left <span class="token operator">-</span> right<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="57-I-数组中数字出现的次数"><a href="#57-I-数组中数字出现的次数" class="headerlink" title="57.I. 数组中数字出现的次数"></a>57.<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">I. 数组中数字出现的次数</a></h2><p>思路：如果想要获得线性的时间复杂度和常数级的空间复杂度，这一类题我们只能使用位运算。</p><p>python的位运算：</p><blockquote><p>&amp;：按位与操作，只有 1 &amp;1 为1，其他情况为0。可用于进位运算。</p><p>|：按位或操作，只有 0|0为0，其他情况为1。</p><p>~：逐位取反。</p><p>^：异或，相同为0，相异为1。可用于加操作（不包括进位项）。</p><p>&lt;&lt;：左移操作，2的幂相关</p><p>&gt;&gt;：右移操作，2的幂相关</p></blockquote><ul><li>假如本题简化为： 除了一个数字出现一次，其他都出现了两次，让我们找到出现一次的数。 </li><li>解决方案：使用按位异或运算，由于任何数异或自己本身得到的是0，任何数异或0得到的是自己本身，所以我们可以对数组中全部的数字执行全员异或。假设全部数字两两出现，那么每一个二进制位上的1和0出现的个数必然是偶数，异或的结果必然是0，最后再异或上出现一次的数字的该二进制位的值，会保留这个值。最终全员异或的结果必是出现了一次的数。</li><li>补充：异或满足交换律，17 xor 19 xor 17 相当于 17 xor 17 xor 19 = 0 xor 19 = 19 。</li><li>这里把其他出现了两次修改为任何的偶数次，都可以全员异或求解。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        single_number <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            single_number <span class="token operator">^</span><span class="token operator">=</span> num        <span class="token keyword">return</span> single_number<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>那么假如我们将偶数次再扩展为任意次，那么对于奇数次如何求解呢？即问题变为： 除了一个数字出现一次，其他都出现了三次，让我们找到出现一次的数。 </li><li>解决方案：依然可以使用位运算。统计二进制编码每一位上1出现的次数，假设所有数字都出现了3次，那么每一位上的1必然出现了3的倍数次（包括0）。考虑到出现了一次的数，如果某一位上1出现的次数不是3的倍数，那么出现了一次的数的二进制编码在这一位上必然是1。根据上述性质，便可求解出现了一次的数的二进制编码，转回十进制即可。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            cnt <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 记录当前 bit 有多少个1</span>            bit <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i  <span class="token comment" spellcheck="true"># 记录当前要操作的 bit</span>            <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>                <span class="token keyword">if</span> num <span class="token operator">&amp;</span> bit <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                    cnt <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> cnt <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 不等于0说明唯一出现的数字在这个 bit 上是1</span>                res <span class="token operator">|</span><span class="token operator">=</span> bit        <span class="token keyword">return</span> res <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token number">32</span> <span class="token keyword">if</span> res <span class="token operator">></span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token number">31</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">else</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>注：这里的返回值是因为python的机制问题，补码上表示符号的位会被解释为数值位。要手动将其变为正确的结果。</p></li><li><p>了解完上述两道题，我们大致知道了使用位运算求解数组中出现次数特殊的数字。回到本题，本题的思路看上去和上面举的第一个例子十分类似。我们已经知道了如何求解一个数组中一个数字出现一次，其他都出现了两次的解法。为了解决当前问题，我们可以把数组划分为两个数组，每个数组中一个数字出现一次，其他都出现了两次。</p></li><li><p>如何划分：同样将整个数组异或，异或之后，得到一个数字，这个数字从二进制数的角度看，一定有位数为1。这个1是怎么来的？就是那两个只出现一次的数字，异或得到的，他们对应的位不一样，肯定是一个数对应位数出现的是0，另一个数字对应位置上出现的数字是1.据此，将这个数组分成两个部分。一部分是，对应位置出现的数是0的数组，一部分是，对应位置出现的数是1的数组，此时，这两个数组满足我们第一个例题提到的要求，我们对其分别进行全局异或，即可得到两个数字。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        result1<span class="token punctuation">,</span>result2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        tmp<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            tmp<span class="token operator">^</span><span class="token operator">=</span>num        n<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>tmp<span class="token operator">&amp;</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            n<span class="token operator">=</span>n<span class="token operator">&lt;&lt;</span><span class="token number">1</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> num<span class="token operator">&amp;</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#注意：这里不能判断其是否等于1，否则会出错。要判断其是否与运算后还是n或0。</span>                result1<span class="token operator">^</span><span class="token operator">=</span>num            <span class="token keyword">else</span><span class="token punctuation">:</span>                result2<span class="token operator">^</span><span class="token operator">=</span>num        <span class="token keyword">return</span> <span class="token punctuation">[</span>result1<span class="token punctuation">,</span>result2<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="58-II-数组中数字出现的次数-II"><a href="#58-II-数组中数字出现的次数-II" class="headerlink" title="58.II. 数组中数字出现的次数 II"></a>58.<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">II. 数组中数字出现的次数 II</a></h2><p>思路：上一题思路中的第二个例子，给出了解法。基本思路就是使用移位+与运算，统计所有数字每一位上1出现的总次数，假如某一位上1出现的总次数不为3的倍数，说明多出来的数字在这一位上取1。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            count<span class="token operator">=</span><span class="token number">0</span>            n<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i            <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>                <span class="token keyword">if</span> num<span class="token operator">&amp;</span>n<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                    count<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> count<span class="token operator">%</span><span class="token number">3</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                result<span class="token operator">|</span><span class="token operator">=</span>n        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="59-和为s的两个数字"><a href="#59-和为s的两个数字" class="headerlink" title="59.和为s的两个数字"></a>59.<a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">和为s的两个数字</a></h2><p>思路：主站n数之和的简化版，使用双指针法从两侧逼近结果，同时逼近时可以注意跳过重复的数字，减少计算量。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token operator">==</span>left<span class="token punctuation">)</span><span class="token punctuation">:</span>                    left<span class="token operator">+=</span><span class="token number">1</span>                left<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token number">-1</span><span class="token operator">==</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>                    right<span class="token operator">-=</span><span class="token number">1</span>                right<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="60-II-和为s的连续正数序列"><a href="#60-II-和为s的连续正数序列" class="headerlink" title="60.II. 和为s的连续正数序列"></a>60.<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">II. 和为s的连续正数序列</a></h2><p>思路：这道题，我们一开始可能会想到数学解法或者暴力解法，事实上并不需要那么做。我们可以使用滑动窗口法来求解。</p><p>我们使用两个指针left和right维护一个在[1，n]的连续整数区间上滑动的窗口。特别地，我们发现，由于题目要求的正数序列连续且至少含两个数，那么滑动窗口中最大的数不能超过（n+1）//2，所以我们滑动的区间可以缩小为[1，（n+1）//2]。开始时，left=1，right=2，然后right顺序向左滑动，如果当前区间和等于s，则可以将当前区间加入到结果中，如果当前区间和大于s，那么我们要收缩左边界至区间和小于等于s，特别地，如果此时区间和等于s，我们也要把当前区间加入到结果中。如果当前区间和小于s，那么继续右边界向右滑动。当右边界到达终点时，结束滑动。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findContinuousSequence</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        left<span class="token operator">=</span><span class="token number">1</span>        sum<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> right <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">(</span>target<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            sum<span class="token operator">+=</span>right            <span class="token keyword">if</span> sum<span class="token operator">==</span>target<span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">elif</span> sum<span class="token operator">></span>target<span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>sum<span class="token operator">></span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>                    sum<span class="token operator">-=</span>left                    left<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> sum<span class="token operator">==</span>target<span class="token punctuation">:</span>                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="61-I-翻转单词顺序"><a href="#61-I-翻转单词顺序" class="headerlink" title="61. I. 翻转单词顺序"></a>61.<a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/" target="_blank" rel="noopener"> I. 翻转单词顺序</a></h2><p>思路：如果用python的字符串方法split（）+join（）来做的话很简单。自己实现的话主要就是先判断一下每个单词的边界：（1）每个单词的首字符不为空格，且要么是句子的第一个字符，要么前一个字符为空格（2）每个单词的尾字符不为空格，且要么是句子的最后一个字符，要么后一个字符为空格。每找到一对边界后，将字符串切片得到的单词加入单词列表，并调用join函数拼接他们。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseWords</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        start<span class="token operator">=</span><span class="token number">0</span>        end<span class="token operator">=</span><span class="token number">0</span>        words<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">' '</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> <span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    start<span class="token operator">=</span>i                <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">or</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    end<span class="token operator">=</span>i                    words<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">[</span>start<span class="token punctuation">:</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>words<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，还可以进行两次翻转。先将整个字符串进行翻转，再对每个单词进行翻转。</p><h2 id="62-II-左旋转字符串"><a href="#62-II-左旋转字符串" class="headerlink" title="62. II. 左旋转字符串"></a>62.<a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank" rel="noopener"> II. 左旋转字符串</a></h2><p>思路：python如果使用字符串的切片将非常简单，更复杂的解法有两种：</p><ul><li>三次翻转。先将s[:k]翻转，再将s[k:]翻转，最后将整个字符串翻转。</li><li>空间换时间。直接拼接两个s为ss，取ss[k:k+(len(s))]即可。</li><li>模运算。类似于动态规划中滚动数组和顺序表队列插入的思想。设i从k到k+len（s），i对len（s）求模。节约了空间。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseLeftWords</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        res<span class="token operator">=</span><span class="token string">""</span>        l<span class="token operator">=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">,</span>n<span class="token operator">+</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token operator">+=</span>s<span class="token punctuation">[</span>i<span class="token operator">%</span>l<span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="63-I-滑动窗口的最大值"><a href="#63-I-滑动窗口的最大值" class="headerlink" title="63. I. 滑动窗口的最大值"></a>63.<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener"> I. 滑动窗口的最大值</a></h2><p>思路：这题表面看可以移动窗口并遍历寻找最大值，但实际上时间复杂度太高，为$O(NK)$，不符合要求。为了将时间复杂度降到$O(N)$，我们需要使用一个辅助双向单调队列来做。双向队列中的元素满足：（1）在当前滑动窗口内（2）单调递减。（为什么使用双向队列：因为我们希望在两端都可以取出元素）。每次添加一个新的元素，调整队列的方法为：</p><ul><li>如果当前队尾元素小于新元素，那么新元素入队后，双向队列将不符合单调递减的性质，所以将队尾元素出队，移除队尾所有比当前元素小的元素。（即辅助队列为当前窗口可能的最大值的降序排列）</li><li>如果当前队首元素下标不在窗口内，将其出队。</li></ul><p>我们先用数组的前k个元素建立该队列，然后每次滑动窗口时添加一个元素并调整队列，当前队列的首元素即为当前窗口中的最大值。在这里，我们在队列中存放下标而非实际的值，这样方便我们判断元素是否在窗口内。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(K)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> nums<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">or</span> k<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">change_queue</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span>nums<span class="token punctuation">[</span>queue<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">if</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>i<span class="token operator">-</span>k<span class="token punctuation">:</span>                queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>            change_queue<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        result<span class="token operator">=</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            change_queue<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，我使用了python的列表来模拟一个双向队列，实际上python的collections库提供了许多封装的数据结构，双向队列为deque。</p><h2 id="64-II-队列的最大值"><a href="#64-II-队列的最大值" class="headerlink" title="64. II. 队列的最大值"></a>64. <a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">II. 队列的最大值</a></h2><p>思路：和63题思路基本一致，使用一个辅助双向单调递减队列存放可能的最大值，每次有新元素入队时，调整队列；每次有元素出队时，如果该元素是当前队列最大元素，那么辅助队列也要进行pop，调整为下一个最大的元素。其实这道题本质上和上一道题是一样的，上一题你可以看作是本题的一种特殊情况：先不断让元素入队，达到窗口大小K之后，每次让新元素入队，队首元素出队。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MaxQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>dequeue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">max_value</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>dequeue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">if</span> self<span class="token punctuation">.</span>dequeue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">push_back</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>dequeue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>dequeue<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>value<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#这里与63题不一样，是小于，因为无法用下标来判断是否出队，索性保留重复的。</span>            self<span class="token punctuation">.</span>dequeue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dequeue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop_front</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>queue<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        res<span class="token operator">=</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> res<span class="token operator">==</span>self<span class="token punctuation">.</span>dequeue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>dequeue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token comment" spellcheck="true"># Your MaxQueue object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MaxQueue()</span><span class="token comment" spellcheck="true"># param_1 = obj.max_value()</span><span class="token comment" spellcheck="true"># obj.push_back(value)</span><span class="token comment" spellcheck="true"># param_3 = obj.pop_front()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="65-n个骰子的点数"><a href="#65-n个骰子的点数" class="headerlink" title="65.n个骰子的点数"></a>65.<a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">n个骰子的点数</a></h2><p>我的最初思路：DFS寻找n个骰子的点数全排列，哈希表记录每种点数和对应的排列数目，最后计算每种点数和的概率即可。时间复杂度为$O(6^n)$。</p><p>编写后，发现时间复杂度太高。再次观察，发现DFS出现了重叠子问题，就像机器人走迷宫的那道题一样。</p><p>解决的方法是采用动态规划。状态矩阵DP[i] [j]为i个骰子掷出j的点数和时的点数排列组合的数目。</p><blockquote><p>转移方程（注意越界）：</p><p>for k in range(1,7):    </p><p>dp[i] [j]=dp[i-1] [j-k]</p></blockquote><ul><li>时间复杂度：$O(N^2)$。</li><li>空间复杂度：$O(N^2)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>float<span class="token punctuation">]</span><span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">6</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> j<span class="token operator">-</span>k<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>k<span class="token punctuation">]</span>        s<span class="token operator">=</span>sum<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> num<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token operator">/</span>s<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别地，像这种每一个状态的转移仅依赖于之前有限个状态的动态规划，还可以使用滚动数组的方法进行空间上的优化，不必保存完整的状态。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>float<span class="token punctuation">]</span><span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">*</span>i<span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token comment" spellcheck="true">#这里一定要清零！</span>                <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> j<span class="token operator">-</span>k<span class="token operator">>=</span>i<span class="token number">-1</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+=</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>k<span class="token punctuation">]</span>        s<span class="token operator">=</span>pow<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">,</span>n<span class="token operator">*</span><span class="token number">6</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>s<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="66-扑克牌中的顺子"><a href="#66-扑克牌中的顺子" class="headerlink" title="66.扑克牌中的顺子"></a>66.<a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">扑克牌中的顺子</a></h2><p>思路：有两种思路，分别是排序和不排序的思路。</p><ul><li>不排序：遍历扑克牌，如果出现了0，那么跳过；如果当前数字重复，那么返回False；如果当前数字不重复，更新最大值和最小值。最后，如果数组中的最大值减去最小值小于5，那么说明可以组成一个顺子。</li><li>时间复杂度：$O(N)$。遍历一次数组。</li><li>空间复杂度：$O(N)$。哈希表。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isStraight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        max_value<span class="token operator">=</span><span class="token number">0</span>        min_value<span class="token operator">=</span><span class="token number">14</span>        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dic<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>            max_value<span class="token operator">=</span>max<span class="token punctuation">(</span>max_value<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            min_value<span class="token operator">=</span>min<span class="token punctuation">(</span>min_value<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> max_value<span class="token operator">-</span>min_value<span class="token operator">&lt;</span><span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>排序：对扑克牌数组进行升序排序，同时统计0的个数。对于非0的相邻数字，先看它们是否重复，再看它们之间缺失的数是否可以被0代替。例如 [0,0,1,2,5]，2和5间缺失了2个数，此时数组中有两个0，可以填补。填补后记得更新0的数量。</li><li>时间复杂度：$O(NlogN)$。排序。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isStraight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        num_zero<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                num_zero<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>                num_zero<span class="token operator">-=</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span>                <span class="token keyword">if</span> num_zero<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="67-圆圈中最后剩下的数字"><a href="#67-圆圈中最后剩下的数字" class="headerlink" title="67.圆圈中最后剩下的数字"></a>67.<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">圆圈中最后剩下的数字</a></h2><p>思路：这道题我们首先想到的是模拟，但是模拟时间复杂度很高，会超时。我尝试了一些优化的方案，都不行。实际上，这道题是数学问题，经典的约瑟夫环问题。具体推导可见<a href="https://blog.csdn.net/u011500062/article/details/72855826" target="_blank" rel="noopener">https://blog.csdn.net/u011500062/article/details/72855826 </a></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lastRemaining</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">or</span> m <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None        last <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            last <span class="token operator">=</span> <span class="token punctuation">(</span>last <span class="token operator">+</span> m<span class="token punctuation">)</span><span class="token operator">%</span>i        <span class="token keyword">return</span> last<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="68-股票的最大利润"><a href="#68-股票的最大利润" class="headerlink" title="68.股票的最大利润"></a>68.<a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">股票的最大利润</a></h2><p> 思路：买卖股票问题，遍历每一天的股票价格。如果当前价格小于当前历史最低价格时，更新当前历史最低价格。如果当前价格大于当前历史最低价格时，计算当前收益，并更新当前最大收益。即贪心算法。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        min_prices<span class="token operator">=</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        max_profit<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> price <span class="token keyword">in</span> prices<span class="token punctuation">:</span>            min_prices<span class="token operator">=</span>min<span class="token punctuation">(</span>price<span class="token punctuation">,</span>min_prices<span class="token punctuation">)</span>            <span class="token keyword">if</span> price<span class="token operator">></span>min_prices<span class="token punctuation">:</span>                max_profit<span class="token operator">=</span>max<span class="token punctuation">(</span>price<span class="token operator">-</span>min_prices<span class="token punctuation">,</span>max_profit<span class="token punctuation">)</span>        <span class="token keyword">return</span> max_profit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，上述思路其实是动态规划算法的优化版本。我们可以维护一个动态规划状态矩阵DP[i]来记录第i天时，股票的最大利润。DP[i]=max（DP[i-1]，price-min_prices）,有点类似于01背包问题。由于我们仅需要前一天的最大收益，我们之前说过，动态规划的转移仅与之前有限个状态有关时，可以优化空间复杂度。所以我们用一个变量max_profit来存放当前最大收益。</p><h2 id="69-求1-2-…-n"><a href="#69-求1-2-…-n" class="headerlink" title="69.求1+2+…+n"></a>69.<a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">求1+2+…+n</a></h2><p>思路：利用python中的and机制。</p><ul><li>如果多个变量均非0（包括None、False等），那么返回最后一个变量的值。如3 and 2 and ‘a’的返回值为’a’； </li><li>如果多个变量中存在0值，则返回第一个0值。如1 and ‘a’ and 0 and None的返回值为0。 </li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sumNums</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> n <span class="token operator">and</span> n<span class="token operator">+</span>self<span class="token punctuation">.</span>sumNums<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="70-不用加减乘除做加法"><a href="#70-不用加减乘除做加法" class="headerlink" title="70.不用加减乘除做加法"></a>70.<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">不用加减乘除做加法</a></h2><p>思路：位运算</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">:</span> int<span class="token punctuation">,</span> b<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        a <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token number">0xFFFFFFFF</span>        b <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token number">0xFFFFFFFF</span>        <span class="token keyword">while</span> b<span class="token punctuation">:</span>            carry <span class="token operator">=</span> a <span class="token operator">&amp;</span> b            a <span class="token operator">^</span><span class="token operator">=</span> b            b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>carry<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFFFFFFFF</span>        <span class="token keyword">return</span> a <span class="token keyword">if</span> a <span class="token operator">&lt;</span> <span class="token number">0x80000000</span> <span class="token keyword">else</span> <span class="token operator">~</span><span class="token punctuation">(</span>a<span class="token operator">^</span><span class="token number">0xFFFFFFFF</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="71-构建乘积数组"><a href="#71-构建乘积数组" class="headerlink" title="71. 构建乘积数组"></a>71.<a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/" target="_blank" rel="noopener"> 构建乘积数组</a></h2><p>思路：对称运算，由于 <code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code>。且不能使用除法。 那么我们先可以正向累乘，计算nums1[i]=A[0]×A[1]×…×A[i-1]。计算完成后，再反向累乘计算nums2[i]=A[i+1]×…×A[n-1]。最后，将nums1[i]和nums2[i]按位相乘即可得到最终的结果。</p><p>为了减少时空复杂度，我们反向计算A[i+1]×…×A[n-1]时，不需要再开一个数组nums2[i]，直接设置一个临时变量存放A[i+1]×…×A[n-1]，并让他与当前nums1[i]相乘即可得到最终的结果。</p><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(N)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">constructArr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> a<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        tmp<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>res<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>a<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp<span class="token operator">*=</span>a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*=</span>tmp        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="72-把字符串转换成整数"><a href="#72-把字符串转换成整数" class="headerlink" title="72.把字符串转换成整数"></a>72.<a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/" target="_blank" rel="noopener">把字符串转换成整数</a></h2><p>思路：这种规则匹配题，没有捷径，需要细心地把每种情况都列出来加以判断。这里我贴出我一年多以前用JAVA写的代码，写的很臃肿。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    public int myAtoi<span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String newS<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">;</span>        int flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        char c<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span>str<span class="token punctuation">.</span>toCharArray<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>c<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">' '</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'+'</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token operator">|</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        newS<span class="token operator">=</span>newS<span class="token punctuation">.</span>concat<span class="token punctuation">(</span>String<span class="token punctuation">.</span>valueOf<span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">48</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">57</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        newS<span class="token operator">=</span>newS<span class="token punctuation">.</span>concat<span class="token punctuation">(</span>String<span class="token punctuation">.</span>valueOf<span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        flag<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">48</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">57</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    newS<span class="token operator">=</span>newS<span class="token punctuation">.</span>concat<span class="token punctuation">(</span>String<span class="token punctuation">.</span>valueOf<span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    flag<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">57</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    newS<span class="token operator">=</span>newS<span class="token punctuation">.</span>concat<span class="token punctuation">(</span>String<span class="token punctuation">.</span>valueOf<span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newS<span class="token punctuation">.</span>equals<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token operator">|</span><span class="token punctuation">(</span>newS<span class="token punctuation">.</span>equals<span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token operator">|</span><span class="token punctuation">(</span>newS<span class="token punctuation">.</span>equals<span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            long result<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>newS<span class="token punctuation">.</span>length<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>newS<span class="token punctuation">.</span>charAt<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result<span class="token operator">=</span><span class="token operator">-</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>Math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                    result<span class="token operator">=</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>Math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                result<span class="token operator">=</span>Long<span class="token punctuation">.</span>parseLong<span class="token punctuation">(</span>newS<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token operator">&lt;</span><span class="token operator">-</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>Math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result<span class="token operator">=</span><span class="token operator">-</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>Math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token operator">>=</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>Math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result<span class="token operator">=</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>Math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>int<span class="token punctuation">)</span>result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正则表达式解法：</p><blockquote><ul><li><code>^</code>：匹配字符串开头</li><li><code>[\+\-]</code>：代表一个+字符或-字符</li><li><code>?</code>：前面一个字符可有可无</li><li><code>\d</code>：一个数字</li><li><code>+</code>：前面一个字符的一个或多个</li></ul></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">strToInt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> str<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        INT_MAX <span class="token operator">=</span> <span class="token number">2147483647</span>        INT_MIN <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2147483648</span>        s<span class="token operator">=</span> str<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#清除两端空格</span>        res <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>r<span class="token string">'^[\+\-]?\d+'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#正则表达式：匹配位于字符串开头且接下来是一个正号或负号或没有且接下来是1到多个数字</span>        num <span class="token operator">=</span> res<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        nums <span class="token operator">=</span> int<span class="token punctuation">(</span><span class="token operator">*</span>num<span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>min<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">,</span> INT_MIN<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="74-I-二叉搜索树的最近公共祖先"><a href="#74-I-二叉搜索树的最近公共祖先" class="headerlink" title="74.I. 二叉搜索树的最近公共祖先"></a>74.<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">I. 二叉搜索树的最近公共祖先</a></h2><p>思路：递归求解，根据二叉搜索树的性质（每个节点的左子树都小于它，右子树都大于它），当当前节点不为None时：</p><ul><li>如果p、q节点的值均比当前节点的值小，那么它们的祖先必然在当前节点的左子树中。</li><li>如果p、q节点的值均比当前节点的值大，那么它们的祖先必然在当前节点的右子树中。</li><li>否则，它们的祖先必是当前节点。（这里有两种情况，一是当前节点的值位于p、q节点的值中间，说明它们两个节点必然分布在当前节点的左右子树中，当前节点必然是他们的最近祖先。二是当前节点的值等于p或者q节点的值，由于一个节点也可以是它自身的祖先，所以当前节点必然是他们的最近祖先。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">DFS</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> None            <span class="token keyword">if</span> p<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val <span class="token operator">and</span> q<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> DFS<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">elif</span> p<span class="token punctuation">.</span>val<span class="token operator">></span>root<span class="token punctuation">.</span>val <span class="token operator">and</span> q<span class="token punctuation">.</span>val<span class="token operator">></span>root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> DFS<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> root        <span class="token keyword">return</span> DFS<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非递归写法：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val <span class="token operator">and</span> q<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                root<span class="token operator">=</span>root<span class="token punctuation">.</span>left            <span class="token keyword">elif</span> p<span class="token punctuation">.</span>val<span class="token operator">></span>root<span class="token punctuation">.</span>val <span class="token operator">and</span> q<span class="token punctuation">.</span>val<span class="token operator">></span>root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                root<span class="token operator">=</span>root<span class="token punctuation">.</span>right            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> root        <span class="token keyword">return</span> None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="75-II-二叉树的最近公共祖先"><a href="#75-II-二叉树的最近公共祖先" class="headerlink" title="75.II. 二叉树的最近公共祖先"></a>75.<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">II. 二叉树的最近公共祖先</a></h2><p>思路：上一道题的复杂版，我们无法直接通过节点值的大小比较来确定公共祖先的位置，只能通过递归搜索的方法求解。</p><p>这里我们使用后序遍历。</p><ul><li>如果当前节点为空，返回None。</li><li>如果当前节点等于p或者q，返回当前节点。 （一个节点的祖先可以是自身）</li><li>递归遍历左、右子树。</li><li>如果左子树返回的节点为空，说明p、q均不在左子树中，返回右子树找到的节点。</li><li>如果右子树返回的节点为空，说明p、q均不在右子树中，返回左子树找到的节点。</li><li>如果左右子树返回的节点都不为空，说明p、q分布在左右子树中，则当前节点必然是最近的公共祖先。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> q<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None <span class="token operator">or</span> root<span class="token operator">==</span>p <span class="token operator">or</span> root<span class="token operator">==</span>q<span class="token punctuation">:</span>                <span class="token keyword">return</span> root            leftNode<span class="token operator">=</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            rightNode<span class="token operator">=</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> leftNode<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> rightNode            <span class="token keyword">if</span> rightNode<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> leftNode            <span class="token keyword">return</span> root        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：线性模型和对数线性模型</title>
      <link href="/2020/03/17/nlp-zi-xue-bi-ji-xian-xing-mo-xing-he-dui-shu-xian-xing-mo-xing/"/>
      <url>/2020/03/17/nlp-zi-xue-bi-ji-xian-xing-mo-xing-he-dui-shu-xian-xing-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是我在学习苏州大学李正华老师的中文信息处理课程（<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">中文信息处理（Chinese Information Processing）Course Resources</a>）时，对于线性模型和对数线性模型的一些个人见解和思考，同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己对于该模型的理解，如有错误欢迎在评论区指出，非常感谢！</p><h2 id="从问题出发"><a href="#从问题出发" class="headerlink" title="从问题出发"></a>从问题出发</h2><p>与隐马尔可夫模型的讲解类似，我们在这里依旧围绕自然语言处理中的经典问题<strong>词性标注问题</strong>进行讨论和解释。</p><ul><li>给定一个句子X，输出句子中每一个单词对应的词性。</li></ul><p><img src="1.png" alt="词性标注任务"></p><p>与隐马尔可夫模型不同的是，线性模型与对数线性模型将词性标注转化为了一个<strong>多元分类</strong>问题，它们将不再以整个句子序列作为模型的输入，整个句子的词性序列作为模型的输出，而是假设<strong>词语之间的预测相互独立</strong>，将问题转化为<strong>从所有可能的词性类别中选取某个词语最有可能的类别进行输出</strong>。</p><h2 id="什么是线性模型"><a href="#什么是线性模型" class="headerlink" title="什么是线性模型"></a>什么是线性模型</h2><p>线性模型（Linear Model)，又称为<strong>线性回归模型</strong>，是一种<strong>有监督学习模型</strong>。我们曾经在高中的时候学习过一种回归方法——线性回归。将这个方法泛化，就可以得到我们的线性模型。</p><p>我们以吴恩达老师在coursera上的机器学习课程中的房价预测例子进行说明。</p><p><img src="2.png" alt="房价预测"></p><p>如上图所示，假设我们得到了一个当地的房价数据集，其中包括了房子的面积、卧室数、层数、房龄等信息，同时给出了对应的房价。我们需要解决的问题就是如何<strong>利用房子的信息预测出它的价格</strong>。在机器学习中，我们把类似于面积、卧室数等这些样本的信息叫做<strong>样本的特征（Feature）</strong>，它们是我们进行预测的依据。我们把需要预测的值叫做<strong>样本的标签（Label)</strong>。训练集中的每一个样本是一个<strong>（特征，标签)二元组</strong>。</p><p>在机器学习中，样本的特征往往是人工选择的，例如上述的面积、卧室数、层数等房屋信息。如何选择合适的特征是一门高深的学问，我们称其为<strong>特征工程</strong>。特征往往不止一个，所以使用<strong>向量</strong>的形式对其进行表示。在这里，我使用列向量$\vec x=(x_1,x_2…x_n)$来表示特征向量，由于书写列向量不是很方便，所以只能这么书写，但你需要记住$\vec x$是一个列向量。</p><p>当给定某个房子的面积、卧室数、层数、房龄等特征，在线性模型中，我们会使用一个线性方程来计算房子的价格。我们使用$h$表示这个线性方程，$h$代表<strong>hypothesis</strong>(<strong>假设</strong>) ，具体公式如下：<br>$$<br>h_{w}(x)=w_0+w_1x_1+w_2x_2+…+w_nx_n<br>$$<br>我们为每个特征给定一个特征权重$w$，这个权重可以是正数也可以是负数。其中，$w_0$为<strong>偏置项</strong>（bias），专门用来表示方程中的常数项。通过训练样本学习权重$w$，我们便可使用上述方程进行预测。</p><p>为了使公式简洁一些，引入$x_0=1$，使用列向量$\vec w=(w_0,w_1…w_n)$来表示权重向量，则公式转化为：<br>$$<br>h_{w}(x)=w_0x_0+w_1x_1+w_2x_2+…+w_nx_n\<br>=w^Tx<br>$$</p><h2 id="线性模型的泛化"><a href="#线性模型的泛化" class="headerlink" title="线性模型的泛化"></a>线性模型的泛化</h2><p>看到上述的线性方程，你可能会疑惑：上述方程得到的仅仅是一条直线方程，而需要拟合的数据点往往不能通过简单的直线来拟合。换句话说， 如果仅仅使用在此之前的单元和多元线性回归，<strong>我们只能得到多维空间的高维平面</strong>。为了进一步增强泛化能力，我们可以引入<strong>幂次项特征和多项式特征</strong>。 </p><p>例如，我们的模型原先只是一个线性方程：<br>$$<br>h_{w}(x)=w_1x_1+w_2x_2<br>$$<br>为了增强拟合能力，我们可以令$x_3=x_1^2$，$x_4=x_2^2$，$x_5=x_1x_2$。于是，我们的模型将变为：<br>$$<br>h_{w}(x)=w_1x_1+w_2x_2+w_3x_3+w_4x_4+w_5x_5\<br>=w_1x_1+w_2x_2+w_3x_1^2+w_4x_2^2+w_5x_1x_2<br>$$<br>可以看到，此时我们的模型将可以拟合复杂的非线性函数。<strong>也就是说，很多复杂的模型都可以转化为线性模型进行建模。</strong></p><p>但需要注意的是：<strong>过多地使用幂次项特征和多项式特征会使模型的拟合能力太强，从而导致过拟合的问题</strong>。我将专门 写一篇blog来讲解机器学习中的过拟合问题，并介绍一些解决过拟合的办法，如正则化和dropout等。</p><h2 id="线性模型的特征提取"><a href="#线性模型的特征提取" class="headerlink" title="线性模型的特征提取"></a>线性模型的特征提取</h2><h3 id="连续型特征"><a href="#连续型特征" class="headerlink" title="连续型特征"></a>连续型特征</h3><p>特征分为连续型特征和离散型特征。<strong>连续型特征顾名思义就是取值是连续的特征，例如上述例子中的房子面积。</strong>在实际的机器学习过程中， 很少直接将连续值作为线性回归模型和逻辑回归模型的特征输入，而是将连续特征离散化为一系列0、1特征交给模型，这样做的优势有以下几点： </p><ol><li>离散特征的增加和减少都很容易，易于模型的<strong>快速迭代</strong>。</li><li>稀疏向量内积乘法运算<strong>速度快</strong>，计算结果<strong>方便存储，容易扩展</strong>。</li><li>离散化后的特征对异常数据有很强的<strong>鲁棒性</strong>：比如一个特征是年龄&gt;30是1，否则0。如果特征没有离散化，一个异常数据“年龄300岁”会给模型造成很大的干扰。</li><li>线性回归模型和逻辑回归模型属于广义线性模型，表达能力受限；单变量离散化为N个后，每个变量有单独的权重，相当于为模型引入了非线性，<strong>能够提升模型表达能力，加大拟合</strong>。</li><li>离散化后可以<strong>进行特征交叉</strong>，由M+N个变量变为M*N个变量，进一步引入非线性，提升表达能力。</li><li>特征离散化后，模型会更<strong>稳定</strong>，比如如果对用户年龄离散化，20-30作为一个区间，不会因为一个用户年龄长了一岁就变成一个完全不同的人。当然处于区间相邻处的样本会刚好相反，所以怎么划分区间是门学问。</li><li>特征离散化以后，起到了简化模型的作用，降低了模型<strong>过拟合</strong>的风险。</li></ol><h3 id="离散性特征"><a href="#离散性特征" class="headerlink" title="离散性特征"></a>离散性特征</h3><p><strong>离散型特征顾名思义就是取值是离散的特征，例如上述例子中的房龄、卧室数和层数。</strong>对于离散型特征，我们使用一种叫做<strong>one-hot</strong>的方法进行编码。</p><p>one-hot的基本思想：<strong>将离散型特征的每一种取值都看成一种状态</strong>，若你的这一特征中有N个不相同的取值，那么我们就可以将该特征抽象成N种不同的状态，one-hot编码保证了每一个取值只会使得一种状态处于“激活态”，也就是说这N种状态中只有一个状态位值为1，其他状态位都是0。举个例子，假设我们以学历为例，我们想要研究的类别为小学、中学、大学、硕士、博士五种类别，我们使用one-hot对其编码就会得到：</p><blockquote><p>小学-&gt;[1,0,0,0,0]</p><p>中学-&gt;[0,1,0,0,0]</p><p>大学-&gt;[0,0,1,0,0]</p><p>硕士-&gt;[0,0,0,1,0]</p><p>博士-&gt;[0,0,0,0,1]</p></blockquote><p><strong>特别地，如果该离散型特征只有True或False两种取值，那么我们通常用1表示True，0表示False</strong>。</p><h2 id="线性模型的训练过程"><a href="#线性模型的训练过程" class="headerlink" title="线性模型的训练过程"></a>线性模型的训练过程</h2><h3 id="定义优化目标"><a href="#定义优化目标" class="headerlink" title="定义优化目标"></a>定义优化目标</h3><p>当我们写出了假设函数$h$后，接下来我们要做的就是通过已有的训练集得到合适的模型权重$\vec w=(w_0,w_1…w_n)$。</p><p>为了进行权重的训练，首先，我们要定义三个函数：</p><ol><li><strong>损失函数（Loss Function ）</strong>：<strong>单个样本</strong>的预测值和真实值（标签）的误差。</li><li><strong>代价函数（Cost Function ）</strong>：<strong>整个训练集所有样本</strong>的预测值和真实值（标签）的误差，也就是损失函数的平均。</li><li><strong>目标函数（Object Function）</strong>：<strong>最终需要优化的函数</strong>。等于经验风险+结构风险（也就是代价函数 + 正则化项）。</li></ol><p><strong>这里，我们先不讲解正则化的知识，假设我们的目标函数即为代价函数</strong>。那么线性模型的优化问题即为最小化所有样本的误差的平均值。线性模型的误差可以用许多函数来表示，其中比较常用的一种是<strong>均方误差</strong>(Mean squared error) ，这里我们使用均方误差来描述我们的模型误差（PS：更多损失函数可以参考<a href="https://www.jiqizhixin.com/articles/091202" target="_blank" rel="noopener">机器学习中常用的损失函数你知多少？</a>）</p><p>假设训练集中样本的标签为$y$，样本的数量为$m$，预测值为假设函数的输出$h_{w}(x)$，则需要优化的目标函数为：<br>$$<br>J(w)=\frac{1}{2m}\sum_{i=1}^{m}(h_w(x^{(i)})-y^{(i)})^2<br>$$<br>我们的目标便是<strong>选择出可以使得建模误差的平方和能够最小的模型参数</strong>，即<strong>找到合适的模型权重$\vec w$，使$J(w)$取得最小值</strong>。需要注意的是，目标函数中的1/2仅仅是为了方便求导。</p><h3 id="从极大似然估计到损失函数"><a href="#从极大似然估计到损失函数" class="headerlink" title="从极大似然估计到损失函数"></a>从极大似然估计到损失函数</h3><p>在隐马尔可夫模型的讲解中，我曾经说过损失函数和极大似然估计有着紧密的联系，例如<strong>我们在逻辑回归模型里使用的交叉熵损失函数其实就是似然函数加上负号</strong>。也就是说，<strong>最优化问题既可以理解为最大化模型的似然估计，也可以理解为最小化模型的损失函数</strong>。</p><p>为什么会出现这样的现象呢？其实这并不是巧合，是可以通过数学公式进行推导的。具体推导内容可以参考这篇讲义<a href="https://wenku.baidu.com/view/78d16462c9d376eeaeaad1f34693daef5ff713d2.html" target="_blank" rel="noopener">各损失函数与最大似然</a>。</p><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><h4 id="正规方程法"><a href="#正规方程法" class="headerlink" title="正规方程法"></a>正规方程法</h4><p>正规方程法可以用于求解线性模型的目标函数取得最小值时，权重$w$的准确值。但在机器学习中，我们很少使用这种方法求解模型的权重，我在这里简单提一下它的弊端：</p><ol><li>对于一个由$n$个训练样本的特征向量$x$组成的训练集矩阵$X$，计算极值点的时间复杂度为$O(n^3)$，<strong>当训练集规模很大时，正规方程法将变得十分缓慢。</strong></li><li>正规方程法需要使用训练集矩阵$X$的逆矩阵$X^{(-1)}$，但是<strong>我们无法保证$X$一定可逆。</strong></li><li><strong>只适用于线性模型</strong>，不适合逻辑回归模型等其他模型 。</li></ol><h4 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h4><p>我们已经说过，当训练集规模很大时，例如有上百万、上千万的数据时，正规方程法将会非常缓慢，那么有没有办法能够降低时间复杂度呢？答案是有的，我们在这里可以使用<strong>梯度下降法</strong>进行求解。</p><p>为了将问题简化，我们假设模型现在只存在两个特征，对应的权重为$\theta_0$和$\theta_1$。 我们绘制一个等高线图，三个坐标分别为$\theta_0$和$\theta_1$和$J(\theta_0,\theta_1)$： </p><p><img src="3.png" alt="等高线图"></p><p>则可以看出在三维空间中存在一个使得$J(\theta_0,\theta_1)$最小的点，我们可以发现均方差损失函数的图像很明显是一个<strong>凸函数</strong>，即不存在局部最优解的问题。 </p><p>梯度下降法的相当于<strong>我们下山的过程</strong>，每次我们要走一步下山，寻找最低的地方，那么最可靠的方法便是环顾四周，寻找下山速度最快的方向前进，持续该过程，最后便能无限接近最低点。</p><p>对于函数而言，<strong>便是求得该函数对所有参数的偏导（梯度），每次根据梯度更新这些参数，直到参数收敛为止，注意这些参数必须同步进行更新</strong>。 从数学上的角度来看，梯度的方向是函数增长速度最快的方向，那么梯度的反方向就是函数减少最快的方向。那么，如果想计算一个函数的最小值，就可以使用梯度下降法的思想来做。 </p><p>假设模型共有$n$个特征，加上偏置项的特征$x_0=1$，共有$n+1$个特征。则对于某个权重参数$w_j$进行梯度下降的公式可以表示为：<br>$$<br>w_j=w_j-\alpha\frac{dJ(w)}{dw_j}=w_j-\alpha\frac{1}{m}\sum^{m}_{i=1}(h_w(x^{(i)})-y^{(i)})x_j^{(i)}<br>$$<br>其中，<strong>$\alpha$是一个由我们自己设置的超参数（hyper parameter）——学习率</strong> （<strong>learning rate</strong>），它决定了我们沿着能让目标函数下降程度最大的方向向下迈出的步子有多大。 </p><p>梯度下降的过程形象表示便是如下图所示，一步一步下降达到最低点。</p><p> <img src="3.jpg" alt="梯度下降的直观表示"></p><p>需要说明以下几点：</p><ul><li><p>$\alpha$为学习率，学习率决定了学习的速度，<strong>我们需要选择合适的学习率</strong>。</p><ul><li><p>如果$\alpha$过小，那么学习的时间就会很长，导致算法的低效。</p></li><li><p>如果$\alpha$过大，那么由于每一步更新过大，可能无法收敛到最低点。由于越偏离最低点函数的导数越大，如果$\alpha$过大，某一次更新直接跨越了最低点，来到了比更新之前<strong>更高</strong>的地方。那么下一步更新步会更大，如此反复震荡，离最低点越来越远。</p></li><li><p>以上两种情况如下图所示 ：</p><p><img src="2.jpg" alt></p></li></ul></li><li><p><strong>我们的算法不一定能达到最优解</strong>。 但是由于线性回归模型中的函数都是<strong>凸函数</strong>,所以利用梯度下降法，是可以找到全局最优解的，在这里不详细阐述。 </p></li><li><p>我们这里得到的是<strong>数值解</strong>而非解析解，存在着一定误差。</p></li></ul><p>顺便说一下，我这里举例的是<strong>批量梯度下降（batch gradient descent,BGD）</strong>，即尝试将<strong>所有样本</strong>的误差优化到最小。这种方法的优点是每次下降都是朝着全局最优的方向前进。但是，我们发现它每次都要计算所有样本的损失，这在大批量数据的情况下会非常缓慢。</p><p>还有一种梯度下降的方法叫做<strong>随机梯度下降法（ Stochastic gradient descent）</strong>，它每次选取<strong>一个随机样本</strong>，尝试优化它的损失函数。虽然随机梯度下降法每次下降是朝着局部最优的方向前进，无法保证全局的优化，但整体而言，它的下降方向还是朝着全局最优点前进的。与此同时，它的计算量相较于批量梯度下降大大减少了。</p><p>此外，还有一种方法叫做<strong>小批量梯度下降法（mini-batch gradient descent）</strong>，这是现在最为常用的一种梯度下降学习法，它是BGD和SGD的折中。它每次尝试优化一个mini-batch-size数量的样本，即减少了运算量，又降低了梯度下降方向出错的可能性。</p><h3 id="过拟合与正则化"><a href="#过拟合与正则化" class="headerlink" title="过拟合与正则化"></a>过拟合与正则化</h3><p>在前面我们提到了可以通过引入<strong>幂次项特征和多项式特征</strong>来增加模型的拟合能力。但是，模型的拟合能力过强有时候并不是一件好事。下面，我将介绍线性回归模型中的<strong>过拟合 (over-fitting) 问题</strong>。</p><p>首先，我们给出过拟合的定义：</p><blockquote><p>在统计学中，过拟合（英语：overfitting，或称过度拟合）现象是指在拟合一个统计模型时，使用过多参数。对比于可获取的数据总量来说，一个荒谬的模型只要足够复杂，是可以完美地适应数据。过拟合一般可以视为违反奥卡姆剃刀原则。当可选择的参数的自由度超过数据所包含信息内容时，这会导致最后（拟合后）模型使用任意的参数，这会减少或破坏模型一般化的能力更甚于适应数据。过拟合的可能性不只取决于参数个数和数据，也跟模型架构与数据的一致性有关。此外对比于数据中预期的噪声或错误数量，跟模型错误的数量也有关。 </p></blockquote><p>通俗的说，过拟合问题的本质是<strong>我们模型的学习能力太强，导致过于强调拟合训练集的样本，从而丢失了泛化的能力</strong>。当模型出现了过拟合的问题，它虽然能非常好地适应我们的训练集，但在新输入变量进行预测时可能会效果不好 。</p><p>我们借用吴恩达老师coursera课程中的PPT来描述过拟合、欠拟合、好的拟合三种情况。</p><p><img src="4.png" alt="拟合的情况"></p><p>在这里，我尝试用一个易于理解的例子来解释上述三种情况：</p><blockquote><p>我们可以把学生做练习题的过程看成是模型的训练过程，学生在做了很多练习题后，可以参加考试了，我们可以把考试看作为模型的预测过程。欠拟合很简单，就是平时不认真学习，做练习题和参加考试的分数自然都很低，也就是训练集和测试集的准确率都很低。那么过拟合是什么呢？过拟合就是平时只知道死记硬背，仅仅记住了练习题，却不知道举一反三，虽然平时作业分数很高，但是考试成绩却并不好，也就是训练集准确率很高，但测试集准确率很低。最佳的情况就是既认真做练习，又不局限于练习题，这种就是我们虽说的拟合较好的情况。</p></blockquote><p>为了解决过拟合的问题，我们应该引入一个<strong>参数项</strong>，<strong>在进行梯度下降的时候尽可能使得参数变小</strong>，这样可以使得很多额外的特征的权重接近于0。 这个方法也叫做<strong>正则化</strong>（regularization）。此外，还有一些防止过拟合的办法，例如神经网络中的dropout等，我会在接下来的博客中继续为大家介绍。</p><p>正则化中的参数项一般也叫做正则项，常用的正则项有以下两种：</p><ul><li>L1正则项：各个权重的<strong>绝对值之和</strong>，可以产生稀疏权值矩阵，即产生一个稀疏模型，可以用于<strong>特征选择</strong> 。同时，一定程度上 也可以防止过拟合 。</li><li>L2正则项：各个权重的<strong>平方和</strong>，可以防止模型过拟合（overfitting）。</li></ul><p>线性模型和对数线性模型中，我们通常采用的是L2正则项。加入正则项后，模型的代价函数变为：<br>$$<br>J(w)=\frac{1}{2m}[\sum_{i=1}^{m}(h_w(x^{(i)})-y^{(i)})^2+\lambda\sum_{j=1}^{n}w^2]<br>$$<br>梯度下降的公式变为：<br>$$<br>w_j=w_j-\alpha\frac{dJ(w)}{dw_j}=w_j-\alpha\frac{1}{m}\sum^{m}_{i=1}[(h_w(x^{(i)})-y^{(i)})x_j^{(i)}+\lambda w_j]<br>$$<br>我们可以发现，通过引入正则化项，可以使模型的所有参数在梯度下降时多下降一些，从而尽可能地减小。上式中，$\lambda$是一个用于控制正则化程度的超参数，我们一般称其为<strong>正则化系数</strong>，如果$\lambda$过大，则所有权重将趋近于0， 这样我们所得到的只能是一条平行于x轴的直线 。 所以对于正则化，我们要取一个合理的$\lambda$的值 。超参数的选择是机器学习中最为常见的问题，我们一般使用<strong>开发集</strong>进行调参。</p><p>顺便提一下，过拟合的情况下，增加训练集的样本数量将会使模型的性能得到提升。在当今这个海量数据的时代，数据是容易获得的，所以深度学习的常见做法是训练出一个拟合能力很强（层数深、神经元多）的神经网络，加上大规模的训练样本，再加上一些正则化的方法，所得出的模型通常性能最好。</p><h2 id="回到词性标注问题上来"><a href="#回到词性标注问题上来" class="headerlink" title="回到词性标注问题上来"></a>回到词性标注问题上来</h2><p>相信通过前面的介绍，你已经对线性模型有了基本的认识，下面我们回到词性标注任务上，简单地介绍一下如何基于多元分类的思想使用线性回归模型进行词性标注。</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>在我们之前的介绍中，你可能会发现，线性模型主要是用于解决机器学习中的<strong>回归（regression）问题</strong>。也就是说，它预测的最终结果通常是连续值。虽然与对数线性模型相比，线性模型不常用于<strong>分类（classification）</strong>，但在介绍对数线性模型之前，我们仍可以通过一些方法使其运用在分类标注词性上。</p><p>最基本的思想就是，<strong>我们通过选取词语的一些特征，训练出一个线性模型，模型的输出为该词语标注为各词性的分值（score），然后我们选取分值最大的词性作为预测的结果。</strong>通过这一转化，我们将线性回归模型运用在了分类问题上。</p><h3 id="特征获取"><a href="#特征获取" class="headerlink" title="特征获取"></a>特征获取</h3><p>与之前预测房价的例子不同，词性标注模型的特征不是事先定义好的，而是通过<strong>特征模板（feature template）</strong>在训练集中抽取而来的。特征模板需要专家进行手工的定义。目前，学术界常用的用于词性标注的特征模板如下表所示。</p><p><img src="5.png" alt="特征模板"></p><p>可以看到，我们一共使用了14种特征模板，其中包含了许多有用的信息，例如词信息，字信息，词缀信息等等。</p><p>在实际训练过程中，我们需要先构建<strong>特征空间（feature space）</strong>。它是训练集中所有特征的集合。<strong>构建的方式是：我们每次选取一个词，根据特征模板抽取相应的14种特征，并将其加入到特征空间内。需要注意的是特征空间中不能出现重复的特征。</strong></p><p>在这里，我们还可以对特征抽取进行优化。我们观察特征模板可以发现，<strong>对于每个样本，每一种特征的模板都需要抽取每一种词性的特征，而对于所有不同的词性，其特征模板的后缀都是相同的</strong>。通过计算机中经常使用的<strong>段加偏移</strong>的思想，我们可以大大减少构建特征空间所耗费的时间，将时间复杂度由$O(MN)$降为$O(M+N)$。具体的优化操作不再赘述，大家可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/9-linear-model/main2.pdf" target="_blank" rel="noopener">李老师的讲义</a>。</p><p>我在这里画出了这个线性模型的示意图，你应该就能理解为什么它的特征空间可以用二维矩阵的方式来存储，以及它是如何工作的。</p><p><img src="6.png" alt="词性标注的线性模型"></p><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>对于模型的训练，我们将采用一种叫做<strong>在线学习（Online training）</strong>的方式。这是一种经常用于<strong>推荐系统</strong>的学习算法，方便对模型进行实时训练。你可以把它看作是一种近似于我们之前所提到的随机梯度下降法的学习算法。它每次选取<strong>一个实例</strong>进行训练。由于样本的标签是经过one-hot处理的离散值，而我们模型的输出是取值范围在负无穷到正无穷 ，所以我们在这里无法使用前述的梯度下降算法进行参数的训练。取而代之的是如下的算法。</p><p><img src="7.png" alt="Online Training"></p><p>简单的讲解一下，可以看到，我们每次选取一个样本进行训练，如果该样本预测正确，那么不修改模型的参数，否则，将该样本与正确词性关联的特征权重全部加1，与错误词性关联的特征权重全部减1。你可以看作是<strong>给预测正确词性的特征一个激励，而给预测错误词性的特征一个惩罚</strong>。</p><p>特别地，我们在这里还可以使用上图中$v$作为模型特征权重，这叫做<strong>averaged perceptron</strong>，我经过实验发现使用$v$确实比$w$更好。有关学习算法的优化问题我将专门撰写一篇博客，介绍常见的优化算法，如momentum算法，RMsprop算法和Adam算法的数学原理等。</p><h2 id="什么是对数线性模型"><a href="#什么是对数线性模型" class="headerlink" title="什么是对数线性模型"></a>什么是对数线性模型</h2><p>回顾一下我们之前介绍的线性模型，它可以将词性标注转化为一个多分类问题，通过给当前词标注为每种词性的情况进行打分，并选择分值最高的词性作为当前词的标注结果，从而进行词性预测。但这样做其实存在着一些弊端：</p><ol><li><strong>一些极端值可能会大大影响分类的效果。</strong></li><li>对于分类问题，$y$取值为 0 或者1，但如果你使用的是线性模型，那么假设函数的输出值可能远大于 1，或者远小于0，即使所有训练样本的标签都等于 0 或 1。尽管我们知道标签应该取值0 或者1，但是如果算法得到的值远大于1或者远小于0的话，就会感觉很奇怪。<strong>同时，我们也就无法使用损失函数进行梯度下降优化。</strong></li></ol><p>为了解决上述问题，我们可以使用<strong>对数线性模型（log-linear model）</strong>，或许它的另一个名称更为常用，也可以叫做<strong>逻辑回归模型（logistic regression model）</strong>，不过似乎人们在使用逻辑回归模型时，默认解决的是二分类问题，这里我们称之为<strong>多分类的逻辑回归模型</strong>似乎更合适。</p><p>对数线性模型主要做的就是<strong>将线性模型输出的分值使用非线性函数映射到[0，1]区间上，即将分值转化为概率</strong>，这种形式大大减少了极端值的影响，同时概率应用在分类问题上也更易于理解，我们也可以通过样本的真实标签和预测概率定义目标函数，从而使用梯度下降法进行模型训练。</p><h2 id="从线性模型到对数线性模型"><a href="#从线性模型到对数线性模型" class="headerlink" title="从线性模型到对数线性模型"></a>从线性模型到对数线性模型</h2><p>为了将分值转化为概率，我们需要使用一些非线性函数进行映射。<strong>比较常用的两种函数分别为：Sigmoid函数和Softmax函数，前者用于二分类的对数线性模型中，而后者用于多分类的对数线性模型中。</strong>顺便提一下，在深度学习中，Sigmoid和Softmax是最为常用的几种<strong>激活函数（activation function）</strong>之一，他们为神经网络增加了非线性特征，从而使神经网络的表达能力大大增强。与此同时，他们也经常是分类任务的神经网络输出层的首选激活函数，其在输出层的作用和在对数线性模型中的作用是一样的，即将分布在任意区间内的分值转化为[0，1]上的概率。</p><h3 id="Sigmoid函数（二分类问题）"><a href="#Sigmoid函数（二分类问题）" class="headerlink" title="Sigmoid函数（二分类问题）"></a>Sigmoid函数（二分类问题）</h3><p>我们使用$z$来表示原先的线性模型的假设函数输出（注意：你可能会在别的地方看到式子的最后加上了偏差项$b$，我在这里没有将偏差项特别拎出来，而是为特征向量额外添加了一个维度$x_0=1$，来和权重$w_0$共同表示偏差）：<br>$$<br>z=w^Tx<br>$$<br>则Sigmoid函数的形式为：<br>$$<br>g(z)=\frac{1}{1+e^{-z}}<br>$$<br>可以看到，它的函数图像如下：</p><p><img src="4.jpg" alt="Sigmoid"></p><p> 可以很明显的看出，该函数将<strong>实数域映射成了[0,1]的区间</strong> ，无论线性模型的输出是什么，我们都可以将其转化为[0，1]上的值，也就是概率。</p><p>所以，加入了Sigmoid函数后，对数线性模型的假设函数变为：<br>$$<br>h_w(x)=g(z)=\frac{1}{1+e^{-z}}=\frac{1}{1+e^{-w^Tx}}<br>$$</p><h3 id="Softmax函数（多分类问题）"><a href="#Softmax函数（多分类问题）" class="headerlink" title="Softmax函数（多分类问题）"></a>Softmax函数（多分类问题）</h3><p>我们依然使用$z$来表示原先的线性模型的假设函数输出，由于多分类问题每个样本会输出多个概率值，每个概率值都是该样本标注为某个词性的概率，我们使用$z_i$来表示当前样本被标注为第$i$种词性的分值，共有$n$种词性。则Softmax函数的形式为：<br>$$<br>g(z_i)=\frac{e^{z_i}}{\sum_{j=1}^{n}{e^{z_j}}}<br>$$<br>所以，加入了Softmax函数后，对数线性模型的假设函数变为：<br>$$<br>h_w(x_i)=g(z_i)=\frac{e^{z_i}}{\sum_{j=1}^{n}{e^{z_j}}}=\frac{e^{w^T_ix}}{\sum_{j=1}^{n}{e^{w^T_jx}}}<br>$$<br>我们发现，该函数实际上对每一个类别 i 的概率进行了归一化处理，从而保证其范围在[0，1]上，此外，它还保证了对于每一个样本，其标注为每一个类别的条件概率之和为1<strong>（这也是另一种多分类方法One vs All所不能做到的）</strong>。实际上，你还可以推导发现，<strong>Sigmoid函数其实是Softmax函数在类别 n=2 时的特殊形式</strong>。</p><h2 id="对数线性模型背后的数学原理"><a href="#对数线性模型背后的数学原理" class="headerlink" title="对数线性模型背后的数学原理"></a>对数线性模型背后的数学原理</h2><p>事实上，上述两种非线性映射函数并不是科学家们一拍脑袋就定义出来的，他们都是有严格的概率统计学证明的。Sigmoid函数是Softmax函数在二分类时的特殊形式，而Softmax函数可以通过信息论中的<strong>最大熵模型</strong>进行推导。我们根据<strong>求解最大熵函数在给定的约束条件下的极值（使用拉格朗日乘子法）</strong>，可以得到最大熵模型的参数形式，也就是Softmax函数的形式。</p><p>具体证明过程可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/10-maxent-loglinear/main.pdf" target="_blank" rel="noopener">李老师的讲义</a>。</p><h2 id="定义对数线性模型的优化目标"><a href="#定义对数线性模型的优化目标" class="headerlink" title="定义对数线性模型的优化目标"></a>定义对数线性模型的优化目标</h2><p>如果我们在对数线性模型中依然使用线性回归模型的均方差损失函数进行梯度下降，我们将发现<strong>加入了非线性映射函数的均方差损失函数不再是一个凸优化问题，无法保证获得全局最优解</strong>，所以我们需要另寻新的损失函数。</p><p>按照我们惯用的做法，我们依然可以通过<strong>极大化似然估计</strong>的方式来求解对数线性模型的优化目标。</p><blockquote><p><strong>极大似然估计：利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值（模型已定，参数未知）</strong> 。</p></blockquote><p>由于我们的词性标注问题是多分类问题，所以我在这里就推导一下Softmax函数的目标函数，事实上，Sigmoid函数只是它的一种特殊情况。</p><p>我们假设当前词预测为第 i 种词性的概率为$\hat{y_i}$，根据Softmax函数，我们的模型现在是：<br>$$<br>\hat{y_i}=h_w(x_i)=\frac{e^{w^T_ix}}{\sum_{j=1}^{n}{e^{w^T_jx}}}<br>$$<br>我们已知模型的真实概率分布，也就是样本结果信息，即训练集中每一个样本的特征向量和标签。<strong>极大似然估计的目标就是找到一组合适的模型的参数，使得这些样本结果出现的概率最大。</strong>也就是说，对于每一个样本，我们都希望它被标注为正确标签的概率最大。 对于整个训练集，我们当然是期望所有样本的联合概率都达到最大。我们的目标函数，本身是个联合概率，但是假设每个样本独立，那就可以写成连乘形式：<br>$$<br>J(w)=\frac{1}{N}\prod^{N}_{i=1}\prod^{M}_{j=1}(\frac{e^{w^T_jx_i}}{\sum_{k=1}^{M}{e^{w^T_kx_i}}})^{y_{ij}}<br>$$<br>其中，$N$指样本数量，$i$指第几个样本，$M$指类别数量，$j$指第几个类别，$y_{ij}$指第$i$个样本被标注为第$j$个类别的取值是0还是1。</p><p>我们还可以发现，对于每一个样本$i$，其标签都是一个One-hot向量，即只有一个正确标签为1，其余均为0，所以我们可以对上述目标函数进行化简。设$y_{i}$为第$i$个样本的正确标签，则目标函数简化为：<br>$$<br>J(w)=\frac{1}{N}\prod^{N}_{i=1}(\frac{e^{w^T_ix_i}}{\sum_{k=1}^{M}{e^{w^T_kx_i}}})^{y_{i}}<br>$$<br>到了这一步，其实我们就可以使用当前的目标函数进行梯度下降，计算模型参数了。但是，我们发现<strong>连乘的形式会使得我们梯度求解变得很复杂，所以为了简化计算，我们可以对目标函数取对数</strong>：<br>$$<br>logJ(w)=\frac{1}{N}\sum^{N}_{i=1}y_{i}log(\frac{e^{w^T_ix_i}}{\sum_{k=1}^{M}{e^{w^T_kx_i}}})=\frac{1}{N}\sum^{N}_{i=1}y_{i}log\hat{y_i}<br>$$<br>以上就是我们极大化似然估计的目标函数，我们只需要使用梯度上升法对它进行优化即可获得最合适的$w$。此外，<strong>我们也可以加上一个负号，将其转化为最小化损失函数的形式，从而进行梯度下降求解</strong>。<br>$$<br>Loss(w)=-\frac{1}{N}\sum^{N}_{i=1}y_{i}log\hat{y_i}<br>$$<br>上面这个式子就是Softmax对数线性模型的损失函数，它其实就是我们常说的<strong>交叉熵（cross entropy）损失函数</strong>，更多有关交叉熵的知识来自于信息论，我在此就不多加介绍了。</p><p>特别地，如果你根据上述损失函数计算梯度，<strong>你会发现对于同一个特征权重，交叉熵损失函数的梯度居然神奇地和均方差损失函数一致！</strong>可以自己动手推导一遍。</p><h2 id="用对数线性模型解决词性标注问题"><a href="#用对数线性模型解决词性标注问题" class="headerlink" title="用对数线性模型解决词性标注问题"></a>用对数线性模型解决词性标注问题</h2><p>有关对数线性模型以及梯度下降法的知识在之前我已经全部介绍过了。在这里我们只需要应用即可。</p><p><strong>依然是使用我们的特征模板构建特征空间，模型使用Softmax函数进行概率转化，模型的训练方式采用随机梯度下降法，损失函数选择交叉熵损失函数。正则化方式选择L2正则化，随机打乱数据集，并使用学习率下降算法，对学习率进行模拟退火处理，使模型在梯度下降后期趋于稳定。</strong></p><p>具体代码可以参考 <a href="https://github.com/SUDA-LA/CIP" target="_blank" rel="noopener">https://github.com/SUDA-LA/CIP</a> 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我在线性模型和对数线性模型学习过程中总结的基础知识，接下来，我还会介绍条件随机场（CRF）模型，并给出其解决词性标注问题的方法。</p><h2 id="参考资料（部分）"><a href="#参考资料（部分）" class="headerlink" title="参考资料（部分）"></a>参考资料（部分）</h2><ul><li><a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">苏州大学李正华老师的课件</a></li><li>李航老师《统计学习方法》的第六章</li><li>Andrew Ng的机器学习课程</li><li>Andrew Ng的深度学习课程</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP自学笔记：隐马尔可夫模型</title>
      <link href="/2020/03/17/nlp-zi-xue-bi-ji-yin-ma-er-ke-fu-mo-xing/"/>
      <url>/2020/03/17/nlp-zi-xue-bi-ji-yin-ma-er-ke-fu-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是我在学习苏州大学李正华老师的中文信息处理课程（<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/" target="_blank" rel="noopener">中文信息处理（Chinese Information Processing）Course Resources</a>）时，对于隐马尔可夫模型的一些个人见解和思考，同时参考了一些书籍和网上的资料编写而成。写这篇文章的主要目的是加深自己对于该模型的理解，如有错误欢迎在评论区指出，非常感谢！</p><h2 id="从问题出发"><a href="#从问题出发" class="headerlink" title="从问题出发"></a>从问题出发</h2><p>隐马尔可夫模型（Hidden Markov Model，HMM模型）是一个序列化标注模型，也能被看作是一种seq2seq（序列到序列）模型。在对隐马尔可夫模型进行学习时，我们引入一个自然语言处理领域的经典序列化问题：<strong>词性标注任务</strong>。接下来的讲解中，将围绕这个问题进行讨论。</p><ul><li>给定一个句子X，输出句子中每一个单词对应的词性。</li></ul><p><img src="1.png" alt="词性标注任务"></p><h2 id="什么是隐马尔可夫模型"><a href="#什么是隐马尔可夫模型" class="headerlink" title="什么是隐马尔可夫模型"></a>什么是隐马尔可夫模型</h2><p>《统计学习方法》中对于隐马尔可夫模型有着如下的定义：</p><blockquote><p>隐马尔科夫是关于时序的概率模型，描述由一个隐藏的马尔科夫链随机生成不可观测的状态随机序列，再由各个状态生成一个观测而产生观测随机序列的过程，隐藏的马尔科夫链生成的随机状态的序列被称为状态序列（state sequence），每个状态生成一个观测，由此而产生的观测的随机序列，称之为观测序列（observation sequence）,序列的每一个位置都可以看作是一个时刻。</p></blockquote><p>上述定义初看比较晦涩难懂，我们需要逐步进行解释。</p><ul><li><p>首先，什么是观测序列和状态序列呢？观测序列通常指可以直接获得的序列，状态序列则是我们无法直接获得的序列，HMM模型的目的就是为了通过可观测到的数据，预测不可观测到的数据。我们结合词性标注问题来看，在此问题中，<strong>观测序列指的是句子的单词序列，而状态序列则指的是句子的词性序列</strong>。</p></li><li><p>那么，什么是马尔可夫链？马尔可夫链是具有马尔可夫性质的随机变量的一个数列，描述了一个状态序列。马尔可夫性质指的是每个状态值取决于前面有限个状态，这在HMM模型中称为<strong>齐次马尔科夫链假设</strong>。需要注意的是<strong>马尔可夫链并没有限定后一个状态的变化仅仅取决于前一个状态，而是说取决于前面有限个状态</strong>。不过为了简化模型，我们在HMM中使用一阶（二元）马尔可夫链，即每个状态仅依赖于前一个状态。带入到词性标注问题中，他指的是<strong>当前的词性仅依赖于前一个词性是什么</strong>。例如，动词后常接名词，很少再接一个动词。那么，根据齐次马尔科夫链假设，如果前一个词性是动词，我们可以推测出当前词倾向于是名词而非动词。</p></li><li><p>接下来，我们要解决的问题是观测序列如何生成状态序列。HMM模型中对于状态序列至观测序列的发射有着这样的假设：<strong>任意时刻的观察状态只仅仅依赖于当前时刻的隐藏状态</strong>。这也叫做<strong>观测独立性假设</strong>，与齐次马尔科夫链假设一样，它也是为了简化模型。带入到词性标注问题中，它指的是<strong>当前词仅与当前词性有关</strong>。举例来说，当给定一个词“苹果”，我们根据训练集统计得知名词词性发射至“苹果”的概率远大于其它词性，所以我们可以预测当前词倾向于是名词。</p></li><li><p>根据齐次马尔可夫假设和观测独立性假设，对于一个长度为$L$的句子，我们用$X=x(0),x(1)……x(L-1)$表示词序列（观测序列），$Y=y(0),y(1)…y(L-1)$表示词性序列（状态序列），那么词性序列的转移过程可以表示为：<br>$$<br>p(y_i|y_0…y_i-1)=p(y_i|y_i-1)（一阶马尔可夫性质）<br>$$</p></li></ul><p>  由词性序列$Y$产生词序列$X$的发射过程可以表示为：<br>  $$<br>  p(x_0…x_L|y_0…y_L)= \prod_{i=0}^L{p(x_i|y_i)}(观测独立性假设)<br>  $$</p><h2 id="什么样的问题需要隐马尔可夫模型"><a href="#什么样的问题需要隐马尔可夫模型" class="headerlink" title="什么样的问题需要隐马尔可夫模型"></a>什么样的问题需要隐马尔可夫模型</h2><blockquote><p>考虑一个简单的例子，有人试图通过一片海藻推断天气——民间传说告诉我们‘湿透的’海藻意味着潮湿阴雨，而‘干燥的’海藻则意味着阳光灿烂。如果它处于一个中间状态（‘有湿气’），我们就无法确定天气如何。然而，天气的状态并没有受限于海藻的状态，所以我们可以在观察的基础上预测天气是雨天或晴天的可能性。另一个有用的线索是前一天的天气状态（或者，至少是它的可能状态）——通过综合昨天的天气及相应观察到的海藻状态，我们有可能更好的预测今天的天气。 </p></blockquote><p>使用HMM模型时我们的问题一般有这两个特征：</p><ol><li><p>我们的问题是基于序列的，比如时间序列，或者状态序列。NLP中常见的机器翻译、词性标注、分词等任务都可以看作是序列化问题。</p></li><li><p>我们的问题中有两类数据，一类序列数据是可以观测到的，即观测序列；而另一类数据是不能观察到的，即隐藏状态序列，简称状态序列。比如，在机器翻译中，我们可以将源语言文本看作是观测序列，目标语言文本看作是状态序列；又比如，词性标注中，词序列是观测序列，词性序列是状态序列。</p></li></ol><h2 id="隐马尔可夫模型：生成模型OR判别模型"><a href="#隐马尔可夫模型：生成模型OR判别模型" class="headerlink" title="隐马尔可夫模型：生成模型OR判别模型"></a>隐马尔可夫模型：生成模型OR判别模型</h2><ul><li>假设样本的特征向量为$X$，标签向量为$Y$。由生成方法学习到的模型称之为生成模型，生成方法是由数据学习联合分布$P(X,Y)$：<br>$$<br>P(X,Y)=P(X|Y)P(Y)<br>$$<br>然后求出条件概率分布$P(Y∣X)$作为预测：</li></ul><p>$$<br>P(Y∣X)=\frac{P(X,Y)}{P(X)}<br>$$</p><p>​        生成模型需要先把所有训练数据的分布情况摸透，最终确定一个分布，并且此分布是包含了所有特征和标签        的联合分布$P(X,Y)$。当我们需要对新的样本的特征向量进行预测时，使用上述公式，即可求出$P(Y∣X)$，即        样本$X$被标注为标签$Y$的概率。</p><p>​        典型的生成模型有：朴素贝叶斯模型，<strong>隐马尔可夫模型</strong>，生成对抗网络（GAN），变分自编码器（VAE）。</p><ul><li><p>由判别方法学习到的模型称之为判别模型，判别方法是由数据直接学习决策函数或者条件概率分布$P(Y∣X) $作为预测的模型。典型的判别模型有：k近邻模型，感知机模型，决策树，逻辑回归模型，最大熵模型，支持向量机，提升方法和<strong>条件随机场</strong>等。</p><p>判别模型直接根据训练数据的标签$Y$，通过定义特征进行学习，使用复杂的函数映射及决策叠加等方法，最后拟合出一个较优的边界。当新的特征向量到来时，我们使用训练得到的决策界进行预测即可。比较经典的判别模型是逻辑回归模型，它通过定义损失函数，最大化似然估计，利用梯度下降等方式将决策边界的拟合转化为最小化损失函数的凸优化问题。</p></li><li><p>总结：<strong>生成模型是指对联合概率建模，判别模型是对条件概率建模 ，HMM模型属于生成模型，因为HMM模型中没有建立决策边界，而是直接对联合概率分布建模。当给定观测序列时，我们使用前向算法计算每条状态序列的概率，选取概率最大的状态序列路径作为序列标注的结果。</strong></p></li><li><p>一个简单的图示表示生成模型和判别模型的区别：</p><p><img src="4.jpg" alt="生成模型和判别模型"></p></li></ul><h2 id="隐马尔可夫模型：概率模型"><a href="#隐马尔可夫模型：概率模型" class="headerlink" title="隐马尔可夫模型：概率模型"></a>隐马尔可夫模型：概率模型</h2><p><strong>概率模型</strong>（probabilistic model ）中，我们需要利用已知变量 “推断（inference）” 未知变量的条件分布。 根据我们之前的介绍，隐马尔可夫模型就是一种概率模型。</p><p><strong>概率图模型</strong>（probabilistic graphical model ）是一类用图表达变量相关关系的概率模型。一个节点表示一个或一组随机变量，节点之间的边表示变量间的概率相关关系。根据边的性质不同，概率图模型可以分为两种：第一类使用有向无环图表示变量之间的依赖关系，称为有向图模型或贝叶斯网（ Bayesian network ）；第二类是使用无向图表示变量之间的相关关系，成为无向图模型或马尔可夫网（Markov network）。根据下图可以看出：<strong>隐马尔可夫模型属于概率图模型中的有向图模型</strong>。</p><p><img src="4.png" alt="隐马尔可夫模型示意图"></p><p>我在知乎上看到了一张很清楚的图片，分享给大家，介绍了常见概率图模型的分类。</p><p><img src="2.png" alt="概率图模型的分类"></p><h2 id="隐马尔可夫模型中需要学习的三个参数"><a href="#隐马尔可夫模型中需要学习的三个参数" class="headerlink" title="隐马尔可夫模型中需要学习的三个参数"></a>隐马尔可夫模型中需要学习的三个参数</h2><p>简单来说，HMM模型主要使用了两个特征，分别是<strong>发射特征</strong>（词性到词的概率）和<strong>转移特征</strong>（前一个词性到当前词性的概率）。特别的，我们还会引入第三个特征，即<strong>初始特征</strong>，它主要指的是句子中第一个词性是什么的概率。它本质上来说仍然是一个转移特征，只不过是从第0个词性（也就是空）转移而来。</p><p>在实际参数学习过程中，这三个特征都是以矩阵的形式存储。 <strong>关于假设，重要的一点是三个特征矩阵并不随时间的改变而改变——这个矩阵在整个系统的生命周期中是固定不变的</strong>。 </p><p>为了简化模型，HMM定义了<strong>两个假设</strong>，即我们前面提到的<strong>齐次马尔可夫假设</strong>和<strong>观测独立性假设</strong>，根据前者，我们使用了转移特征和初始特征，根据后者，我们使用了发射特征。<strong>这些假设虽然简化了模型，但同时由于过于粗糙，导致HMM只能使用三类特征，无法考虑句子中的更多信息</strong>。在我的接下来的文章中，将探讨<strong>线性模型</strong>和<strong>对数线性模型</strong>，他们虽然无法解决序列标注问题，一次只能预测一个词的词性，但是<strong>能够使用更多的特征</strong>。特别的，<strong>条件随机场</strong>结合了对数线性模型与隐马尔可夫模型的优点，实现了<strong>可以使用无限制的特征模板进行序列化标注</strong>。</p><p>HMM（隐马尔可夫模型）、LR（逻辑回归模型，即对数线性模型）、CRF（条件随机场）的关系如下图所示。</p><p><img src="3.png" alt="几种模型的对比"></p><h2 id="隐马尔可夫模型的五个要素"><a href="#隐马尔可夫模型的五个要素" class="headerlink" title="隐马尔可夫模型的五个要素"></a>隐马尔可夫模型的五个要素</h2><p>总结一下，隐马尔可夫模型的核心就是五个要素： </p><ul><li>两个序列：<ul><li>观测序列：句子（词序列）</li><li>状态序列：词性序列</li></ul></li><li>三个矩阵：<ul><li>初始概率矩阵：第一个词性的概率，实际上是一个一维向量</li><li>发射概率矩阵：词性发射到词的概率，维度为[训练集中的词性数,训练集中的词数]</li><li>状态转移概率矩阵：从一个词性变化到另一个词性的概率，维度为[训练集中的词性数,训练集中的词性数]</li></ul></li></ul><p>任何一个能用以上五个参数描述的模型都是隐马尔可夫模型。</p><ul><li>这里，我们补充一个HMM的例子：</li></ul><blockquote><p>例子：病情转化<br>假设：某一时刻只有一种疾病，且只依赖于上一时刻疾病，一种疾病只有一种症状，且只依赖于当时的疾病<br>症状（观察值）：发烧，咳嗽，咽喉肿痛，流涕<br>疾病（状态值）：感冒，肺炎，扁桃体炎，猝死<br>转移概率：从一种疾病转变到另一种疾病的概率<br>输出概率：某一疾病呈现出某一症状的概率<br>初始分布：初始疾病的概率</p></blockquote><h2 id="隐马尔可夫模型解决序列标注问题的过程"><a href="#隐马尔可夫模型解决序列标注问题的过程" class="headerlink" title="隐马尔可夫模型解决序列标注问题的过程"></a>隐马尔可夫模型解决序列标注问题的过程</h2><ol><li><p><strong>训练过程</strong>：利用训练数据，统计得到HMM模型的三个参数，也就是上一节提到的三个矩阵。主要的方法有：<strong>极大似然估计法（有监督学习）</strong>和 <strong>Baum-Welch算法（无监督学习）</strong>。</p></li><li><p><strong>预测过程</strong>：给定一个句子的词序列，通过我们训练好的模型预测出最有可能的词性序列。主要的方法为<strong>维特比算法</strong>。</p></li></ol><h2 id="隐马尔可夫模型的训练过程"><a href="#隐马尔可夫模型的训练过程" class="headerlink" title="隐马尔可夫模型的训练过程"></a>隐马尔可夫模型的训练过程</h2><h3 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h3><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">$w$</td><td align="center">观测序列中的单词</td></tr><tr><td align="center">$y$</td><td align="center">状态序列中的词性</td></tr><tr><td align="center">$N=\{y_0,…,y_n\}$</td><td align="center">状态集合，包含了数据集中所有的n个状态，即词性</td></tr><tr><td align="center">$M=\{w_0,…,w_n\}$</td><td align="center">观测集合，包含了数据集中所有的m个观测，即词</td></tr><tr><td align="center">$A=[a_{ij}]_{N*N}$</td><td align="center">状态转移矩阵，包含了词性间的转移概率，其中$a_{ij}=P(y_i|y_j)$，且这里的转移需要是两个连续出现的词性（一阶马尔可夫假设）</td></tr><tr><td align="center">$B=[b_{ij}]_{N*M}$</td><td align="center">状态发射矩阵，包含了词性到词的发射概率，其中$b_{ij}=P(w_i|y_j)$</td></tr><tr><td align="center">$C=[c_i]_N$</td><td align="center">初始状态矩阵，包含了每一个词性出现在词性序列的第一个节点的概率</td></tr></tbody></table><h3 id="极大似然估计法（有监督学习）"><a href="#极大似然估计法（有监督学习）" class="headerlink" title="极大似然估计法（有监督学习）"></a>极大似然估计法（有监督学习）</h3><p>机器学习中，有监督学习指的是训练数据给出了标签。在词性标注问题中，即指的是训练数据给出了词性序列。</p><p>在有监督学习的参数学习过程中， <strong>参数的计算频率近似于参数的概率</strong> ，我们可以利用极大似然估计法进行证明。具体证明的过程参考李老师的讲义<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/7-hmm-tagging-MLE/main.pdf" target="_blank" rel="noopener"> HMM模型中极大似然估计的由来 </a> 。基于上述推导，通过对训练数据进行统计，我们便可计算出模型的三个基本参数矩阵，并可以使用他们进行预测。</p><p>具体的<strong>训练过程</strong>如下：</p><ul><li><p>Step1.统计状态的概率分布，也就是初始概率矩阵 $C$，这一步<strong>直接计算各词性在序列首节点（即句首）出现的频率即可</strong>。</p></li><li><p>Step2. 统计状态转移矩阵 $A$，<strong>这一步需要分别统计当前词性转移至所有词性的次数$\sum_{k=1}^N{count(y_i,y_k)}$和统计当前词性转移至目标词性的次数$count(y_i,y_j)$</strong>，根据一阶马尔可夫假设，这里统计的词性间的转移次数<strong>只统计两个词性连续出现的情况</strong>。将统计得到的两个次数相除，即可得到当前训练集中某词性转移到目标词性的频率，根据极大似然估计，该频率就是状态转移概率。<br>$$<br>a_{ij}=\frac{count(y_i,y_j)}{\sum_{k=1}^N{count(y_i,y_k)}}<br>$$</p></li></ul><p>根据上述公式，我们可以预测出所有状态自身和相互转移的概率，填充状态转移矩阵。</p><ul><li>Step3. 统计状态发射矩阵 $B$，<strong>这一步需要分别统计当前词性发射至所有词的次数$\sum_{k=1}^M{count(y_i,w_k)}$和统计当前词性发射至目标词的次数$count(y_i,w_j)$</strong>。将统计得到的两个次数相除，即可得到当前数据集中某词性发射到目标词的概率，根据极大似然估计，该频率就是状态发射概率。<br>$$<br>b_{ij}=\frac{count(y_i,w_j)}{\sum_{k=1}^N{count(y_i,w_k)}}<br>$$<br>根据上述公式，我们可以预测出所有状态自身和相互转移的概率，填充状态发射矩阵。</li></ul><p>至此，我们完成了在人工标注的数据集上的隐马尔可夫模型所有参数的学习，并可以将其投入至结果预测中。</p><h2 id="Baum-Welch算法（无监督学习）"><a href="#Baum-Welch算法（无监督学习）" class="headerlink" title="Baum-Welch算法（无监督学习）"></a>Baum-Welch算法（无监督学习）</h2><p>机器学习中，无监督学习指的是训练数据没有给出标签。在词性标注问题中，即指的是训练数据只有句子，没有对应的词性。在这个问题中，无监督学习远比有监督学习复杂。这里仅给出我现在对该算法的理解，如果大家发现有问题可以在评论区指出。</p><p>我的理解是：Baum-Welch算法就是一个<strong>EM</strong>的过程，参数的求解需要使用到<strong>前向后向（Forward-Backward）算法</strong>。</p><p>EM的意思是 <strong>Expectation Maximization</strong> ，即期望最大化。这个算法一般分为两步，即E步（Expection 步）和M步（Maximization 步）：</p><ol><li>随机初始化模型参数$\theta$的初值$\theta_0$。</li><li>E步：计算联合分布的条件概率期望$Q$</li><li>M步：<strong>极大化似然函数</strong>$L(\theta)$，得到新的$\theta$</li><li>重复E、M步骤直到$\theta$收敛</li></ol><p>这里说的比较简略，从极大似然估计到EM算法的推导大家可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/7-hmm-em/main.pdf" target="_blank" rel="noopener">李老师的课件</a>以及这篇知乎上的文章<a href="https://zhuanlan.zhihu.com/p/36331115" target="_blank" rel="noopener">人人都懂EM算法</a>。</p><p>如果你有机器学习的基础，那你很可能学习过<strong>K-Means算法</strong>，这是一种无监督的聚类算法。它本质上就是一种EM算法。对于给定的许多个无标签的样本点，K-Means可以将他们聚成任意n个类别。具体的做法是先随机选取数据集中的n个点作为聚类的质心点，计算每个点到每个质心点的距离，将他们归类到距离最小的类别下；然后对于每一个类别，重新计算其质心点；我们反复迭代进行上述的归类和质心计算的步骤，直到质心不再变化。<strong>随机初始化和重置质心的过程其实就是EM算法的E步，计算样本点到质心的距离并将其聚类到最近的质心的过程其实就是EM算法的M步。</strong></p><p>K-Means算法直接对样本点进行归类，而不是计算每个类别的概率，所以属于<strong>Hard EM</strong>。Hard EM和 Soft EM的区别和我之前在吴恩达的深度学习课程上看到的 SoftMax和HardMax的区别很像，个人感觉本质是一样。</p><p><strong>总结一下，当我们的样本没有给定标注数据，即只有句子没有词性时，我们可以对需要学习的三个参数矩阵进行随机初始化（np.rand），初步确定模型，然后极大化数据的某种似然，调整得到新的参数矩阵，通过不断地迭代，参数矩阵将逐渐收敛，当它们的变化范围缩小到某个可以被接受的阈值时，我们可以停止迭代，将当前的参数矩阵用于预测。</strong></p><p><strong>EM算法的收敛性可以使用Jensen不等式来证明</strong>，具体过程非常精妙，详细内容可以参考<a href="https://www.cnblogs.com/jerrylead/archive/2011/04/06/2006936.html" target="_blank" rel="noopener">吴恩达的讲义</a>。</p><p>需要注意的是，<strong>EM算法无法保证全局最优解</strong>，和梯度下降算法非常类似，他们能够稳定达到全局最优的条件都是似然函数（损失函数）是一个凸函数。（PS：似然函数和损失函数的关系我个人认为非常紧密，后面会专门写一篇blog说一下这个问题）</p><p><strong>前向后向算法</strong>的使用，主要是因为对于网格中的每一个状态，它既计算到达此状态的“前向”概率（给定当前模型的近似估计），又计算到达此状态的“后向”概率（给定当前模型的近似估计）。 这些都可以通过利用递归进行加速计算。<strong>使用前向算法和后向算法的相互合作，我们可以得到很多有用的信息，并可以将它们运用在EM算法过程中的极大化似然估计上</strong>。（<strong>PS：这里的Forward算法和后面Viterbi算法中的Forward算法并不完全相同，这里是 sum-product ，你可以看作是神经网络中的正向传播过程，对于传至当前状态的概率进行求和；而后者是 max-product，对于传至当前状态的概率取最大值</strong> ）</p><p>这里顺带说一句，前向算法还可以用于计算序列的概率，从而选择模型。如果我们训练了多个词性标注的HMM模型，那么对于一个需要标注的句子，我们可以通过前向算法计算它在不同模型中可能出现的概率，然后选取最大概率的模型用于预测。</p><h2 id="隐马尔可夫模型的预测（解码）过程"><a href="#隐马尔可夫模型的预测（解码）过程" class="headerlink" title="隐马尔可夫模型的预测（解码）过程"></a>隐马尔可夫模型的预测（解码）过程</h2><p>学习完隐马尔可夫模型的参数后，便可以使用这三个参数矩阵对我们输入的句子进行词性预测了。在这里，我们使用一种叫做<strong>维特比（viterbi）算法</strong>的动态规划算法进行状态序列的解码，也就是词性序列的预测。</p><p>维特比算法是一种<strong>动态规划求解篱笆网络（Lattice）的最优路径问题的方法</strong>。此处，我依然不会给出详细的公式，具体公式大家可以参考<a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/7-hmm-em/main.pdf" target="_blank" rel="noopener">李老师的课件</a>，我仅以通俗的语言简单地解释一下维特比算法的原理。</p><p><img src="5.png" alt="篱笆网络（Lattice）的最短路径问题"></p><p>维特比算法可以应用在任何<strong>有向无环图的最优路径计算</strong>上，这里它恰巧符合隐马尔可夫算法的解码需求。它主要分为两个步骤：</p><ol><li>前向传播计算序列的最大概率。</li><li>反向回溯确定最大概率序列的路径。</li></ol><p>维特比算法前向传播的过程主要采用了动态规划思想，因为在上述有向无环图中，同一个节点可以被多次访问，所以如果采用穷举法计算所有序列，会产生对子问题的大量重复计算。我们自然想到采用动态规划的方法来降低时间复杂度，因为这里满足动态规划的三个基本要求：（1）重叠子问题（2）最优子结构（3）无后效性。</p><p>这个算法并不难理解，我也就不一步步推给大家看了，感兴趣的同学可以看一下这个问题<a href="https://www.zhihu.com/question/20136144" target="_blank" rel="noopener">如何通俗地讲解 viterbi 算法？</a>。简单阐述一下就是：<strong>状态矩阵中，当前节点的值等于上一层各节点的值乘以对应的转移路径的权值所得结果中的最优值（max-product），同时，我们还建立一个回溯矩阵，保存状态矩阵中每个节点的值是由上一层的哪个节点转移而来。当前向传播计算到最后一层时，我们选取最后一层的节点中的最优值，并通过回溯矩阵反向回溯得到对应的最优序列。特别地，在隐马尔可夫模型中，我们在前向传播计算每个节点最优值的时候，还需要考虑发射概率。</strong></p><p>通过维特比算法，我们可以较快的利用训练好的模型去预测一个句子的最大概率词性序列，并输出。</p><p>在实际运用模型的过程中，我们还会发现这样的一个问题：训练得到的参数矩阵很可能是较为稀疏的，例如从一个词性从未发射到某个单词过。同时，训练集的规模有限，不可能包含所有的词和词性。由于状态矩阵的转移涉及概率的累乘，上述未登录的情况将导致发射或转移或初始概率为0，进而使得前向传播计算出的整条序列地概率为0。<strong>为了解决零概率问题，我们需要还引入平滑方法，例如Laplace平滑等</strong>。更多方法可以参考<a href="https://www.jianshu.com/p/a28acdc32b56" target="_blank" rel="noopener">NLP系列学习:数据平滑</a>。<br>$$<br>a_{ij}=\frac{count(y_i,y_j)+\lambda}{\sum_{k=1}^N[{count(y_i,y_k)+\lambda}]}<br>$$<br>特别注意的是，如果你使用Laplace平滑，下方的$\lambda$一定不要忘记加，我曾经写模型的时候就犯过这样的错误。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我学习隐马尔可夫模型过程中的笔记和思考，接下来我将继续介绍序列标注概率图模型中的最大熵马尔可夫模型（MEMM）和条件随机场模型（CRF），并阐明他们之间的关系。</p><h2 id="参考资料（部分）"><a href="#参考资料（部分）" class="headerlink" title="参考资料（部分）"></a>参考资料（部分）</h2><ul><li><a href="http://hlt.suda.edu.cn/~zhli/teach/cip-2015-fall/7-hmm-tagging/main.pdf" target="_blank" rel="noopener">李正华老师的课件</a></li><li>李航老师的《统计学习方法》第10章</li><li><a href="http://www.comp.leeds.ac.uk/roger/HiddenMarkovModels/html_dev/main.html" target="_blank" rel="noopener"> HMM学习最佳范例 </a></li><li><a href="https://blog.csdn.net/lukabruce/article/details/82380511" target="_blank" rel="noopener">隐马尔科夫模型（Hidden Markov Model，HMM）</a></li><li><a href="https://zhuanlan.zhihu.com/p/85454896" target="_blank" rel="noopener">一站式解决：隐马尔可夫模型（HMM）全过程推导及实现</a></li><li><a href="https://www.zhihu.com/question/35866596" target="_blank" rel="noopener">如何用简单易懂的例子解释条件随机场（CRF）模型？它和HMM有什么区别？</a></li><li><a href="https://www.zhihu.com/question/20962240" target="_blank" rel="noopener">如何用简单易懂的例子解释隐马尔可夫模型？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2020/03/17/kmp-suan-fa/"/>
      <url>/2020/03/17/kmp-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文整理了KMP算法的原理及代码，可以使用LEETCODE上的题目进行测试：<a href="https://leetcode-cn.com/problems/implement-strstr/submissions/" title="28. 实现 strStr()" target="_blank" rel="noopener">28. 实现 strStr()</a>。</p><h2 id="从Brute-Force算法说起"><a href="#从Brute-Force算法说起" class="headerlink" title="从Brute-Force算法说起"></a>从Brute-Force算法说起</h2><p>BF算法是最为简单的一种字符串匹配算法，它采用纯暴力匹配的思想。对于目标串S和模式串P，其基本匹配思路如下：</p><ul><li>枚举 i = 0, 1, 2 … , len（S）-len（P）</li><li>将 S[i : i+len（P）] 与 P 作比较。如果一致，则找到了一个匹配。</li></ul><p><img src="1.jpg" alt="BF算法匹配流程"></p><p>BF算法的缺点在于每一次都是将目标串中的指针直接回溯为i+1。</p><p>我们记 n = |S| 为串 S 的长度，m = |P| 为串 P 的长度。不难想到，最坏情况下其时间复杂度为$O(MN)$。</p><p><img src="2.jpg" alt="BF算法python实现"></p><h2 id="KMP算法：Brute-Force算法的优化"><a href="#KMP算法：Brute-Force算法的优化" class="headerlink" title="KMP算法：Brute-Force算法的优化"></a>KMP算法：Brute-Force算法的优化</h2><p>为了优化BF算法，我们需要尽可能地减少匹配的趟数。那么，我们如何达到这一目的呢？</p><p>如果把模式串视为一把标尺，在主串上移动，那么 Brute-Force 就是每次失配之后只右移一位；改进算法则是每次失配之后，移很多位，跳过那些不可能匹配成功的位置。为了减少重复匹配，我们需要在失配处计算移动的位数，而不是单纯的回退目标串和模式串中的指针。通过一个名叫“部分匹配表”的东西，我们可以跳过绝不可能匹配成功的字符串比较，从而实现算法的优化。</p><h3 id="部分匹配表"><a href="#部分匹配表" class="headerlink" title="部分匹配表"></a>部分匹配表</h3><p>部分匹配表（Partial Match Table）的含义为：</p><ul><li><p>对于长度为m的字符串P，部分匹配表是与之对应的长度为m的一个数组PMT。</p></li><li><p>PMT[i]的值等于：字符串P的前i位字符组成的子字符串中，前缀集合和后缀集合中公共子串（前缀和后缀不包括自身）的最大长度。</p></li></ul><p>对于字符串“abababca”，它的PMT如下表所示：</p><p><img src="3.png" alt="PMT"></p><p>例如，对于”aba”，它的前缀集合为{”a”, ”ab”}，后缀 集合为{”ba”, ”a”}。两个集合的交集为{”a”}，那么长度最长的元素就是字符串”a”了，长 度为1，所以对于”aba”而言，它在PMT表中对应的值就是1。再比如，对于字符串”ababa”，它的前缀集合为{”a”, ”ab”, ”aba”, ”abab”}，它的后缀集合为{”baba”, ”aba”, ”ba”, ”a”}， 两个集合的交集为{”a”, ”aba”}，其中最长的元素为”aba”，长度为3。</p><h3 id="如何使用部分匹配表进行优化"><a href="#如何使用部分匹配表进行优化" class="headerlink" title="如何使用部分匹配表进行优化"></a>如何使用部分匹配表进行优化</h3><p><img src="4.png" alt="KMT算法示意图"></p><p>我们以上图为例进行说明。当目标串S的指针为i，模式串P的指针为j时，此时匹配失败了。按照BF算法，我们会将i回退至下标为1处，j回退至下标为0处继续匹配。这显然是很笨拙的。</p><p>通过观察，我们可以发现， S[:i] 和 P[:j] 是成功匹配的，只是 S[i] 和 P[j] 不相同。</p><p>这时，我们在上一节所得的模式串的部分匹配表就派上了用场。通过 PMT[j-1] ，我们可以得知，P[:j] 这一子串中前后缀公共子串的最大长度为4。又因为 S[:i] 和 P[:j] 是相等的，所以 P[:j] 的后缀也就是 S[:i] 的后缀。那么，我们可以推知目标串i之前的4位和模式串开头的4位是相同的。就是图中的灰色部分。那这部分就不用再比较了。</p><p>有了上面的思路，我们就可以使用PMT加速字符串的查找了。我们看到如果是在 j 位 失配，那么影响 j 指针回溯的位置的其实是第 j −1 位的 PMT 值。</p><p>以上其实就是KMP算法的基本思想了，我们总结一下：KMP算法的目的是使用部分匹配表，来跳过必不可能成功的匹配，减少匹配的趟数。</p><h3 id="KMP算法的流程"><a href="#KMP算法的流程" class="headerlink" title="KMP算法的流程"></a>KMP算法的流程</h3><p>我们现在来总结一下KMP算法主程序的基本流程：</p><p>假设现在文本串 S 匹配到 tar 位置，模式串 P 匹配到 pos 位置：</p><ol><li><p>如果当前字符匹配成功，则tar++，pos++，继续匹配二者的下个字符。若当前的pos等于模式串的长度，则说明全部匹配成功，此时可以返回tar减去pos的值，即模式串在目标串中出现的首个字符的下标。</p></li><li><p>如果当前匹配失败，且pos大于0，说明此时模式串已经成功匹配了部分字符，可以尝试利用部分匹配表跳过必然无法匹配成功的子串，令pos=PMT[pos-1]。</p></li><li><p>如果匹配失败，且pos等于0，说明此时模式串的第一个字符就无法匹配，则tar++，尝试与目标串的下个字符匹配。</p></li></ol><p>根据上述的流程，我们可以编写KMP算法主体函数如下：</p><pre class="line-numbers language-python"><code class="language-python">        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span>pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>            tar<span class="token operator">=</span><span class="token number">0</span>            pos<span class="token operator">=</span><span class="token number">0</span>            PMT<span class="token operator">=</span>getPMT<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>tar<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>st<span class="token punctuation">[</span>tar<span class="token punctuation">]</span><span class="token operator">==</span>pattern<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    tar<span class="token operator">+=</span><span class="token number">1</span>                    pos<span class="token operator">+=</span><span class="token number">1</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token operator">==</span>len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> tar<span class="token operator">-</span>pos                <span class="token keyword">elif</span> <span class="token punctuation">(</span>pos<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    pos<span class="token operator">=</span>PMT<span class="token punctuation">[</span>pos<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    tar<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="KMP算法的难点：获取部分匹配表"><a href="#KMP算法的难点：获取部分匹配表" class="headerlink" title="KMP算法的难点：获取部分匹配表"></a>KMP算法的难点：获取部分匹配表</h3><p>KMP算法的基本思想其实并不难，但KMP算法主要的难点在于如何求解模式串的PMT数组。这里我们可以采取<strong>动态规划</strong>的方式求解。</p><ul><li>问题：对于模式串P，已知PMT[0],PMT[1],PMT[2]…PMT[x-1]，求解PMT[x]。</li></ul><p>观察上述问题，我们发现，该问题符合最优子结构和重叠子问题的动态规划要求，动态规划具体的转移情况我们进行分类讨论。</p><ul><li>情况一：已知now=PMT[x-1]，若P[x]==P[now]，则PMT[x]=now+1。如下图所示，因为我们已知前x-1个字符中有长度为now的公共前后缀，如果当前前缀的后一位P[now]等于当前后缀的后一位P[x]，则公共前后缀长度自然可以加1。</li></ul><p><img src="4.jpg" alt="情况1"></p><ul><li>情况二： 若P[x]!=P[now]，则令now=PMT[now-1]，再次尝试比较P[x]和P[now]，如果相等则PMT[x]=now+1，如果不相等再重复之前的过程，直到now等于0。如下图所示，此时由于子串A必然与子串B相等，则子串A的后缀与子串B的后缀必然相同，所以子串A的最大公共前后缀即为前x-1个字符中第二长的公共前后缀。</li></ul><p><img src="5.jpg" alt="情况2"></p><p>根据上述分析，我们可以编写获取模式串PMT数组的代码如下：</p><pre class="line-numbers language-python"><code class="language-python">        <span class="token keyword">def</span> <span class="token function">getPMT</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>            PMT<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#PMT[0]必定为0</span>            x<span class="token operator">=</span><span class="token number">1</span>            now<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">==</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    now<span class="token operator">+=</span><span class="token number">1</span>                    PMT<span class="token punctuation">.</span>append<span class="token punctuation">(</span>now<span class="token punctuation">)</span>                    x<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">elif</span> now<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                    now<span class="token operator">=</span>PMT<span class="token punctuation">[</span>now<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    PMT<span class="token punctuation">.</span>append<span class="token punctuation">(</span>now<span class="token punctuation">)</span>                    x<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">return</span> PMT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，KMP算法介绍完毕。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>KMP算法在我看来，主要有两方面的内容，一是通过动态规划求解模式串的部分匹配表；二是通过部分匹配表来跳过必不可能的情况，提升匹配的速度。其核心难点在于PMT动态规划的转移方程，需要静下心来自己推导一遍。</p><p>我们不难看出，对于长度为M的目标串S和长度为N的模式串P，KMP算法的时间复杂度由两部分组成：一是match函数中需要让指针遍历目标串S的每一个位置，需要耗费$O(M)$的时间，二是getPMT函数中计算部分匹配表，这一部分我们采用均摊时间复杂度分析，可以发现耗费的时间为$O(N)$。</p><p>利用KMP算法，我们将BF算法的时间复杂度$O(MN)$成功降为$O(M+N)$，使速度大大提升。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日两题</title>
      <link href="/2020/03/13/leetcode-ti-jie-chi-xu-geng-xin/"/>
      <url>/2020/03/13/leetcode-ti-jie-chi-xu-geng-xin/</url>
      
        <content type="html"><![CDATA[<h1 id="每日算法-LEETCODE-PYTHON3"><a href="#每日算法-LEETCODE-PYTHON3" class="headerlink" title="每日算法(LEETCODE,PYTHON3)"></a>每日算法(LEETCODE,PYTHON3)</h1><h2 id="2020-3-2-（2-medium）"><a href="#2020-3-2-（2-medium）" class="headerlink" title="2020.3.2 （2 medium）"></a>2020.3.2 （2 medium）</h2><h3 id="第3题-无重复的字符的最长字串"><a href="#第3题-无重复的字符的最长字串" class="headerlink" title="第3题 无重复的字符的最长字串"></a>第3题 无重复的字符的最长字串</h3><p><img src="3.png" alt="第3题 无重复的字符的最长字串"></p><h4 id="思路1-动态规划"><a href="#思路1-动态规划" class="headerlink" title="思路1 动态规划"></a>思路1 动态规划</h4><p>我的最初思路：可以采用动态规划法（区间DP），从区间为2的子串开始计算无重复字符的长度，接着计算下个更大的区间，依次类推，直到区间长度等于字符串长度。</p><ul><li><p>空间复杂度优化：这道题的动态规划状态矩阵中，可以发现有一半的空间（对角线以下）全部为0，所以可以压缩。</p></li><li><p>时间复杂度优化：分析后发现，这道题其实不需要动态规划，因为本质上没有重叠子问题。我尝试了两层循环遍历字符串的所有子串，一旦出现重复就可以跳出与当前最大长度比较，后面的子串不用再比较了，必有重复的字符。时间复杂度$O(N^2)$</p></li></ul><h4 id="思路2-滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）"><a href="#思路2-滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）" class="headerlink" title="思路2 滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）"></a>思路2 滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）</h4><p>使用左右两个指针维护一个无重复字符的窗口，两个指针初始都在0处。通过右指针不断向右延伸添加新的字符，并记录当前窗口大小，每次与当前最大值比较，如果大于当前最大值，则可以更新。当窗口延伸至新字符已存在于窗口内时。把窗口左侧的字符不断移除（左指针收缩），直到当前窗口无重复子串。继续滑动窗口，直到右指针触及字符串尾部，此时可以输出当前最大长度即可。</p><p>滑动窗口法减少了对字符串的重复遍历。</p><pre><code>class Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        if not s:return 0 #字符串为空的处理        left = 0        lookup = []        n = len(s)        max_len = 0        cur_len = 0        for i in range(n):            cur_len += 1            if s[i] in lookup:                pos=len(lookup)-lookup[::-1].index(s[i]) #寻找重复字符出现在窗口内的最后一次位置，直接将左指针移动到该位置后面即可。                lookup=lookup[pos:]                left += pos                cur_len -= pos            if cur_len &gt; max_len:max_len = cur_len            lookup.append(s[i])        return max_len</code></pre><h3 id="第4题-寻找两个有序数组的中位数"><a href="#第4题-寻找两个有序数组的中位数" class="headerlink" title="第4题 寻找两个有序数组的中位数"></a>第4题 寻找两个有序数组的中位数</h3><p><img src="4.png" alt="第4题 寻找两个有序数组的中位数"></p><h4 id="思路1-指针遍历"><a href="#思路1-指针遍历" class="headerlink" title="思路1 指针遍历"></a>思路1 指针遍历</h4><p>我的方法：归并排序的思想，通过设置两个指针对两个有序数组进行归并排序，若已排序到中位数位置，则输入当前指针指向的数。</p><p>缺点：时间复杂度$O(M+N)$，较高。空间复杂度可以优化至$O(1)$，即只存当前数和前一个数。</p><p>要想获得log级别的时间复杂度，需要使用二分法或者堆。</p><pre><code>class Solution:    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:        mid_pos=(len(nums1)+len(nums2)-1)/2        p=0        q=0        li=[]        count=-1        while (p!=len(nums1))and(q!=len(nums2)):            if (nums1[p]&lt;=nums2[q]):                li.append(nums1[p])                count+=1                p+=1                if (count&gt;=mid_pos):                    if mid_pos%1!=0:                        return (li[-1]+li[-2])/2                    else:                        return li[-1]            else:                li.append(nums2[q])                count+=1                q+=1                if (count&gt;=mid_pos):                    if mid_pos%1!=0:                        return (li[-1]+li[-2])/2                    else:                        return li[-1]        if (p==len(nums1)):            for i in range(q,len(nums2)):                li.append(nums2[i])                count+=1                if (count&gt;=mid_pos):                    if mid_pos%1!=0:                        return (li[-1]+li[-2])/2                    else:                        return li[-1]        elif (q==len(nums2)):            for i in range(p,len(nums1)):                li.append(nums1[i])                count+=1                if (count&gt;=mid_pos):                    if mid_pos%1!=0:                        return (li[-1]+li[-2])/2                    else:                        return li[-1]</code></pre><h4 id="思路2-递归二分"><a href="#思路2-递归二分" class="headerlink" title="思路2 递归二分"></a>思路2 递归二分</h4><p>为了使时间复杂度指数倍地下降，我们以数组[1，3，4，9]和[1，2，3，4，5，6，7，8，9，10]为例。计算得知：（1+14）/2=7.5，所以二者合并后的中位数为：第7小数和第8小数的平均值。</p><p>首先，我们学习一种二分法求解两个有序数组合并后第k小的数的方法，我们以第7小数为例：</p><p>1.先计算7整除2的商为3，然后比较第一个数组和第二个数组的第3个数（如果某个数组的元素不足3个，则比较它的最后一个数）。将较小的那个数及之前所有的数从所在的数组中去除。（此时它们必在合并后前6小的数中，具体证明可以自己推导一遍）。</p><p>2.此时，求解第7小的数变为：在更新后的两个数组中求解第4小的数（因为已经确定了3个）。</p><p>3.计算4整除2的商为2，然后比较两个数组的第2个数，与第1步中类似，将较小的数及之前的所有数从所在数组中删除。</p><p>4.此时，求解第4小的数变为：在更新后的两个数组中求解第2小的数（因为又确定了2个）。</p><p>5.重复以上过程，直到问题变为求解第1小的数，这时比较两个数组中的第1个数，返回较小值即可。</p><p>通过以上算法，我们可以用二分删除法计算出合并后第7小数和第8小数，然后便可计算中位数。</p><ul><li>时间复杂度:每进行一次循环，我们就减少 k/2 个元素，所以时间复杂度是 $O(log(k))$，而 k=（m+n）/2，所以最终的复杂也就是 O（log（m+n））。</li></ul><pre><code>class Solution:    def findk(self,nums1,nums2,k):#求解合并后第k小数        m=k//2        if (len(nums1)&gt;len(nums2)):#保证第一个数组较小            return self.findk(nums2,nums1,k)        if (len(nums1)==0):#如果第一个数组为空，直接返回第二个数组的第k个数即可            return nums2[k-1]        i=min(len(nums1),m)#防止第一个数组长度不足m        if (k==1):#如果求解第1小数，则直接比较二者第1个数即可            return min(nums1[0],nums2[0])        if (nums1[i-1]&gt;nums2[m-1]):#删除第二个数组的前m个数，再递归查找            return self.findk(nums1,nums2[m:],k-m)        else:#删除第一个数组的前i个数，再递归查找            return self.findk(nums1[i:],nums2,k-i)    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:        if (len(nums1)+len(nums2)+1)%2!=0:#数组总长为偶数            return (self.findk(nums1,nums2,int((len(nums1)+len(nums2)+1)/2))+self.findk(nums1,nums2,int((len(nums1)+len(nums2)+1)/2)+1))/2        else:#数组总长为奇数            return self.findk(nums1,nums2,int((len(nums1)+len(nums2)+1)/2))</code></pre><ul><li>空间复杂度:O（1）。<strong>因为这里使用了尾递归！</strong></li></ul><h4 id="什么是尾递归"><a href="#什么是尾递归" class="headerlink" title="什么是尾递归"></a>什么是尾递归</h4><p>以递归方式实现阶乘函数的实现：</p><pre><code>int recsum(int n) {    if (n &lt; 0)        return 0;    else if(n == 0 || n == 1)        return 1;    else        return n * fact(n - 1);}</code></pre><p>以尾递归方式实现阶乘函数的实现：</p><pre><code>int tailrecsum(int n, int res=0){    if (n &lt; 0)        return 0;    else if(n == 0)        return res;    else        return facttail(n - 1, n + res);}</code></pre><p>非尾递归，下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。</p><p>尾递归，进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。</p><p><strong>尾递归的判断标准是函数运行最后一步是否调用自身，而不是是否在函数的最后一行调用自身。</strong></p><p>上述例子中：</p><ul><li><p>递归方式的倒数第二步是调用自身求解recsum（n-1），而最后一步是将recsum（n-1）的结果与n相乘并返回，所以rescum(n)的运算依赖于rescum（n-1）的运算。需要将本层函数压栈保存，当计算完最后一层后，再进行层层返回，得出结果。</p></li><li><p>尾递归方式的最后一步就是调用自身求解n-1时的结果，并将当前层的结果作为参数传入下一层，不需要再返回当前层进行运算。下层计算结果对上层“无用”（上一层运算已经做完，不依赖后续的递归），为了效率，可以直接将下一层需要的空间覆盖在上一层上。</p></li></ul><p>总结：</p><ul><li><p>尾递归，比线性递归多一个参数，这个参数是上一次调用函数得到的结果；所以，关键点在于，尾递归每次调用都在收集结果，避免了线性递归不收集结果只能依次展开消耗内存的坏处。</p></li><li><p>使用尾递归可以带来一个好处：因为进入最后一步后不再需要参考外层函数（caller）的信息，因此没必要保存外层函数的stack，递归需要用的stack只有目前这层函数的，因此避免了栈溢出风险。 </p></li></ul><p><strong>本题中，所有递归调用都是当前层递归的最后一步，所以不需要额外的栈空间保存当前层，时间复杂度为O（1）。</strong></p><h2 id="2020-3-3-（2-medium）"><a href="#2020-3-3-（2-medium）" class="headerlink" title="2020.3.3 （2 medium）"></a>2020.3.3 （2 medium）</h2><h3 id="第5题-最长回文子串"><a href="#第5题-最长回文子串" class="headerlink" title="第5题 最长回文子串"></a>第5题 最长回文子串</h3><p><img src="5.png" alt="第5题 最长回文子串"></p><h4 id="思路1："><a href="#思路1：" class="headerlink" title="思路1："></a>思路1：</h4><p>区间动态规划+状态空间压缩，利用区间首尾字符是否相等，且去除首尾字符后的子串是否为回文串，来判断当前区间是否为回文子串。</p><ul><li><p>时间复杂度：$O(N^2)$</p></li><li><p>空间复杂度：$O(N^2)$（可以压缩一半）</p></li></ul><h4 id="思路2："><a href="#思路2：" class="headerlink" title="思路2："></a>思路2：</h4><p>中心扩展法，不需要额外的状态矩阵。对于一个长度为n的字符串，有2n-1个中心（奇偶回文串分类讨论）可以选取，由中心向两侧扩散寻找该中心所能构成的最长回文子串，若大于当前最大值，则将最大值替换为当前长度。</p><ul><li><p>时间复杂度：$O(N^2)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><pre><code>class Solution:    def longestPalindrome(self, s: str) -&gt; str:        max_length=&#39;&#39;        for i in range(len(s)):            if (i!=len(s)-1):                if len(self.expandcenter(s,i,i))&gt;len(max_length):                    max_length=self.expandcenter(s,i,i)                if len(self.expandcenter(s,i,i+1))&gt;len(max_length):                    max_length=self.expandcenter(s,i,i+1)            else:                if len(self.expandcenter(s,i,i))&gt;len(max_length):                    max_length=self.expandcenter(s,i,i)        return max_length    def expandcenter(self,s,l,r):#中心扩展法向两侧搜索判断        if (l==r):#奇回文串            length=1            while True:                l-=1                r+=1                if (l&gt;=0)and(r&lt;=len(s)-1)and(s[l]==s[r]):                    length+=2                else:                    return s[l+1:r]        else:#偶回文串            length=0            while True:                if (l&gt;=0)and(r&lt;=len(s)-1)and(s[l]==s[r]):                    length+=2                else:                    return s[l+1:r]                l-=1                r+=1</code></pre><h4 id="进阶算法："><a href="#进阶算法：" class="headerlink" title="进阶算法："></a>进阶算法：</h4><p>Manacher算法，时间复杂度只有$O(N)$，但比较复杂。可以参考<a href="https://www.jianshu.com/p/392172762e55" target="_blank" rel="noopener">https://www.jianshu.com/p/392172762e55</a></p><h3 id="第6题-Z-字形变换"><a href="#第6题-Z-字形变换" class="headerlink" title="第6题 Z 字形变换"></a>第6题 Z 字形变换</h3><p><img src="6.png" alt="第6题 Z 字形变换"></p><h4 id="思路1：-1"><a href="#思路1：-1" class="headerlink" title="思路1："></a>思路1：</h4><p>通过观察变换前后的字符串，利用规律求解，直接使用下标运算。</p><pre><code>class Solution:    def convert(self, s: str, numRows: int) -&gt; str:        a=2*numRows-2        result=&#39;&#39;        if (a==0):            return s        for i in range(numRows):            t=i            while(t&lt;len(s)):                result+=s[t]                delta=2*(numRows-i-1)                if (i!=0) and (t+delta&lt;len(s)) and(delta&gt;0):                    result+=s[t+delta]                t+=a        return result</code></pre><ul><li><p>时间复杂度：$O(N)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><h4 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h4><p>按顺序遍历字符串，并设置与行数相等的数组。遍历时，按照Z字形变化的格式放入对应的数组（行数先加1，遍历到底部再减1，遍历到顶部再加1，直到遍历完）</p><pre><code>class Solution:    def convert(self, s: str, numRows: int) -&gt; str:        if numRows &lt; 2: return s        res = [&quot;&quot; for _ in range(numRows)]        i, flag = 0, -1        for c in s:            res[i] += c            if i == 0 or i == numRows - 1: flag = -flag            i += flag        return &quot;&quot;.join(res)</code></pre><h2 id="2020-3-4-（1-hard-1-medium）"><a href="#2020-3-4-（1-hard-1-medium）" class="headerlink" title="2020.3.4 （1 hard 1 medium）"></a>2020.3.4 （1 hard 1 medium）</h2><h3 id="第10题-正则表达式匹配"><a href="#第10题-正则表达式匹配" class="headerlink" title="第10题 正则表达式匹配"></a>第10题 正则表达式匹配</h3><p><img src="10.png" alt="第10题 正则表达式匹配"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>本题可以用递归求解，但时空复杂度很高。</p><p>考虑到本题符合动态规划的两个基本要求：（1）重叠子问题，（2）最优子结构。所以本题可以使用动态规划来求解。</p><p>解决可递归问题的三种方法：</p><ul><li>递归：自顶向下，代码简单，但是复杂度高，可能会进行重复的计算，同时会使用大量的栈空间。</li><li>备忘录：自顶向下，将递归中的子问题求解结果保存起来，防止重复计算，降低了时间复杂度，但栈空间的消耗依然存在。</li><li>动态规划：自底向上，使用状态矩阵，由子问题通过状态转移方程递推出最后的结果。</li></ul><p>本题中，可以使用状态矩阵$dp(i,j)$表示text[i:]和pattern[j:]是否能匹配。我们可以用更短的字符串匹配问题来表示原本的问题。</p><ul><li><p>当首字母匹配且第二个字母为”*”时，可以尝试转移到匹配0次（目标串不变，模式串变）或1次（目标串变，模式串不变，因为此时可以多次匹配）的状态矩阵。</p></li><li><p>当首字母不匹配且第二个字母为”*”时，转移到匹配0次（目标串不变，模式串变）的状态矩阵。</p></li><li><p>首字母匹配且第二个字母不为”*”时，转移到首字母匹配1次（目标串和模式串都变）的状态矩阵。</p></li><li><p>否则，当前状态为False，即无法匹配。</p></li><li><p>$dp(-1,-1)$说明此时模式串和目标串完成了全匹配，可以成功，默认为True。</p></li></ul><pre><code>class Solution(object):    def isMatch(self, text, pattern):        dp=[[False for x in range(len(pattern)+1)] for x in range(len(text)+1)]        dp[-1][-1]=True #两个字符串都为空必然匹配        for i in range(len(text),-1,-1): #为什么i从len(text))开始，而j从len(pattern)-1开始：字符串为空，正则表达式不为空，可能匹配成功（存在*），而正则表达式为空，字符串不为空，必然不可能匹配成功            for j in range(len(pattern)-1,-1,-1):                f_match=(i&lt;len(text))and(pattern[j] in [text[i],&#39;.&#39;]) #第一个对i的限制条件是为了防止后面访问text[i]时数组越界                if (j+1&lt;len(pattern))and(pattern[j+1]==&#39;*&#39;):                    if f_match:                        dp[i][j]=dp[i][j+2] or dp[i+1][j]                    else:                        dp[i][j]=dp[i][j+2]                else:                    if f_match:                        dp[i][j]=dp[i+1][j+1]        return dp[0][0]</code></pre><h3 id="第11题-盛最多水的容器"><a href="#第11题-盛最多水的容器" class="headerlink" title="第11题 盛最多水的容器"></a>第11题 盛最多水的容器</h3><p><img src="11.png" alt="第11题 盛最多水的容器"></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h4><p>双指针法（这种从两端向内收缩的双指针我叫做双侧指针，如第3题中滑动窗口的同一侧出发的指针我叫做快慢指针）。</p><p>由于容器的容积只与短板有关，我们可以使用两个指针从数组的两侧每一次向内收缩短板，计算当前的容积，直到两个指针相交。</p><p>为什么只收缩短板：如果收缩长板，那么移动后的板长要么小于移动前的短板长度，要么大于短板长度，前者会使容积变小，后者会使容积不变，所以我们只有移动短板才可能使容积变大。</p><ul><li><p>时间复杂度：$O(N)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><pre><code>class Solution:    def maxArea(self, height: List[int]) -&gt; int:        max_v=0        left=0        right=len(height)-1        while (left&lt;right):            v=min(height[left],height[right])*(right-left)            if v&gt;max_v:                max_v=v            if (height[left]&lt;height[right]):                left+=1            else:                right-=1        return max_v</code></pre><h2 id="2020-3-5-（4-medium）"><a href="#2020-3-5-（4-medium）" class="headerlink" title="2020.3.5 （4 medium）"></a>2020.3.5 （4 medium）</h2><h3 id="第12题-整数转罗马数字"><a href="#第12题-整数转罗马数字" class="headerlink" title="第12题 整数转罗马数字"></a>第12题 整数转罗马数字</h3><p><img src="12.png" alt="第12题 整数转罗马数字"></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路:"></a>思路:</h4><p>贪心算法，每次取当前能够匹配的最大罗马数字进行选择。类似于用最少的纸币凑出整数。</p><pre><code>class Solution:    def intToRoman(self, num: int) -&gt; str:        # 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中        # 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想        nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]        romans = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]        index = 0        res = &#39;&#39;        while index &lt; 13:            # 注意：这里是等于号，表示尽量使用大的&quot;面值&quot;            while num &gt;= nums[index]:                res += romans[index]                num -= nums[index]            index += 1        return res</code></pre><h3 id="第15题-三数之和"><a href="#第15题-三数之和" class="headerlink" title="第15题 三数之和"></a>第15题 三数之和</h3><p><img src="15.png" alt="第15题 三数之和"></p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路:"></a>思路:</h4><p>在一个有序数组中求解两个数之和，可以使用暴力遍历的方法，但时间复杂度很高。在这里，我们可以使用双侧指针法，先在数组两端各固定一个指针。当两数之和小于target时，左指针加1（由于是有序数组，会使和变大），当两数之和大于target时，右指针减1，等于target时，保存结果，并左右指针同时向内收缩。</p><p>那么，知道了两数之和问题的解决方案后，我们可以求解三数之和（本质上，任意n数之和都可以采取相同的方法）。我们先对数组进行排序，然后固定一个数，便可将问题转化为两数之和，接着对于该数之后的所有数进行两数之和的求解。求解完成后，我们可以接着固定下一个数，直到求出所有结果。</p><p>要注意的问题：</p><ul><li><p>结果的去重（求解两数之和时，相同的数字不应重复使用。同时，固定的数若等于上个数，则他的所有情况都被上个数的遍历所包含，也可以跳过）。</p></li><li><p>性能的提升（剪枝，当右指针的数小于0时或者固定的数大于0时，三数之和必定不等于0，因为此时三个数都大于0或者都小于0）</p></li><li><p>时间复杂度：$O(N^2)+O(NlogN)=O(N^2)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><pre><code>class Solution {    public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList();        Arrays.sort(nums); # 排序        int len = nums.length;        if(nums == null || len &lt; 3) return ans;        for (int i = 0; i &lt; len ; i++) {            if(nums[i] &gt; 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; // 去重            int L = i+1;            int R = len-1;            while(L &lt; R){                if (nums[R]&lt;0){                    break;                }                int sum = nums[i] + nums[L] + nums[R];                if(sum == 0){                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));                    while (L&lt;R &amp;&amp; nums[L] == nums[L+1]) L++; // 去重                    while (L&lt;R &amp;&amp; nums[R] == nums[R-1]) R--; // 去重                    L++;                    R--;                }                else if (sum &lt; 0){                    while (L&lt;R &amp;&amp; nums[L] == nums[L+1]){                        L++; // 去重;                    }                    L++;                }                else if (sum &gt; 0) {                    while (L&lt;R &amp;&amp; nums[R] == nums[R-1]){                        R--; // 去重                    } // 去重                    R--;                }            }        }                return ans;    }}</code></pre><h3 id="第16题-最接近的三数之和"><a href="#第16题-最接近的三数之和" class="headerlink" title="第16题 最接近的三数之和"></a>第16题 最接近的三数之和</h3><p><img src="16.png" alt="第16题 最接近的三数之和"></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路:"></a>思路:</h4><p>与第15题几乎没有区别，只是双指针收缩时，每次记录当前的三数之和，看与结果的差值是否为当前最小，最小则修改当前的最接近的三数之和。当差值为0时可以直接返回。</p><pre><code>class Solution:    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:        nums.sort()        closest=nums[0]+nums[1]+nums[2]        diff=abs(closest-target)        for i in range(len(nums)-2):            if i&gt;0 and nums[i]==nums[i-1]:                continue            L=i+1            R=len(nums)-1            while (L&lt;R):                summa=nums[i]+nums[L]+nums[R]                if abs(summa-target)&lt;diff:                    closest=summa                    diff=abs(closest-target)                if (summa&gt;target):                    R-=1                elif (summa&lt;target):                    L+=1                else:                    return summa        return closest</code></pre><h3 id="第18题-四数之和"><a href="#第18题-四数之和" class="headerlink" title="第18题 四数之和"></a>第18题 四数之和</h3><p><img src="18.png" alt="第18题 四数之和"></p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路:"></a>思路:</h4><p>任意n数之和都求解，都可以先固定一个数，转化为n-1数之和问题，逐步转化，直到最后变为求解二数之和。这里的四数之和也是类似的道理，其去重的思想与三数之和也是一样的。</p><pre><code>class Solution {    public static List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums,int target) {        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList();        Arrays.sort(nums); // 排序        int len = nums.length;        if(nums == null || len &lt; 4) return ans;        for (int i = 0; i &lt; len-3 ; i++) {//多固定了一个数，将问题转化为内部的三数之和            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; // 去重            for (int j =i+1;j&lt;len-2;j++){                if(j &gt; i+1 &amp;&amp; nums[j] == nums[j-1]) continue; // 去重                int L = j+1;                int R = len-1;                while(L &lt; R){                    int sum = nums[i] + nums[j]+nums[L] + nums[R];                    if(sum == target){                        ans.add(Arrays.asList(nums[i],nums[j],nums[L],nums[R]));                        while (L&lt;R &amp;&amp; nums[L] == nums[L+1]) L++; // 去重                        while (L&lt;R &amp;&amp; nums[R] == nums[R-1]) R--; // 去重                        L++;                        R--;                    }                    else if (sum &lt; target) L++;                    else if (sum &gt; target) R--;                }            }        }                return ans;    }}</code></pre><h2 id="2020-3-6-（2-medium）"><a href="#2020-3-6-（2-medium）" class="headerlink" title="2020.3.6 （2 medium）"></a>2020.3.6 （2 medium）</h2><h3 id="第17题-电话号码的字母组合"><a href="#第17题-电话号码的字母组合" class="headerlink" title="第17题 电话号码的字母组合"></a>第17题 电话号码的字母组合</h3><p><img src="17.png" alt="第17题 电话号码的字母组合"></p><h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1:"></a>思路1:</h4><p>打表+队列，类似于BFS。</p><pre><code>class Solution:    def letterCombinations(self, digits: str) -&gt; List[str]:        dic={&#39;2&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],&#39;3&#39;:[&#39;d&#39;,&#39;e&#39;,&#39;f&#39;],&#39;4&#39;:[&#39;g&#39;,&#39;h&#39;,&#39;i&#39;],&#39;5&#39;:[&#39;j&#39;,&#39;k&#39;,&#39;l&#39;],&#39;6&#39;:[&#39;m&#39;,&#39;n&#39;,&#39;o&#39;],&#39;7&#39;:[&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;],&#39;8&#39;:[&#39;t&#39;,&#39;u&#39;,&#39;v&#39;],&#39;9&#39;:[&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]}        result=[]        for char in digits:            if result==[]:                result=dic[char]            else:                l=len(result)                for i in range(l):                    st=result[0]                    result=result[1:]#出队                    for c in dic[char]:                        result.append(st+c)#入队        return result</code></pre><p>时间复杂度:$O(3^M+4^N)$</p><h4 id="思路2-1"><a href="#思路2-1" class="headerlink" title="思路2:"></a>思路2:</h4><p>这里也可以使用回溯+递归的方法，将其看作是一个类似于全排列的问题。</p><pre><code>class Solution:    def letterCombinations(self, digits):        &quot;&quot;&quot;        :type digits: str        :rtype: List[str]        &quot;&quot;&quot;        phone = {&#39;2&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],                 &#39;3&#39;: [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;],                 &#39;4&#39;: [&#39;g&#39;, &#39;h&#39;, &#39;i&#39;],                 &#39;5&#39;: [&#39;j&#39;, &#39;k&#39;, &#39;l&#39;],                 &#39;6&#39;: [&#39;m&#39;, &#39;n&#39;, &#39;o&#39;],                 &#39;7&#39;: [&#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;],                 &#39;8&#39;: [&#39;t&#39;, &#39;u&#39;, &#39;v&#39;],                 &#39;9&#39;: [&#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;]}        def backtrack(combination, next_digits):            # if there is no more digits to check            if len(next_digits) == 0:                # the combination is done                output.append(combination)            # if there are still digits to check            else:                # iterate over all letters which map                 # the next available digit                for letter in phone[next_digits[0]]:                    # append the current letter to the combination                    # and proceed to the next digits                    backtrack(combination + letter, next_digits[1:])//这里可以看作是进行了回溯，因为直接使用了新的字符串，所以不用恢复状态         output = []        if digits:            backtrack(&quot;&quot;, digits)        return output</code></pre><h3 id="第19题-删除链表的倒数第N个节点"><a href="#第19题-删除链表的倒数第N个节点" class="headerlink" title="第19题 删除链表的倒数第N个节点"></a>第19题 删除链表的倒数第N个节点</h3><p><img src="19.png" alt="第19题 删除链表的倒数第N个节点"></p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>快慢指针法+dummy head。</p><p>快指针在前遍历链表，慢指针在后用于保存快指针的前第N个节点。当快指针遍历到链表的尾部，则可以使用慢指针删除节点。这里需要注意，当要删除的节点是第一个节点时，若使用题目中给出的头指针，需要分类讨论进行操作。为了不进行分类讨论，我们在链表开头处添加一个空的头结点（dummy head）。</p><ul><li><p>时间复杂度:$O(N)$</p></li><li><p>空间复杂度:$O(1)$</p></li></ul><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:        fore_head=ListNode(0)        fore_head.next=head        p=fore_head        back_n=fore_head        while (p.next!=None):            p=p.next            if (n&gt;0):                n-=1            elif (n==0)://n减到0时，才能移动慢指针，否则说明前第n个元素越界                back_n=back_n.next        back_n.next=back_n.next.next        return fore_head.next</code></pre><h2 id="2020-3-7-（1-medium-1-hard）"><a href="#2020-3-7-（1-medium-1-hard）" class="headerlink" title="2020.3.7 （1 medium 1 hard）"></a>2020.3.7 （1 medium 1 hard）</h2><h3 id="第22题-括号生成"><a href="#第22题-括号生成" class="headerlink" title="第22题 括号生成"></a>第22题 括号生成</h3><p><img src="22.png" alt="第22题 括号生成"></p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路:"></a>思路:</h4><p>二叉树的先根遍历+剪枝。使用count记录当前字符串内左括号个数减去右括号个数的值，当count&lt;0或者count&gt;n，n为剩余的目标括号对数时，进行剪枝。</p><pre><code>class Solution:    def generateParenthesis(self, n: int) -&gt; List[str]:        count=0        st=&#39;&#39;        result=[]        def dp(count,n,st):            if (0&lt;=count&lt;=n):#剪枝                if (n==0):#满足要求                    result.append(st)                else:#先根遍历                    dp(count-1,n-1,st+&#39;)&#39;)                    dp(count+1,n,st+&#39;(&#39;)        dp(count,n,st)        return result</code></pre><h3 id="第23题-合并K个排序链表"><a href="#第23题-合并K个排序链表" class="headerlink" title="第23题 合并K个排序链表"></a>第23题 合并K个排序链表</h3><p><img src="23.png" alt="第23题 合并K个排序链表"></p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路:"></a>思路:</h4><p>分治法，类似于标准归并排序的思想。先将相邻的链表两两合并，得到个数为原来一半的新链表，接着继续两两合并，重复直到只剩下最后一个链表，即为最终的结果。</p><p>两两合并的方法，采用的是双指针法，即两个链表各设置一个指针，用于比较和插入结果链表。</p><ul><li>时间复杂度：$O(NlogK)$，N是所有链表中元素的总和，K是链表个数。</li></ul><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        def merge(list1,list2):#两两合并            p=list1            q=list2            head=ListNode(0)            m=head            while (p!=None) and (q!=None):                if p.val&lt;q.val:                    m.next=p                    m=m.next                    p=p.next                else:                    m.next=q                    m=m.next                    q=q.next            if (p==None):                m.next=q            elif (q==None):                m.next=p            return head.next        amount = len(lists)        interval = 1        while interval &lt; amount:#两两合并            for i in range(0, amount - interval, interval * 2):                lists[i] = merge(lists[i], lists[i + interval])            interval *= 2        return lists[0] if amount &gt; 0 else lists</code></pre><p>为什么不使用逐一合并的算法呢？那样合并的过程写起来会很简单？</p><ul><li><p>逐一合并的时间复杂度：$O(NK)$</p></li><li><p>因为这里的两两排序实际上运用了分治法的思想，逐一合并的话，每一次合并在最坏的情况下都需要比较N个节点，而两两合并，每一轮合并的最坏情况才需要比较N个节点。逐一合并需要进行（K-1）次，而两两合并仅需要进行（logN）轮，所以时间复杂度大大降低。</p></li></ul><p><img src="23-2.png" alt="分治法"></p><h2 id="2020-3-8-（1-hard-1-medium）"><a href="#2020-3-8-（1-hard-1-medium）" class="headerlink" title="2020.3.8 （1 hard 1 medium）"></a>2020.3.8 （1 hard 1 medium）</h2><h3 id="第24题-两两交换链表中的节点"><a href="#第24题-两两交换链表中的节点" class="headerlink" title="第24题 两两交换链表中的节点"></a>第24题 两两交换链表中的节点</h3><p><img src="24.png" alt="第24题 两两交换链表中的节点"></p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路:"></a>思路:</h4><p>本质上就是两个一组翻转链表。可以使用头插法+dummy head。使用三个指针pre、p、q，将q结点插入至p结点之前，即完成了一次交换。然后移动指针至下两个节点处，继续交换。</p><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def swapPairs(self, head: ListNode) -&gt; ListNode:        h=ListNode(0)#dummy head         h.next=head        pre=h        p=head        if (head==None):            return head        else:            q=p.next            while (p!=None)and(q!=None):                p.next=q.next                q.next=p                pre.next=q                #两个一组翻转链表                pre=p                p=p.next                if p!=None:                    q=p.next                #移动至下两个节点进行操作           return h.next</code></pre><h3 id="第25题-K-个一组翻转链表"><a href="#第25题-K-个一组翻转链表" class="headerlink" title="第25题  K 个一组翻转链表"></a>第25题  K 个一组翻转链表</h3><p><img src="25.png" alt="第25题  K 个一组翻转链表"></p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路:"></a>思路:</h4><p>上一题的扩展，使用dummy head+头插法即可。</p><ul><li>pre指针：当前组的第一个节点的前一个节点，用于插入元素。</li><li>q指针： 要插到头部的那个节点。</li><li>p指针： q节点的前一个节点，用于删除q节点。</li></ul><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode:        h=ListNode(0)        h.next=head        pre=h        p=head        count=0        t=pre.next        while(t!=None):#统计当前链表的长度            count+=1            t=t.next        if (head==None):            return head        else:            q=p.next            while (pre!=None) and (p!=None) and (q!=None):                if (count&lt;k):#当前链表的剩余长度是否可以进行翻转                    return h.next                for i in range(k-1):                    p.next=q.next                    q.next=pre.next                    pre.next=q                     q=p.next                      #当前组内的节点进行头插法翻转                pre=p                p=pre.next                if p==None:                    return h.next                q=p.next                count-=k                #指针移动至下一组开始处        return h.next</code></pre><h2 id="2020-3-9-（3-easy）"><a href="#2020-3-9-（3-easy）" class="headerlink" title="2020.3.9 （3 easy）"></a>2020.3.9 （3 easy）</h2><h3 id="第26题-删除排序数组中的重复项"><a href="#第26题-删除排序数组中的重复项" class="headerlink" title="第26题 删除排序数组中的重复项"></a>第26题 删除排序数组中的重复项</h3><p><img src="26.png" alt="第26题 删除排序数组中的重复项"></p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路:"></a>思路:</h4><p>快慢指针法，慢指针指向当前数组内无重复的子序列的最后一项，快指针用于遍历整个数组。</p><ul><li>当快指针指向的元素与慢指针指向的元素不相等时，将该元素加入至慢指针维护的无重复子序列中，慢指针和快指针都加1。</li><li>当元素相等时，快指针直接遍历下一个元素。</li><li>时间复杂度：$O(N)$</li></ul><pre><code>class Solution:    def removeDuplicates(self, nums: List[int]) -&gt; int:        slow=0        for fast in range(1,len(nums)):            if (nums[slow]!=nums[fast]):                slow+=1                nums[slow]=nums[fast]        return slow+1#由于慢指针指向的是子序列最后一项的下标，子序列长度需要加1</code></pre><h3 id="第27题-移除元素"><a href="#第27题-移除元素" class="headerlink" title="第27题 移除元素"></a>第27题 移除元素</h3><p><img src="27.png" alt="第27题 移除元素"></p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路:"></a>思路:</h4><p>同样使用快慢指针法，快指针用于遍历，慢指针维护一个没有target元素的子序列，指向该子序列末尾的后一个元素。</p><pre><code>class Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        slow=0        for fast in range(len(nums)):            if (nums[fast]!=val):                nums[slow]=nums[fast]                slow+=1        return slow</code></pre><p>这里，慢指针与26题有一些区别，27题的慢指针指向的是符合要求的子序列的后一项，而26题是最后一项。这是因为26题中，单个元素不可能重复，而27题中，单个元素也可能是需要被移除的。</p><h3 id="第28题-实现-strStr"><a href="#第28题-实现-strStr" class="headerlink" title="第28题 实现 strStr()"></a>第28题 实现 strStr()</h3><p><img src="27.png" alt="第28题 实现 strStr()"></p><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路:"></a>思路:</h4><p>KMP算法，具体可以看这里：<a href="/2020/03/17/kmp-suan-fa">KMP算法总结</a></p><h2 id="2020-3-10-（1-hard-1-medium）"><a href="#2020-3-10-（1-hard-1-medium）" class="headerlink" title="2020.3.10 （1 hard 1 medium）"></a>2020.3.10 （1 hard 1 medium）</h2><h3 id="第29题-两数相除"><a href="#第29题-两数相除" class="headerlink" title="第29题 两数相除"></a>第29题 两数相除</h3><p><img src="29.png" alt="第29题 两数相除"></p><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路:"></a>思路:</h4><p>我们最初很容易可以想到使用累减法来解决除法问题，但这会很慢，所以我们需要使用递归方法加速累减。</p><p>递归的具体过程是，在递归函数内部，我们在保证当前除数不大于被除数的情况下，使除数不断翻倍，并记录倍数。当除数即将大于当前被除数时，我们停止翻倍，并记录下当前的倍数，加到商上。此时，我们将除数减去当前的被除数，剩余的结果重复之前的过程，直到剩余的数小于原始的除数。</p><p>本质上，这题的思想类似于快速幂算法，都是使用翻倍来加速，利用二分思想优化至logN级别的时间复杂度。因为一个一个减肯定不如翻倍翻倍减快速。</p><p>特别的，这道题还需要考虑补码的机制问题，当被除数等于$-2^31$时，商最大只能等于$2^31-1$。</p><pre><code>class Solution:    def divide(self, dividend: int, divisor: int) -&gt; int:        if dividend==0:#防止除数为0            return 0        if divisor==1:#除数为1，直接返回结果，加速运算            return dividend        if divisor==-1:#除数为-1，直接返回结果的负数，加速运算            if dividend==-2**31:#考虑integer的溢出                return 2**31-1            else:                return -dividend        flag=-1        if ((dividend&gt;0) and (divisor&gt;0)) or ((dividend&lt;0) and (divisor&lt;0)):#考虑符号            flag=1        dividend=abs(dividend)        divisor=abs(divisor)        def div(result,a):#递归求解            if (a&lt;divisor):                return result            count=1            result+=count            b=divisor            a-=b            while (b+b)&lt;=a:#翻倍累减                count+=count                result+=count                b+=b                a-=b            return div(result,a)#尾递归，减少栈空间调用        return flag*(div(0,dividend))</code></pre><h3 id="第30题-串联所有单词的子串"><a href="#第30题-串联所有单词的子串" class="headerlink" title="第30题 串联所有单词的子串"></a>第30题 串联所有单词的子串</h3><p><img src="30.png" alt="第30题 串联所有单词的子串"></p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路:"></a>思路:</h4><p>滑动窗口法+哈希表。</p><p>由于题目中提到了所有单词等长，那么我们对于n个长度为k的单词可以维护一个长度为k*n的滑动窗口。接着，我们利用哈希表建立words列表中的单词和单词数目的映射。然后，我们可以使用滑动窗口进行滑动匹配，每次移动一个单词的长度。对于窗口内部，我们统计每k长度的字符串，若出现了不在哈希表的键中的字符串，或者字符串出现的次数大于哈希表中对应的值时，说明此窗口失配，进行下一次匹配，否则，记录下窗口起始位置。</p><pre><code>class Solution:    def findSubstring(self, s: str, words: List[str]) -&gt; List[int]:        dic={}        result=[]        if s==&quot;&quot; or words==[]:#目标串或者待匹配列表为空            return []        for w in words:#建哈希表（字典）            if w in dic.keys():                dic[w]+=1            else:                dic[w]=1        l=len(words[0])        window=l*len(words)        for i in range(len(s)-window+1):#滑动匹配            end=i+window            tmp=dic.copy()            flag=1            for j in range(i,end,l):                w=s[j:j+l]                if w not in tmp.keys():                    flag=0                    break                tmp[w]-=1                if tmp[w]&lt;0:                    flag=0                    break            if flag:                result.append(i)        return result</code></pre><h2 id="2020-3-11-（2-medium-1-hard）"><a href="#2020-3-11-（2-medium-1-hard）" class="headerlink" title="2020.3.11 （2 medium 1 hard）"></a>2020.3.11 （2 medium 1 hard）</h2><h3 id="第31题-下一个排列"><a href="#第31题-下一个排列" class="headerlink" title="第31题 下一个排列"></a>第31题 下一个排列</h3><p><img src="31.png" alt="第31题 下一个排列"></p><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路:"></a>思路:</h4><p>核心思想：</p><ul><li>我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。</li><li>我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：</li></ul><ol><li>在尽可能靠右的低位进行交换，需要从后向前查找</li><li>将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换</li><li>将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列</li></ol><pre><code>class Solution:    def nextPermutation(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        def swap(a,b):#交换数组中的两个元素            temp=nums[a]            nums[a]=nums[b]            nums[b]=temp        p=len(nums)-1        while (p&gt;0):            if (nums[p]&gt;nums[p-1]):从后向前遍历，找到从后向前看的第一个下降的位置                min_pos=p                for i in range(len(nums)-1,p,-1):#搜索最小的大数并交换                    if (nums[i]&gt;nums[p-1]):                        min_pos=i                        break                swap(min_pos,p-1)                for i in range(int((len(nums)-p)/2)):#原地翻转，将大数后所有数重置为升序                    swap(p+i,len(nums)-i-1)                break            else:                p-=1        if (p&lt;=0):#如果为降序数组，则重置为升序数组            nums.sort()        return nums</code></pre><p><strong>这类题一定要把情况自己模拟一遍，寻找下一个转移的规律。</strong></p><h3 id="第32题-最长有效括号"><a href="#第32题-最长有效括号" class="headerlink" title="第32题 最长有效括号"></a>第32题 最长有效括号</h3><p><img src="32.png" alt="第32题 最长有效括号"></p><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路:"></a>思路:</h4><p>双向滑动窗口。</p><p>使用双指针维护一个滑动窗口。先从左向右滑动窗口，左右指针初始为0，使用一个变量count来存储当前窗口内左括号数量减去右括号数量的值。右指针不断向前遍历，当遍历到当前窗口内count&lt;0时，将左右指针都移动到当前右指针的下一个位置，重置窗口，当count==0时，使用当前窗口长度比较并尝试更新最大长度，当count&gt;0时，右指针继续向前遍历。</p><p>上述滑动完成后，再反向从右往左滑动一次窗口。此时的结果即为最大长度。</p><pre><code>class Solution:    def longestValidParentheses(self, s: str) -&gt; int:        p=0        q=0        count=0        max_len=0        if (len(s)&lt;2):            return 0        while (q&lt;len(s)):            if (s[q]==&quot;(&quot;):                count+=1            elif (s[q]==&quot;)&quot;):                count-=1            if (count&lt;0):                q+=1                p=q                count=0            else:                if (count==0):                    if (q-p+1)&gt;max_len:                        max_len=q-p+1                q+=1        #从左向右滑动        p=len(s)-1        q=len(s)-1        count=0        while (p &gt;=0):            if (s[p] == &quot;(&quot;):                count += 1            elif (s[p] == &quot;)&quot;):                count -= 1            if (count &gt; 0):                p-= 1                q = p                count = 0            else:                if (count == 0):                    if (q - p + 1) &gt; max_len:                        max_len = q - p + 1                p-= 1        #从右向左滑动        return max_len</code></pre><h3 id="第33题-搜索旋转排序数组"><a href="#第33题-搜索旋转排序数组" class="headerlink" title="第33题 搜索旋转排序数组"></a>第33题 搜索旋转排序数组</h3><p><img src="33.png" alt="第33题 搜索旋转排序数组"></p><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路:"></a>思路:</h4><p>由于题目要求时间复杂度在logN级别，所以必须是用二分法进行查找。但我们知道二分查找只适用于有序数组，所以我们需要使用嵌套二分。</p><p>首先，我们将数组从中间一分为二，根据旋转排序数组的性质，必然至少有一半有序。我们先判断左半数组是否有序，若有序，判断目标是否在它的范围内，若在，则在左半数组中二分查找，而不在，则去右半数组中二分查找。否则，即为右半数组有序，若目标在范围内，则在右半数组中二分，否则去左半数组中二分。</p><pre><code>class Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left=0        right=len(nums)-1        while (left&lt;=right):            mid=(left+right)//2            if nums[mid]==target:#中间数为目标                return mid            if (nums[left]&lt;=nums[mid]):#左半数组有序                if (nums[left]&lt;=target&lt;=nums[mid]):#目标在左半数组中                    right=mid-1                else:                    left=mid+1            else:#右半数组有序                if (nums[mid]&lt;=target&lt;=nums[right]):#目标在右半数组中                    left=mid+1                else:                    right=mid-1        return -1</code></pre><h2 id="2020-3-12-（2-medium-1-hard）"><a href="#2020-3-12-（2-medium-1-hard）" class="headerlink" title="2020.3.12 （2 medium 1 hard）"></a>2020.3.12 （2 medium 1 hard）</h2><h3 id="第34题-在排序数组中查找元素的第一个和最后一个位置"><a href="#第34题-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="第34题 在排序数组中查找元素的第一个和最后一个位置"></a>第34题 在排序数组中查找元素的第一个和最后一个位置</h3><p><img src="41.png" alt="第34题 在排序数组中查找元素的第一个和最后一个位置"></p><h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路:"></a>思路:</h4><p>由于时间复杂度控制在logN级别，所以很明显需要使用二分查找。</p><p>我们以二分查找获取左边界为例进行说明。首先，我们使用的是常规二分查找的框架，即比较目标与当前区间的中位数。不过常规二分查找是当目标大于中位数时进入右区间查找，小于中位数时进入左区间查找，等于中位数时返回当前中位数的位置。不同的是，此时我们需要查找的是元素的第一个位置。所以，我们需要进行这样的修改：当中位数等于目标时，目标元素的起始位置很明显要么在中位数处，要么在中位数左侧区间，此时我们直接进入左区间查找即可，其余的做法和常规二分查找一样。你可能会疑惑万一第一个位置就是中位数怎么办。不用担心，当遍历完左区间后无法再次找到目标元素，此时会在左区间的末尾尝试进入右区间，又回到了我们原先的中位数处。</p><p>二分查找右边界的方法同理，只是将中位数等于目标时改为进入右区间查找即可。</p><p>注意，当得到左右边界后还要判定是否合法。</p><p>通过两次二分，我们可以在$O(logN)$的时间复杂度内完成查找。</p><pre><code>class Solution:    def searchRange(self, nums: List[int], target: int) -&gt; List[int]:        if nums==[]:            return [-1,-1]        def getLeftBound(nums,target):#查找左边界            left=0            right=len(nums)-1            while (left&lt;=right):                mid=(left+right)//2                if (nums[mid]&gt;=target):                    right=mid-1                else:                    left=mid+1            if (left&gt;=0) and (left&lt;len(nums)) and (nums[left]==target):#左边界合法                return left            return -1        def getRightBound(nums,target):#查找右边界            left=0            right=len(nums)-1            while (left&lt;=right):                mid=(left+right)//2                if (nums[mid]&lt;=target):                    left=mid+1                else:                    right=mid-1            if (right&gt;=0) and (right&lt;len(nums)) and (nums[right]==target):#右边界合法                return right            return -1        return [getLeftBound(nums,target),getRightBound(nums,target)]</code></pre><h3 id="第36题-有效的数独"><a href="#第36题-有效的数独" class="headerlink" title="第36题 有效的数独"></a>第36题 有效的数独</h3><p><img src="36.png" alt="第36题 有效的数独"></p><h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路:"></a>思路:</h4><p>使用三个二维数组，分别存放每一行、每一列、每一个子数独当前放置的值。依次遍历这81个格子，每次遍历时将非空格子中的数放入对应的行、列、子数独的列表中。若出现了重复，则说明当前数独无效。</p><ul><li>时间复杂度：$O(1)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code>class Solution:    def isValidSudoku(self, board: List[List[str]]) -&gt; bool:        cols=[[] for x in range(9)]        rows=[[] for x in range(9)]        sons=[[] for x in range(9)]        for i in range(9):            for j in range(9):                if board[i][j]!=&#39;.&#39;:                    if (board[i][j] in cols[j]) or (board[i][j] in rows[i]) or (board[i][j] in sons[(i//3)*3+j//3]):                        return False                    else:                        cols[j].append(board[i][j])                        rows[i].append(board[i][j])                        sons[(i//3)*3+j//3].append(board[i][j])        return True</code></pre><h3 id="第37题-解数独"><a href="#第37题-解数独" class="headerlink" title="第37题 解数独"></a>第37题 解数独</h3><p><img src="37.png" alt="第37题 解数独"></p><h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路:"></a>思路:</h4><p>递归+回溯。类似的问题还有走迷宫、皇后问题、全排列等，本质的思路都是去使用回溯算法递归的尝试每种可能的情况。</p><p>回溯算法模板如下：</p><blockquote><p>def backtrack(…):<br> if (符合结束条件):<br>      保存结果<br>  else:<br>      for 选择 in 选择列表：<br>          if 选择合法：<br>              进行选择<br>              backtrack(…)#递归进入下一个位置进行选择<br>              撤销选择</p></blockquote><p>本题中，我们对每一个格子进行遍历，如果当前格子非空，我们便在“1”到“9”中选择合法的数字填入当前格子，并进入下一个格子继续选择。如果一直到最后一个格子都可以成功填入数字，则说明解完了数独，可以返回真。如果当前格子无法填入任何数字，则需要回溯至上一层递归函数，去恢复数独的状态，并选择下一个数字尝试填入。</p><p>判定当前数独矩阵是否合法，参考第36题即可。</p><pre><code>class Solution:    def solveSudoku(self, board) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify board in-place instead.        &quot;&quot;&quot;        cols=[[] for x in range(9)]        rows=[[] for x in range(9)]        sons=[[] for x in range(9)]        def could_place(i,j,value):#是否可以在当前格子放置value数字            if (value in cols[j]) or (value in rows[i]) or (value in sons[(i//3)*3+j//3]):                return False            return True        def place(i,j,value):#放置数字            cols[j].append(value)            rows[i].append(value)            sons[(i//3)*3+j//3].append(value)            board[i][j]=value        def remove(i,j,value):#移除数字            cols[j].remove(value)            rows[i].remove(value)            sons[(i//3)*3+j//3].remove(value)            board[i][j]=&quot;.&quot;        def DFS(i,j):#回溯函数            if i&gt;8:#结束递归条件               return True            if board[i][j]==&quot;.&quot;:#当前格子是否为空                for value in range(1,10):#遍历选择                    value=str(value)                    if (could_place(i,j,value)):#如果选择合法                        place(i,j,value)#进行选择                        if (j==8):#判断是否走到行尾                            if not(DFS(i+1,0)):#如果当前可以递归找到解，那么直接返回真，不需要再继续选择，否则回溯继续选择。                                remove(i,j,value)                            else:                                return True                        else:                            if not(DFS(i,j+1)):                                remove(i,j,value)                            else:                                return True            else:                if (j==8):                    return DFS(i+1,0)                else:                    return DFS(i,j+1)            return False        for i in range(9):#统计已经存在的数            for j in range(9):                if board[i][j]!=&#39;.&#39;:                    if (board[i][j] in cols[j]) or (board[i][j] in rows[i]) or (board[i][j] in sons[(i//3)*3+j//3]):                        return                    else:                        cols[j].append(board[i][j])                        rows[i].append(board[i][j])                        sons[(i//3)*3+j//3].append(board[i][j])        DFS(0,0)</code></pre><h2 id="2020-3-13-（2-medium）"><a href="#2020-3-13-（2-medium）" class="headerlink" title="2020.3.13 （2 medium）"></a>2020.3.13 （2 medium）</h2><h3 id="第39题-组合总和"><a href="#第39题-组合总和" class="headerlink" title="第39题 组合总和"></a>第39题 组合总和</h3><p><img src="39.png" alt="第39题 组合总和"></p><h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路:"></a>思路:</h4><p>递归回溯算法+剪枝</p><p>递归组合分解，每次选择候选数组中的一个元素，用目标值减去它。</p><ul><li>若得到的结果大于0，说明还可以继续分解，将当前选择的元素加入至路径列表，并尝试继续分解。</li><li>如果当前结果等于0，说明分解成功，将当前选择的元素加入至路径列表，并将当前路径列表加入至结果列表。</li><li>如果当前结果小于0，说明无法再分解，特别地，当候选数组升序时，后面的元素很明显也无法分解，需要跳出循环。</li></ul><p><img src="39-1.png" alt="回溯法"><br>此外，有可能出现重复的结果，即虽然路径不同，但元素相同。考虑到这一问题，尝试进行剪枝：</p><ul><li>记录下当前选择的元素的下标，下一次选择元素从该下标开始。<br><img src="39-2.png" alt="剪枝"></li></ul><pre><code>class Solution:    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:        result=[]        candidates.sort()        def back(re,index,target):            for i in range(index,len(candidates)):#遍历选择                num=candidates[i]                target_now=target-num                if target_now&lt;0:                    break                re.append(num)#选择                if target_now==0:                    res=re[:]                    result.append(res)                else:                    back(re,i,target_now)                re.pop()#回溯恢复        back([],0,target)        return result</code></pre><h3 id="第40题-组合总和2"><a href="#第40题-组合总和2" class="headerlink" title="第40题 组合总和2"></a>第40题 组合总和2</h3><p><img src="40.png" alt="第40题 组合总和2"></p><h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路:"></a>思路:</h4><p>和上一题类似，依然使用剪枝+递归回溯的思路来做。</p><p>有两个区别，一个是候选数组可能会出现重复，我们采用三数之和问题里类似的剪枝思路进行去重。第二个区别是数字不能重复使用，所以递归进行下一次元素的选择时，要从当前元素下标的下一个开始。</p><p><img src="40-1.png" alt="剪枝过程"></p><pre><code>class Solution:    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:        result=[]        candidates.sort()        def back(re,index,target):            if (index&lt;len(candidates)):                for i in range(index,len(candidates)):                    if i!=index and (candidates[i]==candidates[i-1]):#去重                        continue                    target_now=target-candidates[i]                    if (target_now&lt;0):                        break                    re.append(candidates[i])                    if (target_now==0):                        result.append(re[:])                    else:                        back(re,i+1,target_now)#从下一元素开始遍历，防止数字重复使用                    re.pop()        back([],0,target)        return result</code></pre><h2 id="2020-3-14-（2-hard-1-medium）"><a href="#2020-3-14-（2-hard-1-medium）" class="headerlink" title="2020.3.14 （2 hard 1 medium）"></a>2020.3.14 （2 hard 1 medium）</h2><h3 id="第41题-缺失的第一个正数"><a href="#第41题-缺失的第一个正数" class="headerlink" title="第41题 缺失的第一个正数"></a>第41题 缺失的第一个正数</h3><p><img src="41.png" alt="第41题 缺失的第一个正数"></p><h4 id="思路-23"><a href="#思路-23" class="headerlink" title="思路:"></a>思路:</h4><p>我们很容易想到利用哈希表（即字典）进行统计，然后去寻找第一个缺失的正数。但是考虑到题目的要求为时间复杂度$O(N)$以及常数级别的空间复杂度，我们可以考虑将数组自身作为一个哈希表，对应的哈希函数为:</p><p>$$f(nums[i])=nums[i]-1$$</p><p>通过哈希函数，将可以进行映射的数组元素映射到对应位置上，然后依次遍历寻找第一个映射不正确的位置即可。</p><p>复杂度分析：</p><ul><li><p>时间复杂度：$O(N)$，这里$N$是数组的长度。<br>说明：while 循环不会每一次都把数组里面的所有元素都看一遍。如果有一些元素在这一次的循环中被交换到了它们应该在的位置，那么在后续的遍历中，由于它们已经在正确的位置上了，代码再执行到它们的时候，就会被跳过。最极端的一种情况是，在第 1 个位置经过这个 while 就把所有的元素都看了一遍，这个所有的元素都被放置在它们应该在的位置，那么 for 循环后面的部分的 while 的循环体都不会被执行。平均下来，每个数只需要看一次就可以了，while 循环体被执行很多次的情况不会每次都发生。这样的复杂度分析的方法叫做<strong>均摊复杂度分析</strong>。</p></li><li><p>空间复杂度：$O(1)$。</p></li></ul><pre><code>class Solution:    def firstMissingPositive(self, nums: List[int]) -&gt; int:        def swap(pos1,pos2):            nums[pos1],nums[pos2]=nums[pos2],nums[pos1]        size=len(nums)        for i in range(size):            while (0&lt;nums[i]&lt;=size)and (nums[i]!=nums[nums[i]-1]):#当当前位置的数字可以进行哈希映射，并且不在对应位置时，与对应位置的数字交换。如果重复了或者无法映射（不在范围内），则不映射。                swap(i,nums[i]-1)        for i in range(size):#寻找第一个不符合映射规则的位置            if nums[i]!=i+1:                return i+1        return size+1#都符合，那么就输出下一个正数</code></pre><p>注:为什么使用nums[i]!=nums[nums[i]-1]来判断而不是i!=nums[i]-1？</p><p>因为后者无法处理重复的数字。</p><h3 id="第42题-接雨水"><a href="#第42题-接雨水" class="headerlink" title="第42题 接雨水"></a>第42题 接雨水</h3><p><img src="42.png" alt="第42题 接雨水"></p><h4 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h4><p>双指针+左右各一次遍历。从左向右遍历时，保证左指针指向的是短板。右指针不断向前遍历，每次右指针遇到长板后，计算此时所形成的容器的容积，再将左指针移到右指针处，右指针继续向前遍历。直到右指针遍历到数组末尾。然后再用相同的方式反向搜索一遍即可。将所有容积相加即为答案。</p><ul><li><p>时间复杂度:两次遍历，$O(N)$。</p></li><li><p>空间复杂度：$O(1)$。</p></li></ul><pre><code>class Solution:    def trap(self, height: List[int]) -&gt; int:        left=0        right=left+1        water=0        while (right&lt;len(height)):#从左向右            if height[right]&gt;=height[left]:                width=right-left-1                tmp=0                for i in range(left+1,right):#减去被柱子占用的体积                    tmp-=height[i]                tmp+=width*height[left]                water+=tmp                left=right            right+=1        right=len(height)-1        left=right-1        while (left&gt;=0):#从右向左            if height[left]&gt;height[right]:                width=right-left-1                tmp=0                for i in range(left+1,right):                    tmp-=height[i]                tmp+=width*height[right]                water+=tmp                right=left            left-=1        return water</code></pre><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>实际上，这里并不需要两次遍历，因为从左向右和从右向左的遍历都会在最高的柱子处停下。所以我们可以同时从两侧开始逼近，每次让左右指针较小的那个移动。</p><p>同时，我们可以维护一个left_max和right_max，即左右指针当前遍历到的最高柱。利用它们可以计算当前格子的积水。</p><pre><code>class Solution:    def trap(self, height: List[int]) -&gt; int:        left_max=0        right_max=0        left=0        right=len(height)-1        water=0        while left&lt;=right:            if height[left]&lt;height[right]:#确保不会越过山顶                if (height[left]&gt;=left_max):                    left_max=height[left]                else:                    water+=left_max-height[left]#利用max变量求解当前格的积水                left+=1            else:                if (height[right]&gt;=right_max):                    right_max=height[right]                else:                    water+=right_max-height[right]                right-=1        return water</code></pre><p>数组必有一个 ”山顶“（若有多个高度相同山顶，任取一个即可）。</p><p>根据”木桶原理“，山顶左侧的元素的盛水量 ，由左侧最大值决定；山顶右侧元素的盛水量，由右侧最大值决定。</p><p>双指针法的两个指针最终会停在 “山顶” 处。</p><h3 id="第43题-字符串相乘"><a href="#第43题-字符串相乘" class="headerlink" title="第43题 字符串相乘"></a>第43题 字符串相乘</h3><p><img src="43.png" alt="第43题 字符串相乘"><br>大数乘法问题，采取模拟竖式计算的方式求解。使用两个数组来存放两个数字字符串，数组的低位存数字字符串的低位。将第1个数组的第i位与第2个数组的第j位相乘，放入结果数组的第i+j位上。计算完成后，遍历结果数组，将所有大于9的进行进位操作。再反向遍历去掉最末尾的0。最后反向拼接成字符串输出即可。</p><pre><code>class Solution:    def multiply(self, num1: str, num2: str) -&gt; str:        numLi1=[int(x) for x in num1[::-1]]        numLi2=[int(x) for x in num2[::-1]]        len1=len(numLi1)        len2=len(numLi2)        res=[0 for x in range(len1+len2)]        for i in range(len1):#模拟两个数字的每一位相乘            for j in range(len2):                res[i+j]+=numLi1[i]*numLi2[j]        for i in range(len1+len2):#进位操作            if res[i]&gt;9:                res[i+1]+=res[i]#10                res[i]%=10          for i in range(len(res)-1,0,-1):#去除结果开头的0            if res[i]==0 :                res.pop()            else:                break        res=[str(x) for x in res[::-1]]        return &quot;&quot;.join(res)</code></pre><ul><li>时间复杂度:$O(MN)$</li><li>空间复杂度:$O(M+N)$</li></ul><h2 id="2020-3-15-（2-hard）"><a href="#2020-3-15-（2-hard）" class="headerlink" title="2020.3.15 （2 hard）"></a>2020.3.15 （2 hard）</h2><h3 id="第44题-通配符匹配"><a href="#第44题-通配符匹配" class="headerlink" title="第44题 通配符匹配"></a>第44题 通配符匹配</h3><p><img src="44.png" alt="第44题 通配符匹配"></p><h4 id="思路-25"><a href="#思路-25" class="headerlink" title="思路:"></a>思路:</h4><p>类似于第十题，可以采用相同的动态规划方法处理，甚至比第十题简单一些。由子串的匹配转移到当前串的匹配，直到转移至目标串和模式串的匹配。</p><pre><code>class Solution:    def isMatch(self, s: str, p: str) -&gt; bool:        dp=[[False for x in range(len(p)+1)] for x in range(len(s)+1)]        dp[-1][-1]=True        for i in range(len(s),-1,-1):#动态规划            for j in range(len(p)-1,-1,-1):                if p[j]==&quot;*&quot;:                    if i&lt;len(s):                        dp[i][j]=dp[i+1][j] or dp[i][j+1]                    else:                        dp[i][j]=dp[i][j+1]                else:                    if i&lt;len(s) and(p[j]==&quot;?&quot; or p[j]==s[i]):                        dp[i][j]=dp[i+1][j+1]        return dp[0][0]</code></pre><ul><li>时间复杂度:$O(MN)$</li><li>空间复杂度:$O(MN)$</li></ul><h4 id="更好的思路："><a href="#更好的思路：" class="headerlink" title="更好的思路："></a>更好的思路：</h4><p>有一种更好的思路来进行匹配，降低了时空复杂度，使用的是回溯和贪心的思想。具体看这里:<a href="https://leetcode-cn.com/problems/wildcard-matching/solution/tong-pei-fu-pi-pei-by-leetcode/" target="_blank" rel="noopener">40题解</a></p><h3 id="第45题-跳跃游戏2"><a href="#第45题-跳跃游戏2" class="headerlink" title="第45题 跳跃游戏2"></a>第45题 跳跃游戏2</h3><p><img src="45.png" alt="第45题 跳跃游戏2"></p><h4 id="思路-26"><a href="#思路-26" class="headerlink" title="思路:"></a>思路:</h4><p>贪心思路。在当前可以跳到的下一跳候选位置中，选择继续跳跃能够到达最远位置的候选位置，贪心地进行跳跃。当即将跳到数组末尾或者超过数组末尾时，返回当前步数加1，否则继续跳跃。</p><pre><code>class Solution:    def jump(self, nums: List[int]) -&gt; int:        now=0#当前位置        count=0#步数        l=len(nums)-1#数组末尾位置        if l==0:            return count        while True:            if now+nums[now]&gt;=l:#即将到达末尾                return count+1            farthest=0            next=0            for i in range(now+1,now+nums[now]+1):#贪心地选择能够抵达更远地方的下一跳位置                farthest_now=i+nums[i]                if farthest_now&gt;farthest:                    farthest=farthest_now                    next=i            now=next            count+=1</code></pre><h2 id="2020-3-16-（4-medium）"><a href="#2020-3-16-（4-medium）" class="headerlink" title="2020.3.16 （4 medium）"></a>2020.3.16 （4 medium）</h2><h3 id="第46题-全排列"><a href="#第46题-全排列" class="headerlink" title="第46题 全排列"></a>第46题 全排列</h3><p><img src="46.png" alt="第46题 全排列"></p><h4 id="思路-27"><a href="#思路-27" class="headerlink" title="思路:"></a>思路:</h4><p>深度优先搜索+回溯。</p><p>为了防止重复遍历数字，使用一个已访问矩阵来存储数字是否已被访问。</p><pre><code>class Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        result=[]        visited=[False for x in nums]        def dfs(re):            if (len(re)==len(nums)):                result.append(re)            else:                for i in range(len(nums)):                    if (visited[i]==False):                        re.append(nums[i])                        visited[i]=True                        dfs(re[:])                        re.pop()                        visited[i]=False        dfs([])        return result</code></pre><p>需要注意的是，一般回溯法中将路径列表添加至结果时，需要添加一个深拷贝，而不能是引用。否则它将跟随回溯变化。</p><h3 id="第47题-全排列2"><a href="#第47题-全排列2" class="headerlink" title="第47题 全排列2"></a>第47题 全排列2</h3><p><img src="47.png" alt="第47题 全排列2"></p><h4 id="思路-28"><a href="#思路-28" class="headerlink" title="思路:"></a>思路:</h4><p>与上一题基础的全排列类似，我们依然使用的是DFS+backtrack算法，但是在这里我们需要进行剪枝处理，去重。</p><p>去重的思路是：先排序，对于多个未访问的连续的相同数字，我们每次只选择第一个进行深度优先搜索，防止重复的搜索。</p><pre><code>class Solution:    def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:        result=[]        visited=[False for x in nums]        nums.sort()        def dfs(re):            if (len(re)==len(nums)):                result.append(re)            else:                for i in range(len(nums)):                    if (i!=0 and nums[i]==nums[i-1] and visited[i-1]==False):#剪枝处理                        continue                    if (visited[i]==False):                        re.append(nums[i])                        visited[i]=True                        dfs(re[:])                        re.pop()                        visited[i]=False        dfs([])        return result</code></pre><h3 id="第48题-旋转图像"><a href="#第48题-旋转图像" class="headerlink" title="第48题 旋转图像"></a>第48题 旋转图像</h3><p><img src="48.png" alt="第48题 旋转图像"></p><h4 id="思路-29"><a href="#思路-29" class="headerlink" title="思路:"></a>思路:</h4><p>先对数组进行转置，再对其进行左右翻转。</p><p>需要进行原地修改。</p><pre><code>class Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify matrix in-place instead.        &quot;&quot;&quot;        for i in range(len(matrix)):            for j in range(i+1,len(matrix[0])):                tmp=matrix[i][j]                matrix[i][j]=matrix[j][i]                matrix[j][i]=tmp        for i in range(len(matrix)):            for j in range(len(matrix[0])//2):                tmp=matrix[i][j]                matrix[i][j]=matrix[i][len(matrix)-j-1]                matrix[i][len(matrix)-j-1]=tmp        return matrix</code></pre><h3 id="第49题-字母异位词分组"><a href="#第49题-字母异位词分组" class="headerlink" title="第49题 字母异位词分组"></a>第49题 字母异位词分组</h3><p><img src="49.png" alt="第49题 字母异位"></p><h4 id="思路-30"><a href="#思路-30" class="headerlink" title="思路:"></a>思路:</h4><p>使用哈希表进行求解。将每个单词的字母按照字典序进行排序，作为哈希表的key，那么字母异位词必然会放入同一个key中。哈希表的value为对应key的字母异位词组成的列表。在最后输出values组成的列表即可。</p><pre><code>class Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        dic={}        for word in strs:            tmp=tuple(sorted(word))            if tmp not in dic.keys():                dic[tmp]=[word]            else:                dic[tmp].append(word)        return list(dic.values())</code></pre><p>实际上，还可以不用对单词进行排序，仅统计二十六个字母出现的次数，也能达到相同的效果，将时间复杂度由$O(NKlogK)$降为$O(NK)$</p><pre><code>class Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        dic={}        for word in strs:            tmp=[0 for x in range(26)]            for ch in word:                tmp[ord(ch)-ord(&#39;a&#39;)]+=1            tmp=tuple(tmp)            if tmp not in dic.keys():                dic[tmp]=[word]            else:                dic[tmp].append(word)        return list(dic.values())</code></pre><h2 id="2020-3-17-（1-medium-1-hard）"><a href="#2020-3-17-（1-medium-1-hard）" class="headerlink" title="2020.3.17 （1 medium 1 hard）"></a>2020.3.17 （1 medium 1 hard）</h2><h3 id="第50题-Pow（x-n）"><a href="#第50题-Pow（x-n）" class="headerlink" title="第50题 Pow（x,n）"></a>第50题 Pow（x,n）</h3><p><img src="50.png" alt="第50题 Pow（x,n）"></p><h4 id="思路-31"><a href="#思路-31" class="headerlink" title="思路:"></a>思路:</h4><p>快速幂算法，采用递归的思路，通过二分法进行加速，将时间复杂度从累乘法的$O(N)$减少到$O(logN)$。基本思想是将$X^n$用两个$X^/frac{n}{2}$表示，这里需要对n的奇偶性进行分类讨论，如果是奇数，无法被2整除的话，还需要再乘以一个x。不断向下二分递归求解，直到将问题转化为求解$X^1$和$X^0$，再层层回退求解结果。</p><p>具体思路有些类似于第29题两数相除，本质思想都是使用递归二分进行加速。</p><p>特别地，当n为负数时，可以将$X^n$转化为$/frac{1}{X}^{-n}$求解。</p><pre><code>class Solution:    def myPow(self, x: float, n: int) -&gt; float:        def fastpow(x,n):            if n==0:                return 1            if n&gt;0:                half=fastpow(x,n//2)                if n%2==0:                    return half*half                else:                    return x*half*half        if n&lt;0:            x=1/x            n=-n        return fastpow(x,n)</code></pre><p>特别地，需要注意Integer类型的补码机制问题，必要时可以采用long，不过python没有这个烦恼。</p><p>也可以使用非递归方式进行求解。</p><pre><code>class Solution:    def myPow(self, x: float, n: int) -&gt; float:        if n&lt;0:            x=1/x            n=-n        result=1        if n==0:            return 1.0        while (n&gt;0):            if n%2==0:                result*=2            else:                result=result*result*x            n//=2        return result</code></pre><h3 id="第51题-N皇后"><a href="#第51题-N皇后" class="headerlink" title="第51题 N皇后"></a>第51题 N皇后</h3><p><img src="51.png" alt="第51题 N皇后"></p><h4 id="思路-32"><a href="#思路-32" class="headerlink" title="思路:"></a>思路:</h4><p>和解数独和全排列等题目类似，依然是使用回溯算法进行递归求解。</p><p>在这个问题中，我们将棋盘看作是一个二维数组，按行进行递归，按列进行选择，每行选择一列放置皇后。如果每一行都能放置一个皇后，则可以将当前棋盘加入至结果数组。</p><p>特别地，我们需要判断当前位置是否可以放置一个皇后。由于皇后会攻击同行、同列、四个对角线上的棋子，所以我们需要保证当前行、当前列、当前四个对角线上没有别的皇后。前两个很好判断，对角线可以使用两个皇后的横坐标与纵坐标的差值绝对值是否相等来判断。</p><pre><code>class Solution:    def solveNQueens(self, n: int) -&gt; List[List[str]]:        def couldplace(chessboard,row,col):#是否可以放置            for i in range(row):                if chessboard[i]==col or abs(i-row)==abs(chessboard[i]-col):                    return False            return True        def trans(li):#将棋盘转化为输出格式            result=[]            for i in li:                result.append(&#39;.&#39;*(i)+&#39;Q&#39;+&#39;.&#39;*(n-i-1))            return result        result=[]        def back(chessboard,row):#递归回溯            if row&gt;=n:#当前行数若超过棋盘范围，则已放置完，可将当前棋盘加入结果数组                result.append(chessboard[:])            else:                for i in range(n):#进行选择                    if (couldplace(chessboard,row,i)):                        chessboard[row]=i                        back(chessboard,row+1)                        chessboard[row]=-1#回溯        chessboard=[-1 for i in range(n)]        back(chessboard,0)        for i in range(len(result)):            result[i]=trans(result[i])        return result</code></pre><p>这里，我使用了一种优化方法，每一次并没有存储真实的棋盘，而是开了一个二维数组，每个数组放置当前行的皇后位置。最后将其转化为输出格式即可。</p><h2 id="2020-3-18-（1-easy-2-medium）"><a href="#2020-3-18-（1-easy-2-medium）" class="headerlink" title="2020.3.18 （1 easy 2 medium）"></a>2020.3.18 （1 easy 2 medium）</h2><h3 id="第53题-最大子序和"><a href="#第53题-最大子序和" class="headerlink" title="第53题 最大子序和"></a>第53题 最大子序和</h3><p><img src="53.png" alt="第53题 最大子序和"></p><h4 id="思路-33"><a href="#思路-33" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划，状态矩阵dp[i]为以元素nums[i]结尾的子数组的最大连续和，转移方程为dp[i]=（1）nums[i]（if dp[i-1]&lt;=0） （2）dp[i-1]+nums[i]（if dp[i-1]&gt;0）。因为当前只有前面的连续子数组最大和为正数，才能对当前连续子数组最大和产生正贡献，否则只会使其变小。</p><p>特别地，为了节约空间，我们可以将nums列表原地修改为dp列表。</p><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code>class Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        max_sum=nums[0]        for i in range(1,len(nums)):            if nums[i-1]&gt;0:                nums[i]+=nums[i-1]            max_sum=max(nums[i],max_sum)#比较当前连续子数组和是否大于全局最大值        return max_sum</code></pre><h3 id="第54题-螺旋矩阵"><a href="#第54题-螺旋矩阵" class="headerlink" title="第54题 螺旋矩阵"></a>第54题 螺旋矩阵</h3><p><img src="54.png" alt="第54题 螺旋矩阵"></p><h4 id="思路-34"><a href="#思路-34" class="headerlink" title="思路:"></a>思路:</h4><p>按圈模拟指针的变化。这一类题目需要自己寻找一下指针变化的规律。</p><pre><code>class Solution:    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:        level=0#圈数        row=0        col=0        if matrix==[]:            return []        result=[matrix[row][col]]        count=1#步数        row_nums=len(matrix)        col_nums=len(matrix[0])        size=row_nums*col_nums        while count&lt;size:            for i in range(level+1,col_nums-level):                col+=1                result.append(matrix[row][col])                count+=1                if count&gt;=size:                    return result            for i in range(level+1,row_nums-level):                row+=1                result.append(matrix[row][col])                count+=1                if count&gt;=size:                    return result            for i in range(level+1,col_nums-level):                col-=1                result.append(matrix[row][col])                count+=1                if count&gt;=size:                    return result            for i in range(level+1,row_nums-level-1):                row-=1                result.append(matrix[row][col])                count+=1                if count&gt;=size:                    return result            #模拟顺时针的遍历，这里写的比较冗余，实际上可以使用列表+取余的方式简化增量的计算。            level+=1            col+=1            result.append(matrix[row][col])            count+=1        return result</code></pre><h3 id="第55题-跳跃游戏"><a href="#第55题-跳跃游戏" class="headerlink" title="第55题 跳跃游戏"></a>第55题 跳跃游戏</h3><p><img src="55.png" alt="第55题 跳跃游戏"></p><h4 id="思路-35"><a href="#思路-35" class="headerlink" title="思路:"></a>思路:</h4><p>我们基于这样的一个假设：如果能跳到位置i，那么位置i之前的所有位置0，1…i-1都能跳到。</p><p>那么问题已经迎刃而解了，我们遍历每一个位置，如果当前位置无法被跳到（大于当前所能到达的最远位置），则说明后面的所有位置都无法跳到，自然也就无法到达数组的末尾。如果当前位置可以跳到，将其所能到达的最远位置与当前最远位置比较，取最大值进行更新当前最远位置。</p><p>时间复杂度：$O(N)$</p><p>空间复杂度: $O(1)$</p><pre><code>class Solution:    def canJump(self, nums: List[int]) -&gt; bool:        farthest=0        for i in range(len(nums)):            if i&gt;farthest:                return False            farthest=max(farthest,i+nums[i])        return True</code></pre><p>也可以和跳跃游戏2一样采用贪心算法求解，不过时间复杂度会高一些。</p><h2 id="2020-3-19-（2-medium-1-hard）"><a href="#2020-3-19-（2-medium-1-hard）" class="headerlink" title="2020.3.19 （2 medium 1 hard）"></a>2020.3.19 （2 medium 1 hard）</h2><h3 id="第56题-合并区间"><a href="#第56题-合并区间" class="headerlink" title="第56题 合并区间"></a>第56题 合并区间</h3><p><img src="56.png" alt="第56题 合并区间"></p><h4 id="思路-36"><a href="#思路-36" class="headerlink" title="思路:"></a>思路:</h4><p>先按每个区间的左边界，为所有区间进行升序排序。接着，遍历每个区间，若当前区间的右边界大于或等于下一区间的左边界，那么说明二者有重复，可以进行合并。合并后，新区间的左边界为当前区间的左边界（升序排序），有边界为两个区间右边界的最大值（两种情况）。将下一区间原地修改为合并后的新区间，可以节约空间，并将当前区间置空。完成后，继续向前遍历。</p><p>最后，将所有空列表进行删除处理，返回最终的列表即可。</p><p>时间复杂度：$O(N)$</p><p>空间复杂度：$O(1)$</p><pre><code>class Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        if len(intervals)&gt;1:            intervals.sort()            for i in range(len(intervals)-1):                if intervals[i][1]&gt;=intervals[i+1][0]:                    intervals[i+1][0]=intervals[i][0]                    intervals[i+1][1]=max(intervals[i][1],intervals[i+1][1])                    intervals[i]=[]            for i in range(len(intervals)-1,-1,-1):                if intervals[i]==[]:                    intervals.remove([])        return intervals</code></pre><h3 id="第57题-插入区间"><a href="#第57题-插入区间" class="headerlink" title="第57题 插入区间"></a>第57题 插入区间</h3><p><img src="57.png" alt="第57题 插入区间"></p><h4 id="思路-37"><a href="#思路-37" class="headerlink" title="思路:"></a>思路:</h4><p>二分查找插入位置，插入新区间，然后采用上一题的思路进行合并。插入需要耗费$O(logN)$，合并需要耗费$O(N)$，总时间复杂度为$O(NlogN)$。</p><pre><code>class Solution:    def insert(self, intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:        def search(target):            left=0            right=len(intervals)-1            while (left&lt;=right):                mid=(left+right)//2                if (intervals[mid][0]==target):                    return mid                elif (intervals[mid][0]&gt;target):                    right=mid-1                else:                    left=mid+1            return left        insert_pos=search(newInterval[0])        intervals.insert(insert_pos,newInterval)        if len(intervals)&gt;1:            for i in range(len(intervals)-1):                if intervals[i][1]&gt;=intervals[i+1][0]:                    intervals[i+1][0]=intervals[i][0]                    intervals[i+1][1]=max(intervals[i][1],intervals[i+1][1])                    intervals[i]=[]            for i in range(len(intervals)-1,-1,-1):                if intervals[i]==[]:                    intervals.remove([])        return intervals</code></pre><p>还可以使用贪心算法，先将新区间插入至插入位置，并将其与前一个区间尝试合并。再向后遍历，尝试合并，直到无法进行合并。</p><h3 id="第60题-第k个排列"><a href="#第60题-第k个排列" class="headerlink" title="第60题 第k个排列"></a>第60题 第k个排列</h3><p><img src="60.png" alt="第60题 第k个排列"></p><h4 id="思路-38"><a href="#思路-38" class="headerlink" title="思路:"></a>思路:</h4><p>DFS算法，因为n！种排列本质是由n组n-1！排列组合而成，根据这一性质，我们可以得知当前的偏移值在哪一组n-1！中，从而计算得到当前位置上应填入的数字，接着取余数获取新的偏移值，不断递归，直到获取最终结果。</p><p>这里的DFS不需要进行回溯，因为每一位数字只有一个是符合条件的，不需要恢复状态去进行下一个选择。</p><pre><code>class Solution:    def getPermutation(self, n: int, k: int) -&gt; str:        def factorial(n):#求解n!            result=1            for i in range(2,n+1):                result*=i            return result        visited=[False for _ in range(n)]        def dfs(n,k,result):            if n==0:                return result            f=factorial(n-1)            base=k//f            offset=k%f            for i in range(len(visited)):                if visited[i]==False:                    if base&lt;=0:#第base个未访问过的元素，即为当前位置上应该填入的数字                        result+=str(i+1)                        visited[i]=True                        return dfs(n-1,offset,result)                    else:                        base-=1        return dfs(n,k-1,&quot;&quot;)#这里数组从0开始，需要将k减1</code></pre><h2 id="2020-3-20-（4-medium）"><a href="#2020-3-20-（4-medium）" class="headerlink" title="2020.3.20 （4 medium）"></a>2020.3.20 （4 medium）</h2><h3 id="第61题-旋转链表"><a href="#第61题-旋转链表" class="headerlink" title="第61题 旋转链表"></a>第61题 旋转链表</h3><p><img src="61.png" alt="第61题 旋转链表"></p><h4 id="思路-39"><a href="#思路-39" class="headerlink" title="思路:"></a>思路:</h4><p>快慢指针法+头插法。</p><p>先统计链表的长度L，令K=K%L，放置进行重复的旋转。再使用快慢指针定位链表最后K个元素的起始位置和终止位置，并将这K个元素插入至链表头部即可。</p><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def rotateRight(self, head: ListNode, k: int) -&gt; ListNode:        dummyhead=ListNode(0)        dummyhead.next=head        fast=slow=dummyhead        l=0        p=dummyhead        if head!=None:            while (p.next!=None):                p=p.next                l+=1            k%=l            while (fast.next!=None):                if (k&gt;0):                    fast=fast.next                    k-=1                else:                    slow=slow.next                    fast=fast.next            fast.next=dummyhead.next            dummyhead.next=slow.next            slow.next=None        return dummyhead.next</code></pre><p>也可以将原先的链表修改成一个环，再从原倒数第K%L个元素处断开环，新得到的链表即为旋转后链表。</p><h3 id="第62题-不同路径"><a href="#第62题-不同路径" class="headerlink" title="第62题 不同路径"></a>第62题 不同路径</h3><p><img src="62.png" alt="第62题 不同路径"></p><h4 id="思路-40"><a href="#思路-40" class="headerlink" title="思路:"></a>思路:</h4><p>我的最初思路想当然地考虑到了DFS+回溯算法，这也是这一类走迷宫问题的常用算法。</p><p>但是，我很快观察到，这道题里有重叠的子问题，那么使用递归将非常缓慢。例如，从位置（0，1）和位置（1，0）都可以走到位置（1，1），如果我们使用递归，将重复从位置（1，1）向下搜索可行解两次，导致了不必要的时间消耗。</p><p>解决重叠子问题的方法就是动态规划。这道题里，我们的状态矩阵dp[i][j]为到达网格中（i，j）位置的路径数目，转移方程为：</p><ol><li>dp[i][j]=1,if i==0 and j==0;</li><li>dp[i][j]=dp[i-1][j],if i&gt;0 and j==0;</li><li>dp[i][j]=dp[i][j-1],if j&gt;0 and i==0;</li><li>dp[i][j]=dp[i-1][j]+dp[i][j-1],if i&gt;0 and j&gt;0.</li></ol><pre><code>class Solution:    def uniquePaths(self, m: int, n: int) -&gt; int:        dp=[[0 for _ in range(m)] for _ in range(n)]#状态矩阵        dp[0][0]=1        for i in range(n):#状态转移            for j in range(m):                if i&gt;0 and j==0:                    dp[i][j]=dp[i-1][j]                elif i==0 and j&gt;0:                    dp[i][j]=dp[i][j-1]                elif i&gt;0 and j==0:                    dp[i][j]=dp[i-1][j]                elif i&gt;0 and j&gt;0:                    dp[i][j]=dp[i][j-1]+dp[i-1][j]        return dp[n-1][m-1]</code></pre><h3 id="第63题-不同路径2"><a href="#第63题-不同路径2" class="headerlink" title="第63题 不同路径2"></a>第63题 不同路径2</h3><p><img src="63.png" alt="第63题 不同路径"></p><h4 id="思路-41"><a href="#思路-41" class="headerlink" title="思路:"></a>思路:</h4><p>思路与上一题基本一致，唯一的区别在于当状态矩阵转移到有障碍物的位置时，应将状态矩阵该位置修改为0.因为很明显该位置有了障碍物后不可达。</p><p>特别地，我们可以将题目提供的数组原地修改为状态矩阵，便可只适用常数级别的额外空间。</p><pre><code>class Solution:    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:        if obstacleGrid[0][0]==1:#初始位置有障碍物，并不可能到达终点            return 0        obstacleGrid[0][0]=1        for i in range(len(obstacleGrid)):            for j in range(len(obstacleGrid[0])):                if obstacleGrid[i][j]==1 and (i&gt;0 or j&gt;0):#将有障碍物的位值设为不可达                    obstacleGrid[i][j]=0                else:#状态转移                    if i&gt;0 and j==0:                        obstacleGrid[i][j]=obstacleGrid[i-1][j]                    elif i==0 and j&gt;0:                        obstacleGrid[i][j]=obstacleGrid[i][j-1]                    elif i&gt;0 and j&gt;0:                        obstacleGrid[i][j]=obstacleGrid[i][j-1]+obstacleGrid[i-1][j]        return obstacleGrid[-1][-1]</code></pre><h3 id="第64题-最小路径和"><a href="#第64题-最小路径和" class="headerlink" title="第64题 最小路径和"></a>第64题 最小路径和</h3><p><img src="64.png" alt="第64题 最小路径和"></p><h4 id="思路-42"><a href="#思路-42" class="headerlink" title="思路:"></a>思路:</h4><p>与62、63题思路基本一致，仍然是动态规划的思想。转移方程略有不同，核心是当前位置上的数字加上上方位置和左侧位置的路径和的最小值。</p><pre><code>class Solution:    def minPathSum(self, grid: List[List[int]]) -&gt; int:        for i in range(len(grid)):            for j in range(len(grid[0])):                if i&gt;0 and j==0:                    grid[i][j]+=grid[i-1][j]                elif i==0 and j&gt;0:                    grid[i][j]+=grid[i][j-1]                elif i&gt;0 and j&gt;0:                    grid[i][j]+=min(grid[i][j-1],grid[i-1][j])        return grid[-1][-1]</code></pre><h2 id="2020-3-29-（1-medium-1-hard）"><a href="#2020-3-29-（1-medium-1-hard）" class="headerlink" title="2020.3.29 （1 medium 1 hard）"></a>2020.3.29 （1 medium 1 hard）</h2><h3 id="第72题-编辑距离"><a href="#第72题-编辑距离" class="headerlink" title="第72题 编辑距离"></a>第72题 编辑距离</h3><p><img src="72.png" alt="第72题 编辑距离"></p><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>动态规划的经典模板题之一，设dp[i] [j]为word1的前i个字符调整至word2的前j个字符所需的最少操作数目。则dp转移方程为：</p><ul><li>dp[i] [j]=0，if i==0 and j==0（空字符串到空字符串，不需要编辑）</li><li>dp[i] [j]=i，if i&gt;0 and j==0（word1的前i个字符调整至空字符串，需要删除i次）</li><li>dp[i] [j]=j，if i==0 and j&gt;0（空字符串调整至word2的前j个字符串，需要添加j次）</li><li>dp[i] [j]=dp[i-1] [j-1]，if i&gt;0 and j&gt;0 and word1[i-1]==word2[j-1] （如果word1的第i个字符和word2的第j个字符相等，那么这一位上不需要操作，直接看word1的前i-1个字符调整至word2的前j-1个字符需要几步即可）</li><li>dp[i] [j]=min（dp[i-1] [j]，dp[i] [j-1], dp[i-1] [j-1]）+1，if i&gt;0 and j&gt;0 and word1[i-1]!=word2[j-1] （如果word1的第i个字符和word2的第j个字符不相等，那我们假设当前的匹配是由添加、删除、替换一个字符而来的，比较三者操作前的状态需要的最少操作数目，选取最小值加上当前这一步，作为当前的最少操作数目）</li></ul><blockquote><p>以 word1 为 “horse”，word2 为 “ros”，且 dp[5] [3] 为例，即要将 word1的前 5 个字符转换为 word2的前 3 个字符，也就是将 horse 转换为 ros，因此有：</p><p>(1) dp[i-1] [j-1]，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 2 个字符 ro，然后将第五个字符 word1[4]（因为下标基数以 0 开始） 由 e 替换为 s（即替换为 word2 的第三个字符，word2[2]）</p><p>(2) dp[i] [j-1]，即先将 word1 的前 5 个字符 horse 转换为 word2 的前 2 个字符 ro，然后在末尾补充一个 s，即插入操作</p><p>(3) dp[i-1] [j]，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 3 个字符 ros，然后删除 word1 的第 5 个字符</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word1<span class="token punctuation">:</span> str<span class="token punctuation">,</span> word2<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>word2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>word1<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>word1<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>word2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>                <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>j                <span class="token keyword">elif</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> word1<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span>word2<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度: $O(MN)$。</li><li>空间复杂度：$O(MN)$。</li><li>这一题有些类似于通识符匹配的那道题。</li></ul><h3 id="第75题-颜色分类"><a href="#第75题-颜色分类" class="headerlink" title="第75题 颜色分类"></a>第75题 颜色分类</h3><p><img src="75.png" alt="第75题 颜色分类"></p><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>三路快排的思想。使用三个指针curr，p0，p2。curr用于遍历数组，p0用于表示全0区间的右边界的下一个位置，p2用于表示全2区间的左边界的下一个位置。具体扫描算法如下：</p><ul><li>当curr小于p2时（说明所有元素尚且没有被扫描完）：<ul><li>如果nums[curr]==0，那么将nums[curr]与nums[p0]交换，并且curr加1，p0加1，相当于全0区间向右扩展了，且由于当前数必然是1或者0，所以可以向后继续遍历（因为之前的元素都已经被遍历过，如果是2会被交换到后面去）。</li><li>如果nums[curr]==2，那么将nums[curr]与nums[p2]交换，并且p2减1，相当于全2区间向左扩展了。由于此时交换过来的数字我们不知道是0、1还是2，所以curr不能加一，还需要继续判断当前元素。</li><li>如果nums[curr]==1，那么直接使curr加1，向后继续遍历。</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortColors</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify nums in-place instead.        """</span>        curr<span class="token punctuation">,</span>p0<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        p2<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token operator">&lt;=</span>p2<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>p0<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>p0<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span>                curr<span class="token operator">+=</span><span class="token number">1</span>                p0<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                curr<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span>                p2<span class="token operator">-=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度: $O(N)$。</li><li>空间复杂度：$O(1)$。</li><li>这道题既有些像快排，使用指针维护区间的思想也有些像26题和27题。</li></ul><h2 id="2020-3-30-（1-medium-1-hard）"><a href="#2020-3-30-（1-medium-1-hard）" class="headerlink" title="2020.3.30 （1 medium 1 hard）"></a>2020.3.30 （1 medium 1 hard）</h2><h3 id="第76题-最小覆盖子串"><a href="#第76题-最小覆盖子串" class="headerlink" title="第76题 最小覆盖子串"></a>第76题 最小覆盖子串</h3><p><img src="76.png" alt="第76题 最小覆盖子串"></p><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><p>经典的滑动窗口题，类似的题目还有 <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">无重复字符的最长子串</a> 、 <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">找到字符串中所有字母异位词</a> 等。基本思路都是使用双指针维护一个符合题目要求的滑动区间。</p><p>本题中，我们使用双指针left和right，right负责向前遍历搜索，如果区间[left：right+1]包含了T中所有的字母，我们尝试移动left，保证当前区间仍然包含T中所有的字母。如果left移动后区间不符合要求，我们记录当前区间，将其与最小覆盖子串比较，更新最小覆盖子串。然后，right继续向前搜索，直到最后一个字符。</p><ul><li>时间复杂度：$O(M+N)$, M为s长度，N为t长度。 在最坏的情况下，可能会对S中的每个元素遍历两遍，左指针和右指针各一遍。 </li><li>空间复杂度：$O(1)$。最多128个字符。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        left<span class="token operator">=</span><span class="token number">0</span>        right<span class="token operator">=</span><span class="token number">0</span>        count_t<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#哈希表统计t中每个字符出现的次数</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> t<span class="token punctuation">:</span>            <span class="token keyword">if</span> ch <span class="token operator">not</span> <span class="token keyword">in</span> count_t<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                count_t<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                count_t<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>        formed<span class="token operator">=</span><span class="token number">0</span><span class="token comment" spellcheck="true">#已覆盖的字符数（指的是不重复的字符）</span>        min_length<span class="token operator">=</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span>        min_st<span class="token operator">=</span><span class="token string">""</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#右区间遍历搜索s的所有字符</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token keyword">in</span> count_t<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> count_t<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当前字符所有出现次数被完全覆盖</span>                    formed<span class="token operator">+=</span><span class="token number">1</span>                count_t<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">if</span> formed<span class="token operator">==</span>len<span class="token punctuation">(</span>count_t<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#完全覆盖了t中所有的字符</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#左区间收缩，尝试寻找最小覆盖字串</span>                    <span class="token keyword">if</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token keyword">in</span> count_t<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        count_t<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>                        <span class="token keyword">if</span> count_t<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#失去匹配</span>                            formed<span class="token operator">-=</span><span class="token number">1</span>                            left<span class="token operator">+=</span><span class="token number">1</span>                            <span class="token keyword">break</span>                    left<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> right<span class="token operator">-</span>left<span class="token operator">&lt;</span>min_length<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#记录失配前的最小子串，更新当前最小覆盖字串</span>                        min_length<span class="token operator">=</span>right<span class="token operator">-</span>left                        min_st<span class="token operator">=</span>s<span class="token punctuation">[</span>left<span class="token number">-1</span><span class="token punctuation">:</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>            right<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> min_st<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第79题-单词搜索"><a href="#第79题-单词搜索" class="headerlink" title="第79题 单词搜索"></a>第79题 单词搜索</h3><p><img src="79.png" alt="第79题 单词搜索"></p><h4 id="思路-43"><a href="#思路-43" class="headerlink" title="思路:"></a>思路:</h4><p>DFS模板题，剑指Offer原题，基本思路就是从每一个单元格开始向上下左右四个方向递归深搜，如果当前单元格不越界且匹配，那么继续搜索下一个字符。考虑到不能搜索重复的单元格，需要使用visited矩阵进行判断，并对其回溯。为了减少空间复杂度，可以原地修改board为visited。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exist</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>            <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index<span class="token operator">==</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> index<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span>word<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>                    tmp<span class="token punctuation">,</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token boolean">False</span>                    <span class="token keyword">if</span> dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> dfs<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token number">-1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> dfs<span class="token punctuation">(</span>row<span class="token number">-1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">True</span>                    board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span>tmp            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-3-31（2-hard）"><a href="#2020-3-31（2-hard）" class="headerlink" title="2020.3.31（2 hard）"></a>2020.3.31（2 hard）</h2><h3 id="第84题-柱状图中最大的矩形"><a href="#第84题-柱状图中最大的矩形" class="headerlink" title="第84题 柱状图中最大的矩形"></a>第84题 <a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">柱状图中最大的矩形</a></h3><p><img src="84.png" alt="第84题 柱状图中最大的矩形"></p><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>由于矩形的面积和区间内最小高度的柱子有关，我们先尝试基本做法动态规划，DP求解数组中每一个区间的最小高度，然后乘以区间的宽度，尝试更新当前最大面积。尝试后发现超时，时间复杂度为$O(n^2)$。</p><p>为了减少时间复杂度，我们可以尝试分治法。通过观察，可以发现，最大面积矩形存在于以下几种情况：</p><ol><li><p>确定了最矮柱子以后，矩形的宽尽可能往两边延伸。</p></li><li><p>在最矮柱子左边的最大面积矩形（子问题）。</p></li><li><p>在最矮柱子右边的最大面积矩形（子问题）。</p></li></ol><p>找到了划分子问题的方法，我们可以尝试分治算法求解。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> heights<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> left<span class="token operator">></span>right <span class="token operator">or</span> left<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">or</span> right<span class="token operator">>=</span>len<span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            tmp<span class="token operator">=</span>heights<span class="token punctuation">[</span>left<span class="token punctuation">:</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>            min_height<span class="token operator">=</span>min<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>            min_pos<span class="token operator">=</span>tmp<span class="token punctuation">.</span>index<span class="token punctuation">(</span>min_height<span class="token punctuation">)</span><span class="token operator">+</span>left            <span class="token keyword">return</span> max<span class="token punctuation">(</span>min_height<span class="token operator">*</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>max<span class="token punctuation">(</span>recur<span class="token punctuation">(</span>left<span class="token punctuation">,</span>min_pos<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>recur<span class="token punctuation">(</span>min_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> recur<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而，我们发现，虽然分治法的平均时间复杂度为$O(nlogn)$，但依然存在着缺陷，即假如数组有序，那么分治法将退化为暴力算法，时间复杂度为$O(n^2)$。</p><p>为了进一步优化，我们需要尝试以空间换时间的算法。我们知道，这道题还有一种暴力的思路，就是类似于最小回文子串问题的中心扩展法，即“ 依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度多少。 ”</p><p><img src="84-2.png" alt="暴力求解"></p><p>这个算法的核心思想是找到每个高度的柱子左侧和右侧的第一个高度小于它的柱子，利用他们所夹的区间和当前柱子的高度即可得到当前高度的矩形的最大面积。时间复杂度为$O(n^2)$。</p><p>那么有没有办法优化它呢？我们可以使用一个单调栈来解决这个问题。</p><ul><li>栈中存放当前高度数组的下标，并在当前高度数组的两端增加高度为0的哨兵，以减少判断。</li><li>遍历高度数组，维持当前栈的非递减性。如果当前高度小于栈顶下标的高度，那么说明栈顶元素必然被当前高度和之前某个高度夹在中间，根据我们之前的中心扩散算法，可以得到该栈顶元素代表的高度的矩阵的最大面积。具体的做法是：栈顶元素不断出栈，查看它出栈后的栈顶元素是否小于它，小于则找到了左边界，然后利用我们当前遍历到的高度作为右边界，计算当前矩阵最大面积，尝试更新结果。</li><li>继续上述过程，直到当前高度大于或等于栈顶下标高度，此时，将当前高度入栈，继续向前并遍历。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> heights<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        heights<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>heights<span class="token operator">+</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#引入哨兵</span>        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>heights<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#此时栈顶下标高度的矩形的面积可被确定</span>                now<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">while</span> heights<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">==</span>heights<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#寻找左边界，即第一个小于栈顶元素的高度</span>                    stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                res<span class="token operator">=</span>max<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">-</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>heights<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#更新结果</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#当前下标入栈（为什么是下标，因为我们要计算矩形的宽度）</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$，每个元素都要出栈、入栈各一次。</li><li>空间复杂度：$O(n)$，维护一个单调栈。</li></ul><h3 id="85题-最大矩形"><a href="#85题-最大矩形" class="headerlink" title="85题 最大矩形"></a>85题 <a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">最大矩形</a></h3><p><img src="85.png" alt="第85题 最大矩形"></p><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><p>基本思路是将求解矩阵中的最大矩形转化为84题中的柱状图中的最大矩形，然后再使用84题的单调栈方法求解。对于矩阵的每一个位置，我们可以求解其位置上“1”的高度，然后对于矩阵中的每一行，我们可以计算出当前行上”1“矩阵的最大面积，并尝试更新结果。</p><ul><li>时间复杂度：$O(MN)$，计算高度时遍历一次矩阵，计算最大面积时再遍历一次矩阵，共2MN次。</li><li>空间复杂度：$O(N)$，每一次求解每行的最大面积时，需要使用一个与列数大小相等的单调栈。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maximalRectangle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">getLargestArea</span><span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token punctuation">:</span>            heights<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>heights<span class="token operator">+</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            res<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>heights<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    now<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>heights<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">==</span>heights<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                    res<span class="token operator">=</span>max<span class="token punctuation">(</span>heights<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">-</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">return</span> res        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>int<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span> <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'0'</span> <span class="token keyword">else</span> <span class="token number">1</span><span class="token operator">+</span>matrix<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>            res<span class="token operator">=</span>max<span class="token punctuation">(</span>getLargestArea<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-1-（3-medium）"><a href="#2020-4-1-（3-medium）" class="headerlink" title="2020.4.1 （3 medium）"></a>2020.4.1 （3 medium）</h2><h3 id="94题-二叉树的中序遍历"><a href="#94题-二叉树的中序遍历" class="headerlink" title="94题 二叉树的中序遍历"></a>94题 <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></h3><p><img src="94.png" alt="第94题"></p><h5 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h5><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="非递归解法"><a href="#非递归解法" class="headerlink" title="非递归解法"></a>非递归解法</h5><p>思路：使用辅助栈。只要弄懂了递归的过程，就可以使用栈来模拟。</p><p>每到一个节点 A，因为根的访问在中间，将 A 入栈。然后遍历左子树，接着访问 A，最后遍历右子树。在访问完 A 后，A 就可以出栈了。因为 A 和其左子树都已经访问完成。</p><p>二叉树的先序、中序、后序遍历的非递归解法都是使用一个辅助栈来暂存需要回过头来访问的节点，从而代替递归函数的返回过程。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        p<span class="token operator">=</span>root        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">or</span> stack<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历左子树，不断将当前节点入栈，因为要遍历完左子树才能访问</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>left            p<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#遍历完左子树后，取出栈顶元素，进行访问</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>right<span class="token comment" spellcheck="true">#继续遍历右子树</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(N)$，所有节点各入栈出栈一次。</li><li>空间复杂度：$O(N)$，最坏情况下需要大小为N的辅助栈。</li></ul><h3 id="144题-二叉树的前序遍历"><a href="#144题-二叉树的前序遍历" class="headerlink" title="144题 二叉树的前序遍历"></a>144题 <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历</a></h3><p><img src="144.png" alt="第144题"></p><h5 id="递归解法-1"><a href="#递归解法-1" class="headerlink" title="递归解法"></a>递归解法</h5><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        preorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="非递归解法-1"><a href="#非递归解法-1" class="headerlink" title="非递归解法"></a>非递归解法</h5><p>思路：依然使用辅助栈，先将当前节点的右孩子入栈保存，然后访问当前节点，接着遍历当前节点的左孩子。遍历完左子树后，继续遍历右子树。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        p<span class="token operator">=</span>root        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">or</span> stack<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#先访问当前节点</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#暂存右孩子至栈中，等遍历完左子树开始访问</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>left<span class="token comment" spellcheck="true">#遍历左孩子</span>            p<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#遍历完左子树后，开始遍历右子树</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="145题-二叉树的后序遍历"><a href="#145题-二叉树的后序遍历" class="headerlink" title="145题 二叉树的后序遍历"></a>145题 二叉树的后序遍历</h3><p><img src="145.png" alt="第145题"></p><h5 id="递归解法-2"><a href="#递归解法-2" class="headerlink" title="递归解法"></a>递归解法</h5><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>                postorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                postorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        postorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="非递归解法-2"><a href="#非递归解法-2" class="headerlink" title="非递归解法"></a>非递归解法</h5><p>思路：我们知道，二叉树的后序遍历是“左-右-根”，而二叉树的逆前序遍历是“右-左-根”，所以我们可以使用辅助栈实现二叉树的逆前序遍历后，再将结果翻转，即为后序遍历。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        p<span class="token operator">=</span>root        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">or</span> stack<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>right            p<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-2-（2-medium-1easy）"><a href="#2020-4-2-（2-medium-1easy）" class="headerlink" title="2020.4.2 （2 medium 1easy）"></a>2020.4.2 （2 medium 1easy）</h2><h3 id="96题-不同的二叉搜索树"><a href="#96题-不同的二叉搜索树" class="headerlink" title="96题 不同的二叉搜索树"></a>96题 <a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">不同的二叉搜索树</a></h3><p><img src="96.png" alt="第96题"></p><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><p>动态规划求解，DFS太耗费时间。我们设状态矩阵DP[i]为1..i为节点的二叉搜索树的数目，f[i]为以i为根节点的二叉搜索树数目，则有：</p><ul><li>DP[i]=f[1]+f[2]+…+f[i]，即计算以1到i的每个节点为根节点的二叉搜索树数目之和。</li><li>f[j]=DP[j-1]*DP[i-j]，即以j为根节点的二叉搜索树，左侧有j-1个节点，右侧有i-j个节点，又因为j+1到i为节点的二叉搜索树数目与1到i-j的二叉搜索树一致，所以可以用DP[i-j]来代替。则左右两边子树组合数目为DP[j-1]乘以DP[i-j]。</li><li>则动态规划转移方程为：DP[i]=DP[0] <em> DP[i-1]+DP[1] </em> DP[i-2]+…+DP[i] * DP[0]</li><li>这个动态规划方程在数学上有一个名字，叫做“卡特兰数”</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token comment" spellcheck="true">#注意，这里的0个数组成的二叉搜索树数目为1，这是因为左子树为空也合法。</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>dp<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="98题-验证二叉搜索树"><a href="#98题-验证二叉搜索树" class="headerlink" title="98题 验证二叉搜索树"></a>98题 <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a></h3><p><img src="98.png" alt="第98题"></p><h4 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h4><p>我们知道，如果我们中序遍历二叉搜索树，那么得到的序列必然是递增的，我们就可以通过这一性质验证二叉搜索树。我们中序遍历二叉搜索树，并且记录下当前中序遍历得到的序列的最后一个元素值，如果当前元素值大于它，说明满足二叉搜索树的性质，可以继续递归判断。如果非递增了，就返回False。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>last_value<span class="token operator">=</span>None        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#我们认为空子树是二叉搜索树，方便递归</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历左子树，看是否满足递增</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>last_value<span class="token operator">==</span>None <span class="token operator">or</span> root<span class="token punctuation">.</span>val<span class="token operator">></span>self<span class="token punctuation">.</span>last_value<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#看当前节点是否满足递增</span>                    self<span class="token punctuation">.</span>last_value<span class="token operator">=</span>root<span class="token punctuation">.</span>val                    <span class="token keyword">if</span> inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#看右子树是否满足递增</span>                        <span class="token keyword">return</span> <span class="token boolean">True</span><span class="token comment" spellcheck="true">#如果左中右都满足，返回True</span>            <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token comment" spellcheck="true">#如果有一项不满足，返回False</span>        <span class="token keyword">return</span> inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="101题-对称二叉树"><a href="#101题-对称二叉树" class="headerlink" title="101题 对称二叉树"></a>101题 <a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">对称二叉树</a></h3><p><img src="101.png" alt="第101题"></p><h4 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer类似题，递归求解法，我们知道，两个节点对称的条件为：</p><ol><li>两个节点均为空。</li><li>两个节点均不为空，且节点a的值等于节点b的值，且节点a的左子树和节点b的右子树镜像，节点b的左子树和节点a的右子树镜像。</li></ol><p>当根节点非空时，我们递归判断左右子树是否对称即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> a<span class="token operator">==</span>None <span class="token operator">and</span> b<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> a<span class="token operator">!=</span>None <span class="token operator">and</span> b<span class="token operator">!=</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> a<span class="token punctuation">.</span>val<span class="token operator">==</span>b<span class="token punctuation">.</span>val <span class="token operator">and</span> match<span class="token punctuation">(</span>a<span class="token punctuation">.</span>left<span class="token punctuation">,</span>b<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">and</span> match<span class="token punctuation">(</span>a<span class="token punctuation">.</span>right<span class="token punctuation">,</span>b<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> match<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(n)$。</li></ul><h2 id="2020-4-3-（2-medium-1easy）"><a href="#2020-4-3-（2-medium-1easy）" class="headerlink" title="2020.4.3 （2 medium 1easy）"></a>2020.4.3 （2 medium 1easy）</h2><h3 id="第104题-二叉树的最大深度"><a href="#第104题-二叉树的最大深度" class="headerlink" title="第104题 二叉树的最大深度"></a>第104题 <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a></h3><p><img src="104.png" alt="第104题"></p><h4 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h4><p>数据结构基本题，剑指offer二叉树原题，递归搜索即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第105题-从前序与中序遍历序列构造二叉树"><a href="#第105题-从前序与中序遍历序列构造二叉树" class="headerlink" title="第105题  从前序与中序遍历序列构造二叉树"></a>第105题 <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener"> 从前序与中序遍历序列构造二叉树</a></h3><p><img src="105.png" alt="第105题"></p><h4 id="思路：-10"><a href="#思路：-10" class="headerlink" title="思路："></a>思路：</h4><p>数据结构基本题，剑指offer二叉树原题，分治法即可。</p><ul><li>前序遍历确定当前子树的根节点。</li><li>中序遍历确定左右子树节点数目。</li><li>根据左右子树节点数目，从前序、中序遍历中切分出左、右子树的前序、中序遍历，分治法确定当前节点左右孩子。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>preL<span class="token punctuation">,</span>preR<span class="token punctuation">,</span>inL<span class="token punctuation">,</span>inR<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> preL<span class="token operator">></span>preR <span class="token operator">or</span> inL<span class="token operator">></span>inR<span class="token punctuation">:</span>                <span class="token keyword">return</span> None            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preL<span class="token punctuation">]</span><span class="token punctuation">)</span>            in_pos<span class="token operator">=</span>inorder<span class="token punctuation">[</span>inL<span class="token punctuation">:</span>inR<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preL<span class="token punctuation">]</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>left<span class="token operator">=</span>build<span class="token punctuation">(</span>preL<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>preL<span class="token operator">+</span>in_pos<span class="token punctuation">,</span>inL<span class="token punctuation">,</span>inL<span class="token operator">+</span>in_pos<span class="token number">-1</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>build<span class="token punctuation">(</span>preL<span class="token operator">+</span>in_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>preR<span class="token punctuation">,</span>inL<span class="token operator">+</span>in_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>inR<span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token keyword">return</span> build<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>preorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>inorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第114题-二叉树展开为链表"><a href="#第114题-二叉树展开为链表" class="headerlink" title="第114题 二叉树展开为链表"></a>第114题 <a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表</a></h3><p><img src="114.png" alt="第114题"></p><h4 id="思路：-11"><a href="#思路：-11" class="headerlink" title="思路："></a>思路：</h4><p>我自己的方法有些类似于剑指Offer中的二叉树转双向链表。</p><ul><li>使用一个全局变量tail作为指针，指向当前已生成链表中的最后一个节点。</li><li>先序遍历二叉树，每次修改tail指针的左节点为当前节点，即使用left指针模拟链表的next指针。</li><li>调整链表，使用right指针模拟next指针，并将left指针置空。（为什么不直接用right指针模拟？因为先序遍历是根-左-右的顺序，对左孩子的遍历可能导致根节点的right指针被覆盖，导致无法继续遍历右孩子）</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">flatten</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify root in-place instead.        """</span>        self<span class="token punctuation">.</span>tail<span class="token operator">=</span>None        <span class="token keyword">def</span> <span class="token function">flat</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>tail<span class="token operator">!=</span>None<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>left<span class="token operator">=</span>root            self<span class="token punctuation">.</span>tail<span class="token operator">=</span>root            flat<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            flat<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">change</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token operator">=</span>None<span class="token punctuation">,</span>root<span class="token punctuation">.</span>left            change<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                 flat<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        change<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(n)$。</li></ul><h2 id="2020-4-4-（2-hard-1easy）"><a href="#2020-4-4-（2-hard-1easy）" class="headerlink" title="2020.4.4 （2 hard 1easy）"></a>2020.4.4 （2 hard 1easy）</h2><h3 id="124题-二叉树中的最大路径和"><a href="#124题-二叉树中的最大路径和" class="headerlink" title="124题  二叉树中的最大路径和"></a>124题 <a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener"> 二叉树中的最大路径和</a></h3><p><img src="124.png" alt="第124题"></p><h4 id="思路：-12"><a href="#思路：-12" class="headerlink" title="思路："></a>思路：</h4><p>我的思路是递归求解，先给出代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>max_sum<span class="token operator">=</span>root<span class="token punctuation">.</span>val        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            left_sum<span class="token operator">=</span>max<span class="token punctuation">(</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>            right_sum<span class="token operator">=</span>max<span class="token punctuation">(</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>            now_path_sum<span class="token operator">=</span>root<span class="token punctuation">.</span>val<span class="token operator">+</span>left_sum<span class="token operator">+</span>right_sum            self<span class="token punctuation">.</span>max_sum<span class="token operator">=</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>max_sum<span class="token punctuation">,</span>now_path_sum<span class="token punctuation">)</span>            <span class="token keyword">return</span> root<span class="token punctuation">.</span>val<span class="token operator">+</span>max<span class="token punctuation">(</span>left_sum<span class="token punctuation">,</span>right_sum<span class="token punctuation">)</span>        recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>max_sum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果当前节点为空，我们的递归函数返回0，表示经过该节点的最大路径和为0。</p><p>接着我们递归计算左子树和右子树，如果递归函数返回值大于0，说明加上它有可能会使当前节点路径和变大，否则不走路径和小于0的子树。</p><p>当前节点的最大路径和即为当前节点的值加上左子树和0的最大值加上右子树和0的最大值，加上后即可尝试更新当前二叉树的最大路径和。</p><p>接下来是进行返回，也是本题中最容易出错的地方！返回值不是当前节点的最大路径和，而是只能走一边的子树，因为二叉树的节点不能被重复访问！</p><h3 id="128题-最长连续序列"><a href="#128题-最长连续序列" class="headerlink" title="128题  最长连续序列"></a>128题 <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener"> 最长连续序列</a></h3><p><img src="128.png" alt="第128题"></p><h4 id="思路：-13"><a href="#思路：-13" class="headerlink" title="思路："></a>思路：</h4><p>我们先从暴力算法想起，暴力算法的做法是遍历数组中的每一个数，查看他的下一个数是否在数组中，如果在，那么就再查看下一个数，直到出现不在数组中的数，记录下当前长度并尝试更新最大长度。由于数组无序，所以每次查找都需要$O(n)$的时间复杂度，最坏情况下（即数组降序），需要的时间复杂度为$O(n^3)$。</p><p>为了优化至$O(n)$的时间复杂度，首先，我们可以建立辅助的数据结构——哈希表。这里，我们使用哈希集合，hashset和hashmap的区别在于，hashset只存key不存value，而hashmap存了键值对。我们知道，哈希集合的查找时间复杂度仅需$O(1)$（直接哈希函数），所以此时的时间复杂度已经降为$O(n^2)$。</p><p>为了进一步优化，我们进行剪枝操作，当我们访问到num，假如num-1已经在hashset中，那么我们就不对他进行向后搜索。即：我们现在只对序列开头的数进行向后搜索。因为我们使用的是hashset，所以判断num-1是否存在依然很快。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        hashset<span class="token operator">=</span>set<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        first_num<span class="token operator">=</span><span class="token number">0</span>        max_length<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> num<span class="token number">-1</span> <span class="token operator">not</span> <span class="token keyword">in</span> hashset<span class="token punctuation">:</span>                length<span class="token operator">=</span><span class="token number">1</span>                <span class="token keyword">while</span> num<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">in</span> hashset<span class="token punctuation">:</span>                    num<span class="token operator">+=</span><span class="token number">1</span>                    length<span class="token operator">+=</span><span class="token number">1</span>                max_length<span class="token operator">=</span>max<span class="token punctuation">(</span>length<span class="token punctuation">,</span>max_length<span class="token punctuation">)</span>        <span class="token keyword">return</span> max_length<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(n)$。</li></ul><h3 id="136题-只出现一次的数字"><a href="#136题-只出现一次的数字" class="headerlink" title="136题 只出现一次的数字"></a>136题 <a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">只出现一次的数字</a></h3><p><img src="136.png" alt="第136题"></p><h4 id="思路：-14"><a href="#思路：-14" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，异或运算，一个数异或自身为0，异或0为自身。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        result<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            result<span class="token operator">^</span><span class="token operator">=</span>num        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-5-（2-medium-1easy）"><a href="#2020-4-5-（2-medium-1easy）" class="headerlink" title="2020.4.5 （2 medium 1easy）"></a>2020.4.5 （2 medium 1easy）</h2><h3 id="139题-单词拆分"><a href="#139题-单词拆分" class="headerlink" title="139题 单词拆分"></a>139题 <a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">单词拆分</a></h3><p><img src="139.png" alt="第139题"></p><h4 id="思路：-15"><a href="#思路：-15" class="headerlink" title="思路："></a>思路：</h4><p>这类题最常见的解法就是动态规划法了。类似的问题还有：正则表达式匹配等。</p><p>我在一开始却尝试了DFS，递归超时了。<strong>类似的题目是不能用DFS的！必然超时！希望自己以后能记住这个教训！因为这道题存在着重叠子问题，就像走迷宫问题一样，假设字符串s的前 i 个字符的匹配可以通过多条路径得到，那么它们从第 i 个字符往后的路径都是相同的，如果使用递归，由于无法记录递归过程中的状态，会产生大量的重复计算。</strong>解决的方案可以是带备忘录的递归，但动态规划显然更加有效。</p><p>我们使用DP求解。DP状态矩阵dp[i]为s的前i个字符是否匹配。转移方程为：遍历wordDict中的word，dp[i]=dp[i-len（word）]（if i-len（word）&gt;=0 and dp[i-len（word）] and s[i-len（word）:i]==word）。即假如前i个字符的末尾存在wordDict中的某个单词，且去除该单词后，前i-len（word）个字符也能拆分，说明前i个字符可以被拆分。</p><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> wordDict<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        sorted<span class="token punctuation">(</span>wordDict<span class="token punctuation">,</span>key<span class="token operator">=</span>len<span class="token punctuation">,</span>reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> word <span class="token keyword">in</span> wordDict<span class="token punctuation">:</span>                start<span class="token operator">=</span>i<span class="token operator">-</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span>                <span class="token keyword">if</span> start<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> dp<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>start<span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token operator">==</span>word<span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                    <span class="token keyword">break</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="141题-环形链表"><a href="#141题-环形链表" class="headerlink" title="141题 环形链表"></a>141题 <a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表</a></h3><p><img src="141.png" alt="第141题"></p><h4 id="思路：-16"><a href="#思路：-16" class="headerlink" title="思路："></a>思路：</h4><p>hashset存放已经访问过的节点，遍历链表，如果访问到已存在hashset中的节点时，返回True，即存在环，否则将当前节点加入hashset，继续向前遍历。</p><ul><li>时间复杂度：$O(n)$，哈希表的查找为$O(1)$</li><li>空间复杂度：$O(n)$</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        nodes<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        p<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> p <span class="token keyword">in</span> nodes<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            nodes<span class="token punctuation">.</span>add<span class="token punctuation">(</span>p<span class="token punctuation">)</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了更进一步的优化时间复杂度和空间复杂度，我们可以原地修改链表，对访问过的节点的值设为”visited“，如果遍历到已访问节点，return True。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        p<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>val<span class="token operator">==</span><span class="token string">"visited"</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            p<span class="token punctuation">.</span>val<span class="token operator">=</span><span class="token string">"visited"</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h3 id="142题-环形链表-II"><a href="#142题-环形链表-II" class="headerlink" title="142题 环形链表 II"></a>142题 <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">环形链表 II</a></h3><p><img src="142.png" alt="第142题"></p><p>这道题要求我们不能原地修改链表，所以141题中的第二种方法就不能使用，只能使用哈希集合的方法。但是，有没有方法能够不使用额外的数据结构呢？</p><p>我们可以使用Floyd算法，采用快慢指针的做法求出环形链表的环入口节点。</p><ul><li>定义双指针fast、slow，均指向head节点。</li><li>fast、slow向前遍历，fast每次走两步，slow每次走一步。</li><li>假如fast走到了None，说明链表无环，直接返回None。</li><li>否则，fast和slow必然会在环中的某一个节点处相遇，此时，fast节点走过的路程为f，slow节点走过的路程为s，环的长度为b，则必有：（1）f=2s（因为快指针每次走两步，慢指针走一步，快指针的路程必然是慢指针的两倍），（2）f=s+nb（要想相遇，快指针必然比慢指针多走了n圈）。二者相减，得：s=nb，f=2nb。</li><li>我们知道，想要从起点走到环入口，需要走a+nb，其中，a是指从链表起点到环入口的步数，nb为在环中转圈的步数。所以，我们已有：s=nb，只要让慢指针再走a步，即可到达环入口节点。</li><li>我们可以移动fast到头节点，让快指针和慢指针每次都走一步，最终，快慢指针将在环入口处相遇，此时:f=a,s=a+nb。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        fast<span class="token operator">=</span>head        slow<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> fast<span class="token operator">==</span>None <span class="token operator">or</span> fast<span class="token punctuation">.</span>next<span class="token operator">==</span>None <span class="token operator">or</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> None            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next            <span class="token keyword">if</span> fast<span class="token operator">==</span>slow<span class="token punctuation">:</span>                <span class="token keyword">break</span>        fast<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token operator">!=</span>slow<span class="token punctuation">)</span><span class="token punctuation">:</span>            fast<span class="token punctuation">,</span>slow<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">,</span>slow<span class="token punctuation">.</span>next        <span class="token keyword">return</span> slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="2020-4-6-（3-medium）"><a href="#2020-4-6-（3-medium）" class="headerlink" title="2020.4.6 （3 medium）"></a>2020.4.6 （3 medium）</h2><h3 id="146题-LRU缓存机制"><a href="#146题-LRU缓存机制" class="headerlink" title="146题 LRU缓存机制"></a>146题 <a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LRU缓存机制</a></h3><p><img src="146.png" alt="第146题"></p><h4 id="思路：-17"><a href="#思路：-17" class="headerlink" title="思路："></a>思路：</h4><p>基本思路是使用一个类似于队列的数据结构，我们将最近使用的键值对放置到队首，这样队尾键值对必然是最近最少使用的。当添加新的键值对，而缓存已满时，我们需要将队尾的键值对出队，并将新的键值对添加到队首，从而实现了LRU缓存机制。</p><p>特别地，题目要求我们使用$O(1)$级别的时间复杂度，我们很容易便想到了哈希表，其查找节点的时间复杂度为$O(1)$（类似于为链表中的节点建立索引）。更进一步，我们需要修改原先的队列为双向链表，因为只有双向链表可以保证删除节点的时间复杂度在$O(1)$，而我们需要在以下两种情况进行删除节点操作（插入节点都是在头部，均为$O(1)$：</p><ul><li>当我们需要进行get操作时，需要将被访问的键值对的节点移动到双向链表开头，需要先删除，再插入。</li><li>当我们需要进行put操作，而缓存已满时，需要将尾部键值对删除。</li></ul><p>所以，使用双向链表是必要的。特别地，为了减少插入、删除过程中的额外判断，我们使用链表中经常需要用到的伪头节点和伪尾节点。（如果直接使用字典，虽然python3中dictionary是有序的，但无法选择插入的位置）</p><p>算法的基本流程如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// key 映射到 Node(key, val)</span>HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Node<span class="token operator">></span> map<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Node(k1, v1) &lt;-> Node(k2, v2)...</span>DoubleList cache<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key 不存在<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                将数据 <span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> 提到开头；        <span class="token keyword">return</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key 已存在<span class="token punctuation">)</span> <span class="token punctuation">{</span>        把旧的数据删除；        将新节点 x 插入到开头；    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cache 已满<span class="token punctuation">)</span> <span class="token punctuation">{</span>            删除链表的最后一个数据腾位置；            删除 map 中映射到该数据的键；        <span class="token punctuation">}</span>         将新节点 x 插入到开头；        map 中新建 key 对新节点 x 的映射；    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们自己实现双向链表、节点、以及调整节点至开头，插入节点至开头，删除尾部节点操作后，完整的代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>key<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>key<span class="token operator">=</span>key        self<span class="token punctuation">.</span>val<span class="token operator">=</span>val        self<span class="token punctuation">.</span>next<span class="token operator">=</span>None        self<span class="token punctuation">.</span>prev<span class="token operator">=</span>None<span class="token keyword">class</span> <span class="token class-name">LinkedList</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>head<span class="token operator">=</span>Node<span class="token punctuation">(</span>None<span class="token punctuation">,</span>None<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>tail<span class="token operator">=</span>Node<span class="token punctuation">(</span>None<span class="token punctuation">,</span>None<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token operator">=</span>self<span class="token punctuation">.</span>tail        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev<span class="token operator">=</span>self<span class="token punctuation">.</span>head    <span class="token keyword">def</span> <span class="token function">move_to_head</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>        node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next<span class="token operator">=</span>node<span class="token punctuation">.</span>next        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev<span class="token operator">=</span>node<span class="token punctuation">.</span>prev        node<span class="token punctuation">.</span>prev<span class="token operator">=</span>self<span class="token punctuation">.</span>head        node<span class="token punctuation">.</span>next<span class="token operator">=</span>self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token operator">=</span>node        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev<span class="token operator">=</span>node        <span class="token keyword">return</span> node<span class="token punctuation">.</span>val    <span class="token keyword">def</span> <span class="token function">add_to_head</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>        node<span class="token punctuation">.</span>prev<span class="token operator">=</span>self<span class="token punctuation">.</span>head        node<span class="token punctuation">.</span>next<span class="token operator">=</span>self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token operator">=</span>node        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev<span class="token operator">=</span>node    <span class="token keyword">def</span> <span class="token function">pop_tail</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        node<span class="token operator">=</span>self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev        node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next<span class="token operator">=</span>self<span class="token punctuation">.</span>tail        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev<span class="token operator">=</span>node<span class="token punctuation">.</span>prev        <span class="token keyword">return</span> node<span class="token punctuation">.</span>key<span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> capacity<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>capacity<span class="token operator">=</span>capacity        self<span class="token punctuation">.</span>hashmap<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        self<span class="token punctuation">.</span>length<span class="token operator">=</span><span class="token number">0</span>        self<span class="token punctuation">.</span>linkedlist<span class="token operator">=</span>LinkedList<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>hashmap<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>move_to_head<span class="token punctuation">(</span>self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">put</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">:</span> int<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>hashmap<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>val<span class="token operator">=</span>value            self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>move_to_head<span class="token punctuation">(</span>self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> self<span class="token punctuation">.</span>length<span class="token operator">&lt;</span>self<span class="token punctuation">.</span>capacity<span class="token punctuation">:</span>            node<span class="token operator">=</span>Node<span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>add_to_head<span class="token punctuation">(</span>node<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span>node            self<span class="token punctuation">.</span>length<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            node<span class="token operator">=</span>Node<span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>            key_del<span class="token operator">=</span>self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>pop_tail<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>hashmap<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>key_del<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>add_to_head<span class="token punctuation">(</span>node<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span>node<span class="token comment" spellcheck="true"># Your LRUCache object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = LRUCache(capacity)</span><span class="token comment" spellcheck="true"># param_1 = obj.get(key)</span><span class="token comment" spellcheck="true"># obj.put(key,value)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后总结一下，我们维护一个链表，链表中数据从前至后依次为上次使用时间从近至远。为了减低时间复杂度，我们使用双向链表和哈希表减少调整链表所花费的时间。</p><h3 id="148题-排序链表"><a href="#148题-排序链表" class="headerlink" title="148题 排序链表"></a>148题 <a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">排序链表</a></h3><p><img src="148.png" alt="第148题"></p><h4 id="思路-44"><a href="#思路-44" class="headerlink" title="思路:"></a>思路:</h4><p>由于时间复杂度需要在$O(nlogn)$，所以可用的算法有：归并排序，快速排序，堆排序等。考虑到合并链表比较方便，所以我们在这里选用归并排序。</p><p>与常规的归并排序类似，我们进行递归合并。先调用自身函数归并排序左半部分和右半部分，再调用合并两个有序链表的函数归并左右部分。</p><p>这里需要注意的是，当前需要排序的是链表而非数组，所以我们无法通过下标运算直接得到中间节点，对当前链表进行二分划分。假如我们直接遍历链表得到长度再遍历长度的一半找到中间节点，则时间复杂度为$O(3n/2)$。为了优化，我们可以使用快慢指针法。让快指针每次走两步，慢指针每次走一步，当快指针走到链表终点时，慢指针必然位于中间节点。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">getMiddle</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> head<span class="token operator">==</span>None <span class="token operator">or</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> head            slow<span class="token operator">=</span>head            fast<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token operator">!=</span>None <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next                fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            <span class="token keyword">return</span> slow        <span class="token keyword">def</span> <span class="token function">mergeTwoList</span><span class="token punctuation">(</span>head1<span class="token punctuation">,</span>head2<span class="token punctuation">)</span><span class="token punctuation">:</span>            dummyhead<span class="token operator">=</span>ListNode<span class="token punctuation">(</span>None<span class="token punctuation">)</span>            p1<span class="token operator">=</span>dummyhead            p2<span class="token operator">=</span>head1            p3<span class="token operator">=</span>head2            <span class="token keyword">while</span> <span class="token punctuation">(</span>p2<span class="token operator">!=</span>None <span class="token operator">and</span> p3<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> p2<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>p3<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                    p1<span class="token punctuation">.</span>next<span class="token operator">=</span>p2                    p2<span class="token operator">=</span>p2<span class="token punctuation">.</span>next                    p1<span class="token operator">=</span>p1<span class="token punctuation">.</span>next                <span class="token keyword">else</span><span class="token punctuation">:</span>                    p1<span class="token punctuation">.</span>next<span class="token operator">=</span>p3                    p3<span class="token operator">=</span>p3<span class="token punctuation">.</span>next                    p1<span class="token operator">=</span>p1<span class="token punctuation">.</span>next            p1<span class="token punctuation">.</span>next<span class="token operator">=</span>p2 <span class="token keyword">if</span> p2<span class="token operator">!=</span>None <span class="token keyword">else</span> p3            <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next        <span class="token keyword">if</span> head<span class="token operator">==</span>None <span class="token operator">or</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        mid<span class="token operator">=</span>getMiddle<span class="token punctuation">(</span>head<span class="token punctuation">)</span>        tmp<span class="token operator">=</span>mid<span class="token punctuation">.</span>next        mid<span class="token punctuation">.</span>next<span class="token operator">=</span>None        head1<span class="token operator">=</span>self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>head<span class="token punctuation">)</span>        head2<span class="token operator">=</span>self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>        <span class="token keyword">return</span> mergeTwoList<span class="token punctuation">(</span>head1<span class="token punctuation">,</span>head2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="152题-乘积最大子数组"><a href="#152题-乘积最大子数组" class="headerlink" title="152题 乘积最大子数组"></a>152题 <a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">乘积最大子数组</a></h3><p><img src="152.png" alt="第152题"></p><h4 id="思路-45"><a href="#思路-45" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划，类似于最大连续子序和问题。我们使用dp[i]表示前i个数字中子数组的最大乘积。动态规划转移方程为：</p><blockquote><p>maxDP[i + 1] = max(maxDP[i] <em> A[i + 1], A[i + 1],minDP[i] </em> A[i + 1])<br>minDP[i + 1] = min(minDP[i] <em> A[i + 1], A[i + 1],maxDP[i] </em> A[i + 1])<br>dp[i + 1] = max(dp[i], maxDP[i + 1])</p></blockquote><p>在这里，maxDP[i] 是以第i个数字结尾的子数组的最大乘积，minDP[i]是以第i个数字结尾的子数组的最小乘积。之所以我们需要保留最小乘积，是因为考虑到第i+1个数字是负数的情况。</p><p>由于我们发现，所有的动态规划转移方程都只需要用到前一个状态，所以我们只需要使用三个变量即可代替状态矩阵（滚动数组法优化DP空间的思想）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProduct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        imax<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        imin<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        max_product<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>                imax<span class="token punctuation">,</span>imin<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>imin<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>imax<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                imax<span class="token punctuation">,</span>imin<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>imax<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>imin<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            max_product<span class="token operator">=</span>max<span class="token punctuation">(</span>imax<span class="token punctuation">,</span>max_product<span class="token punctuation">)</span>        <span class="token keyword">return</span> max_product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，imax和imin必须同步更新，因为imin的更新需要使用到imax的值，如果imax的值先被改变，结果将出错。</p><h2 id="2020-4-7-（4-easy）"><a href="#2020-4-7-（4-easy）" class="headerlink" title="2020.4.7 （4 easy）"></a>2020.4.7 （4 easy）</h2><h3 id="155题-最小栈"><a href="#155题-最小栈" class="headerlink" title="155题 最小栈"></a>155题 <a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">最小栈</a></h3><p><img src="155.png" alt="第155题"></p><h4 id="思路：-18"><a href="#思路：-18" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，我们可以使用一个辅助栈，存放栈内前i个元素中的最小值，以空间换时间。</p><ul><li>时间复杂度：$O(1)$。</li><li>空间复杂度：$O(n)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MinStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>stack1<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>stack2<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack2<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>min<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">getMin</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Your MinStack object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MinStack()</span><span class="token comment" spellcheck="true"># obj.push(x)</span><span class="token comment" spellcheck="true"># obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.top()</span><span class="token comment" spellcheck="true"># param_4 = obj.getMin()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="160题-相交链表"><a href="#160题-相交链表" class="headerlink" title="160题 相交链表"></a>160题 <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">相交链表</a></h3><p><img src="160.png" alt="第160题"></p><h4 id="思路：-19"><a href="#思路：-19" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，我们最容易想到的方法是采用哈希表的方式，记录下A、B链表中的每一个节点，找到第一个重复的节点返回。但有没有方法可以不使用额外的空间呢？答案是有的，我们可以使用双指针法，这有些类似于环形链表142题。</p><p>我们创建指针p指向headA，指针q指向headB，使二者向前遍历链表A和B。当p遍历到链表A结尾时，令p=headB，当q遍历到链表B结尾时，令q=headA。如果链表A和链表B存在相交点时，p和q继续向后遍历，必然会在相交点处相等。如果不存在相交点，p和q继续向后遍历，必然会同时遍历到链表结尾。</p><p>原理：</p><p><img src="160-1.png" alt="第160题示意图"></p><p>假如相交，则a+b+c必然等于c+b+a！p指针和q指针在链表相交点处必然走过相同的路程。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> headA<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> headB<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> headA<span class="token operator">==</span>None <span class="token operator">or</span> headB<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        p<span class="token operator">=</span>headA        q<span class="token operator">=</span>headB        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>next<span class="token operator">==</span>None <span class="token operator">and</span> q<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> None            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next <span class="token keyword">if</span> p<span class="token punctuation">.</span>next<span class="token operator">!=</span>None <span class="token keyword">else</span> headB            q<span class="token operator">=</span>q<span class="token punctuation">.</span>next <span class="token keyword">if</span> q<span class="token punctuation">.</span>next<span class="token operator">!=</span>None <span class="token keyword">else</span> headA        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="169题-多数元素"><a href="#169题-多数元素" class="headerlink" title="169题 多数元素"></a>169题 <a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">多数元素</a></h3><p><img src="169.png" alt="第169题"></p><h4 id="思路：-20"><a href="#思路：-20" class="headerlink" title="思路："></a>思路：</h4><p>常规的做法有：（1）哈希表记录各元素出现的次数，选择出现次数最多的元素（时：$O(n)$，空：$O(n)$）（2）排序法，取中值。（时：$O(nlogn)$，空：$O(1)$）</p><p>为了获得最优的时空复杂度，我们还可以使用投票算法：</p><ul><li>如果我们把众数记为 +1，把其他数记为 -1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。 </li><li>我们遍历数组，使用count记录下当前投票和。如果count等于0，那么就更新候选人。接着进行投票，如果当前值等于候选人，count加1，否则count减1。</li><li>投票算法证明：<ol><li>如果候选人不是maj（多数元素） 则 maj,会和其他非候选人一起反对 会反对候选人,所以候选人一定会下台(maj==0时发生换届选举)</li><li>如果候选人是maj , 则maj 会支持自己，其他候选人会反对，同样因为maj 票数超过一半，所以maj 一定会成功当选</li></ol></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        count<span class="token operator">=</span><span class="token number">0</span>        candidate<span class="token operator">=</span>None        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                candidate<span class="token operator">=</span>num            count<span class="token operator">+=</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">if</span> num<span class="token operator">==</span>candidate <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> candidate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><h3 id="198题-打家劫舍"><a href="#198题-打家劫舍" class="headerlink" title="198题 打家劫舍"></a>198题 <a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">打家劫舍</a></h3><p><img src="198.png" alt="第198题"></p><h4 id="思路：-21"><a href="#思路：-21" class="headerlink" title="思路："></a>思路：</h4><p>动态规划模板题，有些类似于01背包问题。动态规划状态矩阵dp[i]用于表示偷前i家的最大金额，转移方程为：</p><ul><li>dp[i]=max（dp[i-1]，dp[i-2]+nums[i]）</li></ul><p>即考虑偷当前这家和不偷当前这家的收益谁更大，选择最大收益。（偷这家就不能偷上一家）</p><p>由于只用到前两个状态，所以我们可以使用滚动数组的思想进行空间优化。</p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        a<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        b<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            a<span class="token punctuation">,</span>b<span class="token operator">=</span>b<span class="token punctuation">,</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>        <span class="token keyword">return</span> b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-8（3-medium-1-easy）"><a href="#2020-4-8（3-medium-1-easy）" class="headerlink" title="2020.4.8（3 medium 1 easy）"></a>2020.4.8（3 medium 1 easy）</h2><h3 id="200题-岛屿数量"><a href="#200题-岛屿数量" class="headerlink" title="200题 岛屿数量"></a>200题 <a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">岛屿数量</a></h3><p><img src="200.png" alt="第200题"></p><h4 id="思路：-22"><a href="#思路：-22" class="headerlink" title="思路："></a>思路：</h4><p>DFS模板题，使用一个visited矩阵来存放某个位置是否已被访问过。</p><p>遍历grid矩阵，每次遇到尚未被访问的岛屿时，将计数变量加1，再使用DFS遍历该岛屿的所有土地，并标记为已访问，访问过的土地或者水域都不会进行访问。这样，将会把该岛屿的所有土地都访问一次，然后终止递归。最后，所有的岛屿将被遍历一次，计数变量的值即为岛屿数。</p><p>特别地，为了减少空间占用，我们还可以原地修改grid矩阵来表示已访问过。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numIslands</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> row<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">or</span> row<span class="token operator">>=</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span> <span class="token operator">or</span> col<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">or</span> col<span class="token operator">>=</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span>            <span class="token keyword">if</span> grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"1"</span><span class="token punctuation">:</span>                grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"0"</span>                dfs<span class="token punctuation">(</span>row<span class="token number">-1</span><span class="token punctuation">,</span>col<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token number">-1</span><span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        islands<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"1"</span><span class="token punctuation">:</span>                    islands<span class="token operator">+=</span><span class="token number">1</span>                    dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span>        <span class="token keyword">return</span> islands<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(mn)$。</li><li>空间复杂度：$O(mn)$，递归栈。</li></ul><p>这道题还可以用<a href="https://blog.csdn.net/qq_41593380/article/details/81146850" target="_blank" rel="noopener">并查集</a>来做。基本思路就是将连同的陆地合并到同一个集合中，最后统计集合数目即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numIslands</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">class</span> <span class="token class-name">UnionFind</span><span class="token punctuation">:</span>            <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>count <span class="token operator">=</span> n                self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">def</span> <span class="token function">get_count</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> self<span class="token punctuation">.</span>count            <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>                now<span class="token operator">=</span>p                <span class="token keyword">while</span> p <span class="token operator">!=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">:</span>                    p <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span>                <span class="token keyword">while</span> now <span class="token operator">!=</span> p<span class="token punctuation">:</span>                    now<span class="token punctuation">,</span>self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">=</span>self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">,</span>p                <span class="token keyword">return</span> p            <span class="token keyword">def</span> <span class="token function">is_connected</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token keyword">def</span> <span class="token function">union</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>                p_root <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span>                q_root <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>                <span class="token keyword">if</span> p_root <span class="token operator">!=</span> q_root<span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>q_root<span class="token punctuation">]</span><span class="token operator">=</span>p_root                    self<span class="token punctuation">.</span>count<span class="token operator">-=</span><span class="token number">1</span>        row <span class="token operator">=</span> len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 特判</span>        <span class="token keyword">if</span> row <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        col <span class="token operator">=</span> len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">get_index</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> x <span class="token operator">*</span> col <span class="token operator">+</span> y        <span class="token comment" spellcheck="true"># 注意：我们不用像 DFS 和 BFS 一样，4 个方向都要尝试，只要看一看右边和下面就可以了</span>        directions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 多开一个空间，把水域 "0" 都归到这个虚拟的老大上</span>        dummy_node <span class="token operator">=</span> row <span class="token operator">*</span> col        <span class="token comment" spellcheck="true"># 多开的一个空间就是那个虚拟的空间</span>        uf <span class="token operator">=</span> UnionFind<span class="token punctuation">(</span>dummy_node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 如果是水域，都连到那个虚拟的空间去</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">:</span>                    uf<span class="token punctuation">.</span>union<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> dummy_node<span class="token punctuation">)</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true"># 向下向右如果都是陆地，即 "1"，就要合并一下</span>                    <span class="token keyword">for</span> direction <span class="token keyword">in</span> directions<span class="token punctuation">:</span>                        new_x <span class="token operator">=</span> i <span class="token operator">+</span> direction<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                        new_y <span class="token operator">=</span> j <span class="token operator">+</span> direction<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                        <span class="token keyword">if</span> new_x <span class="token operator">&lt;</span> row <span class="token operator">and</span> new_y <span class="token operator">&lt;</span> col <span class="token operator">and</span> grid<span class="token punctuation">[</span>new_x<span class="token punctuation">]</span><span class="token punctuation">[</span>new_y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">:</span>                            uf<span class="token punctuation">.</span>union<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> get_index<span class="token punctuation">(</span>new_x<span class="token punctuation">,</span> new_y<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 不要忘记把那个虚拟结点减掉</span>        <span class="token keyword">return</span> uf<span class="token punctuation">.</span>get_count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>顾名思义，并查集的主要操作有两个，分别是并和查。类似于这种最小连通子树的问题，我们使用图结构未免过于复杂，所以并查集能够很好的解决这一问题。</p><p>我们使用一个数组parent存放每个节点的父节点。</p><ul><li>查操作：如果节点A的父节点是自身，那么他就是所在树的根节点，否则向上递归搜索，直到找到所在树的根节点。（查询每个节点所在子树的根节点，如果A和B所在子树的根节点相同，则说明它们是连通的）</li><li>特别地，为了进行路径压缩，我们在查操作递归查找到根节点后，将递归路径上的所有节点的父节点设置为根节点，从而确保所有的节点都可以在两步之内找到根节点。</li><li>并操作：合并节点A和节点B所在的子树。具体做法是：查找A所在子树的根节点，查找B所在子树的根节点，修改A的根节点的父节点为B的根节点。</li><li>初始情况下，我们设定每一个位置都是一个集合（子树），并查集的count数为总位置数目加1（有一个虚拟节点）。然后我们遍历所有位置，如果当前位置是陆地，则合并右方和下方的陆地至当前位置的子树，每次合并后将count数减1，说明集合数减1。如果当前位置是水域，则将其合并到伪节点下。</li><li>最后，我们将并查集内的集合数目减1，即为岛屿数目（其中有一个集合是水域的集合）。</li></ul><h3 id="206题-反转链表"><a href="#206题-反转链表" class="headerlink" title="206题 反转链表"></a>206题 <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a></h3><p><img src="206.png" alt="第206题"></p><h4 id="思路：-23"><a href="#思路：-23" class="headerlink" title="思路："></a>思路：</h4><p>可以使用头插法，遍历链表中的每个节点都插入到头部即可。</p><p>也可以使用快慢指针法，慢指针开始时指向None，快指针指向Head。每次将快指针的next指向慢指针，即实现了反转。然后将快慢指针同时向前移动一个节点，继续修改快指针的next。、</p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        p<span class="token operator">=</span>None        q<span class="token operator">=</span>head        <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp<span class="token punctuation">,</span>q<span class="token punctuation">.</span>next<span class="token operator">=</span>q<span class="token punctuation">.</span>next<span class="token punctuation">,</span>p            p<span class="token punctuation">,</span>q<span class="token operator">=</span>q<span class="token punctuation">,</span>tmp        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="207题-课程表"><a href="#207题-课程表" class="headerlink" title="207题  课程表"></a>207题 <a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener"> 课程表</a></h3><p><img src="207.png" alt="第207题"></p><h4 id="思路：-24"><a href="#思路：-24" class="headerlink" title="思路："></a>思路：</h4><p>这是一个有向图找环路的问题，基本的思路是拓扑排序。</p><p>我们每次找到一个入度为0的节点，将其从图上删除，并删除以它为起点的所有边，修改相应的边终点的入度。循环执行上述操作，直到图中不存在节点，说明无环。如果无法将节点全部清空，说明存在环。</p><ul><li>时间复杂度：$O(N + M)$： 遍历一个图需要访问所有节点和所有临边；</li><li>空间复杂度：$O(N + M)$： 为建立邻接表所需额外空间。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canFinish</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> numCourses<span class="token punctuation">:</span> int<span class="token punctuation">,</span> prerequisites<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        indegree<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>numCourses<span class="token punctuation">)</span><span class="token punctuation">]</span>        hashmap<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>numCourses<span class="token punctuation">)</span><span class="token punctuation">:</span>            hashmap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> edge <span class="token keyword">in</span> prerequisites<span class="token punctuation">:</span>            indegree<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>            hashmap<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> hashmap<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果还剩下节点，那么继续删除节点</span>            flag<span class="token operator">=</span><span class="token boolean">False</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>indegree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    flag<span class="token operator">=</span><span class="token boolean">True</span>                    <span class="token keyword">for</span> next <span class="token keyword">in</span> hashmap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                        indegree<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>                    indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>                    hashmap<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">if</span> flag<span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果不存在入度为0的节点，那么说明必然存在环路</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span class="token comment" spellcheck="true">#节点可以被全部删除，说明无环</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="215题-数组中的第K个最大元素"><a href="#215题-数组中的第K个最大元素" class="headerlink" title="215题 数组中的第K个最大元素"></a>215题 <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">数组中的第K个最大元素</a></h3><p><img src="215.png" alt="第215题"></p><h4 id="思路：-25"><a href="#思路：-25" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，两种做法：快速选择法和辅助堆。具体解析可见剑指Offer的博客。</p><p>辅助堆：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        heap<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>heap<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>heap<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(nlogk)$，堆的插入、删除都需要$O(logk)$，最坏情况下，每个数字都要入堆出堆一次。</li><li>空间复杂度：$O(k)$，辅助堆。</li></ul><p>快速选择：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#和快速排序中的分治一样，将当前区间首部的枢纽元素调整至正确的位置</span>            i<span class="token operator">=</span>left<span class="token operator">+</span><span class="token number">1</span>            j<span class="token operator">=</span>right            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>right <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    i<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j<span class="token operator">></span>left <span class="token operator">and</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">>=</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    j<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">if</span> i<span class="token operator">&lt;</span>j<span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                    <span class="token keyword">break</span>            <span class="token keyword">return</span> j        <span class="token keyword">def</span> <span class="token function">quickSelect</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#快速选择算法</span>            m<span class="token operator">=</span>partition<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> m<span class="token operator">==</span>k<span class="token punctuation">:</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span>            <span class="token keyword">elif</span> m<span class="token operator">></span>k<span class="token punctuation">:</span>                <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span>left<span class="token punctuation">,</span>m<span class="token number">-1</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>k<span class="token punctuation">)</span>        random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#非常重要！</span>        <span class="token keyword">if</span> k<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> k<span class="token operator">></span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> nums        <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span>k<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是：如果数组有序，那么快速选择法的时间复杂度会大幅提高。（原理和快排一样，当数组有序时，会退化成冒泡排序，时间复杂度升至$O(MN)$）所以我们需要提前随机打乱数组。</p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><h2 id="2020-4-9（2-medium-2-easy）"><a href="#2020-4-9（2-medium-2-easy）" class="headerlink" title="2020.4.9（2 medium 2 easy）"></a>2020.4.9（2 medium 2 easy）</h2><h3 id="221题-最大正方形"><a href="#221题-最大正方形" class="headerlink" title="221题  最大正方形"></a>221题 <a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener"> 最大正方形</a></h3><p><img src="221.png" alt="第221题"></p><h4 id="思路：-26"><a href="#思路：-26" class="headerlink" title="思路："></a>思路：</h4><p>动态规划算法，但很难想到。我们使用状态矩阵dp[i] [j]来表示以第i行第j列的1为右下角顶点的正方形的边长，则动态规划转移方程为：</p><ul><li>dp[i] [j]=0 （if grid[i] [j]==0）</li><li>dp[i] [j]=min(dp[i-1] [j], dp[i] [j-1], dp[i-1] [j-1]) （if grid[i] [j]==1）</li></ul><p>为什么当格子为1时，动态规划转移方程会是那样呢？</p><p>事实上，可以画图自己推导一遍，和木桶短板原理类似：</p><p><img src="221-1.png" alt="dp原理"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maximalSquare</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        m<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"1"</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#只有行号、列号都大于0时，我们才可以使用dp转移方程</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>                    m<span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span>        <span class="token keyword">return</span> m<span class="token operator">*</span>m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(mn)$。</li><li>空间复杂度：$O(mn)$。</li></ul><p>这道题我们可以进一步压缩状态矩阵（很多Dp题目都可以，状态转移只要和之前的有限个状态有关即可。如果我们不需要用到之前的状态，就可以不保存他们）</p><h3 id="226题-翻转二叉树"><a href="#226题-翻转二叉树" class="headerlink" title="226题 翻转二叉树"></a>226题 <a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">翻转二叉树</a></h3><p><img src="226.png" alt="第226题"></p><h4 id="思路：-27"><a href="#思路：-27" class="headerlink" title="思路："></a>思路：</h4><p>递归翻转，翻转当前根节点的左右孩子，同时递归翻转左右孩子的左右孩子，直到当前节点为空。</p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(n)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>            root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>invertTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>invertTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以非递归，使用一个辅助队列即可，稍微复杂一些：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span>        <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token operator">!=</span>None<span class="token punctuation">:</span>                node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>node<span class="token punctuation">.</span>right<span class="token operator">=</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span>node<span class="token punctuation">.</span>left                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="234题-回文链表"><a href="#234题-回文链表" class="headerlink" title="234题 回文链表"></a>234题 <a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">回文链表</a></h3><p><img src="234.png" alt="第234题"></p><h4 id="思路：-28"><a href="#思路：-28" class="headerlink" title="思路："></a>思路：</h4><p>如果我们单纯的使用辅助的数据结构，题目将会很容易解决，例如，我们可以使用另一个链表存放翻转过的链表，再比较二者遍历是否完全相等。也可以将链表存放进数组中，使用双指针从两端遍历。</p><p>但是，为了获得$O(1)$的时间复杂度，我们必须原地对链表进行修改。</p><p>具体流程如下：</p><ul><li>先使用快慢指针法找到链表的中间位置。</li><li>然后使用快慢指针法将链表的后半部分翻转。</li><li>然后将快指针移动到head，快慢指针同时向中间遍历，如果出现了val不相等，则不是回文链表，如果直到快慢指针某一个为空时，均相等，则是回文链表。</li></ul><p><img src="234-1.png" alt="第234题"></p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> head<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">if</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token comment" spellcheck="true">##特判</span>        fast<span class="token operator">=</span>head<span class="token punctuation">.</span>next        slow<span class="token operator">=</span>head        <span class="token keyword">while</span> fast<span class="token operator">!=</span>None <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span>            slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        <span class="token comment" spellcheck="true">##找到中间位置</span>        fast<span class="token operator">=</span>slow<span class="token punctuation">.</span>next        slow<span class="token punctuation">.</span>next<span class="token operator">=</span>None        <span class="token keyword">while</span> fast<span class="token operator">!=</span>None<span class="token punctuation">:</span>            tmp<span class="token operator">=</span>fast<span class="token punctuation">.</span>next            fast<span class="token punctuation">.</span>next<span class="token operator">=</span>slow            slow<span class="token operator">=</span>fast            fast<span class="token operator">=</span>tmp        <span class="token comment" spellcheck="true">##翻转后半部分</span>        fast<span class="token operator">=</span>head        <span class="token keyword">while</span> fast<span class="token operator">!=</span>None <span class="token operator">and</span> slow<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">if</span> fast<span class="token punctuation">.</span>val<span class="token operator">!=</span>slow<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next            slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next        <span class="token comment" spellcheck="true">##</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="236题-二叉树的最近公共祖先"><a href="#236题-二叉树的最近公共祖先" class="headerlink" title="236题 二叉树的最近公共祖先"></a>236题 <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">二叉树的最近公共祖先</a></h3><p><img src="236.png" alt="第236题"></p><h4 id="思路：-29"><a href="#思路：-29" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题。递归法，我们可以直接使用题目给出的函数框架进行先根递归：</p><ul><li>如果当前节点为空，必然不是公共祖先，返回None。</li><li>如果当前节点的值是p或者q的值，那么可能是公共祖先，返回当前节点。</li><li>我们从左右子树中递归搜索：<ul><li>如果左右子树均返回了节点，说明p和q分布在当前节点的两侧，则当前节点必然是他们的最近祖先。</li><li>如果只有左子树返回了节点，那么公共祖先必然在左子树中，返回该节点。</li><li>如果只有右子树返回了节点，那么公共祖先必然右左子树中，返回该节点。</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>p<span class="token punctuation">.</span>val <span class="token operator">or</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> root        leftNode<span class="token operator">=</span>self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>        rightNode<span class="token operator">=</span>self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>        <span class="token keyword">if</span> leftNode<span class="token operator">!=</span>None <span class="token operator">and</span> rightNode<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> root        <span class="token keyword">if</span> rightNode<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> rightNode        <span class="token keyword">if</span> leftNode<span class="token operator">!=</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> leftNode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-10（3-medium-1-hard）"><a href="#2020-4-10（3-medium-1-hard）" class="headerlink" title="2020.4.10（3 medium 1 hard）"></a>2020.4.10（3 medium 1 hard）</h2><h3 id="238题-除自身以外数组的乘积"><a href="#238题-除自身以外数组的乘积" class="headerlink" title="238题 除自身以外数组的乘积"></a>238题 <a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">除自身以外数组的乘积</a></h3><p><img src="238.png" alt="第238题"></p><h4 id="思路：-30"><a href="#思路：-30" class="headerlink" title="思路："></a>思路：</h4><p>首先，我们注意到题目要求我们不能使用除法，所以我们无法通过求所有数的乘积后挨个进行除法的方式获取结果。此外，题目要求我们使用$O(n)$的时间复杂度，所以我们也不能使用暴力两层循环的方式。</p><p>较好的思路是使用类似于动态规划的思想，先顺序DP求出前缀乘积数组L（L[i]=L[i-1]*nums[i-1])，再倒序DP求出后缀乘积数组R，对于第i个位置的结果res[i]=L[i]*R[i]。</p><p>更进一步，我们可以减少空间复杂度。由于结果数组不算额外空间，我们可以将L数组存入res数组，再倒序计算R数组。因为此时R数组不需要保存所有的状态，只需要保存一个状态用于转移，所以我们只需要用一个变量保存它即可。</p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">productExceptSelf</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> nums<span class="token punctuation">]</span>        res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>res<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>        R<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*=</span>R            R<span class="token operator">=</span>R<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="239题-滑动窗口最大值"><a href="#239题-滑动窗口最大值" class="headerlink" title="239题 滑动窗口最大值"></a>239题 <a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">滑动窗口最大值</a></h3><p><img src="239.png" alt="第239题"></p><h4 id="思路：-31"><a href="#思路：-31" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题。为了获得线性时间复杂度，我们需要维护一个单调双向队列。</p><ul><li>队列中存放的是数组元素的下标。</li><li>队列中的元素单调递减，队首元素为当前窗口内最大的元素下标，第二个元素为在队首元素下标之后第二大的元素下标（一定要在队首元素之后！如果在队首元素下标之前，那么它将比队首元素更早被移出窗口，不可能成为继续滑动窗口后的最大元素），第三个元素为在第二个元素下标之后第三大的元素下标。依次类推。</li><li>我们遍历nums数组中的所有元素下标i，如果此时双向队列为空，我们直接将i入队。否则，我们计算i-k的值与队首元素下标值是否相等，相等则说明此时队首元素下标值已经被恰好移出窗口，我们需要将其出队。接着，我们需要调整双向队列，使其保持递减的性质。并将队列中比nums[i]小的元素下标值出队。（因为此时元素i不仅比他们大，而且还在它们的后面，所以它们再也不可能是某个滑动窗口的最大值了，可以删掉）</li><li>当i大于等于k-1时，说明此时窗口大小达到要求，可以开始统计滑动窗口的最大值。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        dequeue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> dequeue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">-</span>k<span class="token operator">==</span>dequeue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    dequeue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">while</span> dequeue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>dequeue<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    dequeue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            dequeue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">if</span> i<span class="token operator">>=</span>k<span class="token number">-1</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>dequeue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(k)$。</li></ul><h3 id="74题-搜索二维矩阵"><a href="#74题-搜索二维矩阵" class="headerlink" title="74题 搜索二维矩阵"></a>74题 <a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">搜索二维矩阵</a></h3><p><img src="74.png" alt="第74题"></p><h4 id="思路：-32"><a href="#思路：-32" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，我们观察这个二维矩阵，可以发现它其实可以转化为二叉搜索树来进行查询。</p><ul><li>我们从右上角开始查询，可以发现，当前元素左侧的元素都比自己小，下方的元素都比自己大。所以，我们可以使用二叉搜索树的思想：如果目标元素比当前元素大，向下方搜索，否则向左侧搜索。</li><li>当搜索到边界仍然无法找到target，我们可以返回False。找到了target，我们可以返回True。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">searchMatrix</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        row<span class="token operator">=</span><span class="token number">0</span>        col<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>                row<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">elif</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>                col<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(m+n)$，最多需要走到左下角位置。</li><li>空间复杂度：$O(1)$。</li></ul><h3 id="240题-搜索二维矩阵-II"><a href="#240题-搜索二维矩阵-II" class="headerlink" title="240题 搜索二维矩阵 II"></a>240题 <a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">搜索二维矩阵 II</a></h3><p><img src="240.png" alt="第240题"></p><h4 id="思路：-33"><a href="#思路：-33" class="headerlink" title="思路："></a>思路：</h4><p>与74题非常类似，只是从左下角开始搜索而已。此外，还可以使用二分查找的方法，因为每行都是有序的，不过时间复杂度远远高于之前的方法。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">searchMatrix</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type matrix: List[List[int]]        :type target: int        :rtype: bool        """</span>        row<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        col<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> <span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>                col<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">elif</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>                row<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-11（1-easy-2-medium-1-hard）"><a href="#2020-4-11（1-easy-2-medium-1-hard）" class="headerlink" title="2020.4.11（1 easy 2 medium 1 hard）"></a>2020.4.11（1 easy 2 medium 1 hard）</h2><h3 id="279题-完全平方数"><a href="#279题-完全平方数" class="headerlink" title="279题 完全平方数"></a>279题 <a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">完全平方数</a></h3><p><img src="279.png" alt="第279题"></p><h4 id="思路：-34"><a href="#思路：-34" class="headerlink" title="思路："></a>思路：</h4><p>这道题的基本解法和剪绳子问题类似，是一个类似于完全背包问题的动态规划问题。状态矩阵dp[i]用于保存数字i的最小完全平方数。转移方程为：dp[i]=min(dp[i],dp[i-j**2]+1)（j从1到i的平方根）（自底向上，递归是自顶向下）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> math<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numSquares</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>int<span class="token punctuation">(</span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n\sqrt{n})$，两层循环。</li><li>空间复杂度：$O(n)$。</li></ul><p>以下图为例。我们知道，动态规划算法是从记忆化递归转变而来的，属于DFS的思想。但是，这道题使用BFS更好，因为我们要求的不是节点为0时的最大深度，而是最小深度，所以从上至下逐层递归（BFS）比每次走到树的底部（DFS）更为合适。</p><p><img src="279-1.png" alt></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> math<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numSquares</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span>        tmpSet<span class="token operator">=</span>set<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            res<span class="token operator">+=</span><span class="token number">1</span>            l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                now<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>int<span class="token punctuation">(</span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    tmp<span class="token operator">=</span>now<span class="token operator">-</span>j<span class="token operator">*</span>j                    <span class="token keyword">if</span> tmp<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> res                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        <span class="token keyword">if</span> tmp <span class="token operator">not</span> <span class="token keyword">in</span> tmpSet<span class="token punctuation">:</span>                            tmpSet<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>                            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>        <span class="token keyword">return</span> n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用BFS，同时，为了防止对相同值的重复搜索，我们可以对树进行剪枝。使用临时哈希集合来保存已搜索过的值，防止重复搜素。当我们找到了第一个被完全平方数拆分至0的节点，返回其深度，即为最小完全平方数目。</p><h3 id="283题-移动零"><a href="#283题-移动零" class="headerlink" title="283题 移动零"></a>283题 <a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零</a></h3><p><img src="283.png" alt="第283题"></p><h4 id="思路：-35"><a href="#思路：-35" class="headerlink" title="思路："></a>思路：</h4><p>基本思路可以采用冒泡排序，两层循环，时间复杂度很高，为$O(n^2)$。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify nums in-place instead.        """</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>较好的思路是使用快慢双指针，有些类似于之前做过的数组去除某个元素和去重的问题。我们使用慢指针来维护一个无零的区间（指向该区间的后一个元素），快指针来对数组元素进行遍历。如果当前值非零，那么就与慢指针指向的元素交换，慢指针加一。（慢指针如果停在某个位置，而不是和快指针同步向前遍历，说明此时必然遇到了0，所以交换后，零元素必然向末尾靠近）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify nums in-place instead.        """</span>        slow<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> fast <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span>                slow<span class="token operator">+=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$，一次循环。</li><li>空间复杂度：$O(1)$。</li></ul><h3 id="287题-寻找重复数"><a href="#287题-寻找重复数" class="headerlink" title="287题 寻找重复数"></a>287题 <a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">寻找重复数</a></h3><p><img src="287.png" alt="第287题"></p><h4 id="思路：-36"><a href="#思路：-36" class="headerlink" title="思路："></a>思路：</h4><p>这道题可以用的思路很多，但大多数被题目条件所限制：</p><ul><li>最简单的是哈希表，value存放key出现的次数，如果出现了次数等于2的数字，那么必然是重复数。时间复杂度为$O(n)$，空间复杂度为$O(n)$。但题目不给使用额外空间。</li><li>我们还可以使用排序的方法，对数组进行排序。接着再遍历数组，如果当前值和下一个值相等，那么是重复的。时间复杂度为$O(nlogn)$，空间复杂度为$O(1)$。</li></ul><p>实际上，这道题可以看作是一个链表找环路的问题。我们可以把数组的下标看作是节点的地址，数组的值看作是next指针，由于重复值的next相同，所以它们必然会产生环路，我们只要找到环路的入口地址即可（由于环路入口地址必然被入度大于1，即元素值出现次数大于1，即为重复元素）。接着的具体解题思路和之前做过的142题类似。使用快慢指针，快指针每次走2步，慢指针每次走1步，二者相遇后，再让慢指针回到链表头部。二者每次走1步，相遇时即为链表入口。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        slow<span class="token operator">=</span><span class="token number">0</span>        fast<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            slow<span class="token operator">=</span>nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span>            fast<span class="token operator">=</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> slow<span class="token operator">==</span>fast<span class="token punctuation">:</span>                <span class="token keyword">break</span>        slow<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> slow<span class="token operator">!=</span>fast<span class="token punctuation">:</span>            slow<span class="token operator">=</span>nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span>            fast<span class="token operator">=</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span>        <span class="token keyword">return</span> slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="297题-二叉树的序列化与反序列化"><a href="#297题-二叉树的序列化与反序列化" class="headerlink" title="297题 二叉树的序列化与反序列化"></a>297题 <a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">二叉树的序列化与反序列化</a></h3><p><img src="297.png" alt="第297题"></p><h4 id="思路：-37"><a href="#思路：-37" class="headerlink" title="思路："></a>思路：</h4><p>剑指offer原题，数据结构课原题，有两种做法：（1）DFS（先根遍历，栈）（2）BFS（层次遍历，队列）</p><ul><li>DFS的做法：<ul><li>序列化：先序遍历将当前节点的val存入字符串。</li><li>反序列化：将字符串切割成数组。使用先序遍历再次遍历，需要使用外层变量index来记录当前已访问的元素下标。（也可以使用队列来做，本质都是一样的）。</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Encodes a tree to a single string.        :type root: TreeNode        :rtype: str        """</span>        data<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        preorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">","</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>data<span class="token punctuation">)</span>         <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Decodes your encoded data to tree.        :type data: str        :rtype: TreeNode        """</span>        data<span class="token operator">=</span>data<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>index<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>index<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"*"</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>index<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">return</span> None            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>index<span class="token operator">+=</span><span class="token number">1</span>            root<span class="token punctuation">.</span>left<span class="token operator">=</span>build<span class="token punctuation">(</span><span class="token punctuation">)</span>            root<span class="token punctuation">.</span>right<span class="token operator">=</span>build<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> root        <span class="token triple-quoted-string string">'''        def build(queue):             now=queue.pop(0)            if now=="*":            return None            root=TreeNode(int(now))            root.left=build(queue)            root.right=build(queue) return root        queue=data.split(",")        return build(queue)        '''</span>        <span class="token keyword">return</span> build<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Your Codec object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># codec = Codec()</span><span class="token comment" spellcheck="true"># codec.deserialize(codec.serialize(root))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>BFS的做法：<ul><li>序列化：使用辅助队列层次遍历，将节点存入data字符串中保存。</li><li>反序列化：先将data字符串切割成数组。然后使用index指针遍历数组，将待处理节点放入一个队列保存。每次将一个节点出队，使移动index指针，使index指向的元素生成它的左右孩子，再将非空的左右孩子入队保存（因为它们也需要处理，尝试生成左右孩子）。开始时使用data数组的首个元素构建root节点，将root入队，index初始值设为1。最后将root返回即可。</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Encodes a tree to a single string.        :type root: TreeNode        :rtype: str        """</span>        data<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span>        <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token operator">==</span>None<span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">","</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Decodes your encoded data to tree.        :type data: str        :rtype: TreeNode        """</span>        data<span class="token operator">=</span>data<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        index<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">if</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"*"</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None        <span class="token keyword">else</span><span class="token punctuation">:</span>            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> index<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">"*"</span><span class="token punctuation">:</span>                node<span class="token punctuation">.</span>left<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            index<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">"*"</span><span class="token punctuation">:</span>                node<span class="token punctuation">.</span>right<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            index<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> root<span class="token comment" spellcheck="true"># Your Codec object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># codec = Codec()</span><span class="token comment" spellcheck="true"># codec.deserialize(codec.serialize(root)) </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-12（2-medium-1-hard）"><a href="#2020-4-12（2-medium-1-hard）" class="headerlink" title="2020.4.12（2 medium 1 hard）"></a>2020.4.12（2 medium 1 hard）</h2><h3 id="300题-最长上升子序列"><a href="#300题-最长上升子序列" class="headerlink" title="300题 最长上升子序列"></a>300题 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长上升子序列</a></h3><p><img src="300.png" alt="300题"></p><h4 id="思路：-38"><a href="#思路：-38" class="headerlink" title="思路："></a>思路：</h4><p>首先，我们可以通过$O(n^2)$的时间复杂度来解决这道题。与最大连续子序列类似，我们可以使用动态规划的方法，dp[i]表示以第i个数字结尾的子序列的最大长度。转移方程：dp[i]=max（dp[i]，dp[j]+1）(if j&lt;i and nums[j]&lt;nums[i])。也就是说，如果第i个数大于在它之前的第j个数，那么它就可以接在以第j个数结尾的最长上升子序列后形成一个更长的上升子序列。我们只需要找到第i个数和之前每个数结尾的最长上升子序列形成的子序列的最大长度即可。</p><ul><li>时间复杂度：$O(n^2)$。</li><li>空间复杂度：$O(n)$，无法进行状态压缩，因为要用到之前每个状态。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> nums<span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>            res<span class="token operator">=</span>max<span class="token punctuation">(</span>res<span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了获取题目要求的$O(nlogn)$的时间复杂度，我们必须要用到二分查找。那么怎么进行二分查找呢？</p><ul><li>首先，我们继续使用动态规划的方法。不过状态矩阵的含义要进行改变，dp[i]表示长度为i的上升子序列的最小结尾值。</li><li>我们遍历nums矩阵，每次遍历时，在当前的dp矩阵中二分查找nums[j]的插入位置，如果插入位置处的dp[i]大于nums[j]，即可将dp[j]修改为nums[j]，说明长度为i的上升子序列的最小结尾值可以更新了。如果插入位置等于len（dp），说明nums[j]比当前所有长度的序列的最小结尾值都大，可以接在它们的后面形成更长的上升子序列，我们将nums[j]加入到dp的末尾。</li><li>当我们遍历完nums[j]后，所得dp数组的长度即为上升序列的最大长度。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Dynamic programming + Dichotomy.</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> <span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> dp<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                left<span class="token operator">=</span><span class="token number">0</span>                right<span class="token operator">=</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>                flag<span class="token operator">=</span><span class="token number">0</span>                <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>                    mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                        flag<span class="token operator">=</span><span class="token number">1</span>                        <span class="token keyword">break</span>                    <span class="token keyword">elif</span> dp<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                        left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        right<span class="token operator">=</span>mid<span class="token number">-1</span>                <span class="token keyword">if</span> flag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> left<span class="token operator">==</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>dp<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="301题-删除无效的括号"><a href="#301题-删除无效的括号" class="headerlink" title="301题 删除无效的括号"></a>301题 <a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/" target="_blank" rel="noopener">删除无效的括号</a></h3><p><img src="301.png" alt="301题"></p><h4 id="思路：-39"><a href="#思路：-39" class="headerlink" title="思路："></a>思路：</h4><p>由于这道题需要的是删除的次数最小，所以BFS很明显比DFS划算，就像昨天做过的最小完全平方数问题一样， 从上至下逐层搜索很明显比每次搜索到底部划算。</p><p><img src="301-1.png" alt="BFS"></p><p>树的每层都是对上一层节点删掉某个括号后得到的新字符串，为了防止重复搜索，这里对重复的字符串进行去重。如果某一层中出现了某个合法的括号串，那么返回该层所有合法的括号串。否则，继续向下层遍历。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeInvalidParentheses</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            count<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>                <span class="token keyword">if</span> ch<span class="token operator">==</span><span class="token string">"("</span><span class="token punctuation">:</span>                    count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">elif</span> ch<span class="token operator">==</span><span class="token string">")"</span><span class="token punctuation">:</span>                    count<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                nowStr<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> isValid<span class="token punctuation">(</span>nowStr<span class="token punctuation">)</span><span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nowStr<span class="token punctuation">)</span>                <span class="token keyword">if</span> res<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nowStr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        newStr<span class="token operator">=</span>nowStr<span class="token punctuation">[</span><span class="token punctuation">:</span>j<span class="token punctuation">]</span><span class="token operator">+</span>nowStr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>                        <span class="token keyword">if</span> newStr <span class="token operator">not</span> <span class="token keyword">in</span> queue<span class="token punctuation">:</span>                            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>newStr<span class="token punctuation">)</span>            <span class="token keyword">if</span> res<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码在python3下运行超时，所以我们要进一步优化，使用集合来完成去重剪枝操作。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeInvalidParentheses</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        level<span class="token operator">=</span><span class="token punctuation">{</span>s<span class="token punctuation">}</span>        <span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            count<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>                <span class="token keyword">if</span> ch<span class="token operator">==</span><span class="token string">"("</span><span class="token punctuation">:</span>                    count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">elif</span> ch<span class="token operator">==</span><span class="token string">")"</span><span class="token punctuation">:</span>                    count<span class="token operator">-=</span><span class="token number">1</span>                <span class="token keyword">if</span> count<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            l<span class="token operator">=</span>len<span class="token punctuation">(</span>level<span class="token punctuation">)</span>            res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> st <span class="token keyword">in</span> level<span class="token punctuation">:</span>                <span class="token keyword">if</span> isValid<span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st<span class="token punctuation">)</span>            <span class="token keyword">if</span> res<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> res            nextlevel<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> st <span class="token keyword">in</span> level<span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> <span class="token string">"()"</span><span class="token punctuation">:</span>                        nextlevel<span class="token punctuation">.</span>add<span class="token punctuation">(</span>st<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token operator">+</span>st<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            level<span class="token operator">=</span>nextlevel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="309题-最佳买卖股票时机含冷冻期"><a href="#309题-最佳买卖股票时机含冷冻期" class="headerlink" title="309题 最佳买卖股票时机含冷冻期"></a>309题 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">最佳买卖股票时机含冷冻期</a></h3><p><img src="309.png" alt="309题"></p><h4 id="思路：-40"><a href="#思路：-40" class="headerlink" title="思路："></a>思路：</h4><p>动态规划求解股票问题。每天存在三种状态：</p><ul><li>持仓：hold，指继续持有股票</li><li>空仓：sold，指卖出所有股票</li><li>冷冻期：rest，指什么也不做</li></ul><p>转换关系（一共有3乘3共9种转换的可能，只有以下几种可能且值得被比较）：</p><ul><li>sold：<ul><li>前一天hold，当日卖出股票</li></ul></li><li>hold： 可由两个情况转换来<ul><li>前一天hold，当日rest</li><li>前一天rest，当日买入股票变为hold（前一天sold转移不到hold，因为卖出股票后必须经历一天冷冻期）</li></ul></li><li>rest：<ul><li>前一天sold，当日必须rest</li><li>前一天rest，当日继续rest</li></ul></li></ul><p>所以:</p><ul><li>sold[i] = hold[i-1] + price[i];</li><li>hold[i] = max(hold[i-1], rest[i-1] - price[i])</li><li>rest[i] = max(rest[i-1], sold[i-1])</li></ul><p>特别地，由于只用到前面有限个状态，我们可以进行状态压缩。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> prices<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        sold<span class="token operator">=</span><span class="token number">0</span>        hold<span class="token operator">=</span><span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        rest<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> price <span class="token keyword">in</span> prices<span class="token punctuation">:</span>            sold<span class="token punctuation">,</span>hold<span class="token punctuation">,</span>rest<span class="token operator">=</span>hold<span class="token operator">+</span>price<span class="token punctuation">,</span>max<span class="token punctuation">(</span>hold<span class="token punctuation">,</span>rest<span class="token operator">-</span>price<span class="token punctuation">)</span><span class="token punctuation">,</span>max<span class="token punctuation">(</span>rest<span class="token punctuation">,</span>sold<span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>sold<span class="token punctuation">,</span>hold<span class="token punctuation">,</span>rest<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-13（1-medium-1-hard）"><a href="#2020-4-13（1-medium-1-hard）" class="headerlink" title="2020.4.13（1 medium 1 hard）"></a>2020.4.13（1 medium 1 hard）</h2><h3 id="312题-戳气球"><a href="#312题-戳气球" class="headerlink" title="312题 戳气球"></a>312题 <a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">戳气球</a></h3><p><img src="312.png" alt="312题"></p><h4 id="思路：-41"><a href="#思路：-41" class="headerlink" title="思路："></a>思路：</h4><p>首先，我想到的是简单的DFS，暴力求解，时间复杂度很高，为$O(N!)$：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token operator">+</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>maxres<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> count<span class="token operator">==</span>n<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>maxres<span class="token operator">=</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxres<span class="token punctuation">,</span>res<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                        tmp<span class="token operator">=</span>nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>i<span class="token punctuation">)</span>                        dfs<span class="token punctuation">(</span>res<span class="token operator">+</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>tmp<span class="token punctuation">)</span><span class="token punctuation">,</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                        nums<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>i<span class="token punctuation">,</span>tmp<span class="token punctuation">)</span>        dfs<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxres<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了优化递归回溯算法，我们通常需要用到的是动态规划或者备忘录。为了使用它们，首先我们需要定义状态矩阵和划分子问题。</p><p>这里，我们定义dp[i] [j]为从第i个气球到第j个气球这个区间所能获得的最大硬币数量。按照我们的惯性思维，我们会先选区间内的一个气球被戳破，然后去求解该气球左侧区间的最大硬币数和右侧区间的最大硬币数之和。但是这道题里这样做是不行的，因为当你戳破了一个气球后，左区间右侧和右区间左侧的气球发生了改变，导致结果发生了改变。所以这样划分状态间互相产生了依赖，也就是说，我们无法保证动态规划的无后效性。</p><p>所以，我们需要重新定义子问题。我们先选取区间内的一个气球k，现在不是让它最先被戳破了，而是让它在这个区间内最后被戳破。这样，保证了dp[i] [k-1] 和 dp[k+1] [j] 两侧的气球始终不变，保证了状态矩阵的稳定。从而状态转移方程为：</p><p>dp[i] [j]=dp [i] [k-1] + dp[k+1] [j] + nums[k]*nums[i-1]*nums[j+1]</p><p>因为k气球是i到j区间内最后被扎破的，所以i到k-1和k+1到j的气球已经全部被扎破了，此时，k气球左侧和右侧的气球便一定是i-1和j+1气球。</p><p>考虑到这道题自顶向下求解比较容易理解，我们采用带备忘录的递归来做。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token operator">+</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">></span>j <span class="token operator">or</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> j<span class="token operator">==</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>                <span class="token keyword">return</span> <span class="token number">0</span>            <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>            nowMax<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                nowMax<span class="token operator">=</span>max<span class="token punctuation">(</span>nowMax<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>recur<span class="token punctuation">(</span>i<span class="token punctuation">,</span>k<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span>recur<span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>nowMax            <span class="token keyword">return</span> nowMax        <span class="token keyword">return</span> recur<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了进一步优化我们还是使用动态规划，这里用的是区间DP，从小区间向大区间转移。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>                j <span class="token operator">=</span> i <span class="token operator">+</span> k                <span class="token keyword">for</span> t <span class="token keyword">in</span> range<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(这里的dp[i] [j] 表示的区间为（i，j），和我之前用的不太一样，不包括第i个和第j个气球。)</p><h3 id="第322题-零钱兑换"><a href="#第322题-零钱兑换" class="headerlink" title="第322题 零钱兑换"></a>第322题 <a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">零钱兑换</a></h3><p><img src="322.png" alt="322题"></p><h4 id="思路：-42"><a href="#思路：-42" class="headerlink" title="思路："></a>思路：</h4><p>与前两天刚做过的最小完全平方数组合那道题非常像，可以用DFS和BFS来遍历情况，由于我们需要取的是最小的组合，所以用BFS很明显更好。</p><p>我们使用辅助队列来进行BFS，再使用一个hashset来辅助我们去重（hashset查找元素时间复杂度为$O(1)$，优于直接列表查询）。</p><p>我们按层对队列中的金额使用硬币面值进行拆分，得到的新金额入队（重复的不入，如果在此之前已经入过队，说明必然更早完成凑成总金额，小于0的也不入）。如果成功拆分得到0，则将层数返回，即为最小硬币数目。如果无法拆分得到0，返回-1.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> coins<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> amount<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> amount<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        hashset<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        queue<span class="token operator">=</span><span class="token punctuation">[</span>amount<span class="token punctuation">]</span>        level<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            level<span class="token operator">+=</span><span class="token number">1</span>            l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                now<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> coin <span class="token keyword">in</span> coins<span class="token punctuation">:</span>                    tmp<span class="token operator">=</span>now<span class="token operator">-</span>coin                    <span class="token keyword">if</span> tmp<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> level                    <span class="token keyword">if</span> tmp <span class="token operator">not</span> <span class="token keyword">in</span> hashset <span class="token operator">and</span> tmp<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                        hashset<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-13（3-medium）"><a href="#2020-4-13（3-medium）" class="headerlink" title="2020.4.13（3 medium）"></a>2020.4.13（3 medium）</h2><h3 id="337题-打家劫舍-III"><a href="#337题-打家劫舍-III" class="headerlink" title="337题 打家劫舍 III"></a>337题 <a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">打家劫舍 III</a></h3><p><img src="337.png" alt="337题"></p><h4 id="思路：-43"><a href="#思路：-43" class="headerlink" title="思路："></a>思路：</h4><p>打家劫舍问题在不久前刚做过1和2，基本思路就是使用动态规划，类似于背包问题。当前状态有两种可能的隐状态转移而来，分别是偷当前这家和不偷当前这家。具体到本问题，假设偷当前这家人，那么只能从二叉树当前节点的孙子节点处继续偷；如果不偷当前这家人，那么可以从孩子节点开始偷。</p><p>特别地，由于二叉树的遍历采用递归比较容易理解，所以这题我们暂时不用DP来做，使用带备忘录的递归。备忘录采用哈希表实现，key为节点，value为以该节点为根节点的子树中所能偷到的最大金额。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                do_now<span class="token operator">=</span>root<span class="token punctuation">.</span>val                do_next<span class="token operator">=</span><span class="token number">0</span>                <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>                    do_next<span class="token operator">+=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>left<span class="token punctuation">]</span>                    do_now<span class="token operator">+=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">]</span>                    do_now<span class="token operator">+=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right<span class="token punctuation">]</span>                <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token operator">!=</span>None<span class="token punctuation">:</span>                    do_next<span class="token operator">+=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>right <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>right<span class="token punctuation">]</span>                    do_now<span class="token operator">+=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left<span class="token punctuation">]</span>                    do_now<span class="token operator">+=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right<span class="token punctuation">]</span>                dic<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>do_next<span class="token punctuation">,</span>do_now<span class="token punctuation">)</span>                <span class="token keyword">return</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">]</span>        <span class="token keyword">return</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="338题-比特位计数"><a href="#338题-比特位计数" class="headerlink" title="338题  比特位计数"></a>338题 <a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener"> 比特位计数</a></h3><p><img src="338.png" alt="338题"></p><h4 id="思路：-44"><a href="#思路：-44" class="headerlink" title="思路："></a>思路：</h4><p>动态规划思想，dp[i]为数字i的二进制中1的数目。分析比特位转移的规律，可以发现：</p><ul><li>如果i是偶数，那么dp[i]=dp[i//2]。左移，末尾补0，例如dp[4]=1（100）等于dp[2]=1（10）。</li><li>如果i是奇数，那么dp[i]=dp[i-1]+1。此时无需进位，直接加1即可。</li></ul><p>上述规律是因为，二进制数，偶数最低位都为0，奇数最低位都为1。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countBits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">return</span> dp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="附：二进制数有多少个1"><a href="#附：二进制数有多少个1" class="headerlink" title="附：二进制数有多少个1"></a>附：二进制数有多少个1</h4><p>一个数字n，求他的二进制形式有多少个1，可以使用位运算的方式来进行。通过与运算(n)&amp;(n-1)，可以做到每次去除n的最后一位1，更新n，重复计算直到n为0。计算的次数即为n中1的个数。</p><p>所以我们也可以根据上述性质进行动态规划：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countBits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token operator">&amp;</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="347题-前-K-个高频元素"><a href="#347题-前-K-个高频元素" class="headerlink" title="347题 前 K 个高频元素"></a>347题 <a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">前 K 个高频元素</a></h3><p><img src="347.png" alt="347题"></p><h4 id="思路：-45"><a href="#思路：-45" class="headerlink" title="思路："></a>思路：</h4><p>最简单的方法很明显是哈希表记录下每个元素出现的次数，然后对哈希表中的元素按照出现次数进行排序，选取前k个值。</p><p>只要我们用哈希表记录下了每个元素出现次数，那么选取出现次数的前k大值就转变为了我们常做的前k大（小）问题。</p><p>可以使用堆或者快速选择法进行解决。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: List[int]        """</span>         count <span class="token operator">=</span> collections<span class="token punctuation">.</span>Counter<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>           <span class="token keyword">return</span> heapq<span class="token punctuation">.</span>nlargest<span class="token punctuation">(</span>k<span class="token punctuation">,</span> count<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span>count<span class="token punctuation">.</span>get<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（python中重写堆的比较方法比较麻烦，就直接调用它的封装好的函数）</p><p>除此之外，我们还可以使用一个不基于比较的排序方法——计数排序，它是桶排序的一种，以空间来换时间。已知数值的区间，我们可以建立一个与区间大小相等的列表list。如果一个数出现的次数为n，那么就在list[n]处新添这个数的值。最后遍历计数区间，从大到小输出k个数即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        hashtable<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            hashtable<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">if</span> num <span class="token operator">not</span> <span class="token keyword">in</span> hashtable<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> hashtable<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        li<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> key <span class="token keyword">in</span> hashtable<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            li<span class="token punctuation">[</span>hashtable<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> l <span class="token keyword">in</span> li<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> num <span class="token keyword">in</span> l<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>                <span class="token keyword">if</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">==</span>k<span class="token punctuation">:</span>                    <span class="token keyword">return</span> res        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-14（3-medium）"><a href="#2020-4-14（3-medium）" class="headerlink" title="2020.4.14（3 medium）"></a>2020.4.14（3 medium）</h2><h3 id="394题-字符串解码"><a href="#394题-字符串解码" class="headerlink" title="394题 字符串解码"></a>394题 <a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">字符串解码</a></h3><p><img src="394.png" alt="394题"></p><h4 id="思路：-46"><a href="#思路：-46" class="headerlink" title="思路："></a>思路：</h4><p>类似的问题，包括带有括号的算式计算，这里的括号是可以嵌套的。针对这种嵌套的子问题，我们可以使用两种思路来解决，分别是：（1）辅助栈（2）递归。</p><p>首先我们来看辅助栈的解法。我们先设立两个关键的遍历mul和res，分别用于存储当前中括号内的结果和该结果的乘数。我们每次遍历原始的字符串s，然后分四种情况讨论：</p><ul><li>当s[i]为数字时，将其添加到当前乘数mul的末尾；</li><li>当s[i]为字母时，将其添加到当前结果res的末尾；</li><li>当s[i]为”[“时，说明需要进入下一个嵌套的中括号内部进行处理，将当前的res和mul入栈保存，并清空它们;</li><li>当s[i]为”]”时，说明当前中括号内部的字符串已经处理完毕，即为res。我们从栈顶取出一组res和mul，即为当前中括号外部的中括号内目前的res和mul，使用mul对当前res进行重复拼接，在拼接到外层res的末尾，继续向后计算。</li></ul><p>遍历完s后，res的结果即为最终结果。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">decodeString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        res<span class="token operator">=</span><span class="token string">""</span>        mul<span class="token operator">=</span><span class="token number">0</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        i<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> i <span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token string">'0'</span><span class="token operator">&lt;=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token string">'9'</span><span class="token punctuation">:</span>                mul<span class="token operator">=</span>mul<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>int<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">elif</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'['</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>mul<span class="token punctuation">,</span>res<span class="token punctuation">]</span><span class="token punctuation">)</span>                res<span class="token operator">=</span><span class="token string">""</span>                mul<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">elif</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">']'</span><span class="token punctuation">:</span>                tmp<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                res<span class="token operator">=</span>tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>res<span class="token operator">*</span>tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                mul<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res<span class="token operator">+=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            i<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>稍加修改，即可得到递归写法。此处为了防止重复遍历，当遍历到”]”时，返回当前的res和当前的索引。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">decodeString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">,</span> multi <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span>            <span class="token keyword">while</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token string">'0'</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token string">'9'</span><span class="token punctuation">:</span>                    multi <span class="token operator">=</span> multi <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> int<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">elif</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'['</span><span class="token punctuation">:</span>                    i<span class="token punctuation">,</span> tmp <span class="token operator">=</span> dfs<span class="token punctuation">(</span>s<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                    res <span class="token operator">+=</span> multi <span class="token operator">*</span> tmp                    multi <span class="token operator">=</span> <span class="token number">0</span>                <span class="token keyword">elif</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">']'</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> i<span class="token punctuation">,</span> res                <span class="token keyword">else</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">return</span> res        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="399-题-除法求值"><a href="#399-题-除法求值" class="headerlink" title="399 题 除法求值"></a>399 题 <a href="https://leetcode-cn.com/problems/evaluate-division/" target="_blank" rel="noopener">除法求值</a></h3><p><img src="399.png" alt="399题"></p><h4 id="思路：-47"><a href="#思路：-47" class="headerlink" title="思路："></a>思路：</h4><p>这道题，我们可以将其转化为图论问题。以等式中出现的每一个变量为顶点，有根据等式建立有向带权图，有向边的含义为起点是终点的几倍。例如“a/b=3”，那么我们就可以建立节点a和接点b，边a-&gt;b的权值为3，边b-&gt;a的权值为1/3。</p><p>所以，除法求值的问题转化为有向带权图的搜索问题，我们可以采用BFS和DFS两类做法来解决。例如：已知 a / b = 2.0, b / c = 3.0 ，我们可以根据上述等式建图，当求解a/c时，只需要将顶点a到顶点c路径上的权值累乘即可。</p><p>这里我们使用DFS来解决。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">calcEquation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> equations<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> values<span class="token punctuation">:</span> List<span class="token punctuation">[</span>float<span class="token punctuation">]</span><span class="token punctuation">,</span> queries<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>float<span class="token punctuation">]</span><span class="token punctuation">:</span>        graph<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#使用defaultdict较为方便，不需要判断key是否在dict的keys中，如果不在的话defaultdict会按照构造函数给定的参数自动为其赋值</span>        weights<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span><span class="token punctuation">)</span>        visited<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> idx<span class="token punctuation">,</span>eq <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>equations<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#enumerate方法可以额外返回迭代对象每个元素的数组下标</span>            graph<span class="token punctuation">[</span>eq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>eq<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            graph<span class="token punctuation">[</span>eq<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>eq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            weights<span class="token punctuation">[</span>tuple<span class="token punctuation">(</span>eq<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">=</span>values<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>            weights<span class="token punctuation">[</span>tuple<span class="token punctuation">(</span>eq<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span>values<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> start <span class="token operator">not</span> <span class="token keyword">in</span> graph<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">or</span> end <span class="token operator">not</span> <span class="token keyword">in</span> graph<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#出现了未在等式中出现的变量，直接返回0</span>                <span class="token keyword">return</span> <span class="token number">0</span>            <span class="token keyword">if</span> start<span class="token operator">==</span>end<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#被除数与除数相等</span>                <span class="token keyword">return</span> <span class="token number">1.0</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span> <span class="token keyword">in</span> weights<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#被除数与除数直接相连</span>                <span class="token keyword">return</span> weights<span class="token punctuation">[</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> nextV <span class="token keyword">in</span> graph<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#深度优先搜索</span>                <span class="token keyword">if</span> nextV <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#防止重复遍历，进入环路</span>                    visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>nextV<span class="token punctuation">)</span>                    res<span class="token operator">=</span>dfs<span class="token punctuation">(</span>nextV<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token operator">*</span>weights<span class="token punctuation">[</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>nextV<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#继续深搜</span>                    <span class="token keyword">if</span> res<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#一旦出现了合法结果，就返回</span>                        weights<span class="token punctuation">[</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">=</span>res<span class="token comment" spellcheck="true">#将被除数和除数修改为直接相连，方便以后的搜索</span>                        visited<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>nextV<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#注意：这里如果不加回溯的话，由于return直接跳出，将导致回溯错误</span>                        <span class="token keyword">return</span> res                    visited<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>nextV<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#回溯</span>            <span class="token keyword">return</span> <span class="token number">0</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> query <span class="token keyword">in</span> queries<span class="token punctuation">:</span>            r<span class="token operator">=</span>dfs<span class="token punctuation">(</span>query<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>query<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>r <span class="token keyword">if</span> r<span class="token operator">!=</span><span class="token number">0</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#为什么用0不直接用-1标识不合法结果：除法运算必然结果不为0，但结果可能为-1.</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这题还可以用带权的并查集来解决。</p><h3 id="406-题-根据身高重建队列"><a href="#406-题-根据身高重建队列" class="headerlink" title="406 题 根据身高重建队列"></a>406 题 <a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">根据身高重建队列</a></h3><p><img src="406.png" alt="406题"></p><h4 id="思路：-48"><a href="#思路：-48" class="headerlink" title="思路："></a>思路：</h4><p>假设所有人都一样高，即（h，k）中的k均相同，那么重建队列将会很简单，直接将对应的人放在k位置处即可。</p><p>现在，每个人的高度可能不同。但上述方案也是可行的，因为个子矮的人相对于个子高的人是不可见的，所以我们只需要从高到低将每个人插入到对应位置即可。如果产生了碰撞，那么个子高的人会向后移动，事实上这对个子高的人的有序性不会产生影响，因为无论你在他之前插入多少矮个子的人，对他都是不可见的。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reconstructQueue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> people<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        people<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> person <span class="token keyword">in</span> people<span class="token punctuation">:</span>            people<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>person<span class="token punctuation">)</span>            people<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>person<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>person<span class="token punctuation">)</span>        <span class="token keyword">return</span> people<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n^2)$，排序需要&amp;O(nlogn)&amp;，而移动需要插入和删除各一次。由于这里是列表，而不是链表，所以移动需要&amp;O(n^2)&amp;的时间复杂度。</li><li>空间复杂度：$O(1)$，原地修改。</li></ul><h2 id="2020-4-16-（2-medium-2-easy）"><a href="#2020-4-16-（2-medium-2-easy）" class="headerlink" title="2020.4.16 （2 medium 2 easy）"></a>2020.4.16 （2 medium 2 easy）</h2><h3 id="416题-分割等和子集"><a href="#416题-分割等和子集" class="headerlink" title="416题 分割等和子集"></a>416题 <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">分割等和子集</a></h3><p><img src="416.png" alt="416题"></p><h4 id="思路：-49"><a href="#思路：-49" class="headerlink" title="思路："></a>思路：</h4><h5 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h5><p>这道题是0-1背包问题的扩展，首先，我们来看0-1背包问题：</p><blockquote><p>假设有n个重量为W1，W2，W3….Wn，价值为V1，V2，V3…..Vn的物品，需要放入一个容量为C的背包，每个物品最多被选中1次（0-1背包），问能放入物品的最大价值是多少？</p></blockquote><p>这道题是一道非常经典的动态规划题，其状态矩阵可能需要思考一段时间后才能定义出来。在本题中，动态规划的状态矩阵为dp[i] [j]，其中，i表示前i个物品，j表示容量为j，该状态矩阵的含义是前i个物品放入容量为j的背包中所能放入的最大价值。</p><p>我们知道，每一个物品只有两种选择：放或者不放。所以，动态规划转移时，当前状态有两种选择：</p><ul><li>dp[i-1] [j] （不放第i个物品，此时，总价值不变，前i-1个物品所能放入的背包容量仍然是j）</li><li>dp[i-1] [j-Wi]+Vi （放置第j个物品，此时总价值加上第j个物品的价值，但前i-1个物品所能放入的背包容量被占用了Wi的大小）</li></ul><p>我们只需要在每次转移时，从上述两个可能的源状态中选取最大的那个即可。特别地，当j&lt;Wi时，只能选择第一种源状态。当i==0时，也需要特判，直接初始化即可，如果dp[0] [j]大于等于W0就等于V0，否则，等于0。</p><pre class="line-numbers language-python"><code class="language-python">w<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>v<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">,</span><span class="token number">63</span><span class="token punctuation">]</span>c<span class="token operator">=</span><span class="token number">10</span>dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#0号物品的特判</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">>=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token number">0</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> j<span class="token operator">>=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假如我们需要找到最大价值的子集具体是哪些物品，可以从动态规划矩阵的最后一个位置进行回溯，回溯的具体方法是：看dp[i] [j] 等于 dp[i-1] [j] 还是 dp[i-1] [j-Wi]+Vi ，即可知第i个物品有没有被放入最大价值子集。</p><pre class="line-numbers language-python"><code class="language-python">i<span class="token operator">=</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span>j<span class="token operator">=</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>        i<span class="token operator">-=</span><span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#因为转移时只有两种可能，所以直接用else即可</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#此时，i号物品被放入最大价值子集</span>        j<span class="token operator">-=</span><span class="token punctuation">[</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>        i<span class="token operator">-=</span><span class="token number">1</span>    <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#0号元素需要特判</span>    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们知道，动态规划时，如果每个状态只和之前有限个状态有关，那么可以采用滚动数组的方式进行空间优化，01背包问题也可以这么做。由于dp[i] [j]的转移只和  dp[i-1] [j] 和 dp[i-1] [j-Wi]+Vi 有关，所以我们只需要存储一维列表即可。我们使用一维列表存放原状态矩阵上一行的值，然后从后向前计算，更新这个一维列表，即计算当前行的值。之所以从后向前，是因为前面的值在后面的计算中可能需要用到，这样做可以防止它们在被使用之前被覆盖。</p><pre class="line-numbers language-python"><code class="language-python">w<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>v<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">,</span><span class="token number">63</span><span class="token punctuation">]</span>c<span class="token operator">=</span><span class="token number">10</span>dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#需要先初始化0号物品的情况，0号物品可以正向计算</span>    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">>=</span>w<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token number">0</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> j<span class="token operator">>=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="回到本题"><a href="#回到本题" class="headerlink" title="回到本题"></a>回到本题</h5><p>我们再次分析本题，发现本题可以抽象成为一个01背包问题：第i个物品的价值和重量等于nums[i]，背包最大容量等于sum（nums）//2，求解最大价值子集，使其等于背包容量（即总和的一半）。</p><p>特别地，sum（nums）如果为奇数，必然找不到两个等和子集。一旦找到等于sum（nums）//2的价值时，可以提前退出。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canPartition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>                c<span class="token operator">=</span>sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> c<span class="token operator">%</span><span class="token number">2</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            c<span class="token operator">//=</span><span class="token number">2</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#需要先初始化0号物品的情况，0号物品可以正向计算</span>            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">>=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> j<span class="token operator">>=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>c<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了进一步进行优化，减少计算量，我们进一步抽象原本的问题。现在，动态规划状态矩阵 dp[i] [j] 是一个布尔值，代表nums的前i个数字是否可以拥有一个子集，值与j相等。则动态规划转移方程为：</p><ul><li>dp[i] [j]=dp[i-1] [j] or dp[i-1] [j-nums[i]]</li></ul><p>也就是说，如果（1）选择第i个数字（2）不选第i个数字 两种情况中有一个可以在前i个数字中构造一个子集 等于j，那么dp[i] [j] 就可以为真。</p><p>特别地，dp[i] [0] 始终为真。因为所有数字都是正整数，所以它们的和必然大于0，我们这里让dp[i] [0] 为真是让其作为一个哨兵元素，试想当nums[i]==j时，我们可以通过这个哨兵元素，得到dp[i] [j]= dp[i-1] [0]=True，从而不需要做额外的判断。</p><p>如果某一行的dp[i] [c]为真，说明前i个数字中存在子集和为c，可以说存在等和子集。</p><p>如果需要求解等和子集的内容，我们可以通过回溯指针实现，和01背包类似。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canPartition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>                c<span class="token operator">=</span>sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> c<span class="token operator">%</span><span class="token number">2</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            c<span class="token operator">//=</span><span class="token number">2</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#需要先初始化0号物品的情况，0号物品可以正向计算</span>            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span> <span class="token keyword">if</span> j<span class="token operator">==</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token boolean">False</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>                    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> j<span class="token operator">>=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">or</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>                <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，直接进行布尔运算，比计算数值更快速。</p><h3 id="437题-路径总和-III"><a href="#437题-路径总和-III" class="headerlink" title="437题 路径总和 III"></a>437题 <a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">路径总和 III</a></h3><p><img src="437.png" alt="437题"></p><h4 id="思路：-50"><a href="#思路：-50" class="headerlink" title="思路："></a>思路：</h4><p>最简单的方法是使用双层循环，以树中的每一个节点为起点，进行DFS，寻找路径和等于目标值的路径。这一方法也叫做双重递归。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#第一层递归</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#以树中每个节点为起点进行递归</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>pathsum<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#第二层递归</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>                pathsum<span class="token operator">+=</span>root<span class="token punctuation">.</span>val<span class="token comment" spellcheck="true">#记录下截止到当前节点的路径和</span>                <span class="token keyword">if</span> pathsum<span class="token operator">==</span>sum<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当路径和为sum时，结果数目加1</span>                    self<span class="token punctuation">.</span>res<span class="token operator">+=</span><span class="token number">1</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>pathsum<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>pathsum<span class="token punctuation">)</span>                pathsum<span class="token operator">-=</span>root<span class="token punctuation">.</span>val<span class="token comment" spellcheck="true">#回溯</span>        preorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，这样效率很低，因为会产生许多子树的重复遍历。</p><p>较好的思路是使用前缀和的方法。我们知道，任何一个有序数组的某一个区间[i，j]的和都可以由 j 的前缀和减去 i 的前缀和得到（第 i 的数字的前缀和指的是第0个数字+第1个数字+…+第 i 个数字），同理，本题中各路径和也可以由前缀和得到。我们通过记忆化递归的方法，使用备忘录记录下每个节点的前缀和，可以防止重复的递归。</p><p>求解节点 i 到 节点 j 的路径和，只需使用 j 的前缀和减去 i 的前缀和即可，这里的前缀和指的是根节点到当前节点处的路径上节点值总和。</p><p>我们使用前序遍历搜索，记录下当前路径列表和当前前缀和。然后将当前节点的前缀和与路径列表上每一个节点的前缀和相减，查看是否有路径和等于目标值。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        ht<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        self<span class="token punctuation">.</span>res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>path<span class="token punctuation">,</span>pathsum<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>                pathsum<span class="token operator">+=</span>root<span class="token punctuation">.</span>val                <span class="token keyword">if</span> pathsum<span class="token operator">==</span>sum<span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>res<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> root <span class="token operator">not</span> <span class="token keyword">in</span> ht<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    ht<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token operator">=</span>pathsum<span class="token comment" spellcheck="true">#前缀和备忘录</span>                <span class="token keyword">for</span> node <span class="token keyword">in</span> path<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历路径列表，采用前缀和相减的方式计算路径和</span>                    <span class="token keyword">if</span> pathsum<span class="token operator">-</span>ht<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token operator">==</span>sum<span class="token punctuation">:</span>                        self<span class="token punctuation">.</span>res<span class="token operator">+=</span><span class="token number">1</span>                path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#理论上，这个路径添加应该放在开头，但是因为自身路径和相减没有意义，所以放在这里更好</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>path<span class="token punctuation">,</span>pathsum<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>path<span class="token punctuation">,</span>pathsum<span class="token punctuation">)</span>                path<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#回溯</span>                pathsum<span class="token operator">-=</span>root<span class="token punctuation">.</span>val        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="438题-找到字符串中所有字母异位词"><a href="#438题-找到字符串中所有字母异位词" class="headerlink" title="438题 找到字符串中所有字母异位词"></a>438题 <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">找到字符串中所有字母异位词</a></h3><p><img src="438.png" alt="438题"></p><h4 id="思路：-51"><a href="#思路：-51" class="headerlink" title="思路："></a>思路：</h4><p>和第76题有些许相似，都是使用滑动窗口法。</p><p>使用两个指针start，end在待匹配串s上滑动区间[start,end)。其中，end=start+len（p）。</p><p>使用哈希表hashtable存放模式串p中的所有字母及其出现的次数。使用哈希表now存放当前滑动区间内的所有字母及其出现次数。</p><p>在s串上进行滑动匹配：</p><ul><li>如果now为空，说明滑动区间在起始位置或者刚刚被整体挪动过多个位置，此时需要重新统计当前滑动区间内的字母和出现次数。这里的统计采用倒序的方式，当倒序遍历到一个不在模式串p中的字母时，整体挪动滑动区间至该字母后面（所有包含此字母的区间都不必访问了），并清空now。否则将其使用哈希表now对当前字母进行统计。</li><li>如果now不为空，说明是由前一个滑动区间向后滑动一个位置得到，此时不需要整体更新，只需要将新遍历到的字母（end-1位置）加入到哈希表now即可。如果新遍历到的字母不在模式串p中，那么依然移动区间至新字母后。</li><li>如果当前区间内未出现不在模式串p中的字母，那么就尝试将当前区间统计哈希表now与模式串统计哈希表hashtable进行比较，如果相等，则将start加入到结果数组中。此时，无论是否相等，我们都需要将当前区间向前滑动一个位置。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> copy<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findAnagrams</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> p<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        l<span class="token operator">=</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span>        hashtable<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> p<span class="token punctuation">:</span>            <span class="token keyword">if</span> ch <span class="token operator">not</span> <span class="token keyword">in</span> hashtable<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                hashtable<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                hashtable<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>        start<span class="token operator">=</span><span class="token number">0</span>        end<span class="token operator">=</span>start<span class="token operator">+</span>l        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        now<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">while</span> end<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            flag<span class="token operator">=</span><span class="token boolean">False</span>            <span class="token keyword">if</span> now<span class="token operator">==</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>end<span class="token number">-1</span><span class="token punctuation">,</span>start<span class="token number">-1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> hashtable<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        flag<span class="token operator">=</span><span class="token boolean">True</span>                        start<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span>                        end<span class="token operator">=</span>start<span class="token operator">+</span>l                        now<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>                        <span class="token keyword">break</span>                    <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> now<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        now<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        now<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>end<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token keyword">in</span> hashtable<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> s<span class="token punctuation">[</span>end<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token keyword">in</span> now<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        now<span class="token punctuation">[</span>s<span class="token punctuation">[</span>end<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        now<span class="token punctuation">[</span>s<span class="token punctuation">[</span>end<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    start<span class="token operator">=</span>end                    end<span class="token operator">=</span>start<span class="token operator">+</span>l                    now<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>                    flag<span class="token operator">=</span><span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token operator">not</span> flag<span class="token punctuation">:</span>                <span class="token keyword">if</span> now<span class="token operator">==</span>hashtable<span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>start<span class="token punctuation">)</span>                now<span class="token punctuation">[</span>s<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>                start<span class="token operator">+=</span><span class="token number">1</span>                end<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="448题-找到所有数组中消失的数字"><a href="#448题-找到所有数组中消失的数字" class="headerlink" title="448题  找到所有数组中消失的数字"></a>448题 <a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener"> 找到所有数组中消失的数字</a></h3><p><img src="448.png" alt="448题"></p><h4 id="思路：-52"><a href="#思路：-52" class="headerlink" title="思路："></a>思路：</h4><p>和之前做过的第41题类似，采用原地哈希映射的方式，将数字i映射到数组下标为i-1的位置上。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findDisappearedNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>pos1<span class="token punctuation">,</span>pos2<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#一定要这样交换！python的机制问题，否则会出错。</span>            nums<span class="token punctuation">[</span>pos1<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>pos2<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>pos2<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>pos1<span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                swap<span class="token punctuation">(</span>i<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">!=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-17-（2-medium，3-easy）"><a href="#2020-4-17-（2-medium，3-easy）" class="headerlink" title="2020.4.17 （2 medium，3 easy）"></a>2020.4.17 （2 medium，3 easy）</h2><h3 id="461题-汉明距离"><a href="#461题-汉明距离" class="headerlink" title="461题 汉明距离"></a>461题 汉明距离</h3><p><img src="461.png" alt="461题"></p><h4 id="思路：-53"><a href="#思路：-53" class="headerlink" title="思路："></a>思路：</h4><p>比较简单，可以用按位异或+统计1的个数的方法来进行汉明距离的统计。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">,</span> y<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        x<span class="token operator">=</span>x<span class="token operator">^</span>y        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span> x<span class="token punctuation">:</span>            x<span class="token operator">&amp;</span><span class="token operator">=</span>x<span class="token number">-1</span>            res<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="494题-目标和"><a href="#494题-目标和" class="headerlink" title="494题 目标和"></a>494题 <a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">目标和</a></h3><p><img src="494.png" alt="494题"></p><h4 id="思路：-54"><a href="#思路：-54" class="headerlink" title="思路："></a>思路：</h4><p>这道题，我的思路是使用BFS 的方法，进行所有计算路径的遍历，同时在遍历过程中，合并和重复的路径，防止重复遍历。</p><p>有点类似于之前的完全平方和问题和找零钱问题。不过这道题与找零钱的不同之处在于：找零钱只需要知道是否有组合，本题还需要知道组合的数目。所以本题要用到哈希表存放当前层的和以及每个和的组合数目。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> S<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        ht<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#初始情况下，哈希表中只有一个0（为什么不用队列，因为哈希表按key存取，合并相同和的组合更方便）</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历数组中所有数</span>            tmp<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>            <span class="token keyword">for</span> key <span class="token keyword">in</span> list<span class="token punctuation">(</span>ht<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历1...num所有的和</span>                newnums<span class="token operator">=</span><span class="token punctuation">[</span>key<span class="token operator">+</span>num<span class="token punctuation">,</span>key<span class="token operator">-</span>num<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#每个和与当前数的+和-进行相加</span>                <span class="token keyword">for</span> newnum <span class="token keyword">in</span> newnums<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#结果存入临时哈希表</span>                    <span class="token keyword">if</span> newnum <span class="token operator">not</span> <span class="token keyword">in</span> tmp<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        tmp<span class="token punctuation">[</span>newnum<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">*</span>ht<span class="token punctuation">[</span>key<span class="token punctuation">]</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        tmp<span class="token punctuation">[</span>newnum<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span><span class="token operator">*</span>ht<span class="token punctuation">[</span>key<span class="token punctuation">]</span>            ht<span class="token operator">=</span>tmp<span class="token comment" spellcheck="true">#更新本层BFS后的哈希表</span>        <span class="token keyword">return</span> ht<span class="token punctuation">[</span>S<span class="token punctuation">]</span> <span class="token keyword">if</span> S <span class="token keyword">in</span> ht<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token comment" spellcheck="true">#返回最后一层结果中，key（即和）为S的组合数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，我们还可以使用01背包的动态规划解法。假设动态规划状态矩阵dp[i] [j]为前 i 个数字和为 j 一共有多少种情况，则动态规划转移方程为：</p><ul><li>dp[i] [j] = dp[j-nums[i]] + dp[j+nums[i]]</li></ul><p>也就是说，上述动态规划转移方程考虑了是否选取当前数字的两种情况，进行状态转移。</p><p>这里的 j 的范围是数组nums所有数字之和可能的值域，即[-sum，sum]，特别的，由于每层状态的转移只依赖上一层状态，所以我们可以进行状态压缩。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> S<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        summa<span class="token operator">=</span>sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> summa<span class="token operator">&lt;</span>abs<span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果数组元素之和小于S，必不可能计算出S</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token operator">-</span>summa<span class="token punctuation">,</span>summa<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#从[-sum,sum]共2*sum+1个元素，dp[sum]即为和为0的情况</span>        dp<span class="token punctuation">[</span>summa<span class="token operator">+</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        dp<span class="token punctuation">[</span>summa<span class="token operator">-</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            next<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token operator">-</span>summa<span class="token punctuation">,</span>summa<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#需要注意！这里的本层元素依赖的上一层元素，其上一层的j可能大于也可能小于当前层的j，所以无法只用一个数组通过倒序（like 01背包模板）遍历的方式更新，要使用辅助数组，和上面BFS解法的辅助哈希表类似。</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                add<span class="token operator">=</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token comment" spellcheck="true">#考虑越界的情况</span>                minus<span class="token operator">=</span>dp<span class="token punctuation">[</span>j<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>j<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">0</span>                next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>add<span class="token operator">+</span>minus            dp<span class="token operator">=</span>next        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>summa<span class="token operator">+</span>S<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="538题-二叉搜索树转换为累加树"><a href="#538题-二叉搜索树转换为累加树" class="headerlink" title="538题 二叉搜索树转换为累加树"></a>538题 <a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">二叉搜索树转换为累加树</a></h3><p><img src="538.png" alt="538题"></p><h4 id="思路：-55"><a href="#思路：-55" class="headerlink" title="思路："></a>思路：</h4><p>我们知道，二叉搜索树的中序遍历（左、中、右）得到的节点，其val是依次递增的，同理，反向中序遍历（右、中、左）得到的节点，其val依次递减。</p><p>这样我们将反向中序遍历所得到的节点的val依次累加并更新当前节点的val，即可使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 </p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">convertBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>s<span class="token operator">=</span><span class="token number">0</span><span class="token comment" spellcheck="true">#用于记录遍历到当前节点前的所有节点值得累加和</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>                recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                root<span class="token punctuation">.</span>val<span class="token operator">+=</span>self<span class="token punctuation">.</span>s                self<span class="token punctuation">.</span>s<span class="token operator">=</span>root<span class="token punctuation">.</span>val                recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="543题-二叉树的直径"><a href="#543题-二叉树的直径" class="headerlink" title="543题 二叉树的直径"></a>543题 <a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">二叉树的直径</a></h3><p><img src="543.png" alt="543题"></p><h4 id="思路：-56"><a href="#思路：-56" class="headerlink" title="思路："></a>思路：</h4><p>可以后序遍历来做。</p><p>以当前节点为根节点的子树，其最大直径上的节点数为：递归搜索左子树返回的值加上递归搜索右子树返回的值再加1。递归函数的返回值的含义是：以当前节点为一个端点的路径的最大节点数。它与最大直径的区别在于：最大直径路径只需要经过root即可，返回的路径需要以root为端点。具体为什么这么做是因为如果直接返回当前节点的最大直径路径，无法与上一层节点组成有效路径，会出现环路。</p><p>我们每次递归时，尝试用当前子树的最大直径路径上的节点数更新全局变量Self.max_d。最后将他的值减去1，即为最大直径路径上的边数。此外，还需要对空树进行特判。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">diameterOfBinaryTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>max_d<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                left<span class="token operator">=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                right<span class="token operator">=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>max_d<span class="token operator">=</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>max_d<span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">+</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>max<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>        recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>max_d<span class="token number">-1</span> <span class="token keyword">if</span> root<span class="token operator">!=</span>None <span class="token keyword">else</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-18-（2-medium，2-easy）"><a href="#2020-4-18-（2-medium，2-easy）" class="headerlink" title="2020.4.18 （2 medium，2 easy）"></a>2020.4.18 （2 medium，2 easy）</h2><h3 id="560题-和为K的子数组"><a href="#560题-和为K的子数组" class="headerlink" title="560题 和为K的子数组"></a>560题 <a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">和为K的子数组</a></h3><p><img src="560.png" alt="560题"></p><h4 id="思路：-57"><a href="#思路：-57" class="headerlink" title="思路："></a>思路：</h4><p>一开始想用区间DP，发现超时了。</p><p>联想到我们前几天做过的寻找二叉树中路径和为k的路径这一问题，我们不难想到本题也可以用前缀和来解决。子数组nums[i：j]可以通过前缀和prefixsum[j]-prefixsum[i]求解。比较它的值是否为k即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">subarraySum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        prefixsum<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        prefixsum<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>prefixsum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            prefixsum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>prefixsum<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>prefixsum<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>prefixsum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> prefixsum<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span>prefixsum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>k<span class="token punctuation">:</span>                    res<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n^2)$。</li><li>空间复杂度：$O(n)$。</li></ul><p>由于我们比较的对象为：prefixsum[j]-prefixsum[i]==k，可以转化为prefixsum[j]-k=prefixsum[i]，所以我们只需要在每次统计前缀和prefixsum[j]时，顺便看是否已经有统计到的前缀和prefixsum[i]等于此时的前缀和prefixsum[j]减去k即可。特别地，对于prefixsum[j]-k=prefixsum[i]，j 之前可能有多个 i 符合该条件。我们可以使用哈希表来进行优化。</p><p>哈希表ht的key为前缀和的值，value为目前有几个前缀和等于key。我们只需要为结果加上ht[prefixsum[j]-k]即可。每次遍历数组需要对哈希表进行更新。</p><pre class="line-numbers language-PYTHON"><code class="language-PYTHON">class Solution:    def subarraySum(self, nums: List[int], k: int) -> int:        prefixsum=0        ht={0:1}        res=0        for num in nums:            prefixsum+=num            if prefixsum-k in ht.keys():                res+=ht[prefixsum-k]            if prefixsum in ht.keys():                ht[prefixsum]+=1            else:                ht[prefixsum]=1        return res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，可以将时间复杂度降为$O(n)$。</p><h3 id="581题-最短无序连续子数组"><a href="#581题-最短无序连续子数组" class="headerlink" title="581题 最短无序连续子数组"></a>581题 <a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">最短无序连续子数组</a></h3><p><img src="581.png" alt="581题"></p><h4 id="思路：-58"><a href="#思路：-58" class="headerlink" title="思路："></a>思路：</h4><p>我们知道，一个单调递增的序列，其每个数字都大于之前所有数字，也就是大于它们的最大值。一个单调递减的序列，其每个数字小于之前所有数字。</p><p>本题中，我们只需要正向遍历数组，找到不符合单调递增性质的最后一个数字，作为最短无序连续数组的右边界。接着反向遍历数组，找到不符合单调递减性质的最后一个数字，作为左边界。即可找到结果。</p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findUnsortedSubarray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        max_now<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        right<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>max_now<span class="token punctuation">:</span>                right<span class="token operator">=</span>i            max_now<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>max_now<span class="token punctuation">)</span>        min_now<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        left<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>min_now<span class="token punctuation">:</span>                left<span class="token operator">=</span>i            min_now<span class="token operator">=</span>min<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>min_now<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span> <span class="token keyword">if</span> right<span class="token operator">-</span>left<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token keyword">else</span> right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本质上是在维护一个单调栈。</p><h3 id="617题-合并二叉树"><a href="#617题-合并二叉树" class="headerlink" title="617题 合并二叉树"></a>617题 <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">合并二叉树</a></h3><p><img src="617.png" alt="617题"></p><h4 id="思路：-59"><a href="#思路：-59" class="headerlink" title="思路："></a>思路：</h4><p>我们采用递归的方式对二叉树进行合并，将t2子树合并到t1子树上去。如果t1子树为空，那么直接返回t2子树。如果t2子树为空，那么直接返回t1子树。否则，将t2节点的值加到t1上，然后分别合并二者的左子树和右子树。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> t1<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> t2<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> t1<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> t2        <span class="token keyword">elif</span> t2<span class="token operator">==</span>None<span class="token punctuation">:</span>            <span class="token keyword">return</span> t1        <span class="token keyword">else</span><span class="token punctuation">:</span>            t1<span class="token punctuation">.</span>val<span class="token operator">+=</span>t2<span class="token punctuation">.</span>val            t1<span class="token punctuation">.</span>left<span class="token operator">=</span>self<span class="token punctuation">.</span>mergeTrees<span class="token punctuation">(</span>t1<span class="token punctuation">.</span>left<span class="token punctuation">,</span>t2<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            t1<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>mergeTrees<span class="token punctuation">(</span>t1<span class="token punctuation">.</span>right<span class="token punctuation">,</span>t2<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">return</span> t1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="621题-任务调度器"><a href="#621题-任务调度器" class="headerlink" title="621题 任务调度器"></a>621题 <a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">任务调度器</a></h3><p><img src="621.png" alt="621题"></p><h4 id="思路：-60"><a href="#思路：-60" class="headerlink" title="思路："></a>思路：</h4><p>可以采用找规律的数学解法。</p><p>因为相同任务必须要有时间片为 n 的间隔，所以我们先把出现次数最多的任务 A 安排上（当然你也可以选择任务 B）。例子中 n = 2，那么任意两个任务 A 之间都必须间隔 2 个单位的时间：</p><blockquote><p>A -&gt; (单位时间) -&gt; (单位时间) -&gt; A -&gt; (单位时间) -&gt; (单位时间) -&gt; A</p></blockquote><p>中间间隔的单位时间可以用来安排别的任务，也可以处于“待命”状态。当然，为了使总任务时间最短，我们要尽可能地把单位时间分配给其他任务。现在把任务 B 安排上：</p><blockquote><p>A -&gt; B -&gt; (单位时间) -&gt; A -&gt; B -&gt; (单位时间) -&gt; A -&gt; B</p></blockquote><p>很容易观察到，前面两个 A 任务一定会固定跟着 2 个单位时间的间隔。最后一个 A 之后是否还有任务跟随取决于是否存在与任务 A 出现次数相同的任务。</p><p>所以整体的解题步骤如下：</p><ol><li>计算每个任务出现的次数</li><li>找出出现次数最多的任务，假设出现次数为 x</li><li>计算至少需要的时间 (x - 1) * (n + 1)，记为 min_time</li><li>计算出现次数为 x 的任务总数 count，计算最终结果为 min_time + count。特别注意，这里的最终结果必须大于任务数目，因为最小时间是任务数目（无拥塞）。</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">leastInterval</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tasks<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        task_table<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> len<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span>        <span class="token keyword">for</span> task <span class="token keyword">in</span> tasks<span class="token punctuation">:</span>            <span class="token keyword">if</span> task <span class="token keyword">in</span> task_table<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                task_table<span class="token punctuation">[</span>task<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                task_table<span class="token punctuation">[</span>task<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>        max_times<span class="token operator">=</span>max<span class="token punctuation">(</span>list<span class="token punctuation">(</span>task_table<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        res<span class="token operator">=</span><span class="token punctuation">(</span>max_times<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        res<span class="token operator">+=</span>list<span class="token punctuation">(</span>task_table<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>count<span class="token punctuation">(</span>max_times<span class="token punctuation">)</span>        <span class="token keyword">return</span> res <span class="token keyword">if</span> res<span class="token operator">>=</span>len<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span> <span class="token keyword">else</span> len<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-19-（2-medium）"><a href="#2020-4-19-（2-medium）" class="headerlink" title="2020.4.19 （2 medium）"></a>2020.4.19 （2 medium）</h2><h3 id="647题-回文子串"><a href="#647题-回文子串" class="headerlink" title="647题 回文子串"></a>647题 <a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">回文子串</a></h3><p><img src="647.png" alt="647题"></p><h4 id="思路：-61"><a href="#思路：-61" class="headerlink" title="思路："></a>思路：</h4><p>中心扩展法，类似于求解最大回文子串问题，只需要稍微修改一下，每一次扩展时将计数变量加1即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countSubstrings</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">centerexpand</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token operator">=</span><span class="token number">0</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>i <span class="token operator">and</span> j<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token operator">+=</span><span class="token number">1</span>                i<span class="token operator">-=</span><span class="token number">1</span>                j<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">return</span> res        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res1<span class="token operator">=</span>centerexpand<span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span>            res2<span class="token operator">=</span>centerexpand<span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> res1<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                res<span class="token operator">+=</span>res1            <span class="token keyword">if</span> res2<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                res<span class="token operator">+=</span>res2        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><h3 id="739题-每日温度"><a href="#739题-每日温度" class="headerlink" title="739题 每日温度"></a>739题 <a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">每日温度</a></h3><p><img src="739.png" alt="739题"></p><h4 id="思路：-62"><a href="#思路：-62" class="headerlink" title="思路："></a>思路：</h4><p>使用单调栈来做。这题使用一个单调递减栈，栈内存放天数和该天的温度，温度从栈底到栈顶依次单调递减。遍历数组T。如果第i天的温度小于等于栈顶元素的温度，那么直接将（i，T（i））入栈。如果大于栈顶元素温度，说明此时必然是第一次高过此温度，则可以将栈顶元素的天数j的结果记录为：res[j]=i-j。</p><p>也就是说，我们的单调递减栈存放的是尚未有温度升高超过的各天和它们的温度。每次向后遍历一天，查看当天气温是否比栈顶最低气温高，是则将二者天数差值保存进结果数组，并且将栈顶元素出栈，比较当天气温与栈中第二低的气温；否则入栈保存，继续向后遍历。</p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(n)$。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> T<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> stack<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">or</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> stack<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    j<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                    res<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">-</span>j                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-20-（3-easy，1-medium）"><a href="#2020-4-20-（3-easy，1-medium）" class="headerlink" title="2020.4.20 （3 easy，1 medium）"></a>2020.4.20 （3 easy，1 medium）</h2><h3 id="88题-合并两个有序数组"><a href="#88题-合并两个有序数组" class="headerlink" title="88题 合并两个有序数组"></a>88题 <a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">合并两个有序数组</a></h3><p><img src="88.png" alt="88题"></p><h4 id="思路：-63"><a href="#思路：-63" class="headerlink" title="思路："></a>思路：</h4><p>这道题是经典的归并排序问题，可以使用双指针法来做。</p><p>唯一需要注意的是，本题将第一个数组原地修改为结果数组，如果从前向后归并排序，那么可能会将第一个数组中尚未被遍历到的数字覆盖掉。为了解决这一问题，我们可以从后向前归并排序。指针p指向数组nums1最后一个非零元素，q指向nums2最后一个非零元素，r指向nums1的尾部。具体流程如代码所示：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify nums1 in-place instead.        """</span>        p<span class="token operator">=</span>m<span class="token number">-1</span>        q<span class="token operator">=</span>n<span class="token number">-1</span>        r<span class="token operator">=</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> q<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#将p和q中较大的数字放在r上</span>                nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span>                q<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span>                p<span class="token operator">-=</span><span class="token number">1</span>            r<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">while</span> q<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#因为如果是nums1的前面有数字没有被遍历完，由于是原地修改nums1，所以此时无需移动，也就没有必要判断nums1未遍历完的情况，只需要判断nums2未遍历完的情况。</span>            nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span>            r<span class="token operator">-=</span><span class="token number">1</span>            q<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> nums1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="122题-买卖股票的最佳时机-II"><a href="#122题-买卖股票的最佳时机-II" class="headerlink" title="122题 买卖股票的最佳时机 II"></a>122题<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener"> 买卖股票的最佳时机 II</a></h3><p><img src="122.png" alt="122题"></p><h4 id="思路：-64"><a href="#思路：-64" class="headerlink" title="思路："></a>思路：</h4><p>所有的买卖股票问题本质上都可以使用动态规划来解决。状态矩阵dp[i] [j]为第 i 天的第 j 个选择总收益。本题中，存在两种选择：（特别地，在有冷冻期的那道题，我们需要特别讨论冷冻状态）</p><ul><li>当日持仓（持有股票）：有前一日持仓，当日继续持仓和前一日空仓，当日买入股票持仓两种情况。由于需要得到的是最大利润，所以我们选取两种情况各自所能获得的最大利润作为当日状态。</li><li>当日空仓（不持有股票）：有前一日空仓，当日继续空仓和前一日持仓，当日卖出股票空仓两种情况。由于需要得到的是最大利润，所以我们选取两种情况各自所能获得的最大利润作为当日状态。</li></ul><p>得到了DP矩阵和转移方程，我们就可以求解。通过动态规划，我们可以获得最后一天持仓和空仓的最大收益。由于最后一天持仓无法卖出，必然小于空仓的收益，所以我们直接返回最后一天空仓的收益即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(n)$。</li></ul><p>特别地，本题还可以用贪心算法来做。假设我们是一个特别保守的股票交易员，一旦当前买入的股票第二天能够赚钱，就迅速买入并在第二天卖出。如下图所示，也就是统计所有上升的小段。</p><p><img src="122-1.png" alt="122题"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>prices<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                res<span class="token operator">+=</span>prices<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><h3 id="217题-存在重复元素"><a href="#217题-存在重复元素" class="headerlink" title="217题 存在重复元素"></a>217题 <a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener">存在重复元素</a></h3><p><img src="217.png" alt="217题"></p><h4 id="思路：-65"><a href="#思路：-65" class="headerlink" title="思路："></a>思路：</h4><p>可以使用哈希集合来存放已出现过的数字。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">containsDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        hs<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> num <span class="token operator">not</span> <span class="token keyword">in</span> hs<span class="token punctuation">:</span>                hs<span class="token punctuation">.</span>add<span class="token punctuation">(</span>num<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="230题-二叉搜索树中第K小的元素"><a href="#230题-二叉搜索树中第K小的元素" class="headerlink" title="230题 二叉搜索树中第K小的元素"></a>230题 <a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">二叉搜索树中第K小的元素</a></h3><p><img src="230.png" alt="230题"></p><h4 id="思路：-66"><a href="#思路：-66" class="headerlink" title="思路："></a>思路：</h4><p>通过中序遍历二叉搜素树，可以获得它的升序序列。使用类变量count存放当前遍历的次数，如果达到k，那么返回当前节点的元素值（剪枝）。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">kthSmallest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res<span class="token operator">=</span>None        self<span class="token punctuation">.</span>count<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>res<span class="token operator">!=</span>None<span class="token punctuation">:</span>                    <span class="token keyword">return</span>                inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>count<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>count<span class="token operator">==</span>k<span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>res<span class="token operator">=</span>root<span class="token punctuation">.</span>val                <span class="token keyword">if</span> self<span class="token punctuation">.</span>res<span class="token operator">!=</span>None<span class="token punctuation">:</span>                    <span class="token keyword">return</span>                inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2020-4-21-（4-easy）"><a href="#2020-4-21-（4-easy）" class="headerlink" title="2020.4.21 （4 easy）"></a>2020.4.21 （4 easy）</h2><h3 id="231题-2的幂"><a href="#231题-2的幂" class="headerlink" title="231题 2的幂"></a>231题 <a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">2的幂</a></h3><p><img src="231.png" alt="231题"></p><h4 id="思路：-67"><a href="#思路：-67" class="headerlink" title="思路："></a>思路：</h4><p>简单题，当n小于1时，不可能是2的幂，当n大于等于1时，如果能被2持续整除而没有余数，直到等于1，说明它是2的幂。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> n<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">while</span> n<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            n<span class="token operator">=</span>n<span class="token operator">//</span><span class="token number">2</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(logN)$</li></ul><p>但同时，我们可以使用位运算的极简解法。我们知道：n&amp;（n-1）是去除n的二进制中最后一位1（之前的位运算题目有涉及）。同时，假设一个数是2的幂，那么它的二进制数必然只有最高位为1。所以，n&amp;（n-1）必然等于0。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">return</span> n<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> n<span class="token operator">&amp;</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(1)$</li></ul><h3 id="235题-二叉搜索树的最近公共祖先"><a href="#235题-二叉搜索树的最近公共祖先" class="headerlink" title="235题 二叉搜索树的最近公共祖先"></a>235题 <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a></h3><p><img src="235.png" alt="235题"></p><h4 id="思路：-68"><a href="#思路：-68" class="headerlink" title="思路："></a>思路：</h4><p>简单题，剑指Offer原题。由于本题是一个二叉搜索树，分类讨论的情况为：</p><ul><li><p>如果root的值位于p、q值之间，说明root必然是它们的最近公共祖先。</p></li><li><p>如果root的值均大于p、q，说明p、q必在root的左子树，递归查找。</p></li><li><p>如果root的值均小于p、q，说明p、q必在root的右子树，递归查找。</p></li><li><p>如果root的值等于p的值或者q的值，说明root必然是它们的最近公共祖先 （<strong>一个节点也可以是它自己的祖先</strong>） 。</p></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>p<span class="token punctuation">.</span>val <span class="token operator">or</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>q<span class="token punctuation">.</span>val <span class="token punctuation">:</span>            <span class="token keyword">return</span> root        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">></span>p<span class="token punctuation">.</span>val <span class="token operator">and</span> root<span class="token punctuation">.</span>val<span class="token operator">></span>q<span class="token punctuation">.</span>val <span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>p<span class="token punctuation">.</span>val <span class="token operator">and</span> root<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>q<span class="token punctuation">.</span>val <span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>        <span class="token keyword">if</span> q<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>p<span class="token punctuation">.</span>val <span class="token operator">or</span> p<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="237题-删除链表中的节点"><a href="#237题-删除链表中的节点" class="headerlink" title="237题 删除链表中的节点"></a>237题 <a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">删除链表中的节点</a></h3><p><img src="237.png" alt="237题"></p><h4 id="思路：-69"><a href="#思路：-69" class="headerlink" title="思路："></a>思路：</h4><p>这道题并没有给出链表的头节点，我一开始以为题目出错了。因为常规的删除节点方法都需要用到被删除节点的前一个节点。</p><p>但其实删除链表的节点也可以不使用前一个节点，而是将当前节点值与后一个节点交换。这样，删除当前节点就转变为删除当前节点的下一个节点，也就可以使用常规方法修改前一个节点的next指针删除节点了。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type node: ListNode        :rtype: void Do not return anything, modify node in-place instead.        """</span>        node<span class="token punctuation">.</span>val<span class="token operator">=</span>node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val        node<span class="token punctuation">.</span>next<span class="token operator">=</span>node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="292题-Nim-游戏"><a href="#292题-Nim-游戏" class="headerlink" title="292题 Nim 游戏"></a>292题 <a href="https://leetcode-cn.com/problems/nim-game/" target="_blank" rel="noopener">Nim 游戏</a></h3><p><img src="292.png" alt="292题"></p><h4 id="思路：-70"><a href="#思路：-70" class="headerlink" title="思路："></a>思路：</h4><p>一开始，我想到了动态规划解法。dp[i]为石头数为 i 时，玩家能否获胜。转移方程为：</p><ul><li>dp[i] = True，if i &lt;=3</li><li>dp[i] = not(dp[i-1] and dp[i-2] and dp[i-3]) ,if i&gt;3</li></ul><p>当 i 大于3时，我们需要看当前的玩家拿走1、2或3个石头后，对方剩余的石头数能否获胜。如果三种情况下对方均能获胜，则dp [i]为False，否则为 True。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canWinNim</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">not</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">and</span> dp<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span> <span class="token operator">and</span> dp<span class="token punctuation">[</span>i<span class="token number">-3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，这在python下会超时。</p><p>我们继续分析：由状态转移方程可以得知：只要dp[i-1]或dp[i-2]或dp[i-3]中存在一个为假，则dp[i]为真。所以，dp[i]为假，必然导致dp[i+1]、dp[i+2]、dp[i+3]为真。由于dp[i+1]、dp[i+2]、dp[i+3]为真，所以dp[i+4]必然为假。</p><p>综上所述，我们发现规律：当 i 被4整除时，必然失败，否则必然获胜。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canWinNim</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">return</span> n<span class="token operator">%</span><span class="token number">4</span><span class="token operator">!=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该问题又叫巴比博弈，设最多能拿M块石头，共有N块石头，则结果的真假为N%（M+1）！=0。</p><h2 id="2020-4-22-（2-medium-2-easy）"><a href="#2020-4-22-（2-medium-2-easy）" class="headerlink" title="2020.4.22 （2 medium 2 easy）"></a>2020.4.22 （2 medium 2 easy）</h2><h3 id="89题-格雷编码"><a href="#89题-格雷编码" class="headerlink" title="89题 格雷编码"></a>89题 格雷编码</h3><p><img src="89.png" alt="89题"></p><h4 id="思路：-71"><a href="#思路：-71" class="headerlink" title="思路："></a>思路：</h4><p>一开始尝试了深搜+回溯，貌似超时了。于是，我们想到使用动态规划法去优化。</p><p>这道题的动态规划状态比较特殊。我们使用每一个不同位数时的格雷编码数组，去递归下一个位数时的格雷编码数组。</p><p>那么动态规划是如何转移的呢？格雷编码是采用镜像反射法递推的。</p><p>根据信息论的知识，去除最高位后，格雷码本身是镜像对称的。我们只需要将第 i 位时刻的格雷编码，倒序后进行拼接，前半部分补全0，后半部分补全1，即可。</p><p><img src="89-1.png" alt="89题"></p><p>二进制的最高位补0，意味着不变，补1，意味着加上2的当前位数减1次方。这里，我们可以使用一个变量head来进行补1操作，并通过移位运算进行更新。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">grayCode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        head<span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token operator">+=</span><span class="token punctuation">[</span>x<span class="token operator">+</span>head <span class="token keyword">for</span> x <span class="token keyword">in</span> res<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>            head<span class="token operator">&lt;&lt;</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="344-题-反转字符串"><a href="#344-题-反转字符串" class="headerlink" title="344 题 反转字符串"></a>344 题 <a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">反转字符串</a></h3><p><img src="344.png" alt="344题"></p><h4 id="思路：-72"><a href="#思路：-72" class="headerlink" title="思路："></a>思路：</h4><p>没什么好说的，简单题，双指针法即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify s in-place instead.        """</span>        l<span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> l<span class="token operator">&lt;</span>r<span class="token punctuation">:</span>            s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span>            l<span class="token operator">+=</span><span class="token number">1</span>            r<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="557题-反转字符串中的单词-III"><a href="#557题-反转字符串中的单词-III" class="headerlink" title="557题 反转字符串中的单词 III"></a>557题 <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">反转字符串中的单词 III</a></h3><p><img src="557.png" alt="557题"></p><h4 id="思路：-73"><a href="#思路：-73" class="headerlink" title="思路："></a>思路：</h4><p>我的思路是：首先，遍历字符串，使用变量L记录一个单词的开始。每当遇到空格，我们就将L到当前字符前一个位置的字符串进行翻转，即翻转了一个单词，并修改L为当前字符下一个位置，即新单词的开头。需要注意的是，最后一个单词由于末尾没有空格，需要遍历完成后单独翻转。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseWords</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">reverse</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> l<span class="token operator">&lt;</span>r<span class="token punctuation">:</span>                s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                l<span class="token operator">+=</span><span class="token number">1</span>                r<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">if</span> s<span class="token operator">==</span><span class="token string">""</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">""</span>        s<span class="token operator">=</span>list<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        l<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">" "</span><span class="token punctuation">:</span>                reverse<span class="token punctuation">(</span>l<span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">)</span>                l<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span>        reverse<span class="token punctuation">(</span>l<span class="token punctuation">,</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="71题-简化路径"><a href="#71题-简化路径" class="headerlink" title="71题 简化路径"></a>71题 <a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">简化路径</a></h3><p><img src="71.png" alt="71题"></p><h4 id="思路：-74"><a href="#思路：-74" class="headerlink" title="思路："></a>思路：</h4><p>我们使用一个地址栈来保存当前所在的路径各级目录。将题目给出的原路径按照“/”进行分割，即可得到原始的各目录操作。</p><p>接下来对每个目录操作进行处理：</p><ul><li>如果当前操作为”..”，则将地址栈中的栈顶目录出栈，也就是等于从当前目录返回上级目录。需要注意的是，如果栈为空，那么直接跳过即可。</li><li>如果当前操作为”.”，那么什么也不做，保持在当前目录。特别注意，由于切片机制，可能会出现全空的目录操作，对于这种情况，我们也直接continue。</li><li>如果当前操作为其他，说明它们必定是下一级目录的名称，直接将其入栈保存即可，相当于执行了cd命令。</li></ul><p>最后，我们将地址栈中的各级目录使用”/“进行拼接。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">simplifyPath</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> path<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        li<span class="token operator">=</span>path<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>        now_path<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> op <span class="token keyword">in</span> li<span class="token punctuation">:</span>            <span class="token keyword">if</span> op<span class="token operator">==</span><span class="token string">".."</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> now_path <span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    now_path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">elif</span> op <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                now_path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>op<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">"/"</span><span class="token operator">+</span><span class="token string">"/"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>now_path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(len(path))$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法整理汇总（附代码）</title>
      <link href="/2020/02/16/sort-algorithms/"/>
      <url>/2020/02/16/sort-algorithms/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。</p><p><strong>本文并不会详细讲解每种排序算法的原理</strong>，网上有很多很好的教程，大家可以自己去搜了看。</p><p>最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 <a href="https://leetcode-cn.com/problems/sort-an-array/" title="LeetCode 912. 排序数组" target="_blank" rel="noopener">LeetCode 912. 排序数组</a> 这道题。</p><h2 id="性质汇总"><a href="#性质汇总" class="headerlink" title="性质汇总"></a>性质汇总</h2><blockquote><p>如果发现表中有错误，请留言告知。</p></blockquote><table><thead><tr><th>算法</th><th>最好</th><th>最坏</th><th>平均</th><th>空间</th><th align="center">稳定性</th><th align="center">是否基于比较</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>插入排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>快速排序</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(n\log n)$</td><td>$O(\log n)$~$O(n)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>归并排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>希尔排序</td><td>$O(n^{1.3})$</td><td>$O(n^2)$</td><td>$O(n\log n)$~$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>基数排序</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>桶排序</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n+m)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>堆排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr></tbody></table><blockquote><p>如果表格显示有问题的话，还可以直接看下面的汇总图：</p></blockquote><p><img src="1.png" alt="十大经典排序算法性质汇总"></p><h3 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h3><p>我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。</p><p><strong>冒泡排序</strong><br><a href="https://en.wikipedia.org/wiki/Bubble_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bubble_sort</a></p><p><strong>选择排序</strong><br><a href="https://en.wikipedia.org/wiki/Selection_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Selection_sort</a></p><p><strong>插入排序</strong><br><a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Insertion_sort</a></p><p><strong>快速排序</strong><br><a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Quicksort</a></p><p><strong>归并排序</strong><br><a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Merge_sort</a></p><p><strong>希尔排序</strong><br><a href="https://en.wikipedia.org/wiki/Shellsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Shellsort</a></p><p><strong>计数排序</strong><br><a href="https://en.wikipedia.org/wiki/Counting_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Counting_sort</a></p><p><strong>基数排序</strong><br><a href="https://en.wikipedia.org/wiki/Radix_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Radix_sort</a></p><p><strong>桶排序</strong><br><a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bucket_sort</a></p><p><strong>堆排序</strong><br><a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heapsort</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>所有的排序算法接口都是相同的，也就是 <code>vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums)</code> 。只需要你传入一个 <code>vector&lt;int&gt;</code> 类型的数组，就能返回排序后的结果。</p><p>运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sortArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 冒泡排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> i<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 选择排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">selectSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    idx <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 插入排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">insertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 快速排序（24 ms）</span>    <span class="token keyword">void</span> <span class="token function">qSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序（192 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rnums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序 + 非递归（80 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSortNR</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> len <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> n<span class="token operator">-</span>len<span class="token punctuation">;</span> l <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span>len<span class="token number">-1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> l<span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>len<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token operator">-</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 希尔排序（40 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">shellSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j<span class="token operator">-</span>gap <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">-</span><span class="token operator">=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计数排序（32 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">countSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> maxv<span class="token operator">-</span>minv<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token operator">+</span>minv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 基数排序（不适用于负数）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">radixSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxv <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxv <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>            maxd<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rank</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxd <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> count<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rank<span class="token punctuation">[</span><span class="token operator">--</span>count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            maxd<span class="token operator">--</span><span class="token punctuation">;</span>            base <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 桶排序 (20 ms)</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> bs <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>maxv<span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">bucket</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bucket<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sz <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 堆排序（32 ms）</span>    <span class="token keyword">void</span> <span class="token function">adjust</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> c1 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c2 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>c2<span class="token operator">&lt;</span>s <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>c2<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> c2 <span class="token operator">:</span> c1<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
