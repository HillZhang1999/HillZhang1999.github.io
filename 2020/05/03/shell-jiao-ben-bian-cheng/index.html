<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="Shell脚本编程, 章岳 学习笔记 计算机 算法 程序">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="提示本文中由于编译的问题，将所有英文括号换成了中文括号，需要注意！
Shell脚本编程什么是ShellShell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。
Shel">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Shell脚本编程 | HillZhang的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="//stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">HillZhang的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">HillZhang的博客</div>
        <div class="logo-desc">
            
            苏州大学 | 计算机科学与技术学院 | 软件工程
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/21.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        Shell脚本编程
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/Linux/" target="_blank">
                            <span class="chip bg-color">Linux</span>
                        </a>
                        
                        <a href="/tags/操作系统/" target="_blank">
                            <span class="chip bg-color">操作系统</span>
                        </a>
                        
                        <a href="/tags/编程语言/" target="_blank">
                            <span class="chip bg-color">编程语言</span>
                        </a>
                        
                        <a href="/tags/Shell/" target="_blank">
                            <span class="chip bg-color">Shell</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/Linux/" class="post-category" target="_blank">
                            Linux
                        </a>
                        
                        <a href="/categories/Linux/Shell/" class="post-category" target="_blank">
                            Shell
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-05-03
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    HillZhang
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    6.6k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    26 分
                </div>
                
                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><p>本文中由于编译的问题，将所有英文括号换成了中文括号，需要注意！</p>
<h1 id="Shell脚本编程"><a href="#Shell脚本编程" class="headerlink" title="Shell脚本编程"></a>Shell脚本编程</h1><h2 id="什么是Shell"><a href="#什么是Shell" class="headerlink" title="什么是Shell"></a>什么是Shell</h2><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p>
<p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p>
<p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p>
<h2 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h2><p>当命令不在命令行中执行，而是从一个文件中执行时，该文件就称为 Shell 脚本。</p>
<ul>
<li>Shell 脚本是纯文本文件。</li>
<li>Shell 脚本通常以 .sh 作为后缀名，但不是必须。</li>
<li>Shell 脚本是以行为单位的，在执行脚本的时候会分解成一行一行依次执行。</li>
<li>Shell 是一种功能强大的解释型编程语言，通常用于完成特定的、较复杂的系统管理任务。</li>
<li>Shell 脚本语言非常擅长处理文本类型的数据。</li>
</ul>
<blockquote>
<p>脚本其实就是短小的、用来让计算机自动化完成一系列工作的程序，这类程序可以用文本编辑器修改，不需要编译，通常是解释运行的。 </p>
</blockquote>
<h2 id="Shell-环境"><a href="#Shell-环境" class="headerlink" title="Shell 环境"></a>Shell 环境</h2><p> Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 </p>
<p>Linux 的 Shell 种类众多，常见的有：</p>
<ul>
<li>Bourne Shell（/usr/bin/sh或/bin/sh）</li>
<li>Bourne Again Shell（/bin/bash）</li>
<li>C Shell（/usr/bin/csh）</li>
<li>K Shell（/usr/bin/ksh）</li>
<li>Shell for Root（/sbin/sh）</li>
<li>……</li>
</ul>
<p>我们最常使用的通常是Bash。 同时，Bash 也是大多数Linux 系统默认的 Shell。 一般而言，bash和sh不严格区分。</p>
<h2 id="Shell编程的步骤"><a href="#Shell编程的步骤" class="headerlink" title="Shell编程的步骤"></a>Shell编程的步骤</h2><p>一般来说，编写、执行一个Shell脚本需要如下的步骤：</p>
<ol>
<li><p>创建一个文本文件，通常以.sh结尾，但不影响脚本的执行（Linux的特性）</p>
<blockquote>
<p>touch test.sh</p>
</blockquote>
</li>
<li><p>使用文本编辑器打开该文件，一般可以使用gedit、vim等</p>
<blockquote>
<p>vim test.sh</p>
</blockquote>
</li>
<li><p>输入脚本代码，通常我们还需要在开头声明执行脚本的程序的解释器，即哪一种Shell解释器</p>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
This is the first Bash shell program 
# Scriptname: greetings.sh
echo
echo -e "Hello $LOGNAME, \c"
echo    "it's nice talking to you."
echo -n "Your present working directory is: "
pwd # Show the name of present directory
echo
echo -e "The time is `date +%T`!. \nBye"
echo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>保存脚本，并为其添加可执行权限</p>
<blockquote>
<p>chmod +x test.sh</p>
</blockquote>
</li>
<li><p>执行脚本，这里必须使用./告诉系统在当前目录下寻找脚本。因为不加./，系统会默认从环境变量<code>$PATH</code>中的路径寻找可执行的脚本，而一般我们的路径都不在<code>$PATH</code>中。</p>
<blockquote>
<p>./test.sh</p>
</blockquote>
</li>
<li><p>也可以直接使用解释器执行，将文件名作为解释器的参数：</p>
<blockquote>
<p>bash test.sh</p>
</blockquote>
</li>
</ol>
<h2 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h2><h3 id="Shell变量的类型"><a href="#Shell变量的类型" class="headerlink" title="Shell变量的类型"></a>Shell变量的类型</h3><p>Shell变量主要可以分为4类：</p>
<ul>
<li>用户自定义变量<ul>
<li>由用户自己定义、修改和使用</li>
</ul>
</li>
<li>Shell 环境变量<ul>
<li>由系统维护，用于设置用户的Shell工作环境</li>
<li>只有少数的变量用户可以修改其值</li>
</ul>
</li>
<li>位置参数变量（Positional Parameters）<ul>
<li>通过命令行给程序传递执行参数</li>
<li>可用 shift 命令实现位置参数的迁移</li>
</ul>
</li>
<li>专用参数变量（Special Parameters）<ul>
<li>Bash 预定义的特殊变量</li>
<li>用户不能修改其值</li>
</ul>
</li>
</ul>
<h3 id="Shell变量的定义和赋值"><a href="#Shell变量的定义和赋值" class="headerlink" title="Shell变量的定义和赋值"></a>Shell变量的定义和赋值</h3><p> 定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如： </p>
<blockquote>
<p>a=0</p>
</blockquote>
<p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p>
<ul>
<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li>
<li>中间不能有空格，可以使用下划线（_）。</li>
<li>不能使用标点符号。</li>
<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>
</ul>
<p>除了显式的为变量赋值，我们还可以使用命令赋值，如：</p>
<blockquote>
<p>for file in <code>$（ls /etc）</code></p>
</blockquote>
<p>此外，还可以用read语句通过读取输入端口的输入为变量赋值，如：</p>
<blockquote>
<p>read -p “please input：” name</p>
</blockquote>
<h3 id="Shell变量的使用"><a href="#Shell变量的使用" class="headerlink" title="Shell变量的使用"></a>Shell变量的使用</h3><p> 使用一个定义过的变量，只要在变量名前面加美元符号即可，如： </p>
<pre class="line-numbers language-shell"><code class="language-shell">your_name="qinjx"
echo $your_name
echo ${your_name}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p> 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况： </p>
<pre class="line-numbers language-shell"><code class="language-shell">for skill in Ada Coffe Action Java; do
    echo "I am good at ${skill}Script"
done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果不给skill变量加花括号，写成echo “I am good at <code>$skillScript&quot;</code>，解释器就会把<code>$skillScript</code>当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。此外，变量还可以参与计算，此时必须加上花括号。</p>
<p>推荐给所有变量加上花括号，这是个好的编程习惯。</p>
<p> 已定义的变量，可以被重新定义，如： </p>
<pre class="line-numbers language-shell"><code class="language-shell">your_name="tom"
echo $your_name
your_name="alibaba"
echo $your_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的是：定义变量时一律不加<code>$</code>，使用变量时一律加<code>$</code>。</p>
<h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><p> 使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 </p>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
a=0
readonly a
a=1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果尝试修改只读变量的值，程序将报错。类似于Java中的final。</p>
<h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>使用 unset 命令可以删除变量。语法：</p>
<pre class="line-numbers language-shell"><code class="language-shell">unset variable_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>变量被删除后不能再次使用。unset 命令不能删除只读变量。</p>
<p>被删除变量的所有资源将被系统回收。</p>
<h3 id="变量的间接引用"><a href="#变量的间接引用" class="headerlink" title="变量的间接引用"></a>变量的间接引用</h3><p>变量的间接引用在高级语言中十分常见，特别是可变类型的变量。Shell中以下两种方式来进行间接引用：</p>
<ul>
<li>使用感叹号：</li>
</ul>
<pre class="line-numbers language-shell"><code class="language-shell">＃ bash2.0以上才支持
newstr=${!str2}
echo $newstr
Hello World
或
echo ${!str2}
Hello World 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>使用<code>$</code>：</li>
</ul>
<pre class="line-numbers language-shell"><code class="language-shell">eval newstr=`$$str2
echo $newstr
Hello World
或
eval echo `$$str2
Hello World <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="内置命令eval"><a href="#内置命令eval" class="headerlink" title="内置命令eval"></a>内置命令eval</h3><blockquote>
<p>eval arg1 [arg2] … [argN]</p>
</blockquote>
<p>Shell内置命令eval通常用于解释并执行字符串类型的命令，我们可以将命令以字符串的形式进行拼接修改，最后用eval命令进行执行。</p>
<p>它对参数进行两次扫描和替换：</p>
<ul>
<li><p>将所有的参数连接成一个表达式，并计算或执行该表达式</p>
</li>
<li><p>参数中的任何变量都将被展开</p>
</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python">listpage<span class="token operator">=</span><span class="token string">"ls -l | more"</span>
eval $listpage
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><p>位置参数变量是一组特殊的内置变量，一般用于跟在函数调用之后或者执行脚本时脚本名的后面。</p>
<p><code>$1</code>代表的是第一个位置参数变量，<code>${11}</code>代表第十一个位置参数变量。</p>
<p>用处主要是：</p>
<ul>
<li>从 shell 命令/脚本 的命令行接受参数</li>
<li>在调用 shell 函数时为其传递参数</li>
</ul>
<h4 id="shift-n"><a href="#shift-n" class="headerlink" title="shift [n]"></a>shift [n]</h4><ul>
<li>将位置参量列表依次左移n次，缺省为左移一次</li>
<li>一旦位置参量列表被移动，最左端的那个参数就会从列表中删除</li>
<li>经常与循环结构语句一起使用，以便遍历每一个位置参数</li>
</ul>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/sh
# ScriptName: pp_shift.sh
# To test Positional Parameters & Shift.
echo "The script name is :  $0"
echo '$1'=$1,'$2'=$2,'$3'=$3,'$4'=$4   --   '$#'="$#" 
echo '$@': "$@" 
shift              # 向左移动所有的位置参数1次
echo '$1'=$1,'$2'=$2,'$3'=$3,'$4'=$4   --   '$#'="$#"
echo '$@': "$@"
shift 2            # 向左移动所有的位置参数2次
echo '$1'=$1,'$2'=$2,'$3'=$3,'$4'=$4   --   '$#'="$#"
echo '$@': "$@"

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="专用参数变量"><a href="#专用参数变量" class="headerlink" title="专用参数变量"></a>专用参数变量</h3><p>用户无法修改这些值。</p>
<h4 id="位置参数相关"><a href="#位置参数相关" class="headerlink" title="位置参数相关"></a>位置参数相关</h4><ul>
<li><code>$*</code>        将所有位置参量看成一个字符串（以空格间隔） 。</li>
<li><code>$@</code>      将每个位置参量看成单独的字符串（以空格间隔）。</li>
<li>“<code>$*</code>”   将所有位置参量看成一个字符串（以$IFS间隔）。</li>
<li>“<code>$@</code>” 将每个位置参量看成单独的字符串（以$IFS间隔） 。</li>
<li><code>$0</code>       命令行上输入的Shell程序名。</li>
<li><code>$#</code>    表示命令行上参数的个数。</li>
</ul>
<h4 id="进程状态相关"><a href="#进程状态相关" class="headerlink" title="进程状态相关"></a>进程状态相关</h4><ul>
<li><code>$?</code>  表示上一条命令执行后的返回值<ul>
<li>0：成功</li>
<li>1－255：不成功<ul>
<li>1：通用错误</li>
<li>126：命令或脚本没有执行权限</li>
<li>127：命令没找到</li>
</ul>
</li>
<li>通常与exit命令配合使用，用于退出脚本或当前Shell </li>
</ul>
</li>
<li><code>$$</code>  当前进程的进程号</li>
<li><code>$!</code>   显示运行在后台的最后一个作业的 PID </li>
<li><code>$_</code>  在此之前执行的命令或脚本的最后一个参数</li>
</ul>
<h2 id="Shell字符串"><a href="#Shell字符串" class="headerlink" title="Shell字符串"></a>Shell字符串</h2><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。 </p>
<h4 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h4><pre class="line-numbers language-shell"><code class="language-shell">str='this is a string'
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>单引号字符串的限制：</p>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>
<li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li>
</ul>
<h4 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h4><pre class="line-numbers language-shell"><code class="language-shell">your_name='runoob'
str="Hello, I know you are \"$your_name\"! \n"
echo -e $str
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>输出结果为：</p>
<pre class="line-numbers language-shell"><code class="language-shell">Hello, I know you are "runoob"! 
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>双引号的优点：</p>
<ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符（但必须在使用echo语句时，加上-e选项，解释转义字符）</li>
</ul>
<p>单双引号最显著的区别在于：<strong>单引号不解释变量，双引号解释变量且支持转义。</strong></p>
<h4 id="反撇号"><a href="#反撇号" class="headerlink" title="反撇号"></a>反撇号</h4><p>反撇号 ` `：展开变量并执行表达式，将命令执行的结果输出给变量。</p>
<pre class="line-numbers language-shell"><code class="language-shell">string="runoob is a great site"
count=`expr index "$string" io`  # 输出 4
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>类似的，$（expression）也有类似的作用，可以用来获取执行命令的结果：</p>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash

echo $（expr 3 + 4）
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><p>拼接时可以使用双引号，也可以使用单引号。嵌套的单引号将解释变量，但不嵌套的单引号不解释内层的变量。</p>
<pre class="line-numbers language-shell"><code class="language-shell">your_name="runoob"
# 使用双引号拼接
greeting="hello, "$your_name" !"
greeting_1="hello, ${your_name} !"
echo $greeting  $greeting_1
# 使用单引号拼接
greeting_2='hello, '$your_name' !'
greeting_3='hello, ${your_name} !'
echo $greeting_2  $greeting_3
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果为：</p>
<pre class="line-numbers language-shell"><code class="language-shell">hello, runoob ! hello, runoob !
hello, runoob ! hello, ${your_name} !
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="字符串计数"><a href="#字符串计数" class="headerlink" title="字符串计数"></a>字符串计数</h3><p>使用#符号，加在字符串变量之前进行计数。</p>
<pre class="line-numbers language-shell"><code class="language-shell">string="abcd"
echo ${#string} #输出 4
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p><code>${var:m}</code>将截取变量<code>${var}</code>从第m个字符到最后一个字符的子串，`${var:\m:len}截取从第m个字符开始，长度为len的部分。默认情况下，变量的字符编号从0开始。</p>
<pre class="line-numbers language-shell"><code class="language-shell">string="runoob is a great site"
echo ${string:1:4} # 输出 unoo
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="字符串删除"><a href="#字符串删除" class="headerlink" title="字符串删除"></a>字符串删除</h3><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>${var#pattern}</td>
<td>删除${var}中开头部分与pattern匹配的最小部分</td>
</tr>
<tr>
<td>${var##pattern}</td>
<td>删除${var}中开头部分与pattern匹配的最大部分（贪心）</td>
</tr>
<tr>
<td>${var%pattern}</td>
<td>删除${var}中结尾部分与pattern匹配的最小部分</td>
</tr>
<tr>
<td>${var%%pattern}</td>
<td>删除${var}中结尾部分与pattern匹配的最大部分（贪心）</td>
</tr>
</tbody></table>
<p>需要注意的是，这里的模式串pattern可以是正则表达式，</p>
<pre class="line-numbers language-shell"><code class="language-shell">str='I love linux. I love UNIX too.’
echo ${str#I love}
linux. I love UNIX too.
echo ${str#I*.}
I love UNIX too.
echo ${str##I*}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>${var//old/new}</td>
<td>用new替换${var}中所有的old(全局替换)</td>
</tr>
<tr>
<td>${var/#old/new}</td>
<td>用new替换${var}中开头部分与old匹配的部分</td>
</tr>
<tr>
<td>${var/old/new}</td>
<td>用new替换${var}中第一次出现的old</td>
</tr>
<tr>
<td>${var/%old/new}</td>
<td>用new替换${var}中结尾部分与old匹配的部分</td>
</tr>
</tbody></table>
<ul>
<li>old 中可以使用 通配符。</li>
<li>var 可以是 @ 或 *，表示对每个位置参数进行替换</li>
</ul>
<pre class="line-numbers language-shell"><code class="language-shell">str='I love linux. I love UNIX too.’
echo ${str/love/like}
I like linux. I love UNIX too.
echo ${str//love/like}
I like linux. I like UNIX too.
echo ${str/I*linux/I like FreeBSD}
I like FreeBSD. I love UNIX too.
echo ${str/#I love/"J'aime"}
J'aime linux. I love UNIX too.
echo ${str//I love/"J'aime"}
J'aime linux. J'aime UNIX too. 
echo ${str/%too./also.}
I love linux. I love UNIX also.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Shell输入输出"><a href="#Shell输入输出" class="headerlink" title="Shell输入输出"></a>Shell输入输出</h2><h3 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h3><blockquote>
<p> read  [-p  “提示信息”]  [var1 var2 …]</p>
</blockquote>
<p>read命令从键盘输入内容为变量赋值。若省略变量名，则将输入的内容存入系统变量$REPLY变量。</p>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
# This script is to test the usage of read
# Scriptname: ex4read.sh
echo "=== examples for testing read ==="
echo -e "What is your name? \c"
read name
echo "Hello $name"
echo
echo -n "Where do you work? "
read
echo "I guess $REPLY keeps you busy!"
echo
read -p "Enter your job title: "
echo "I thought you might be an $REPLY."
echo
echo "=== End of the script ==="

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h3><blockquote>
<p>echo 字符串</p>
</blockquote>
<p> Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。</p>
<p>字符串的类型依然分为三类，分别是单引号、双引号、反撇号，具体功能见上一章。</p>
<p>这里需要注意的是：<strong>echo命令输出时，双引号可以省略，但如果字符串内有空格，必须加上双引号</strong>。</p>
<p>如果在字符串内使用了转义字符，我们在使用echo进行输出时还需要开启转义，具体做法是采用-e选项。</p>
<pre class="line-numbers language-shell"><code class="language-shell">echo -e "OK! \n" # -e 开启转义
echo "It is a test"
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>echo命令可以使用重定向符号进行标准输出端口的重定向（默认是终端的屏幕）。</p>
<h3 id="printf-命令"><a href="#printf-命令" class="headerlink" title="printf 命令"></a>printf 命令</h3><blockquote>
<p>printf format 输出参数列表</p>
</blockquote>
<p>printf命令与C++等高级语言中类似，都是用来输出格式化字符串的。</p>
<p>格式字符串format的规格如下：</p>
<p>![printf]（printf.png）</p>
<p>常用的格式替代符有：</p>
<ul>
<li>%s：字符串string</li>
<li>%c：字符char</li>
<li>%d：整型数</li>
<li>%f ：浮点数</li>
</ul>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash

printf "%-10s %-8s %-4s\n" 姓名 性别 体重kg  
printf "%-10s %-8s %-4.2f\n" 郭靖 男 66.1234 
printf "%-10s %-8s %-4.2f\n" 杨过 男 48.6543 
printf "%-10s %-8s %-4.2f\n" 郭芙 女 47.9876 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>printf命令支持如下的转义序列：</p>
<table>
<thead>
<tr>
<th align="left">序列</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\a</td>
<td align="left">警告字符，通常为ASCII的BEL字符</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">后退</td>
</tr>
<tr>
<td align="left">\c</td>
<td align="left">抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页（formfeed）</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车（Carriage return）</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">水平制表符</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">垂直制表符</td>
</tr>
<tr>
<td align="left">\\</td>
<td align="left">一个字面上的反斜杠字符</td>
</tr>
<tr>
<td align="left">\ddd</td>
<td align="left">表示1到3位数八进制值的字符。仅在格式字符串中有效</td>
</tr>
<tr>
<td align="left">\0ddd</td>
<td align="left">表示1到3位的八进制值字符</td>
</tr>
</tbody></table>
<pre class="line-numbers language-shell"><code class="language-shell">printf "%6d\t%6o\"%6x\"\n" 20 20 20
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="Shell整数运算"><a href="#Shell整数运算" class="headerlink" title="Shell整数运算"></a>Shell整数运算</h2><p>Bash 变量没有严格的类型定义</p>
<ul>
<li>本质上 Bash 变量都是字符串</li>
<li>若一个字面常量或变量的值是纯数字的，不包含字母或其他字符， Bash可以将其视为长整型值，并可做算数运算和比较运算。</li>
</ul>
<p>Bash 也允许显式地声明整型变量</p>
<ul>
<li>declare -i 变量名</li>
</ul>
<h3 id="declare命令"><a href="#declare命令" class="headerlink" title="declare命令"></a>declare命令</h3><blockquote>
<p>declare [选项] variable[=value]</p>
</blockquote>
<p>Shell内置命令 declare 可用来显式地声明变量，因为Shell默认是弱类型语言，使用declare命令可以强制规定变量的类型，无需等到执行到具体的命令时才知道变量的类型。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>将变量设为只读 ( <em>readonly</em> )</td>
</tr>
<tr>
<td>-x</td>
<td>将变量输出到子 shell 中（<em>export</em> 为全局变量）</td>
</tr>
<tr>
<td>-i</td>
<td>将变量设为整型 ( <em>integer</em> )</td>
</tr>
<tr>
<td>-a</td>
<td>将变量设置为一个数组 ( <em>array</em> )</td>
</tr>
<tr>
<td>-f</td>
<td>列出函数的名字和定义 ( <em>function</em> )</td>
</tr>
<tr>
<td>-F</td>
<td>只列出函数名</td>
</tr>
</tbody></table>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table>
<thead>
<tr>
<th>算术运算符</th>
</tr>
</thead>
<tbody><tr>
<td>+、 -、 *、 / （四则运算）</td>
</tr>
<tr>
<td>**、 %    （幂运算 和 模运算，取余数）</td>
</tr>
<tr>
<td>&lt;&lt;、 &gt;&gt;   （按位左移 和 按位右移）</td>
</tr>
<tr>
<td>&amp;、 ^、 |  （按位与 、按位异或 和 按位 或）</td>
</tr>
<tr>
<td>=、 +=、 -= 、 *=、 /= 、 %= 、&lt;&lt;= 、 &gt;&gt;= 、 &amp;=、 ^=、 |=  （赋值运算）</td>
</tr>
<tr>
<td>&lt;、 &gt;、 &lt;=、 &gt;=、 ==、 !=   （比较操作符）</td>
</tr>
<tr>
<td>&amp;&amp;、 ||   （逻辑与 和 逻辑 或）</td>
</tr>
</tbody></table>
<p>Shell自带的算术运算符基本与Java类似，含义也类似。</p>
<h3 id="expr命令"><a href="#expr命令" class="headerlink" title="expr命令"></a>expr命令</h3><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p>
<p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash

val=`expr 2 + 2`
echo "两数之和为 : $val"
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>两点注意：</p>
<ul>
<li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</li>
<li>完整的表达式要被``包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li>
<li>表达式中的运算可以是算术运算，比较运算，字符串运算和逻辑运算。</li>
</ul>
<h3 id="expression-、-（（expression））"><a href="#expression-、-（（expression））" class="headerlink" title="$[expression]  、$（（expression））"></a><code>$[expression]</code>  、<code>$（（expression））</code></h3><p>同时，随着Bash的升级，我们也可以使用符号来声明和进行整数运算。</p>
<pre class="line-numbers language-shell"><code class="language-shell">num1=$[4+1]; echo $num1
num1=$（（$num1*2-3））; echo $num1
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>需要注意的是，用 <code>$[···]</code>，<code>$（（···））</code>进行整数运算时，括号内变量前的美元符号  $ 可以省略。</p>
<p>这样运算的话，不需要在表达式和运算符之间打空格（不过推荐都打上，养成良好习惯，看的也清楚，赋值时不能打）</p>
<h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><p>Shell还内置了let命令用于算术运算。</p>
<pre class="line-numbers language-shell"><code class="language-shell">num2=1; echo $num2
let num2=4+1; echo $num2
let num2=$num2+1; echo $num2
let "num2=4 + 1" # 用引号忽略空格的特殊含义
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意以下几点：</p>
<ul>
<li><p>赋值符号和运算符两边不能留空格！除非用引号将算式括起来。</p>
</li>
<li><p>如果将字符串赋值给一个整型变量时，则变量的值为 0。</p>
</li>
<li><p>如果变量的值是字符串，则进行算术运算时设为 0。</p>
</li>
</ul>
<h2 id="Shell浮点数运算"><a href="#Shell浮点数运算" class="headerlink" title="Shell浮点数运算"></a>Shell浮点数运算</h2><p>bash 只支持整数运算。</p>
<p>但我们可以使用一些工具，例如：可以通过使用 bc 或 awk 工具来处理浮点数运算。</p>
<pre class="line-numbers language-shell"><code class="language-shell">n=$（echo "scale=3; 13/2" | bc ）
echo $n

m=`awk 'BEGIN{x=2.45;y=3.123; \ 
   printf "%.3f\n", x*y}'`
echo $m

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Shell数组"><a href="#Shell数组" class="headerlink" title="Shell数组"></a>Shell数组</h2><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><p>数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。</p>
<p>与大部分编程语言类似，数组元素的下标由0开始。</p>
<p>Shell 数组用括号来表示，元素用”空格”符号分割开，语法格式如下：</p>
<blockquote>
<p>array_name=（value1 … valuen）</p>
</blockquote>
<p>与python等弱类型脚本语言类似，Shell数组可以存放任意类型的值，这一点和C++、Java等编译型语言不同：</p>
<pre class="line-numbers language-shell"><code class="language-shell">my_array=（A B "C" D）
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们也可以使用declare命令声明数组，直接使用下标定义元素，并使用`${array_name[index]}去访问元素，这里的下标可以为变量：</p>
<pre class="line-numbers language-shell"><code class="language-shell">declare -a array_name

array_name[0]=value0
array_name[1]=value1
array_name[2]=value2

echo "第一个元素为: ${my_array[0]}"
echo "第二个元素为: ${my_array[1]}"
echo "第三个元素为: ${my_array[2]}"
echo "第四个元素为: ${my_array[3]}"
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 使用@ 或 * 可以获取数组中的所有元素，获取所有元素后我们可以使用#符号获取数组的长度，和字符串类似，例如： </p>
<pre class="line-numbers language-shell"><code class="language-shell">my_array[0]=A
my_array[1]=B
my_array[2]=C
my_array[3]=D

echo "数组的元素为: ${my_array[*]}"
echo "数组的元素为: ${my_array[@]}"
echo "数组元素个数为: ${#my_array[*]}"
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="数组与数组元素的删除"><a href="#数组与数组元素的删除" class="headerlink" title="数组与数组元素的删除"></a>数组与数组元素的删除</h3><p>使用unset命令：</p>
<pre class="line-numbers language-shell"><code class="language-shell">unset stu[1]   # 删除stu的第二个元素
unset stu      # 删除整个数组
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="Shell条件测试"><a href="#Shell条件测试" class="headerlink" title="Shell条件测试"></a>Shell条件测试</h2><p>条件测试可以判断某个特定条件是否满足，通常是命令是否成功或者是表达式的真假。</p>
<p>条件测试的值：</p>
<ul>
<li>Bash中没有布尔类型变量<ul>
<li>退出状态为 0 表示命令成功或表达式为真</li>
<li>非0 则表示命令失败或表达式为假</li>
</ul>
</li>
<li>状态变量 <code>$?</code> 中保存了退出状态的值Bash中没有布尔类型变量</li>
</ul>
<h3 id="条件测试的格式"><a href="#条件测试的格式" class="headerlink" title="条件测试的格式"></a>条件测试的格式</h3><p>Shell支持三种格式的条件测试语句，分别为：</p>
<ul>
<li>格式1： test &lt;测试表达式&gt; </li>
<li>格式2： [ &lt;测试表达式&gt; ] </li>
<li>格式3： [[ &lt;测试表达式&gt; ]] （bash 2.x 版本以上）</li>
<li>格式4： （（&lt;测试表达式&gt;）） （整数关系运算）</li>
</ul>
<p>说明：</p>
<ul>
<li>格式1 和 格式2 是等价的，格式3是扩展的 test 命令</li>
<li>在 [[ ]] 中可以使用通配符进行模式匹配</li>
<li>&amp;&amp;, ||, &lt;, 和&gt;能够正常存在于[[ ]]中，但不能在 [] 中出现</li>
<li>[和[[之后的字符必须为空格，]和]]之前的字符必须为空格</li>
<li>要对整数进行关系运算也可以使用 （（）） 进行测试</li>
</ul>
<h3 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h3><p>文件测试用于检测文件是否存在，文件属性，访问权限等。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>[ -f fname ]</td>
<td>fname 存在且是普通文件时，返回真 ( 即返回 0 )</td>
</tr>
<tr>
<td>[ -L fname ]</td>
<td>fname 存在且是链接文件时，返回真</td>
</tr>
<tr>
<td>[ -d fname ]</td>
<td>fname 存在且是一个目录时，返回真</td>
</tr>
<tr>
<td>[ -e fname ]</td>
<td>fname（文件或目录）存在时，返回真</td>
</tr>
<tr>
<td>[ -s fname ]</td>
<td>fname 存在且大小大于 0 时，返回真</td>
</tr>
<tr>
<td>[ -r fname ]</td>
<td>fname（文件或目录）存在且可读时，返回真</td>
</tr>
<tr>
<td>[ -w fname ]</td>
<td>fname（文件或目录）存在且可写时，返回真</td>
</tr>
<tr>
<td>[ -x fname ]</td>
<td>fname（文件或目录）存在且可执行时，返回真</td>
</tr>
</tbody></table>
<h3 id="字符串测试"><a href="#字符串测试" class="headerlink" title="字符串测试"></a>字符串测试</h3><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>[ -z string ]</td>
<td>如果字符串string长度为0，返回真</td>
</tr>
<tr>
<td>[ -n string ]</td>
<td>如果字符串string长度不为0，返回真</td>
</tr>
<tr>
<td>[ str1 = str2 ]</td>
<td>两字符串相等（也可使用 == ）返回真</td>
</tr>
<tr>
<td>[ str1 != str2 ]</td>
<td>两字符串不等返回真</td>
</tr>
<tr>
<td>[[ str1 == str2 ]]</td>
<td>两字符串相同返回真</td>
</tr>
<tr>
<td>[[ str1 != str2 ]]</td>
<td>两字符串不相同返回真</td>
</tr>
<tr>
<td>[[ str1 =~ str2 ]]</td>
<td>str2是str1的子串返回真</td>
</tr>
<tr>
<td>[[ str1 &gt; str2 ]]</td>
<td>str1大于str2返回真（按照Ascii码进行比较）</td>
</tr>
<tr>
<td>[[ str1 &lt; str2 ]]</td>
<td>str1小于str2返回真</td>
</tr>
</tbody></table>
<h3 id="整数测试"><a href="#整数测试" class="headerlink" title="整数测试"></a>整数测试</h3><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>[ int1 -eq int2 ]</td>
<td>int1 等于 int2 返回真</td>
</tr>
<tr>
<td>[ int1 -ne int2 ]</td>
<td>int1 不等于 int2 返回真</td>
</tr>
<tr>
<td>[ int1 -gt int2 ]</td>
<td>int1 大于 int2 返回真</td>
</tr>
<tr>
<td>[ int1 -ge int2 ]</td>
<td>int1 大于或等于 int2 返回真</td>
</tr>
<tr>
<td>[ int1 -lt int2 ]</td>
<td>int1 小于 int2 返回真</td>
</tr>
<tr>
<td>[ int1 -le int2 ]</td>
<td>int1 小于或等于 int2 返回真</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>[[ int1 == int2 ]]</td>
<td>int1 等于 int2 返回真</td>
</tr>
<tr>
<td>[[ int1 != int2 ]]</td>
<td>int1 不等于 int2 返回真</td>
</tr>
<tr>
<td>[[ int1 &gt; int2 ]]</td>
<td>int1 大于 int2 返回真</td>
</tr>
<tr>
<td>[[ int1 &gt;= int2 ]]</td>
<td>int1 大于或等于 int2 返回真</td>
</tr>
<tr>
<td>[[ int1 &lt;int2 ]]</td>
<td>int1 小于 int2 返回真</td>
</tr>
<tr>
<td>[[ int1 &lt;= int2 ]]</td>
<td>int1 小于或等于 int2 返回真</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>（（int1 == int2））</td>
<td>int1 等于 int2 返回真</td>
</tr>
<tr>
<td>（（int1 != int2））</td>
<td>int1 不等于 int2 返回真</td>
</tr>
<tr>
<td>（（int1 &gt; int2））</td>
<td>int1 大于 int2 返回真</td>
</tr>
<tr>
<td>（（int1 &gt;= int2））</td>
<td>int1 大于或等于 int2 返回真</td>
</tr>
<tr>
<td>（（int1 &lt; int2））</td>
<td>int1 小于 int2 返回真</td>
</tr>
<tr>
<td>（（int1 &lt;= int2））</td>
<td>int1 小于或等于 int2 返回真</td>
</tr>
</tbody></table>
<p>观察上述表格，我们可以发现：</p>
<ul>
<li><p>[]和[[]]两侧必须加空格</p>
</li>
<li><p>[[]]可以加入诸如&gt;、&lt;等符号的逻辑运算符，而[]只能使用字母来表示</p>
</li>
<li><p>（（））两侧不一定需要加入空格，可省略</p>
</li>
<li><p>[]不能加入通识匹配符，如&gt;、&lt;</p>
</li>
</ul>
<h3 id="逻辑测试"><a href="#逻辑测试" class="headerlink" title="逻辑测试"></a>逻辑测试</h3><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>[ expr1 -a expr2 ]</td>
<td>逻辑与，都为真时，结果为真</td>
</tr>
<tr>
<td>[ expr1 -o expr2 ]</td>
<td>逻辑或，有一个为真时，结果为真</td>
</tr>
<tr>
<td>[ ! expr ]</td>
<td>逻辑非</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>[[ pattern1 &amp;&amp; pattern2 ]]</td>
<td>逻辑与</td>
</tr>
<tr>
<td>[[ pattern1 || pattern2 ]]</td>
<td>逻辑或</td>
</tr>
<tr>
<td>[[ ! pattern ]]</td>
<td>逻辑非</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>（（ expr1 &amp;&amp; expr2 ）\）</td>
<td>逻辑与</td>
</tr>
<tr>
<td>（\（ expr1 || expr2 ））</td>
<td>逻辑或</td>
</tr>
<tr>
<td>（（ ! expr ））</td>
<td>逻辑非</td>
</tr>
</tbody></table>
<p>需要注意的点有：</p>
<ul>
<li>不能随便添加括号</li>
<li>不能在 （（）） 中做字符串比较，只能进行整数运算</li>
</ul>
<h2 id="Shell流程控制"><a href="#Shell流程控制" class="headerlink" title="Shell流程控制"></a>Shell流程控制</h2><h3 id="分支语句if"><a href="#分支语句if" class="headerlink" title="分支语句if"></a>分支语句if</h3><p>分支语句if通常和条件测试语句配合使用。</p>
<pre class="line-numbers language-shell"><code class="language-shell">if expr1      # 如果 expr1 为真（返回值为0）
then          # 那么
   commands1  # 执行语句块 commands1
elif expr2    # 若 expr1 不真，而 expr2 为真
then          # 那么
   commands2  # 执行语句块 commands2
 ... ...      # 可以有多个 elif 语句 
else          # else 最多只能有一个
   commands4  # 执行语句块 commands4
fi            # if 语句必须以单词 fi 终止
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意点：</p>
<ul>
<li>elif 可以有任意多个（0 个或多个）</li>
<li>else 最多只能有一个（0 个或 1 个）</li>
<li>if 语句必须以 fi 表示结束</li>
<li>exprX 通常为条件测试表达式；也可以是多个命令，以最后一个命令的退出状态为条件值。</li>
<li>commands 为可执行语句块，如果为空，需使用 shell 提供的空命令 “ : ”，即冒号。该命令不做任何事情，只返回一个退出状态 0</li>
<li>if 语句可以嵌套使用</li>
</ul>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename: ask-age.sh
read  -p "How old are you?  "  age 
# 使用 Shell算术运算符（（））进行条件测试
if （（age<0||age>120））; then
    echo "Out of range !"
    exit 1
fi 
# 使用多分支if语句
if   （（age>=0&&age<13）） ; then   echo "Child !"
elif （（age>=13&&age<20））; then   echo "Callan !"
elif （（age>=20&&age<30））; then   echo "P III !"
elif （（age>=30&&age<40））; then   echo "P IV !"
else   echo "Sorry I asked."
fi
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="分支语句Case"><a href="#分支语句Case" class="headerlink" title="分支语句Case"></a>分支语句Case</h3><p>与高级语言类似，Shell中也存在着Case语句，用来进行多分支的判断。</p>
<pre class="line-numbers language-shell"><code class="language-shell">case expr in # expr 为表达式，关键词 in 不要忘！
  pattern1）  # 若 expr 与 pattern1 匹配，注意括号
   commands1 # 执行语句块 commands1
   ;;        # 跳出 case 结构
  pattern2）  # 若 expr 与 pattern2 匹配
   commands2 # 执行语句块 commands2
   ;;        # 跳出 case 结构  ... ...    # 可以有任意多个模式匹配
  *）         # 若 expr 与上面的模式都不匹配
   commands  # 执行语句块 commands
   ;;        # 跳出 case 结构
esac         # case 语句必须以 esac 终止
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的点有：</p>
<ul>
<li>表达式 expr 按顺序匹配每个模式，一旦有一个模式匹配成功，则执行该模式后面的所有命令，然后退出 case。</li>
<li>如果 expr 没有找到匹配的模式，则执行缺省值 “ <em>） ” 后面的命令块（ 类似于 if  中的 else ）；“ </em>） ” 可以不出现。</li>
<li>所给的匹配模式 pattern 中可以含有通配符和“ | ”。</li>
<li>每个命令块的最后必须有一个双分号;;，可以独占一行，或放在最后一个命令的后面。</li>
<li>case语句必须以esac终止。</li>
</ul>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename: all_in_one_backup.sh
# A shell script to backup mysql, webserver and files.
# opt=$1
case $1 in
   sql） echo "Running mysql backup using mysqldump tool..." ;;
  sync） echo "Running backup using rsync tool..."           ;;
   git） echo "Running backup using gistore tool..."         ;;
   tar） echo "Running tape backup using tar tool..."        ;;
     *） 
        echo "Backup shell script utility"
        echo "Usage: $0 {sql|sync|git|tar}"
        echo "    sql  : Run mySQL backup utility."
        echo "    sync : Run web server backup utility."    
        echo "    git  : Run gistore backup utility."    
        echo "    tar  : Run tape backup utility." 
        ;;
esac
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="循环语句For"><a href="#循环语句For" class="headerlink" title="循环语句For"></a>循环语句For</h3><p>与高级语言类似，Shell支持两种类型的循环，分别是foreach型和c语言型</p>
<h4 id="for循环（foreach型）"><a href="#for循环（foreach型）" class="headerlink" title="for循环（foreach型）"></a>for循环（foreach型）</h4><pre class="line-numbers language-shell"><code class="language-shell">for variable in list 
# 每一次循环，依次把列表 list 中的一个值赋给循环变量
do          # 循环体开始的标志
  commands  # 循环变量每取一次值，循环体就执行一遍
done        # 循环结束的标志，返回循环顶部
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>说明：</p>
<ul>
<li>列表 list 可以是命令替换、变量名替换、字符串和文件名列表 （ 可包含通配符 ），每个列表项以空格间隔</li>
<li>for 循环执行的次数取决于列表 list 中单词的个数</li>
<li>可以省略  in list ， 如果不用它，for循环使用命令行的位置参数，相当于  in “$@”。</li>
</ul>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename: for1--constant_as_list.sh
# 使用字面字符串列表作为 WordList
for x in centos ubuntu gentoo opensuse
do   echo "$x" ; done
# 若列表项中包含空格必需使用引号括起来
for x in Linux "Gnu Hurd" FreeBSD "Mac OS X"
do  echo "$x" ; done
for x in ls "df -h" "du -sh"
do
    echo "==$x==" ; eval $x
done
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意，如果同一行出现了两条命令，需要在他们之间加分号；</p>
<p>下面的情况特别需要注意，用于分割的空格不能被包含进双引号内：</p>
<ul>
<li>for x in “centos” “ubuntu” “gentoo” “opensuse”，输出的是四个单词</li>
<li>for x in “centos ubuntu gentoo opensuse”，输出的是一整个句子</li>
</ul>
<p>更多实例：</p>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename: for3--pp_as_list.sh
# 使用位置参数变量 $@ 作为 WordList， in $@ 可以省略
i=1
for day ; do
  echo -n "Positional parameter $（（i++））: $day "
  case $day in
    [Mm]on|[Tt]ue|[Ww]ed|[Tt]hu|[Ff]ri）
       echo " （weekday）" ;;
    [Ss]at|[Ss]un）
       echo " （WEEKEND）" ;;
    *） echo " （Invalid weekday）" ;;
  esac
done
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename: for4--filenames_as_list.sh
# 使用文件名或目录名列表作为 WordList

# 将当前目录下的所有的大写文件名改为小写文件名
for filename in * ; do
  # 使用命令替换生成小写的文件名，赋予新的变量 fn
  fn=$（echo $fname | tr A-Z a-z）
  # 若新生成的小写文件名与原文件名不同，改为小写的文件名
  if [[ $fname != $fn ]] ; then mv $fname $fn ; fi
  # 上面的 if 语句与下面的命令聚合均等效
  # [[ $fname != $fn ]] && mv $fname $fn
  # [[ $fname == $fn ]] || mv $fname $fn
done

for fn in /etc/[abcd]*.conf ; do echo $fn ; done
for fn in /etc/cron.{*ly,d}/* ; do echo $fn ; done
for i in *.zip; do 
  j="${i%.zip}"; mkdir "$j" && unzip -d "$j" "$i"
done
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename: for5--command_output_as_list.sh
# 使用命令的执行结果作为 WordList
i=1
for username in `awk -F: '{print $1}' /etc/passwd` 
do
    echo "Username $（（i++）） : $username"
done

for line in $（cat files.txt|egrep -v "^$|^#"） ; do
    echo "$line"; done 

for suffix in $（seq 254）
do echo "192.168.0.${suffix}"; done

for f in $（ ls /var/ ）; do echo $f; done
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="for循环（C语言型）"><a href="#for循环（C语言型）" class="headerlink" title="for循环（C语言型）"></a>for循环（C语言型）</h4><p>C 语言风格的 for 语句通常用于实现计数型循环。该循环方式和C语言、Java等非常类似：</p>
<pre class="line-numbers language-shell"><code class="language-shell">for （（expr1;expr2;expr3）） # 执行 expr1
do # 若 expr2的值为真时进入循环，否则退出 for循环
  commands  # 执行循环体，之后执行 expr3
done        # 循环结束的标志，返回循环顶部
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>expr1：初始赋值</li>
<li>expr2：结束条件</li>
<li>expr3：每轮变化</li>
</ul>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename: addusers_for_C-style.sh
# 成批添加50个用户

for （（ n=1; n<=50; n++ ））
do
    if （（num<10））
    then  st="st0${n}" 
    else  st="st${n}"
    fi
    useradd $st
    echo "centos"|passwd --stdin $st
    chage -d 0 $st
done
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h4><blockquote>
<p>break [n]</p>
</blockquote>
<p>用于强行退出当前循环。</p>
<p>如果是嵌套循环，则 break 命令后面可以跟一数字 n，表示退出第 n 重循环（最里面的为第一重循环）。</p>
<blockquote>
<p>continue [n]</p>
</blockquote>
<p>用于忽略本次循环的剩余部分，回到循环的顶部，继续下一次循环。</p>
<p>如果是嵌套循环，continue 命令后面也可跟一数字 n，表示回到第 n 重循环的顶部。</p>
<h4 id="While循环语句"><a href="#While循环语句" class="headerlink" title="While循环语句"></a>While循环语句</h4><p>格式：</p>
<pre class="line-numbers language-shell"><code class="language-shell">while expr  # 执行 expr
do # 若expr的退出状态为0，进入循环，否则退出while
  commands  # 循环体
done        # 循环结束标志，返回循环顶部
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>While语句当expr为真时（状态不为0），循环执行。</p>
<p>实例：</p>
<ul>
<li>使用重定向符号为while的条件表达式中的read进行输入重定向。</li>
</ul>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename: while--read_file.sh
file=/etc/resolv.conf
while IFS= read -r line
do
    # echo line is stored in $line
    echo $line
done < "$file"

while IFS=: read -r user enpass uid gid desc home shell
do
    # only display if UID >= 500 
    [ $uid -ge 500 ] && echo "User $user （$uid） assigned \"$home\" home directory with $shell shell."
done < /etc/passwd

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>使用管道符为while传入输入</li>
</ul>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename: while-rename_filename.sh
# 找出当前目录下包含空格的文件名，将空格替换为下划线

DIR="."
find $DIR -type f | while read file; do
  # using POSIX class [:space:] to find space in the filename
  if [[ "$file" = *[[:space:]]* ]]; then
     # substitute space with "_" character （rename the filename）
     mv "$file" $（echo $file | tr ' ' '_'）
  fi
done

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="until循环语句"><a href="#until循环语句" class="headerlink" title="until循环语句"></a>until循环语句</h4><p>格式：</p>
<pre class="line-numbers language-shell"><code class="language-shell">until expr  # 执行 expr
do # 若expr的退出状态非0，进入循环，否则退出until
  commands  # 循环体
done        # 循环结束标志，返回循环顶部
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>While语句当expr为假时（状态不为0），循环执行。</p>
<p>实例：</p>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename: until-user_online_to_write.sh
username=$1
if [ $# -lt 1 ] ; then
  echo "Usage: `basename $0`  <username>  [<message>]"
  exit 1
fi
if grep "^$username:" /etc/passwd > /dev/null ; then   :
else
  echo "$username is not a user on this system."
  exit 2
fi
until who|grep "$username" > /dev/null ; do
    echo "$username is not logged on."
    sleep 600
done
shift ; msg=$*
[[ X"$msg" == "X" ]] && msg="Hello, $username"
echo "$msg" | write $username

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename: while-until-for_sum.sh

# 使用当型循环求 sum（1..100）
（（i=0,s=0））        # i=0 ; s=0
while （（i<100）） ; do （（i++,s+=i）） ; done
echo sum（1..100）=$s

# 使用直到型循环求 sum（1..100）
（（i=0,s=0））
until （（i==100）） ; do （（i++,s+=i）） ; done
echo sum（1..100）=$s

# 使用C风格的 for 循环求 sum（1..100）
for （（s=0,i=1;i<=100;s+=i,i++）） ; do : ; done
echo sum（1..100）=$s

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="循环语句的使用技巧"><a href="#循环语句的使用技巧" class="headerlink" title="循环语句的使用技巧"></a>循环语句的使用技巧</h4><p>循环语句可以在末尾done之后加入管道符和重定向符，用来重定向当前循环体内的输入、输出端口，以及将循环体内的命令执行结果传入其他命令处理。</p>
<ul>
<li>管道：</li>
</ul>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename: loop--to_pipe.sh

for i in 7 8 9 2 3 4 5 11; do
    echo $i
done | sort -n


awk -F':' '$3 >= 500 {print $1}' /etc/passwd | 
while IFS= read -r person 
do
    echo $person 
done | sort 

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以在done后加入&amp;，来将循环体放在后台运行：</p>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename: loop--in_background.sh

for person in Brown Jiff John Stone
do
     mail -s "Test" $person < "Hello $person ."
done &

awk -F':' '$3 >= 500 {print $1}' /etc/passwd | 
while IFS= read -r person
do
    mail -s "Test" $person <<-END
    Hello $person,
        This message is from $（hostname -f）.
                     $USER   $（date +%F）
    END
done &
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Select语句实现菜单"><a href="#Select语句实现菜单" class="headerlink" title="Select语句实现菜单"></a>Select语句实现菜单</h2><p>select 循环主要用于创建菜单，通常与case语句配合使用，根据用户输入的不同进入不同的菜单分支。<br>select 是个无限循环，退出方式为：</p>
<ul>
<li>按  ctrl+c  退出循环</li>
<li>在循环体内用 break 命令退出循环</li>
<li>或用 exit 命令终止脚本</li>
</ul>
<p>格式：</p>
<pre class="line-numbers language-shell"><code class="language-shell">select variable in list 
do          # 循环开始的标志
  commands  # 循环变量每取一次值，循环体就执行一遍
done        # 循环结束的标志

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的点有：</p>
<ul>
<li>按数值顺序排列的菜单项（list item）会显示到标准错误</li>
<li>菜单项的间隔符由环境变量 IFS 决定</li>
<li>用于引导用户输入的提示信息存放在环境变量 PS3 中</li>
<li>用户输入的值会被存储在内置变量 RELAY 中</li>
<li>用户直接输入回车将重新显示菜单</li>
<li>与 for 循环类似，省略 in list 时等价于 in “<code>$*</code>”</li>
</ul>
<p>实例：</p>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename: what-os-do-you-like_select.sh
clear
PS3="What is your preferred OS? "
IFS='|'
os="Linux|Gnu Hurd|FreeBSD|Mac OS X"
select s in $os
do
  case $REPLY in
    1|2|3|4） echo "You selected $s"  ;;
          *） exit ;;
  esac
done
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="位置参数处理"><a href="#位置参数处理" class="headerlink" title="位置参数处理"></a>位置参数处理</h2><p>在脚本中经常使用流程控制处理位置参数：</p>
<ul>
<li>循环结构：while、for</li>
<li>多分支结构：case</li>
</ul>
<p>在脚本中经常使用如下命令配合位置参数处理：</p>
<ul>
<li>shift</li>
<li>getopts</li>
</ul>
<h3 id="shift命令"><a href="#shift命令" class="headerlink" title="shift命令"></a>shift命令</h3><p>shift命令没有参数，它的作用是将所有位置向左循环移动一位。</p>
<p>以下是一个while循环+shift命令，循环遍历命令行位置参数的例子：</p>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename: pp_traverse_shift_while.sh
# Usage: pp_traverse_shift_while.sh [arguments]
#
echo "using while loop to traverse positional parameter"

#while [[ "$1" ]] ; do
#    echo "$1"
#    shift
#done

num=1
while [[ "$1" ]] ; do
    echo "The ${num}th argument is: $1"
    let num=num+1
    shift
done
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="getops命令"><a href="#getops命令" class="headerlink" title="getops命令"></a>getops命令</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><blockquote>
<p>getopts OPTSTRING VARNAME [ARGS…]</p>
</blockquote>
<p>OPTSTRING ：</p>
<ul>
<li>是由若干有效的选项标识符组成的选项字符串</li>
<li>若某选项标识符后有冒号，则表示此选项有附加参数</li>
<li>若整个字符串前有冒号，将使用“安静”的错误模式</li>
</ul>
<p>VARNAME ：</p>
<ul>
<li>每次匹配成功的选项保存在变量中</li>
</ul>
<p>ARGS ：:</p>
<ul>
<li>参数列表，省略时为 ”$@”</li>
</ul>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><ul>
<li>通常需要以循环的方式执行多次 getopts 来解析位置参数中的选项以及可能存在的选项附加参数</li>
<li>每次调用 getopts，将会处理参数列表中的“下一个”选项</li>
<li>将选项存储在VARNAME变量中</li>
<li>将此选项对应的附加参数存储在环境变量OPTARG中</li>
<li>对环境变量OPTIND进行自增操作，使 OPTIND 总是指向原始参数列表中“下一个”要处理的元素位置</li>
<li>若VARNAME与OPTSTRING的所有选项均不匹配，则做“invalid option”的错误设置</li>
<li>若某选项的参数不存在，则做“required argument not found”的错误设置</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>getopts 不能解析 GNU-style 长参数 （–myoption） </li>
<li>getopts从不改变原始位置参数</li>
<li>若希望移动位置参数，需手工执行 shift</li>
<li>getopts会自动对变量 OPTIND 做自增处理</li>
<li>OPTIDX的初始值为 1</li>
<li>若要重新解析命令行参数，需将OPTIDX的值置为 1</li>
<li>getopts 遭遇到第一个非选项参数时终止解析</li>
<li>终止解析后执行命令<pre><code>shift （（OPTIND-1））</code></pre></li>
<li>可以使 ”<code>$@</code>” 只包含“操作 对象/数”（operands）</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename : mybackup_getopts2.sh
while getopts :zc:x:rv opt
do
  case $opt in
    c） if [[ $OPTARG = -* ]]; then  （（OPTIND--）） ;  continue ;  fi
       ConfFile=$OPTARG       ;;
    x） ExcludeFile=$OPTARG    ;;
    z） Compress=true          ;;
    r） Recursive=true         ;;
    v） Verbose=true           ;;
    :）
      echo "$0: Must supply an argument to -$OPTARG." >&2
      exit 1
      ;;
    \?） echo "Invalid option -$OPTARG ignored." >&2   ;;
  esac
done

shift （（OPTIND-1）） ; echo $0 ; echo "$@"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>环境变量说明：</p>
<ul>
<li>OPTIND：存放当前遍历的选项的下标</li>
<li>OPTARG：存放当前选项的附加参数</li>
<li>VARNAME：存放当前选项</li>
</ul>
<h2 id="Shell函数"><a href="#Shell函数" class="headerlink" title="Shell函数"></a>Shell函数</h2><p>使用函数式编程有如下的优点：</p>
<ul>
<li>简化程序代码，实现代码重用<ul>
<li>实现一次定义多次调用。如：is_root_user（）函数可以由不同的shell脚本重复使用。</li>
</ul>
</li>
<li>实现结构化编程<ul>
<li>使脚本内容更加简洁，增强程序的易读性</li>
</ul>
</li>
<li>提高执行效率<ul>
<li>将常用的功能定义为多个函数并将其保存在一个文件中</li>
<li>类似其他语言的“模块”文件<ul>
<li>在 ~/bashrc 或命令行上使用 source 命令调用这个文件</li>
</ul>
</li>
<li>此文件中定义的多个函数一次性地调入内存，从而加快运行速度</li>
</ul>
</li>
</ul>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>Shell函数的定义可以带function fun（） 定义，也可以直接fun（） 定义,不带任何参数。 如：</p>
<pre class="line-numbers language-shell"><code class="language-shell">function 函数名 （） {
   commands 
}

函数名 （） {
   commands
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>实例：</p>
<pre class="line-numbers language-shell"><code class="language-shell">demoFun（）{
    echo "这是我的第一个 shell 函数!"
}
echo "-----函数开始执行-----"
demoFun
echo "-----函数执行完毕-----"
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="函数调用和传参"><a href="#函数调用和传参" class="headerlink" title="函数调用和传参"></a>函数调用和传参</h3><p>Shell函数的调用和执行命令是一样的，只需输入函数名即可调用函数，函数必须在调用之前定义。</p>
<p>函数的参数利用位置参数进行获取与使用：</p>
<ul>
<li>调用函数时，使用位置参数的形式为函数传递参数</li>
<li>函数内的<code>$1</code>-<code>${n}</code> 、<code>$*</code> 和 <code>$@</code> 表示其接收的参数</li>
<li>函数调用结束后位置参数 <code>$1</code>-<code>${n}</code> 、<code>$*</code> 和 <code>$@</code> 将被重置为调用函数之前的值</li>
<li>在主程序和函数中，<code>$0</code>始终代表脚本名</li>
</ul>
<pre class="line-numbers language-shell"><code class="language-shell">funWithParam（）{
    echo "第一个参数为 $1 !"
    echo "第二个参数为 $2 !"
    echo "第十个参数为 $10 !"
    echo "第十个参数为 ${10} !"
    echo "第十一个参数为 ${11} !"
    echo "参数总数有 $# 个!"
    echo "作为一个字符串输出所有参数 $* !"
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="函数内变量的作用域"><a href="#函数内变量的作用域" class="headerlink" title="函数内变量的作用域"></a>函数内变量的作用域</h3><ul>
<li>函数内使用 local 声明的变量是局部（Local）变量，局部变量的作用域是当前函数以及其调用的所有函数。</li>
<li>函数内未使用 local 声明的变量是全局（Global）变量，即主程序和函数中的同名变量是一个变量（地址一致）。</li>
<li>这一点与python不同，python在函数内默认的变量作用域是函数作用域，也就是说默认是局部变量，需要用globa在函数内将其声明为全局变量。</li>
</ul>
<p>我觉得Shell的变量作用域比较容易混乱。</p>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename: function_max.sh
# User define Function （UDF）
usage （） {
  echo "List the MAX of the positive integers in command line. "
  echo "Usage: `basename $0` <num1> <num2> [ <num3> ... ]"
  exit
}
max （） {
  [[ -z $1 || -z $2 ]] && usage    #发现挺多这样写的，因为Shell的与运算默认是短路与，相当于if的效果
  largest=0
  for i ; do  （（i>largest）） && largest=$i ; done
}
### Main script starts here ###
max "$@"
echo "The largest of the numbers is $largest."

#由于largest变量在函数max内没有使用local声明，所以它是全局的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="source命令"><a href="#source命令" class="headerlink" title="source命令"></a>source命令</h4><ul>
<li>如果函数和调用它的主程序保存在同一个文件中，那么函数的定义必须出现在调用之前，这是所有脚本语言共同的特点，python也是这样的。</li>
<li>如果函数和调用它的主程序保存在不同的文件中，保存函数的文件必须先使用 source 命令执行，之后才能调用其中的函数。<ul>
<li>source命令类似于python中的import，引入对应的代码文件内容。</li>
</ul>
</li>
</ul>
<p>文件1：</p>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename: /root/bin/my_backup_functions.sh
### User define Function （UDF） ###
sql_bak  （） { echo "Running mysqldump tool..."; }
sync_bak （） { echo "Running rsync tool..."; }
git_bak  （） { echo "Running gistore tool..."; }
tar_bak  （） { echo "Running tar tool..."; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>文件2：</p>
<pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash
## filename: all_in_one_backup_select.sourcefunc.sh
source /root/bin/my_backup_functions.sh    #在这里进行了引入
### Main script starts here ###
PS3="Please choose a backup tools : "
select s in  mysqldump rsync gistore tar quit ; do
  case $REPLY in
       1|[mM]ysqldump） sql_bak  ;;
       2|[rR]sync）     sync_bak ;;
       3|[gG]istore）   git_bak  ;;
       4|[tT]ar）       tar_bak  ;;
       5） exit     ;;
  esac
done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="函数的结束和返回值"><a href="#函数的结束和返回值" class="headerlink" title="函数的结束和返回值"></a>函数的结束和返回值</h3><p>隐式结束：</p>
<ul>
<li>当函数的最后一条命令执行完毕，将自动结束</li>
<li>函数的返回值就是最后一条命令的退出码</li>
<li>其返回值被保存在系统变量<code>$?</code>中</li>
</ul>
<p>显式结束：</p>
<ul>
<li><p>return [N]</p>
<ul>
<li>return 将结束函数的执行</li>
<li>可以使用 N 指定函数返回值</li>
</ul>
</li>
<li><p>exit  [N]</p>
<ul>
<li>exit 将中断当前函数及当前Shell的执行</li>
<li>可以使用 N 指定返回值</li>
</ul>
</li>
<li><p>return只结束函数，而exit直接退出脚本</p>
</li>
<li><p>使用 return 或 exit 只能返回整数值</p>
<ul>
<li>我们也可以使用echo命令输出我们想要返回的结果至标准输出，然后在调用函数时，利用<code>$（func）</code>或者`func`执行函数，并获取结果。这样既可以返回整数，也可以返回字符串。</li>
</ul>
<pre class="line-numbers language-shell"><code class="language-shell">RES=$（functionName）
echo $RES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ul>

            </div>
            <hr />

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《Shell脚本编程》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2020/05/03/shell-jiao-ben-bian-cheng/" property="cc:attributionName"
               rel="cc:attributionURL">
                HillZhang
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: 'uCuovwWUzxnygDdXy6SPs97E-gzGzoHsz',
        appKey: 'oroAoITTPFXepwWrR1qGq7b7',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '欢迎和我一起交流！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/05/05/zheng-ze-biao-da-shi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/27.jpg" class="responsive-img" alt="正则表达式笔记">
                        
                        <span class="card-title">正则表达式笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            正则表达式笔记什么是正则表达式正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。

                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2020-05-05
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux/" class="post-category" target="_blank">
                                    Linux
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Linux/" target="_blank">
                        <span class="chip bg-color">Linux</span>
                    </a>
                    
                    <a href="/tags/正则表达式/" target="_blank">
                        <span class="chip bg-color">正则表达式</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/05/02/linux-xi-tong-qi-dong-ji-chang-yong-ming-ling/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="Linux系统启动及常用命令">
                        
                        <span class="card-title">Linux系统启动及常用命令</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Linux系统启动及常用命令Linux系统启动过程RHEL/CentOS启动过程总览
BIOS初始化
检测所有外围设备
按配置顺序寻找启动介质
从MBR寻找引导程序


启动加载器
GRUB（stage1）
GRUB（stage1.5）
G
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2020-05-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux/" class="post-category" target="_blank">
                                    Linux
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Linux/" target="_blank">
                        <span class="chip bg-color">Linux</span>
                    </a>
                    
                    <a href="/tags/操作系统/" target="_blank">
                        <span class="chip bg-color">操作系统</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: HillZhang的博客<br />'
            + '作者: HillZhang<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2019-2020 章岳. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">178.6k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/HillZhang1999" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:471791641@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>





    <a href="http://wpa.qq.com/msgrd?v=3&uin=471791641&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>





    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 80000;
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2020, 03, 11, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    

    <!-- 雪花特效 -->
    

</body>

</html>