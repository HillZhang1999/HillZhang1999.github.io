<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="数据库复习——基于MySQL, 章岳 学习笔记 计算机 算法 程序">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="数据库复习笔记本文是我复习数据库所做的知识总结，选用的数据库主要为：MySQL。更详细的内容可以看牛客网上这篇https://www.nowcoder.com/discuss/150059?type=0&amp;amp;order=7&amp;amp;po">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>数据库复习——基于MySQL | HillZhang的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="//stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">HillZhang的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">HillZhang的博客</div>
        <div class="logo-desc">
            
            苏州大学 | 计算机科学与技术学院 | 软件工程
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/24.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        数据库复习——基于MySQL
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/数据库/" target="_blank">
                            <span class="chip bg-color">数据库</span>
                        </a>
                        
                        <a href="/tags/mysql/" target="_blank">
                            <span class="chip bg-color">mysql</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/数据库/" class="post-category" target="_blank">
                            数据库
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-05-29
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    HillZhang
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    24.8k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    88 分
                </div>
                
                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="数据库复习笔记"><a href="#数据库复习笔记" class="headerlink" title="数据库复习笔记"></a>数据库复习笔记</h1><p>本文是我复习数据库所做的知识总结，选用的数据库主要为：MySQL。更详细的内容可以看牛客网上这篇<a href="https://www.nowcoder.com/discuss/150059?type=0&amp;order=7&amp;pos=43&amp;page=2&amp;source_id=discuss_center_0&amp;channel=2000。" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/150059?type=0&amp;order=7&amp;pos=43&amp;page=2&amp;source_id=discuss_center_0&amp;channel=2000。</a></p>
<h2 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h2><h3 id="数据库定义"><a href="#数据库定义" class="headerlink" title="数据库定义"></a>数据库定义</h3><p>数据库（Database）是<strong>按照数据结构来组织、存储和管理数据的仓库</strong>。</p>
<p>每个数据库都有一个或多个不同的 API 用于<strong>创建，访问，管理，搜索和复制</strong>所保存的数据。</p>
<p>我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较<strong>慢</strong>。还存在着以下的缺陷:</p>
<ul>
<li>共享性差</li>
<li>安全性差</li>
<li>数据不一致</li>
<li>数据独立性差</li>
<li>数据冗余大</li>
<li>数据删除、添加、修改等麻烦</li>
</ul>
<h3 id="数据库基本概念-1"><a href="#数据库基本概念-1" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h3><p>数据库的四大基本概念为：</p>
<ul>
<li><strong>数据</strong>（Data）：数据库中存储的<strong>基本对象</strong>，是事物的<strong>符号记录</strong>。<ul>
<li>特点：数据的解释是指对<strong>数据含义</strong>的说明。</li>
</ul>
</li>
<li><strong>数据库</strong>（DataBase，DB）：数据库是<strong>长期储存在计算机内、有组织的、可共享的大量数据的集合</strong>。存储的是<strong>数据以及数据之间的联系</strong>。<ul>
<li>特点：<ul>
<li><strong>数据结构化</strong>，统一管理和控制</li>
<li>较小的<strong>冗余度</strong></li>
<li>较高的<strong>独立性、易扩展性、共享性</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>数据库管理系统</strong>（DBMS）：<strong>位于用户与操作系统之间的一层数据管理软件</strong>。用于科学地组织和存储数据、高效地获取和维护数据。属于<strong>系统软件</strong>。主要功能是<strong>定义数据库</strong>。（MySQL、Oracle、SQL Sever等都属于DBMS）<ul>
<li>主要功能：<ul>
<li>数据<strong>定义</strong>功能：DBMS提供<strong>数据描述语言</strong>（DDL），用户可通过它来定义数据对象。</li>
<li>数据<strong>操纵</strong>功能：DBMS还提供<strong>数据操纵语言</strong>（DML），实现对数据库的基本操作（<strong>CURD</strong>）：查询、插入、删除和修改。</li>
<li>数据库的<strong>运行管理</strong>：这是DBMS运行时的<strong>核心</strong>部分，它包括<strong>并发控制，安全性检查，完整性约束条件的检查和执行，发生故障后的恢复</strong>等。</li>
<li>数据库的<strong>建立和维护</strong>功能 ：它包括数据库初始数据的输入及转换，数据库的转储与恢复，数据库的重组功能和性能的监视与分析功能等。</li>
</ul>
</li>
</ul>
</li>
<li><strong>数据库系统</strong>（DBS） ：核心是<strong>数据库管理模型</strong>。是在文件系统上发展起来的，计算机系统引用数据库后的系统。 由<strong>DB、DBMS（及其开发工具）、应用系统、DBA（数据库管理员）</strong>构成。能够减少冗余、提高数据独立性、并集中检查数据完整性。<ul>
<li>DBA数据库管理员的主要职责为：<ul>
<li>决定DB中的信息内容和结构；</li>
<li>决定DB的存储结构和存取策略；</li>
<li>定义数据的安全性要求和完整性约束条件；</li>
<li>监控数据库的使用和运行。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="三级模式结构"><a href="#三级模式结构" class="headerlink" title="三级模式结构"></a>三级模式结构</h3><h4 id="模式（全体数据逻辑结构）"><a href="#模式（全体数据逻辑结构）" class="headerlink" title="模式（全体数据逻辑结构）"></a>模式（全体数据逻辑结构）</h4><p><strong>模式（逻辑模式）</strong>：数据库中<strong>全体</strong>数据<strong>的逻辑结构和特征</strong>的描述。一个数据库只有<strong>一个</strong>模式，定义数据的逻辑结构，如：<strong>数据之间的联系，与数据有关的安全性、完整性要求</strong>。</p>
<p>关系型数据库中的<strong>表</strong>属于模式。</p>
<h4 id="外模式（局部数据逻辑结构）"><a href="#外模式（局部数据逻辑结构）" class="headerlink" title="外模式（局部数据逻辑结构）"></a>外模式（局部数据逻辑结构）</h4><p><strong>外模式（子模式）</strong>：数据库中<strong>局部</strong>数据的<strong>逻辑结构和特征的描述</strong>。一个数据库可以有<strong>多个</strong>外模式。保证数据库<strong>安全性</strong>的有力措施。是<strong>模式的逻辑子集</strong>。</p>
<h4 id="内模式（全体数据物理结构）"><a href="#内模式（全体数据物理结构）" class="headerlink" title="内模式（全体数据物理结构）"></a>内模式（全体数据物理结构）</h4><p><strong>内模式（存储模式）</strong>：数据<strong>物理结构和存储方式</strong>的描述。一个数据库只有<strong>一个</strong>内模式。是数据在数据库内部的表达方式，物理结构指的是<strong>数据在硬盘上是怎么被保存的</strong>。</p>
<h3 id="二级映象"><a href="#二级映象" class="headerlink" title="二级映象"></a>二级映象</h3><p>三级模式是对数据的<strong>三个抽象级别</strong>，二级映象在DBMS内部实现这三个抽象层次的联系和转换</p>
<h4 id="外模式-模式映像"><a href="#外模式-模式映像" class="headerlink" title="外模式/模式映像"></a>外模式/模式映像</h4><p>定义<strong>外模式与模式</strong>之间的对应关系。保证数据的<strong>逻辑独立性</strong>。</p>
<p><strong>逻辑独立性</strong>：用户的应用程序与数据库中的<strong>逻辑结构</strong>是相互独立的。</p>
<h4 id="模式-内模式映像"><a href="#模式-内模式映像" class="headerlink" title="模式/内模式映像"></a>模式/内模式映像</h4><p>定义数据<strong>全局逻辑结构与存储结构</strong>之间的对应关系。 保证数据的<strong>物理独立性。</strong></p>
<p><strong>物理独立性</strong>：用户的应用程序与<strong>储存在硬盘上的数据库中的数</strong>据是相互独立的。</p>
<h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><h3 id="关系模型概述"><a href="#关系模型概述" class="headerlink" title="关系模型概述"></a>关系模型概述</h3><p>关系模型的数据结构是：<strong>二维表结构</strong>，它是<strong>关系型数据库</strong>的基础。</p>
<p>关系数据模型由<strong>关系数据结构、关系操作和关系完整性约束</strong>三部分组成。</p>
<p>关系必须是<strong>规范化</strong>的，满足一定的<strong>规范条件</strong>。</p>
<p>关系数据库必须满足<strong>1NF</strong>范式，即一张表中不包含<strong>子表</strong>。（关系的每一个分量必须是一个<strong>不可分</strong>的数据项, 不允许表中还有表）</p>
<p>关系模型只是<strong>常用的数据模型</strong>的一种，数据模型按照<strong>数据之间的联系</strong>可以划分为：</p>
<ul>
<li><strong>层次</strong>模型</li>
<li><strong>网状</strong>模型</li>
<li><strong>关系</strong>模型</li>
<li><strong>面向对象</strong>模型</li>
</ul>
<h3 id="关系模型的基本概念"><a href="#关系模型的基本概念" class="headerlink" title="关系模型的基本概念"></a>关系模型的基本概念</h3><p>关系模型在1970年E.F.Codd提出，操作语言是<strong>结构化查询语言SQL</strong>（Structural Querry Language）</p>
<ul>
<li><strong>关系</strong>：通常指一张<strong>表</strong></li>
<li><strong>元组</strong>：表中的一行<strong>记录</strong></li>
<li><strong>属性</strong>：表中的一<strong>列</strong>，有<strong>属性名和属性值（分量）</strong></li>
<li><strong>分量</strong>：元组中的一个<strong>属性值</strong></li>
<li><strong>关系模式</strong>：对关系的<strong>描述</strong>，通常有几张表就有几个关系模式</li>
<li><strong>域</strong>：属性值的<strong>取值范围</strong></li>
<li><strong>键</strong>：<ul>
<li><strong>超键（关键字）</strong>：在关系中能<strong>唯一标识元组的属性集</strong></li>
<li><strong>候选键</strong>：不含有<strong>多余属性</strong>的<strong>超键</strong></li>
<li><strong>主键</strong>：用户<strong>选作</strong>元组标识的<strong>候选键</strong>（<strong>人为设定</strong>）</li>
<li><strong>外键</strong>：<strong>如果关系模式R中的属性k是其他关系模式的主键，则k是R中的外键</strong>（表与表的关系通过外键来描述）外键表中的外键不能有主键表中<strong>不存在</strong>的数据。（保证数据的完整性和一致性）</li>
</ul>
</li>
<li><strong>主属性</strong>：一个属性只要在<strong>任何一个候选键</strong>中出现过，这个属性就是主属性。</li>
<li><strong>非主属性</strong>：与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。</li>
</ul>
<h3 id="关系的完整性约束"><a href="#关系的完整性约束" class="headerlink" title="关系的完整性约束"></a>关系的完整性约束</h3><ul>
<li><strong>实体完整性</strong>：关系必须有<strong>主键</strong>，且<strong>主键不能重复</strong>，<strong>不能为空</strong> </li>
<li><strong>参照完整性</strong>：以<strong>外键</strong>的形式维护实体间的引用关系，可以<strong>为空</strong>或者值为<strong>被参照关系的主键值</strong></li>
<li><strong>用户自定义完整性</strong>：用户由应用环境决定的针对<strong>具体关系数据库</strong>的约束（属性类型等）</li>
</ul>
<h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p>我们以如下的两张表作为原始数据：</p>
<p><img src="%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0.png" alt="关系代数"></p>
<h4 id="并操作（Union）"><a href="#并操作（Union）" class="headerlink" title="并操作（Union）"></a>并操作（Union）</h4><p>关系（表） R 与关系 S 的并（∪）由<strong>属于 R 或属于 S</strong> 的元组（记录）组成。</p>
<p><img src="%E5%B9%B6.png" alt="并"></p>
<h4 id="差操作（except）"><a href="#差操作（except）" class="headerlink" title="差操作（except）"></a>差操作（except）</h4><p>关系R与关系S的差由<strong>属于R而不属于S</strong>的所有元组组成。</p>
<p><img src="%E5%B7%AE.png" alt="差"></p>
<h4 id="交操作（intersection）"><a href="#交操作（intersection）" class="headerlink" title="交操作（intersection）"></a>交操作（intersection）</h4><p>关系R与关系S的差由<strong>属于R且属于S</strong>的所有元组组成。</p>
<p><img src="%E4%BA%A4.png" alt="交"></p>
<h4 id="笛卡尔积（cartesian-product）"><a href="#笛卡尔积（cartesian-product）" class="headerlink" title="笛卡尔积（cartesian product）"></a>笛卡尔积（cartesian product）</h4><p>这里的笛卡尔积严格地讲是<strong>广义笛卡尔积</strong>。在不会出现混淆的情况下广义笛卡尔积也称为笛卡尔积。</p>
<p>两个分别为n目和m目的关系R和S的广义笛卡尔积是一个<strong>n+m列</strong>的元组的集合。元组的前n列是关系R的一个元组，后m列是关系S的一个元组。若R有k1个元组，S有k2个元组，则关系R和关系S的广义笛卡尔积有<strong>k1×k2</strong>个元组。</p>
<p><strong>R中的每一行元素与S中的每一行元素连接。</strong></p>
<p>相当于：<strong>select 列名 from 表A，表B</strong> 或者<strong>select 列名 from 表A join 表B</strong></p>
<p><img src="%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF.png" alt="笛卡尔积"></p>
<h4 id="投影（projection）"><a href="#投影（projection）" class="headerlink" title="投影（projection）"></a>投影（projection）</h4><p>关系R上的投影是从R中选择出<strong>若干属性列</strong>组成新的关系。</p>
<p>相当于：<strong>select 列名 from 表名</strong>。</p>
<h4 id="选择（selection）"><a href="#选择（selection）" class="headerlink" title="选择（selection）"></a>选择（selection）</h4><p>选择又称为限制（Restriction）。它是在关系R中<strong>选择满足给定条件的诸元组</strong>。</p>
<p>相当于：<strong>select * from 表名 where 条件</strong>。</p>
<h4 id="除（division）"><a href="#除（division）" class="headerlink" title="除（division）"></a>除（division）</h4><p>除法运算是一个复合的二目运算。如果把笛卡尔积看作“乘法”运算，则除法运算可以看作这个“乘法”的逆运算。</p>
<p>若T=R÷S，则S×T的结果应该<strong>全部包含</strong>在R中。</p>
<p><img src="%E9%99%A4.png" alt="除"></p>
<h4 id="连接（join）"><a href="#连接（join）" class="headerlink" title="连接（join）"></a>连接（join）</h4><p>关系R与关系S的连接运算是从两个关系的<strong>广义笛卡尔积</strong>中选取<strong>属性间满足一定条件</strong>的元组形成一个新的连接。（如果不加任何条件，那么默认的连接就是两张表的广义笛卡尔积）</p>
<h5 id="等值连接（equal-join）"><a href="#等值连接（equal-join）" class="headerlink" title="等值连接（equal join）"></a>等值连接（equal join）</h5><p>从关系R和S的广义笛卡尔积中选取<strong>A、B属性值</strong>相等的那些元组。</p>
<p>对应的SQL语句为：<strong>select * from R join S on R.A = S.B</strong></p>
<h5 id="自然连接（natural-join）"><a href="#自然连接（natural-join）" class="headerlink" title="自然连接（natural join）"></a>自然连接（natural join）</h5><p>自然连接是一种<strong>特殊的等值连接</strong>，它要求两个关系中进行比较的分量必须是<strong>相同的属性组</strong>，并且在结果中把<strong>属性重复的列</strong>去掉。</p>
<p>对应的SQL语句为：<strong>select * from R natural join S。</strong></p>
<p>等值连接与自然连接的区别和联系：</p>
<p>1、自然连接<strong>一定</strong>是等值连接，但等值连接<strong>不一定</strong>是自然连接。</p>
<p>2、等值连接要求相等的分量，不一定是公共属性；而自然连接要求相等的分量<strong>必须是公共属性</strong>。</p>
<p>3、等值连接不把重复的属性除去；而自然连接要<strong>把重复的属性除去</strong>。</p>
<h5 id="内连接（inner-join）"><a href="#内连接（inner-join）" class="headerlink" title="内连接（inner join）"></a>内连接（inner join）</h5><p>内连接是将两张表中<strong>共有某属性值</strong>的记录挑选出来。与等值连接类似，二者都是取<strong>交集</strong>。</p>
<p><img src="%E5%86%85%E8%BF%9E%E6%8E%A5.png" alt="内连接"></p>
<h5 id="左外连接（left-join）"><a href="#左外连接（left-join）" class="headerlink" title="左外连接（left join）"></a>左外连接（left join）</h5><p>在自然连接的基础上，保证<strong>左表完全显示</strong>，右表若不存在则<strong>用null填满</strong>。</p>
<p><img src="%E5%B7%A6%E8%BF%9E%E6%8E%A5.png" alt="左连接"></p>
<h5 id="右外连接（right-join）"><a href="#右外连接（right-join）" class="headerlink" title="右外连接（right join）"></a>右外连接（right join）</h5><p>在自然连接的基础上，保证<strong>右表完全显示</strong>，左表若不存在则<strong>用null填满</strong>。</p>
<p><img src="%E5%8F%B3%E8%BF%9E%E6%8E%A5.png" alt="右连接"></p>
<h5 id="全外连接（OUTER-JOIN）"><a href="#全外连接（OUTER-JOIN）" class="headerlink" title="全外连接（OUTER JOIN）"></a>全外连接（OUTER JOIN）</h5><p><strong>左连接+右连接+去重=全连接</strong></p>
<p><img src="%E5%85%A8%E8%BF%9E%E6%8E%A5.png" alt="全连接"></p>
<h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><h4 id="平凡的函数依赖"><a href="#平凡的函数依赖" class="headerlink" title="平凡的函数依赖"></a>平凡的函数依赖</h4><p>如果X→Y，但Y∈X，则称X→Y是平凡的函数依赖.</p>
<h4 id="非平凡的函数依赖"><a href="#非平凡的函数依赖" class="headerlink" title="非平凡的函数依赖"></a>非平凡的函数依赖</h4><p>如果X→Y，但Y∉X，则称X→Y是非平凡的函数依赖。通常情况下总是讨论<strong>非平凡的函数依赖</strong>.</p>
<h4 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h4><p>如果存在 X 属性集（注意是集合，说明是<strong>联合主键</strong>）决定唯一的 Y ，且 <strong>X 中的任一子集都不能决定 唯一的 Y</strong>，则 Y 完全依赖于 X。</p>
<p>例子：学生数学成绩完全由该学生的学号和数学课决定，所以<strong>数学课成绩完全依赖于（学号，数学课）</strong></p>
<h4 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h4><p>如果存在 X 属性集（注意是集合，说明是<strong>联合主键</strong>）决定唯一的 Y ，且 <strong>X 中的任一子集也可以决定 唯一的 Y</strong>，则 Y 部分依赖于 X。</p>
<p>例子：学生学号和姓名可以决定唯一的学生，但是学生号<strong>也可以</strong>决定唯一的学生。</p>
<h4 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h4><p> 在R(U,F)中，如果X→Y，Y∉X，Y→Z，Y不完全函数依赖于X，则称Z对X<strong>传递依赖</strong>。</p>
<p>例如：书的出版编号是唯一，版权归出版社所有，所以只能由该出版社出版。所以存在函数依赖：<strong>书出版编号—&gt;出版社名，出版社名—&gt;出版社地址</strong>，但是出版社名不能决定唯一的出版书编号（除非出版社只出版过一本书，那我没话说?），则有出版书编号传递依赖于出版社地址。</p>
<h3 id="关系范式"><a href="#关系范式" class="headerlink" title="关系范式"></a>关系范式</h3><p>范式是<strong>符合某一种级别的关系模式的集合</strong>。</p>
<p>设计<strong>性能较优</strong>的关系模式称为<strong>规范化</strong>，规范化主要的理论依据是关系规范化理论。目的是<strong>消除插入、删除异常和数据冗余，提高数据库性能。</strong></p>
<p>一般而言，我们只要让数据库中的所有表符合<strong>第三范式或者BCNF</strong>即可。</p>
<h4 id="数据冗余"><a href="#数据冗余" class="headerlink" title="数据冗余"></a>数据冗余</h4><p>数据冗余是指<strong>各个数据文件中存在重复的数据</strong>。会导致：</p>
<ul>
<li><strong>浪费存储空间，降低检索效率</strong>  </li>
<li><strong>潜在的数据不一致性</strong></li>
</ul>
<p>在文件管理系统中各数据文件中难免有许多数据相互重复，数据的冗余度比较大。数据库系统更注重文件之间的联系。数据库系统中的数据具有<strong>共享性</strong>，因而尽可能地避免了数据的重复存储，减少和控制了数据的冗余。</p>
<p>然而，DBS中也不是不存在数据冗余的现象。当<strong>存在传递依赖或者部分依赖</strong>时，必然会出现数据冗余现象，我们要依据<strong>关系范式</strong>进行<strong>数据表分解</strong>，从而减轻冗余。</p>
<h4 id="第一范式1NF（原子性）"><a href="#第一范式1NF（原子性）" class="headerlink" title="第一范式1NF（原子性）"></a>第一范式1NF（原子性）</h4><p>表中的每一列都是<strong>不可分解的基本数据项</strong>，每一个属性<strong>不可拥有</strong>多个值。是关系数据库的<strong>基本要求</strong>。需要满足<strong>原子性</strong>。</p>
<h4 id="第二范式2NF（消除部分依赖）"><a href="#第二范式2NF（消除部分依赖）" class="headerlink" title="第二范式2NF（消除部分依赖）"></a>第二范式2NF（消除部分依赖）</h4><p>前提是满足1NF。此外：一个表必须有主键，<strong>非主属性必须完全依赖于主键。</strong>（<strong>消除非主属性对主键的部分依赖</strong>）</p>
<p><img src="2NF.png" alt="2NF"></p>
<h4 id="第三范式3NF（消除传递依赖）"><a href="#第三范式3NF（消除传递依赖）" class="headerlink" title="第三范式3NF（消除传递依赖）"></a>第三范式3NF（消除传递依赖）</h4><p>前提是满足2NF。此外：<strong>任意一个非主属性都不可传递依赖于主键</strong>。（消除非主属性对主键的<strong>传递依赖</strong>）（要求依赖右侧全部为候选键或者它的成员）</p>
<p><img src="3NF.png" alt="3NF"></p>
<h4 id="BC范式BCNF（主属性不能依赖于主属性）"><a href="#BC范式BCNF（主属性不能依赖于主属性）" class="headerlink" title="BC范式BCNF（主属性不能依赖于主属性）"></a>BC范式BCNF（主属性不能依赖于主属性）</h4><p>前途是满足3NF。此外：<strong>不能存在主键的一部分被另一部分或者非主键的其它部分所决定</strong>。（消除所有部分依赖与传递依赖）（要求依赖右侧全部为候选键）</p>
<h4 id="第四范式"><a href="#第四范式" class="headerlink" title="第四范式"></a>第四范式</h4><p>要求把同一表内的多对多关系删除。</p>
<h4 id="第五范式"><a href="#第五范式" class="headerlink" title="第五范式"></a>第五范式</h4><p>从最终结构重新建立原始结构。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包指的是：<strong>由一个属性或者属性组直接或间接推导出的所有属性的集合</strong>。</p>
<p>求闭包的算法：<strong>循环迭代</strong>，每一次迭代过程中找到能够被当前闭包中的属性直接推出的属性加入到闭包中。直到无法加入新属性。</p>
<h3 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a>关系型数据库和非关系型数据库</h3><table>
<thead>
<tr>
<th>数据库 类型</th>
<th>特性</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>关系型数据库：SQLite、Oracle、mysql</td>
<td>1、关系型数据库，是指采用了<strong>关系模型</strong>来组织数据的数据库；<br>2、关系型数据库的最大特点就是事务的<strong>一致性</strong>；<br>3、简单来说，关系模型指的就是<strong>二维表格模型</strong>，而一个关系型数据库就是由<strong>二维表及其之间的联系</strong>所组成的一个数据组织。</td>
<td>1、<strong>容易理解</strong>：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；<br>2、<strong>使用方便</strong>：通用的SQL语言使得操作关系型数据库非常方便；<br>3、<strong>易于维护</strong>：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了<strong>数据冗余和数据不一致</strong>的概率；<br>4、<strong>支持SQL</strong>，可用于复杂的查询。<br></td>
<td>1、为了维护一致性所付出的巨大代价就是其<strong>读写性能比较差</strong>；<br>2、固定的<strong>表结构</strong>；<br>3、不适合<strong>高并发</strong>读写需求；<br>4、不适合<strong>海量数据</strong>的高效率读写；</td>
</tr>
<tr>
<td>非关系型数据库：MongoDb、redis、HBase</td>
<td>1、使用<strong>键值对（也可以是文档形式、图片形式等）</strong>存储数据；<br>2、<strong>支持分布式</strong>；<br>3、一般不支持事务的<strong>ACID特性</strong>；<br>4、非关系型数据库严格上不是一种数据库，应该是一种<strong>数据结构化存储方法的集合</strong>。</td>
<td>1、无需经过sql层的解析，<strong>读写性能很高</strong>；<br>2、基于键值对，数据没有<strong>耦合性</strong>，<strong>容易扩展</strong>；<br>3、存储数据的格式：nosql的存储格式是<strong>key,value形式、文档形式、图片形式</strong>等等，而关系型数据库则只支持基础类型。</td>
<td>1、不提供sql支持，<strong>学习和使用成本较高</strong>；<br>2、<strong>无事务处理</strong>，附加功能bi和报表等支持也不好；</td>
</tr>
</tbody></table>
<p>数据的持久存储，尤其是<strong>海量数据的持久存储</strong>，还是需要一种<strong>关系数据库</strong>。</p>
<h2 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>MySQL是一个<strong>关系型数据库管理系统，</strong>由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS 软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</p>
<h3 id="MySQL权限表"><a href="#MySQL权限表" class="headerlink" title="MySQL权限表"></a>MySQL权限表</h3><p>MySQL服务器通过<strong>权限表</strong>来控制<strong>用户对数据库的访问</strong>，权限表存放在mysql数据库里，由<strong>mysql_install_db</strong>脚本初始化。这些权限表分别为<strong>user，db，table_priv，columns_priv和host</strong>。下面分别介绍一下这些表的结构和内容：</p>
<ul>
<li><p><strong>user权限表</strong>：记录<strong>允许</strong>连接到服务器的<strong>用户帐号信息</strong>，里面的权限是<strong>全局级</strong>的。</p>
</li>
<li><p><strong>db权限表</strong>：记录各个帐号在各个<strong>数据库</strong>上的操作权限，，里面的权限是<strong>数据库级</strong>的。</p>
</li>
<li><p><strong>table_priv权限表</strong>：记录<strong>数据表级</strong>的操作权限。</p>
</li>
<li><p><strong>columns_priv权限表</strong>：记录<strong>数据列级</strong>的操作权限。</p>
</li>
<li><p><strong>host权限表</strong>：配合db权限表对<strong>给定主机上数据库级操作权限</strong>作更细致的控制。这个权限表不受<strong>GRANT和</strong></p>
<p><strong>REVOKE语句</strong>的影响。</p>
</li>
</ul>
<p>MySQL中的权限管理：</p>
<ul>
<li><p><strong>授予权限</strong>：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">grant 权限 on 数据库对象 to 用户<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>撤销权限</strong>：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">revoke 权限 on 数据库对象 from 用户<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
<h3 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h3><p>MySQL的常见日志log分为以下类型：</p>
<table>
<thead>
<tr>
<th>日志类型</th>
<th>日志内容</th>
</tr>
</thead>
<tbody><tr>
<td>错误日志</td>
<td>mysql 启动、停止和运行过程中出现的异常</td>
</tr>
<tr>
<td>常规操作日志</td>
<td>已创建客户端连接和客户端处理记录</td>
</tr>
<tr>
<td>二进制日志</td>
<td>数据变更日志(可用于同步)</td>
</tr>
<tr>
<td>转存日志</td>
<td>从主服务器同步的数据记录</td>
</tr>
<tr>
<td>慢查询日志</td>
<td>耗时超过 long_query_time 所设置时间的查询</td>
</tr>
<tr>
<td>DDL日志（元日志）</td>
<td>ddl 语句执行的元数据操作</td>
</tr>
</tbody></table>
<p>其中，<strong>二进制日志binlog</strong>是实际最常使用的日志，因为它可以对数据库进行<strong>恢复</strong>。</p>
<p>binlog的录入格式为：</p>
<ul>
<li><strong>Statement（只记录修改语句）</strong>：只记录<strong>每条修改数据的SQL执行语句</strong>；但还必须记录每条语句在执行的时候的一些相关信息，确保所有语句能在slave得到和在master端（<strong>主从复制</strong>）执行时候相同的结果。但<strong>一些函数功能不能被复制</strong>。</li>
<li><strong>row（只记录修改结果）</strong>：不记录SQL的上下语句信息，只记录<strong>那一条记录被修改成什么</strong>了；解决了Statement的问题，但单语句更新（删除）表的行数过多，会导致<strong>形成大量binlog</strong>。</li>
<li><strong>Mixedlevel（混合）</strong>：前两个的混合使用，一般的语句修改用Statement，一些函数复制等用row，根据执行的语句来选择使用哪种方式。</li>
</ul>
<h3 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h3><p>MySQL中定义数据字段的类型对<strong>数据库的优化</strong>是非常重要的。</p>
<p>MySQL支持多种类型，大致可以分为三类：<strong>数值、日期/时间和字符串(字符)类型。</strong></p>
<h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">范围（有符号）</th>
<th align="left">范围（无符号）</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TINYINT</td>
<td align="left">1 byte</td>
<td align="left">(-128，127)</td>
<td align="left">(0，255)</td>
<td align="left">小整数值</td>
</tr>
<tr>
<td align="left">SMALLINT</td>
<td align="left">2 bytes</td>
<td align="left">(-32 768，32 767)</td>
<td align="left">(0，65 535)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">MEDIUMINT</td>
<td align="left">3 bytes</td>
<td align="left">(-8 388 608，8 388 607)</td>
<td align="left">(0，16 777 215)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">INT或INTEGER</td>
<td align="left">4 bytes</td>
<td align="left">(-2 147 483 648，2 147 483 647)</td>
<td align="left">(0，4 294 967 295)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">BIGINT</td>
<td align="left">8 bytes</td>
<td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td>
<td align="left">(0，18 446 744 073 709 551 615)</td>
<td align="left">极大整数值</td>
</tr>
<tr>
<td align="left">FLOAT</td>
<td align="left">4 bytes</td>
<td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td align="left">单精度 浮点数值</td>
</tr>
<tr>
<td align="left">DOUBLE</td>
<td align="left">8 bytes</td>
<td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">双精度 浮点数值</td>
</tr>
<tr>
<td align="left">DECIMAL</td>
<td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td align="left">依赖于M和D的值</td>
<td align="left">依赖于M和D的值</td>
<td align="left">小数值</td>
</tr>
</tbody></table>
<h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><p>每个时间类型有一个有效值范围和一个”<strong>零”</strong>值，当指定不合法的MySQL不能表示的值时使用”零”值。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小 ( bytes)</th>
<th align="left">范围</th>
<th align="left">格式</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DATE</td>
<td align="left">3</td>
<td align="left">1000-01-01/9999-12-31</td>
<td align="left">YYYY-MM-DD</td>
<td align="left">日期值</td>
</tr>
<tr>
<td align="left">TIME</td>
<td align="left">3</td>
<td align="left">‘-838:59:59’/‘838:59:59’</td>
<td align="left">HH:MM:SS</td>
<td align="left">时间值或持续时间</td>
</tr>
<tr>
<td align="left">YEAR</td>
<td align="left">1</td>
<td align="left">1901/2155</td>
<td align="left">YYYY</td>
<td align="left">年份值</td>
</tr>
<tr>
<td align="left">DATETIME</td>
<td align="left">8</td>
<td align="left">1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td align="left">YYYY-MM-DD HH:MM:SS</td>
<td align="left">混合日期和时间值</td>
</tr>
<tr>
<td align="left">TIMESTAMP</td>
<td align="left">4</td>
<td align="left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td>
<td align="left">YYYYMMDD HHMMSS</td>
<td align="left">混合日期和时间值，时间戳</td>
</tr>
</tbody></table>
<h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CHAR</td>
<td align="left">0-255 bytes</td>
<td align="left">定长字符串</td>
</tr>
<tr>
<td align="left">VARCHAR</td>
<td align="left">0-65535 bytes</td>
<td align="left">变长字符串</td>
</tr>
<tr>
<td align="left">TINYBLOB</td>
<td align="left">0-255 bytes</td>
<td align="left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td align="left">TINYTEXT</td>
<td align="left">0-255 bytes</td>
<td align="left">短文本字符串</td>
</tr>
<tr>
<td align="left">BLOB</td>
<td align="left">0-65 535 bytes</td>
<td align="left">二进制形式的长文本数据</td>
</tr>
<tr>
<td align="left">TEXT</td>
<td align="left">0-65 535 bytes</td>
<td align="left">长文本数据</td>
</tr>
<tr>
<td align="left">MEDIUMBLOB</td>
<td align="left">0-16 777 215 bytes</td>
<td align="left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td align="left">MEDIUMTEXT</td>
<td align="left">0-16 777 215 bytes</td>
<td align="left">中等长度文本数据</td>
</tr>
<tr>
<td align="left">LONGBLOB</td>
<td align="left">0-4 294 967 295 bytes</td>
<td align="left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td align="left">LONGTEXT</td>
<td align="left">0-4 294 967 295 bytes</td>
<td align="left">极大文本数据</td>
</tr>
</tbody></table>
<ul>
<li>char（n）和 varchar（n） 中括号中 n 代表<strong>字符的个数</strong>，并不代表字节个数</li>
<li>CHAR 和 VARCHAR 类型类似，但它们<strong>保存和检索的方式</strong>不同。它们的<strong>最大长度和是否尾部空格被保留</strong>等方面也不同。在存储或检索过程中不进行<strong>大小写转换</strong>。<ul>
<li>定义一个char[10]和varchar[10],如果存进去的是‘abcd’,那么char所占的长度<strong>依然为10</strong>，除了字符‘abcd’外，后面<strong>跟六个空格</strong>，而varchar就立马把长度<strong>变为4</strong>了，取数据的时候，char类型的要用<strong>trim</strong>去掉多余的空格，而varchar是不需要的</li>
<li>char的存取数度还是要比varchar<strong>要快得多</strong>，因为其<strong>长度固定</strong>，方便程序的存储与查找；但是char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取<strong>时间效率</strong>，而varchar是以<strong>空间效率</strong>为首位的。</li>
<li>char的存储方式是，<strong>对英文字符（ASCII）占用1个字节，对一个汉字占用2个字节</strong>；而varchar的存储方式是，<strong>对每个英文字符占用2个字节，汉字也占用2个字节</strong>，两者的存储数据都非unicode的字符数据。</li>
</ul>
</li>
</ul>
<h2 id="MySQL基本操作"><a href="#MySQL基本操作" class="headerlink" title="MySQL基本操作"></a>MySQL基本操作</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>我们可以在登陆 MySQL 服务后，使用 <strong>create</strong> 命令<strong>创建数据库</strong>，语法如下:</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">CREATE DATABASE 数据库名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在<strong>删除数据库</strong>过程中，务必要十分谨慎，因为在执行删除命令后，所有数据将会消失。我们使用<strong>drop</strong>命令删除数据库：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">drop database 数据库名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>修改数据库属性</strong>，包括更改数据库名称、数据库所有者等等：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">ALTER DATABASE yyDB RENAME TO yyDBnew;
ALTER DATABASE yyDB OWNER TO yy;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h3><h4 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h4><p>我们使用<strong>create命令</strong>创建数据表，同时可以<strong>指定每一列的数据类型和属性等</strong>。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE IF NOT EXISTS `runoob_tbl`(
   `runoob_id` INT UNSIGNED AUTO_INCREMENT,
   `runoob_title` VARCHAR(100) NOT NULL,
   `runoob_author` VARCHAR(40) NOT NULL,
   `submission_date` DATE,
   PRIMARY KEY ( `runoob_id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意，这里的列名被<strong>反引号</strong>框了起来，而不是单引号。</p>
<p>实例解析：</p>
<ul>
<li>如果你不想字段为 <strong>NULL</strong> 可以设置字段的属性为 <strong>NOT NULL</strong>， 在操作数据库时如果输入该字段的数据为<strong>NULL</strong> ，就会报错。</li>
<li>AUTO_INCREMENT定义列为<strong>自增</strong>的属性，一般用于主键，数值会<strong>自动加1</strong>。</li>
<li>PRIMARY KEY关键字用于定义列为<strong>主键</strong>。 您可以使用多列来定义主键，列间以逗号分隔。</li>
<li>ENGINE 设置<strong>存储引擎</strong>，CHARSET 设置<strong>编码</strong>。</li>
</ul>
<p>MySQL 字段属性应该尽量设置为 <strong>NOT NULL</strong>，NULL类型的字段会导致种种弊端，例如：</p>
<ul>
<li>含有空值的列很难进行<strong>查询优化</strong>，而且对表索引时不会存储 NULL 值的，所以如果索引的字段可以为 NULL，<strong>索引的效率会下降很多</strong>。因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用 0、一个特殊的值或者一个空串代替空值。</li>
<li>联表查询的时候，例如 LEFT JOIN table2，若没有记录，则查找出的 table2 字段都是 null。假如 table2 有些字段本身可以是 null，那么除非把 table2 中 not null 的字段查出来，否则就<strong>难以区分到底是没有关联记录还是其他情况。</strong></li>
</ul>
<p>实际上，<strong>空串“”不等于NULL。</strong>任何数跟 NULL 进行运算都是 NULL, 判断值是否等于 NULL，不能简单用 =，而要用 <strong>IS NULL</strong>关键字。</p>
<p>可以看到，我们在定义数据表时，为每个列都定义了一些约束，<strong>列完整性约束包括：</strong></p>
<ul>
<li><code>PRIMARY Key</code>（主键）、<code>NULL</code>（空值）、<code>NOT NULL</code>（非空值）、<code>UNIQUE</code>（值唯一）、<code>CHECK</code>（有效性检查）、<code>DEFAULT</code>（缺省值）</li>
</ul>
<p>使用<strong>列约束</strong>定义单个主键，若要定义<strong>多个列构成的复合主键、代理键、外键</strong>时，需要使用<strong>表约束</strong>关键词：<code>CONSTRAINT</code></p>
<pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE Plan(
CourseID         char(4)         NOT NULL,
TeacherID         char(4)         NOT NULL,
CourseName         varchar(20),
CourseRoom         varchar(30),
CONSTRAINT         CoursePlan_PK         PRIMARY Key(CourseID, TeacherID)   --定义复合主键
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>定义<strong>外键</strong>也需要使用<strong>CONSTRAINT表约束</strong>关键字：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE Register(
CourseRegID        serial            NOT NULL,
CoursePlanID    int                NOT NULL,  
StudentID         char(13)         
CONSTRAINT         CourseRegID_PK         PRIMARY Key(CourseRegID),   --定义代理键
CONSTRAINT CoursePlanID_FK FOREIGN Key(CoursePlanID)  --定义外键1
REFERENCES Plan(CoursePlanID)  --参考表的主键列
 ON DELETE CASCADE,  --级联删除
CONSTRAINT StudentID_FK FOREIGN Key(StudentID)  --定义外键2
REFERENCES Student(StudentID)  --参考表的主键列
 ON DELETE CASCADE  --级联删除
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>级联删除<code>DELETE CASCADE</code>：是指当主表(parent table)中的一条记录被删除，子表中关联的记录也相应的<strong>自动删除</strong>。</p>
<p>外键的约束：</p>
<p>1.在对<strong>子表</strong>（有<code>FOREIGN KEY</code>关键词的表）进行数据操作时，外键的取值或者变更必须与其关联表的主键的列值一致。（不能是不存在的值）</p>
<p>2.<strong>主表</strong>元素删除或者主键值变更，子表中参照的外键值应对应变更，要么取空值，要么引用主表中存在的主键值，以保持关联数据表数据一致。</p>
<h4 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h4><p>MySQL中<strong>删除数据表</strong>是非常容易操作的， 但是你再进行删除表操作时要非常小心，因为执行删除命令后所有数据都会消失。</p>
<p>我们有以下几种不同的方式对表进行删除：</p>
<ul>
<li><strong>drop命令</strong>：删除<strong>表全部数据和表结构</strong>，立刻<strong>释放磁盘空间</strong>，不管是 <strong>Innodb 和 MyISAM;</strong></li>
</ul>
<pre class="line-numbers language-mysql"><code class="language-mysql">drop table student;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><strong>truncate命令</strong>：删除<strong>表全部数据</strong>，<strong>保留表结构</strong>，立刻<strong>释放磁盘空间</strong> ，不管是 <strong>Innodb 和 MyISAM;</strong></li>
</ul>
<pre class="line-numbers language-mysql"><code class="language-mysql">truncate table student;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><strong>delete命令</strong>： 删除<strong>表全部数据</strong>，<strong>表结构不变</strong>，对于 <strong>MyISAM</strong> 会立刻释放磁盘空间，<strong>InnoDB</strong> 不会释放磁盘空间;</li>
</ul>
<pre class="line-numbers language-mysql"><code class="language-mysql">delete from student;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>需要注意</strong>： 不能直接删除由<code>FOREIGN KEY</code>约束引用的表。只有先删除<code>FOREIGN KEY</code>约束或引用的表后，才能删除本表。即：<strong>先删子表（有FOREIGN Key关键词的表）再删主表（被关联的表）</strong>。</p>
<h3 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h3><p>与修改数据库、列类似，我们可以使用一个<strong>ALTER关键字</strong>对数据表的属性进行替换。    </p>
<pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE Student ADD StudentGender char(2) NULL;
ALTER TABLE Student DROP COLUMN BirthDay;
ALTER TABLE Student RENAME TO StudentNew;
ALTER TABLE Student ALTER COLUMN StudentName TYPE varchar(12);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>MySQL 表中使用 <strong>INSERT INTO</strong> SQL语句来插入数据。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">INSERT INTO table_name ( field1, field2,...fieldN )
                       VALUES
                       ( value1, value2,...valueN );
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果数据是<strong>字符型</strong>，必须使用<strong>单引号或者双引号</strong>，如：”value”。</p>
<p>插入数据的格式必须与表结构中固定的数据格式<strong>一致</strong>。</p>
<h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><p>查询数据是MYSQL数据库中最为常用的操作之一，使用<strong>SELECT</strong>语句：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">SELECT column_name,column_name
FROM table_name
[WHERE Clause]
[LIMIT N][ OFFSET M]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>查询语句中你可以使用<strong>一个或者多个表</strong>，表之间使用<strong>逗号</strong>分割，并使用WHERE语句来设定查询条件。</p>
</li>
<li><p>SELECT 命令可以读取<strong>一条或者多条记录</strong>。</p>
</li>
<li><p>你可以使用<strong>星号（*）</strong>来代替其他字段，SELECT语句会返回表的<strong>所有字段数据</strong></p>
</li>
<li><p>你可以使用 <strong>WHERE 语句</strong>来包含任何条件。</p>
</li>
<li><p>你可以使用 <strong>LIMIT 属性</strong>来设定返回的记录数，也可以<strong>截取</strong>一定的记录返回。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">select * from table limit 5; --返回前5行
select * from table limit 0,5; --同上，返回前5行
select * from table limit 5,10; --返回6-10行
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>你可以通过<strong>OFFSET</strong>指定SELECT语句开始查询的<strong>数据偏移量</strong>。默认情况下<strong>偏移量为0</strong>。</p>
</li>
</ul>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>你可以使用 SQL 的 <strong>DELETE FROM</strong> 命令来删除 MySQL 数据表中的记录。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">DELETE FROM table_name [WHERE Clause]
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果不指定条件语句，那么DELETE命令会将表中的全部数据都删除。</p>
<h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p>如果我们需要修改或更新 MySQL 中的数据，我们可以使用 SQL <strong>UPDATE 命令</strong>来操作。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">UPDATE table_name SET field1=new-value1, field2=new-value2
[WHERE Clause]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>你可以同时更新一个或多个字段。</li>
<li>你可以在 WHERE 子句中指定任何条件。</li>
<li>你可以在一个单独表中同时更新数据。</li>
</ul>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>MySQL中常用的<strong>聚合函数</strong>主要有：</p>
<ul>
<li><code>AVG()</code>：计算<strong>平均值</strong></li>
<li><code>MIN()</code>：计算<strong>最小值</strong></li>
<li><code>MAX()</code>：计算<strong>最大值</strong></li>
<li><code>SUM()</code>：计算该列所有值的<strong>和</strong></li>
<li><code>COUNT()</code>：计算<strong>结果集行数</strong></li>
</ul>
<p><strong>聚合函数只能出现在having条件语句中，而不能出现在where条件语句中，因为它的执行晚于where。</strong></p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>MySQL中的条件语句主要分为两种类型，分别是：</p>
<ul>
<li><strong>where</strong>：是一个<strong>约束声明</strong>，是在<strong>查询之前</strong>约束来自数据库的数据。</li>
<li><strong>having</strong>：是一个<strong>过滤声明</strong>，是在<strong>查询结果集返回以后</strong>对查询结果进行的过滤操作。HAVING语通常与<strong>GROUP BY</strong>语句联合使用，用来<strong>过滤由GROUP BY语句返回的记录集</strong>。HAVING语句的存在<strong>弥补</strong>了WHERE关键字不能与聚合函数联合使用的<strong>不足</strong>。</li>
</ul>
<p>where和having的差别本质上来源于<strong>MySQL关键字执行顺序</strong>的差别：</p>
<blockquote>
<p>MySQL关键字的执行顺序：<strong>from、where、group by、聚集函数、having、select、order by、limit</strong></p>
</blockquote>
<p>例子：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">select goods_name,goods_number from sw_goods where goods_price > 100
#只可以使用where，不能改成having，因为查询的结果中不包含goods_price列

select goods_category_id , avg(goods_price) as ag from sw_goods group by goods_category having ag > 1000
#只可以使用having，不可以使用where，因为原数据表中不存在ag列，且聚集函数的执行晚于where
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-mysql"><code class="language-mysql">SELECT Major AS 专业, COUNT(StudentID) AS 学生人数
FROM Student
WHERE StudentGender='女'  --过滤数据集：性别为女
GROUP BY Major  --根据专业来分组
HAVING COUNT(*)>3;  --限定分组数据：行数大于3的
#筛选出女同学数目大于3的专业
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="常用关系运算符"><a href="#常用关系运算符" class="headerlink" title="常用关系运算符"></a>常用关系运算符</h4><table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">等号，检测两个值是否相等，如果相等返回true。</td>
<td align="left">A = B 返回false。</td>
</tr>
<tr>
<td align="left">&lt;&gt;, !=</td>
<td align="left">不等于，检测两个值是否相等，如果不相等返回true</td>
<td align="left">A != B 返回 true。</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true</td>
<td align="left">A &gt; B 返回false。</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true</td>
<td align="left">A &lt; B 返回 true。</td>
</tr>
<tr>
<td align="left">&gt;=</td>
<td align="left">大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true</td>
<td align="left">A &gt;= B 返回false。</td>
</tr>
<tr>
<td align="left">&lt;=</td>
<td align="left">小于等于号，检测左边的值是否小于或等于右边的值, 如果左边的值小于或等于右边的值返回true</td>
<td align="left">A &lt;= B 返回 true。</td>
</tr>
<tr>
<td align="left">IS NULL</td>
<td align="left">当列的值是 NULL,此运算符返回 true。</td>
<td align="left">A = NULL 返回true</td>
</tr>
<tr>
<td align="left">IS NOT NULL</td>
<td align="left">当列的值不是 NULL,此运算符返回 true。</td>
<td align="left">A != NULL 返回true</td>
</tr>
<tr>
<td align="left">&lt;=&gt;</td>
<td align="left">比较操作符（不同于 = 运算符），<strong>当比较的的两个值相等或者都为 NULL 时返回 true。</strong></td>
<td align="left">NULL &lt;=&gt; NULL 返回true</td>
</tr>
</tbody></table>
<h4 id="BETWEEN运算符"><a href="#BETWEEN运算符" class="headerlink" title="BETWEEN运算符"></a>BETWEEN运算符</h4><p>我们可以利用<code>BETWEEN...AND</code>限定范围，相比于常规的比较操作符（&gt;,&lt;,=），<strong>BETWEEN关键字可以运用在更广阔的范围内，如时间范围、字符范围等。</strong></p>
<pre class="line-numbers language-mysql"><code class="language-mysql">SELECT *
FROM Student
WHERE BirthDay BETWEEN '1999-01-01' AND '1999-12-31';
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="LIKE运算符"><a href="#LIKE运算符" class="headerlink" title="LIKE运算符"></a>LIKE运算符</h4><p>我们可以利用<code>LIKE</code>与通配符限定范围。</p>
<p>常见的通配符有：</p>
<ul>
<li><p><code>通配符 _</code>代表一个未指定的字符，</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">SELECT *
FROM Student
WHERE StudentName LIKE '袁_';
#找到姓袁且名字共两个字的人
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>通配符 %</code>代表任意个未指定的字符。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">SELECT *
FROM Student
WHERE Major LIKE '软件%';
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h4 id="GREATEST关键字"><a href="#GREATEST关键字" class="headerlink" title="GREATEST关键字"></a>GREATEST关键字</h4><p>语法格式为：GREATEST（值1，值2，…值n），其中n表示参数列表中有n个值。当有2个或多个参数时，返回值为<strong>最大值</strong>，假如任意一个自然变量为NULL，则GREATEST（）的返回值<strong>为NULL</strong>。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">select greatest(2,0),greatest(20.0,3.0,100.5),greatest(10,NULL);
#返回值=2,100.5，null
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="LEAST关键字"><a href="#LEAST关键字" class="headerlink" title="LEAST关键字"></a>LEAST关键字</h4><p>语法格式为：LEAST（值1，值2，…值n），其中值n表示参数列表中有n个值。在有两个或多个参数的情况下，返回<strong>最小值</strong>。假如任意一个自变量为NULL，则LEAST（）的返回值为NULL。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">select least(2,0),least(20.0,3.0,100.5),least(10,NULL);　
#返回值=0,3.0，null
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="IN、NOT-IN运算符。"><a href="#IN、NOT-IN运算符。" class="headerlink" title="IN、NOT IN运算符。"></a>IN、NOT IN运算符。</h4><p>IN运算符用来判断操作数<strong>是否为列表中的其中一个值</strong>，如果是，返回值为1；否则返回值为0。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">select 2 IN(1,3,5,'thks'),'thks' IN(1,3,5,'thks');  
#返回值=0,1
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="REGEXP运算符"><a href="#REGEXP运算符" class="headerlink" title="REGEXP运算符"></a>REGEXP运算符</h4><p>REGEXP运算符用来<strong>用正则表达式匹配字符串</strong>，语法格式为：expr REGEXP 匹配条件，如果expr满足匹配条件，返回1；如果不满足，则返回0；若expr或匹配条件任意一个为NULL，则结果为NULL。</p>
<h3 id="结果排序"><a href="#结果排序" class="headerlink" title="结果排序"></a>结果排序</h3><p>如果我们需要对select读取的数据进行<strong>排序</strong>，我们就可以使用 MySQL 的 <strong>ORDER BY</strong> 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">SELECT field1, field2,...fieldN FROM table_name1, table_name2...
ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>你可以使用<strong>任何字段</strong>来作为排序的条件，从而返回排序后的查询结果。</li>
<li>你可以设定<strong>多个字段</strong>来排序。</li>
<li>你可以使用 <strong>ASC（升序） 或 DESC（降序）</strong> 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是<strong>按升序排列</strong>。</li>
<li>你可以添加 <strong>WHERE…LIKE 子句</strong>来设置条件。</li>
</ul>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>GROUP BY 语句根据一个或多个列对结果集进行<strong>分组</strong>。</p>
<p>在分组的列上我们可以使用 <strong>聚集函数</strong>，如果要<strong>对分组结果进行筛选</strong>，必须<strong>使用having</strong>。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">SELECT Major AS 专业, COUNT(StudentID) AS 学生人数
FROM Student
GROUP BY Major;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>当要查询的数据涉及到多个表时，我们可以通过<strong>嵌套查询或者连接</strong>的方式进行多表查询。</p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>在使用 MySQL查询时，当<strong>表名很长或者执行一些特殊查询</strong>的时候，为了<strong>方便操作或者需要多次使用相同的表</strong>时，可以为表指定<strong>别名</strong>，用这个别名代替表原来的名称。需要注意的是，这个新指定的临时别名<strong>不能与数据库中已有的表重名。</strong></p>
<p>格式为：</p>
<blockquote>
<p>&lt;表名&gt; [AS] &lt;别名&gt;</p>
</blockquote>
<p>例如：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">select * from stu as a join stu as b where a.friendid = b.id
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>同样，在使用 SELECT 语句显示查询结果时，MySQL 会显示每个 SELECT 后面指定输出的列，在有些情况下，显示的列名称会<strong>很长或者名称不够直观</strong>，MySQL 可以<strong>指定列的别名</strong>，替换字段或表达式。</p>
<p>格式为：</p>
<blockquote>
<p>&lt;列名&gt; [AS] &lt;列别名&gt;</p>
</blockquote>
<p>例如：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">select count(*) as boy_num from stu where sex = '男'
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="过滤重复数据"><a href="#过滤重复数据" class="headerlink" title="过滤重复数据"></a>过滤重复数据</h3><p>如果你需要读取不重复的数据可以在 SELECT 语句中使用 <strong>DISTINCT 关键字</strong>来过滤重复数据。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">SELECT DISTINCT last_name, first_name FROM person_tbl
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="MySQL-临时表"><a href="#MySQL-临时表" class="headerlink" title="MySQL 临时表"></a>MySQL 临时表</h3><p>MySQL 临时表在我们需要保存一些<strong>临时数据</strong>时是非常有用的。<strong>临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。</strong></p>
<p>临时表在<strong>MySQL 3.23版本</strong>中添加，如果你的MySQL版本低于 3.23版本就无法使用MySQL的临时表。不过现在一般很少有再使用这么低版本的MySQL数据库服务了。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">mysql> CREATE TEMPORARY TABLE SalesSummary (
    -> product_name VARCHAR(50) NOT NULL
    -> , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00
    -> , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00
    -> , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0
);

mysql> INSERT INTO SalesSummary
    -> (product_name, total_sales, avg_unit_price, total_units_sold)
    -> VALUES
    -> ('cucumber', 100.25, 90, 2);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="MySQL复制表"><a href="#MySQL复制表" class="headerlink" title="MySQL复制表"></a>MySQL复制表</h3><p>如果我们需要完全的复制MySQL的数据表，包括表的结构，索引，默认值等。 如果仅仅使用<strong>CREATE TABLE … SELECT</strong> 命令，是无法实现的，<strong>该命令只复制数据</strong>。</p>
<p>我们可以通过先创建相同结构的表，再复制数据的形式进行表复制：</p>
<ul>
<li>使用 <strong>SHOW CREATE TABLE</strong> 命令获取创建数据表(<strong>CREATE TABLE</strong>) 语句，该语句包含了原数据表的结构，索引等。</li>
<li>复制以下命令显示的SQL语句，修改数据表名，并执行SQL语句，通过以上命令 将完全的复制数据表结构。</li>
<li>如果你想复制表的内容，你就可以使用 <strong>INSERT INTO … SELECT</strong> 语句来实现。</li>
</ul>
<p>也可以使用如下方法：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE targetTable LIKE sourceTable;
INSERT INTO targetTable SELECT * FROM sourceTable;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><h3 id="什么是数据库索引"><a href="#什么是数据库索引" class="headerlink" title="什么是数据库索引"></a>什么是数据库索引</h3><p>数据库索引，类似于<strong>书籍的目录</strong>，可以根据目录的某个页码立即找到对应的内容。很多存储数据的情况下都使用了索引结构，比如操作系统逻辑文件系统的索引文件，既保留了顺序文件的空间优点，也保留了直接文件的访问优点。</p>
<p>数据库只做两件事情：存储数据、检索数据。而<strong>索引</strong>是在你存储的数据之外，额外保存一些<strong>路标</strong>（一般是<strong>B+树</strong>），以<strong>减少检索数据的时间</strong>。所以索引是主数据衍生的附加结构。</p>
<p>一个索引是存储的表中<strong>一个或多个特定列的值</strong>数据结构（最常见的是<strong>B+Tree和hash表</strong>）。索引是在表的列上创建。所以，要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中。<strong>请记住记住这一点：索引是一种数据结构 。</strong></p>
<p>索引是一种典型的“<strong>以空间换时间</strong>”的优化方法，类似的方法还有Cache等。</p>
<p>SQL数据库的常用索引有：</p>
<ul>
<li><strong>B+树结构</strong></li>
<li><strong>Hash结构</strong></li>
</ul>
<h3 id="MySQL的数据库存储结构"><a href="#MySQL的数据库存储结构" class="headerlink" title="MySQL的数据库存储结构"></a>MySQL的数据库存储结构</h3><p>MySQL的基本存储结构：<strong>页</strong>，记录都存储在页里面。（类似于操作系统的概念）</p>
<ul>
<li>各个数据页可以组成一个<strong>双向链表</strong>。</li>
<li>每个数据页中的行记录组成<strong>单向链表</strong>。</li>
<li>每个数据页都会为存储在它里边儿的记录生成一个<strong>页目录</strong>，在通过<strong>主键（聚集索引）</strong>查找某条记录的时候可以在页目录中使用<strong>二分法</strong>快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li>
<li>以<strong>其他列</strong>作为搜索条件：只能从最小记录开始<strong>依次遍历</strong>单链表中的每条记录。</li>
</ul>
<p>MySQL的索引存储的是<strong>创建索引的列上的属性值和对应记录所在物理存储位置的指针</strong>。</p>
<h3 id="什么时候使用索引"><a href="#什么时候使用索引" class="headerlink" title="什么时候使用索引"></a>什么时候使用索引</h3><p><strong>频繁查询，很少修改</strong>：一张表可以建立<strong>任意多个索引，</strong>每个索引可以是<strong>任意多个字段</strong>的组合。索引<strong>可能会提高查询速度</strong>（避免全表扫描，如果查询时使用了索引），但<strong>一定会减慢写入速度，并会占用额外的空间</strong>，因为每次写入时都需要更新索引，所以索引只应该加在<strong>经常需要搜索</strong>的列上，不要加在<strong>写多读少</strong>的列上。</p>
<p><strong>中大规模</strong>：索引不应该用于<strong>小规模</strong>的表，当字段用于WHERE子句作为过滤器会<strong>返回表里的大部分记录</strong>时，该字段就不适合设置索引。<strong>小规模的表无需维护索引，直接全表扫描即可。超大规模的表，索引也会失效。</strong></p>
<p>基本原则：</p>
<ul>
<li>在经常用作<strong>过滤器</strong>的字段上建立索引；</li>
<li>在SQL语句中经常进行<strong>GROUP BY、ORDER BY</strong>的字段上建立索引；</li>
<li>在不同值较少的字段上不必要建立索引，如<strong>性别字段</strong>，性别字段无非男女两种值，区分度不好，建立索引效果不好，要选择<strong>区分度高</strong>的字段；</li>
<li>对于<strong>经常存取</strong>的列避免建立索引；</li>
<li>用于<strong>联接</strong>的列（主健/<strong>外健</strong>）上建立索引</li>
</ul>
<h3 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h3><h4 id="聚集索引（主键索引）"><a href="#聚集索引（主键索引）" class="headerlink" title="聚集索引（主键索引）"></a>聚集索引（主键索引）</h4><p>聚集（clustered）索引，也叫聚簇索引。它的定义为：数据行的<strong>物理顺序</strong>与<strong>列值（一般是主键的那一列）的逻辑顺序</strong>相同，一个表中只能拥有<strong>一个</strong>聚集索引。</p>
<p>聚集索引的定义看上去比较抽象，我们可以举个例子：</p>
<blockquote>
<p>一个表就像是我们以前用的新华字典，聚集索引就像是拼音目录，而每个字存放的页码就是我们的数据物理地址，我们如果要查询一个“哇”字，我们只需要查询“哇”字对应在新华字典拼音目录对应的页码，就可以查询到对应的“哇”字所在的位置，而拼音目录对应的A-Z的字顺序，和新华字典实际存储的字的顺序A-Z也是一样的，如果我们中文新出了一个字，拼音开头第一个是B，那么他插入的时候也要按照拼音目录顺序插入到A字的后面</p>
</blockquote>
<p>聚集索引的<strong>可以根据主键的逻辑顺序快速地搜索到对应的记录</strong>。因为如果我们查询id比较靠后的数据，那么这行数据的地址在磁盘中的物理地址也会比较靠后。而且由于物理排列方式与聚集索引的顺序相同，所以也就只能建立一个聚集索引了。</p>
<p>通常来说，聚集索引在<strong>创建表的时候</strong>指定，MySQL默认指定<strong>主键</strong>为一张表的聚集索引。如果在表创建完成后指定聚集索引，那么将会根据指定的列的逻辑顺序调整数据行的物理位置，<strong>非常耗费时间</strong>。所以，<strong>聚集索引也会被叫做主键索引。</strong></p>
<p>定义聚集索引的方式有两种：</p>
<ul>
<li>创建表时直接指定主键，就等于指定聚集索引：</li>
</ul>
<pre class="line-numbers language-mysql"><code class="language-mysql">create table t1(
    id int primary key,
    name nvarchar(255)
)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>创建表后修改主键：</li>
</ul>
<pre class="line-numbers language-mysql"><code class="language-mysql">alter table table_name add primary key(colum_name)
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>MySQL最常用的引擎<strong>InnoDB</strong>中，对于聚集索引的存储是这样的：</p>
<p><img src="InnoDB%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.png" alt="聚集索引"></p>
<p><strong>InnoDB使用B+树存储聚集索引，叶子节点就是对应的数据节点。</strong>正是因为聚集索引逻辑顺序和实际物理顺序一致的特点，所以才能直接用叶子节点存储记录。“聚集”就是<strong>指数据行和相邻的键值紧密地存储在一起</strong>。</p>
<p>而MySQL的MyISAM除外，<strong>此存储引擎的聚集索引和非聚集索引只多了个唯一约束，其他没什么区别</strong>。无论是否为聚集索引，<strong>MyISAM都只在B+树的叶子节点存放指向对应记录物理地址的指针。</strong></p>
<p>所以，在InnoDB中使用聚集索引非常<strong>高效</strong>，因为可以<strong>直接获取</strong>想要记录，而如果使用非聚集索引查询对应的记录，只能获取对应记录的<strong>主键</strong>，还需要<strong>到主键索引B+树中进行二次查询，这一过程也被称作是“回表”。</strong>（PS：InnoDB的非聚集索引叶子结点存放的是对应记录的主键，而MyISAM无论是否聚集索引，存放的都是对应记录的指针）</p>
<h4 id="非聚集索引（非主键索引）"><a href="#非聚集索引（非主键索引）" class="headerlink" title="非聚集索引（非主键索引）"></a>非聚集索引（非主键索引）</h4><p>与聚集索引相反，该索引中索引的<strong>逻辑顺序与磁盘上行的物理存储顺序不同</strong>，一个表中可以拥有<strong>多个</strong>非聚集索引。</p>
<p>按照定义，<strong>除了聚集索引以外的索引都是非聚集索引</strong>，非聚集索引可以细分为：</p>
<ul>
<li>UNIQUE（<strong>唯一索引</strong>）：不可以出现<strong>相同的值</strong>，可以有<strong>NULL值</strong></li>
<li>INDEX（<strong>普通索引</strong>）：允许出现<strong>相同的索引内容</strong></li>
<li>fulltext index（<strong>全文索引</strong>）：可以针对值中的<strong>某个单词</strong>，但<strong>效率不是很好</strong></li>
</ul>
<p>此外，有的博客认为主键索引也可以被当做是一种非聚集索引。我认为，一般来说，主键索引就是聚集索引，不需要强调特殊情况。</p>
<p>非聚集索引就像新华字典的<strong>偏旁字典</strong>，他结构顺序与实际存放顺序不一定一致。</p>
<p>下图是MyISAM中对于非聚集索引的存储，它在B+树的叶子节点中存放了对应记录的<strong>指针</strong>。</p>
<p><img src="%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.png" alt="非聚集索引"></p>
<p>正如我们之前所说的，<strong>非聚集索引在InnoDB引擎的B+树中只会存放所在记录的主键，查询完整的记录需要二次查询主键索引树（回表）。</strong></p>
<p>但是，当需要查询的列位于索引中时，我们可以使用<strong>覆盖索引</strong>而无需回表：</p>
<blockquote>
<p>覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。 如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。当我们通过SQL语句：select key2 from covering_index_sample where key1 = ‘keytest’;的时候，就可以通过覆盖索引查询，无需回表。</p>
</blockquote>
<p>何时使用两类索引，有如下的一张表格：</p>
<p><img src="%E7%B4%A2%E5%BC%95.png" alt="索引"></p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>联合索引，顾名思义，实质上是将<strong>多个字段</strong>建到一个索引里，列值的组合必须<strong>唯一</strong>。</p>
<p>如果我们尝试建立<strong>联合的聚集索引</strong>，那么使用过程中，MySQL会遵循<strong>最左匹配原则</strong>：</p>
<ul>
<li>mysql会一直<strong>向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配</strong>，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立（a,b,c,d）顺序的索引，那么后面的d是用不到索引的，如果建立（a,b,d,c）的索引就可以用到。</li>
<li>上述情况的原因是：B+树按照联合聚集索引的逻辑顺序，将记录在物理空间进行排序，排序时，优先按照前面的列。例如（a,b,c,d）顺序就是先按照 a 列的值，再按照 b 列的值直到 d 列的值。当我们遇到范围查询时，只需要定位到 a = 1 and b = 2 and c = 3的记录位置，然后<strong>在B+树的叶子节点中直接向右遍历</strong>所有c&gt;3的记录，直到b&gt;2为止。这种定位到最左边，然后向右遍历寻找，就是我们所说的<strong>最左前缀原则</strong>。</li>
<li>由于聚集索引的特性，所以可以<strong>较为方便地使用B+树进行范围查询。</strong></li>
<li>根据最左前缀匹配原则，我们创建联合索引时，<strong>多个字段之间顺序应该按照使用频繁的程度放置</strong>，这样可以提升查询效率。</li>
</ul>
<h3 id="索引底层实现"><a href="#索引底层实现" class="headerlink" title="索引底层实现"></a>索引底层实现</h3><h4 id="FULLTEXT索引"><a href="#FULLTEXT索引" class="headerlink" title="FULLTEXT索引"></a>FULLTEXT索引</h4><p><strong>全文索引</strong>，目前只有<strong>MyISAM引擎</strong>支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 <strong>CHAR、VARCHAR ，TEXT</strong> 列上可以创建全文索引。</p>
<p>全文索引并不是和MyISAM一起诞生的，它的出现是为了解决<strong>WHERE name LIKE “%word%”</strong>这类针对文本的模糊查询效率较低的问题。</p>
<h4 id="RTREE索引"><a href="#RTREE索引" class="headerlink" title="RTREE索引"></a>RTREE索引</h4><p>RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。相对于BTREE，<strong>RTREE的优势在于范围查找</strong>。</p>
<h4 id="HASH索引"><a href="#HASH索引" class="headerlink" title="HASH索引"></a>HASH索引</h4><p>由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。</p>
<p>HASH索引可以<strong>一次定位（哈希函数）</strong>，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在<strong>“=”和“in</strong>”条件下高效，对于<strong>范围查询、排序及组合索引</strong>仍然效率不高。</p>
<h4 id="BTREE索引"><a href="#BTREE索引" class="headerlink" title="BTREE索引"></a>BTREE索引</h4><p>BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf（这里指的是B+树，常规B树的键值对存放在每一个节点中）<strong>这是MySQL里默认和最常用的索引类型。</strong></p>
<h3 id="B树简介"><a href="#B树简介" class="headerlink" title="B树简介"></a>B树简介</h3><p>B+树是Mysql顶层最常用的索引数据结构，它是由B树演变而来的。</p>
<p>B树是一种<strong>多路平衡查找树。</strong>与常规的二叉查找树相比，它的优势在于<strong>尽可能少的磁盘 IO，加快了检索速度</strong>：</p>
<ul>
<li>常规的二叉查找树，如：基础二叉查找树、AVL、RBT等，由于都是<strong>二叉</strong>的，也就是每个父节点最多只有两个孩子，所以通常是“<strong>高瘦</strong>”的，也就是<strong>层数较多</strong>。但我们知道，数据库中的数据大都存放在外存上。磁盘IO的一个特性是<strong>按照磁盘块进行IO</strong>，所以即使是访问一个节点，也需要<strong>读取一个完整的磁盘块。</strong>如果我们使用高瘦的二叉查找树，那么访问的层数较多，读取的磁盘块数目也较多，降低了时间效率。相反，B树的每个内部节点能够指向多个孩子节点，它的搜索过程是：<strong>从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的孩子结点；重复，直到所对应的孩子指针为空，或已经是叶子结点。</strong></li>
<li>由于每一层的节点数增多，所以查找树的高度降低，也就是说<strong>平均每一次搜索需要读取的节点数减少，</strong>从而让<strong>磁盘IO次数减少</strong>，降低了时间消耗。（B树是“<strong>矮胖</strong>”的）</li>
<li>在数据较小，可以完全放到内存中时，RBT的时间复杂度比B树低（<strong>RBT是二叉的，直接根据当前节点值和目标值的大小关系即可决定进入哪个子树，而B-TREE是多叉的，在每一个节点内部需要进行二分查找，才能决定进入哪个子树</strong>）。反之，数据量较大，<strong>外存中占主要部分</strong>时，B树因其读磁盘次数少，<strong>而具有更快的速度。</strong></li>
</ul>
<p>下面是一个存储了 16 个数据的 二叉查找树，同样每个节点最多存储 2 个 key，查询 id=16 这个数据需要查询比较 4 个节点，也就是经过 4 次磁盘 IO：</p>
<p><img src="%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png" alt="二叉查找树"></p>
<p>考虑到磁盘 IO 读同一块上的1个数据和读 100 个数据都需要读取完整的磁盘块，消耗的时间基本一致，那我们的优化思路就可以改为：<strong>尽可能在一次磁盘 IO 中多读一点数据到内存</strong>。这个直接反映到树的结构就是，每个节点能存储的 key 可以适当增加。我们可以使用一个6阶的B树进行检索，只需要进行 2 次磁盘 IO.</p>
<p><img src="B%E6%A0%911.png" alt="B树"></p>
<p>B树的特点是：</p>
<ul>
<li>关键字集合分布在整个树中；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束；</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找；</li>
<li>自动层次控制；</li>
</ul>
<p>它的定义为：</p>
<ul>
<li>每个节点最多有m-1个<strong>关键字</strong>（可以存有的键值对）。</li>
<li>根节点最少可以只有1个<strong>关键字</strong>。</li>
<li>非根节点至少有m/2个<strong>关键字</strong>。</li>
<li>每个节点中的关键字都按照<strong>从小到大的顺序</strong>排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。（<strong>方便二分查找</strong>）</li>
<li>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。（<strong>完全二叉树</strong>）</li>
<li><strong>每个节点都存有索引和数据，也就是对应的key和value。（B树和B+树最大的区别）</strong></li>
</ul>
<p><img src="B%E6%A0%91.png" alt="B树"></p>
<h3 id="B-树简介"><a href="#B-树简介" class="headerlink" title="B+树简介"></a>B+树简介</h3><p>上面介绍了B树的优势，实际上，我们可以对B树进行进一步改进，使其更适合数据库索引的需求。</p>
<p>与B树相比，B+树的特点在于：</p>
<ul>
<li><strong>B 树的非叶子节点里既存索引也存数据，而 B+只存索引（地址）</strong>，所以 B 树里非叶子节点存不了很多个键值对，但是 B+树一个非叶子节点能存很多索引，<strong>B+树将所有的数据存放在叶子节点中</strong>。</li>
<li><strong>B+树的叶子节点用了一个链表串联起来，便于范围查找</strong>。</li>
</ul>
<p><img src="B+%E6%A0%91.png" alt="B+树"></p>
<p>由于上述特点，B+树存在着以下的优势： </p>
<ul>
<li>在<strong>单个节点存储容量有限</strong>的情况下，B+树的内部节点也能<strong>存储大量索引，</strong>使得整个 B+树高度<strong>进一步降低</strong>，<strong>进一步减少了磁盘 IO</strong>。</li>
<li>B+树的叶子节点是真正数据存储的地方，叶子节点<strong>用了链表连接起来</strong>，这个链表本身就是有序的，<strong>在数据范围查找</strong>时，更具备效率。（<strong>InnoDB的B+树聚集索引的范围查找优势原因，最左前缀匹配原则的原理</strong>）</li>
<li>B+树的<strong>查询效率更加稳定</strong> 。由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。 所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ul>
<h4 id="为什么不使用哈希索引"><a href="#为什么不使用哈希索引" class="headerlink" title="为什么不使用哈希索引"></a>为什么不使用哈希索引</h4><ul>
<li>哈希索引适合<strong>等值查询</strong>，可以直接使用哈希函数运算找到记录。但是<strong>无法进行范围查询</strong> 。</li>
<li>哈希索引没办法利用索引<strong>完成排序</strong>。</li>
<li>哈希索引不支持多列联合索引的<strong>最左匹配规则</strong> 。</li>
<li>如果有大量重复键值得情况下，哈希索引的效率<strong>会很低</strong>，因为存在<strong>哈希碰撞问题</strong>。</li>
</ul>
<h2 id="MySQL引擎InnoDB和MyISAM对比"><a href="#MySQL引擎InnoDB和MyISAM对比" class="headerlink" title="MySQL引擎InnoDB和MyISAM对比"></a>MySQL引擎InnoDB和MyISAM对比</h2><h3 id="索引区别"><a href="#索引区别" class="headerlink" title="索引区别"></a>索引区别</h3><p>在MySQL最常用的两类引擎InnoDB、MyISAM中都使用了B+树作为默认的索引数据结构。但我们之前说过，他们在底层的实现方法略有不同，这里再总结一下：</p>
<ul>
<li><p>InnoDB对于聚集索引，B+树的叶子节点会存放对应Key的<strong>完整记录</strong>，访问时可以直接获取所有的列，十分方便。但对于非聚集索引，B+树的叶子结点只存放对应Key的记录的<strong>主键</strong>，如果需要访问完整的记录，必须进行<strong>回表</strong>，依据主键<strong>二次访问</strong>聚集索引树。</p>
<ul>
<li>之所以只在非聚集索引中存放主键，是因为防止数据冗余，减少空间浪费。<strong>在牺牲较少查询的性能下节省了巨大的磁盘空间。</strong></li>
</ul>
<p><img src="InnoDB%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.png" alt="InnoDB索引"></p>
</li>
<li><p>MyISAM对于非聚集索引和聚集索引，无一例外都只在叶子节点中存放<strong>指向对应记录物理位置的指针</strong>，所以如果根据<strong>非聚集索引</strong>访问记录，<strong>MyISAM将会比InnoDB耗时更短</strong>，因为它只需要一次访问，直接找到物理地址后就可以直接定位到数据记录。但是很明显，MyISAM的<strong>插入删除数据性能更差</strong>。我们如果要在InnoDB中添加数据，只需要修改B+树的叶子结点（<strong>链接存储</strong>），但如果要在MyISAM中添加数据，需要移动磁盘上很多条记录（<strong>顺序存储</strong>）。</p>
<p><img src="MyISAM%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.png" alt="MyISAM索引"></p>
</li>
</ul>
<h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><ul>
<li>若数据库平台<strong>读多写少</strong>，可以选择MyISAM引擎，如<strong>博客系统、学习网站</strong>等；</li>
<li>若数据库平台<strong>更新操作（增删改）较多</strong>，则选择InnoDB，如<strong>信息管理系统</strong>等。</li>
</ul>
<h3 id="完整区别"><a href="#完整区别" class="headerlink" title="完整区别"></a>完整区别</h3><ul>
<li><strong>InnoDB支持事务，MyISAM不支持</strong>，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li>
<li><strong>InnoDB支持外键，而MyISAM不支持</strong>。对一个包含外键的InnoDB表转为MYISAM会失败</li>
<li>InnoDB使用B+Tree作为索引结构，<strong>数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构）</strong>，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，<strong>主键不应该过大，因为主键太大，其他索引也都会很大</strong>。而MyISAM也是使用B+Tree作为索引结构，<strong>索引和数据文件是分离的，索引保存的是数据文件的指针</strong>。**主键索引和辅助索引是独立的。</li>
<li><strong>InnoDB不保存表的具体行数</strong>，执行select count(*) from table时需要全表扫描。<strong>而MyISAM用一个变量保存了整个表的行数</strong>，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）</li>
<li><strong>MyISAM表格可以被压缩后进行查询操作</strong></li>
<li><strong>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁</strong></li>
<li><strong>InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有</strong></li>
</ul>
<p>如何选择：</p>
<ul>
<li><strong>是否要支持事务</strong>，如果要请选择innodb，如果不需要可以考虑MyISAM</li>
<li>如果表中绝大多数都只是<strong>读查询</strong>，可以考虑MyISAM，如果<strong>既有读也有写</strong>，请使用InnoDB</li>
<li><strong>系统崩溃后，MyISAM恢复起来更困难，能否接受；</strong></li>
<li><strong>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎</strong>，建议使用InnoDB</li>
</ul>
<h3 id="InnoDB的四大特性"><a href="#InnoDB的四大特性" class="headerlink" title="InnoDB的四大特性"></a>InnoDB的四大特性</h3><ul>
<li><strong>插入缓冲</strong>（insert buffer）</li>
<li><strong>二次写</strong>（double write）</li>
<li><strong>自适应哈希索引</strong>（ahi）</li>
<li><strong>预读</strong>（read ahead）</li>
</ul>
<h3 id="自增ID（-AUTO-INCREMENT）"><a href="#自增ID（-AUTO-INCREMENT）" class="headerlink" title="自增ID（ AUTO_INCREMENT）"></a>自增ID（ AUTO_INCREMENT）</h3><p>InnoDB推荐使用<strong>自增ID</strong>作为主键，自增ID可以保证每次插入时B+索引是从<strong>右边</strong>扩展的，可以避免B+树和频繁<strong>合并和分裂</strong>（对比使用UUID）。如果使用<strong>字符串主键和随机主键</strong>，会使得数据<strong>随机插入</strong>，<strong>效率比较差</strong>。</p>
<h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>事务是一个<strong>不可分割</strong>的数据库操作序列，也是数据库<strong>并发控制的基本单位</strong>，其执行的结果必须使数据库从<strong>一种一致性状态变到另一种一致性状态</strong>（<strong>事务的一致性</strong>）。事务是逻辑上的一组操作，<strong>要么都执行，要么都不执行</strong>。</p>
<p>有一个经典的例子就是转账，比如小明要给小方转100块钱，如果成功了，那么小明的账户余额信息和小方的账户余额信息都需要更新；但是如果转账过程中突然银行系统崩溃，导致小明的余额少了，小方的余额却不变，这就不对了。<strong>事务就是保证这两个关键操作要么都成功，要么都要失败。</strong></p>
<p>一个完整的业务需要批量的DML（数据库管理语言，如insert、update、delete）语句共同联合完成</p>
<h3 id="事务的四大特性ACID"><a href="#事务的四大特性ACID" class="headerlink" title="事务的四大特性ACID"></a>事务的四大特性ACID</h3><ul>
<li><strong>Atomicity原子性</strong>：事务中包括的所有操作<strong>要么都做，要么都不做</strong>。<ul>
<li>实现事务的原子性，要支持<strong>回滚操作</strong>，在某个操作失败后，回滚到<strong>事务执行之前</strong>的状态。需要使用<strong>undolog回滚日志</strong>实现。</li>
</ul>
</li>
<li><strong>Consistency一致性</strong>：事务必须使数据库<strong>从一个一致性状态变到另一个一致性状态。</strong>（例如上面的银行转账例子，<strong>总钱数在事务执行前后发生了变化</strong>，说明事务完成后，不符合逻辑运算，状态不一致了）其实也就是说：保证事务只能把数据库从<strong>一个有效（正确）的状态“转移”到另一个有效（正确）的状态</strong>，什么是正确的状态，其实<strong>是用户自己指定的</strong>，所以说一致性其实是一个<strong>用户层</strong>的概念。<ul>
<li>事务的一致性决定了一个<strong>系统设计和实现的复杂</strong>度，也导致了<strong>事务的不同隔离级别</strong>。</li>
<li><strong>一致性是事务的最终目的，原子性、隔离性、持久性都是为了实现一致性。</strong>（AID是为了C）</li>
</ul>
</li>
<li><strong>隔离性 Isolation</strong>：隔离性是指多个事务<strong>并发执行</strong>的时候，事务内部的操作与其他事务是隔离的，<strong>并发执行的各个事务之间不能互相干扰</strong>。</li>
<li><strong>duration持久性</strong>：根据定义，持久性是指事务<strong>一旦提交</strong>，它对数据库的改变就应该是<strong>永久性</strong>的。接下来的其他操作或故障不应该对其有任何影响。<ul>
<li>事务的持久性是<strong>通过redo log恢复日志实现的</strong>。Mysql是先把磁盘上的数据<strong>加载到内存</strong>中，在内存中对数据进行修改，再<strong>刷回磁盘</strong>上。如果此时突然宕机，内存中的数据就会丢失。为了防止上述故障造成数据不一致，我们使用<strong>redo log日志记录下每一条数据库修改操作</strong>，从而保证数据库宕机重启的时候能够选择是否将数据恢复。</li>
</ul>
</li>
</ul>
<h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p>我们在前面已经介绍了两种日志：</p>
<ul>
<li><p><strong>undolog</strong> 记录某<strong>数据被修改前的值</strong>。类似于Word中的<strong>撤销</strong>操作，<strong>用于事务的回滚，为了保证原子性。</strong></p>
</li>
<li><p><strong>redolog</strong> 记录某 <strong>数据块</strong> 被修改 <strong>后</strong> 的值，可以用来恢复未写入 data file 的已成功事务更新的数据。类似于Word中的<strong>恢复</strong>操作。<strong>用于事务的重做，为了保证持久性。</strong></p>
</li>
<li><p>redolog和undolog是<strong>InnoDB事务机制中的日志</strong>，与MySQL级别的日志不同（如binlog）：</p>
<ul>
<li>redo/undo 是 innodb 引擎层维护的。而 binlog 是 mysql server 层维护的，跟采用何种引擎没有关系，记录的是<strong>所有引擎的更新操作的日志记录</strong>。</li>
<li>redo/undo 记录的是 <strong>每个页/每个数据 的修改情况</strong>，属于<strong>物理日志+逻辑日志结合</strong>的方式（<strong>redo log 是物理日志，undo log 是逻辑日志</strong>）。binlog 记录的都是事务操作内容，属于<strong>逻辑日志</strong>。<ul>
<li>redo log通常是<strong>物理日志</strong>，记录的是<strong>数据页的物理修改</strong>，而不是某一行或某几行修改成怎样怎样，它用来<strong>恢复提交后的物理数据页</strong>（恢复数据页，且只能恢复到最后一次提交的位置)）。</li>
</ul>
</li>
<li>undo用来回滚行记录到某个版本。undo log一般是<strong>逻辑日志</strong>，<strong>符合SQL的逻辑特性，根据每行记录进行记录</strong>。</li>
<li>redo/undo 在 <strong>事务执行过程中</strong> 会不断的写入，而 binlog 是在 <strong>事务最终提交前</strong> 写入的。binlog 什么时候刷新到磁盘跟参数 <code>sync_binlog</code> 相关</li>
</ul>
</li>
</ul>
<p>事务日志的详细内容可以参考：<a href="https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html</a></p>
<h3 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h3><p>我们知道，数据库显然是一个常常需要<strong>高并发</strong>的场景，例如：<strong>淘宝网的秒杀活动</strong>，需要支持多个用户购买后同时修改商品的库存量，如果数据库不支持并行，只支持串行，那么同一时刻只能有一个用户进行购买，这将导致用户的阻塞，显然是不好。</p>
<p>所以，我们需要让数据库使用并发技术。但是，我们知道，并发技术往往会带来<strong>数据的不一致性</strong>的问题，这点在多线程、多进程编程中是非常常见。</p>
<p>并发事务不加以控制可能导致的问题主要有：</p>
<ul>
<li><strong>脏读(Drity Read）</strong>：某个事务读取的数据正在被另一个<strong>未提交事务</strong>所处理，而另一个事务可能会<strong>回滚</strong>，导致该事务读取的数据是<strong>错误</strong>的。</li>
<li><strong>不可重复读</strong>：在<strong>同一个事务</strong>内，读取数据后，该数据被<strong>另一个事务</strong>所修改，导致<strong>无法重现</strong>前一次读取结果。</li>
<li><strong>丢失修改</strong>：多个事务读入<strong>同一个数据</strong>并修改，一个事务的修改结果被另一个事务的提交所<strong>覆盖</strong>。</li>
<li><strong>幻读</strong>：<strong>同一事务</strong>两次读取之间，其他事务<strong>插入或删除</strong>一条数据。例如：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>
</ul>
<p>幻读和不可重复读很容易混淆，实际上，<strong>幻读侧重于数据的增添和删除，而不可重复读侧重于数据的修改</strong>。</p>
<p><strong>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</strong>。</p>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>考虑到上述的并发事务问题，最简单粗暴的解决方案是让所有事务都串行化处理，不允许并发。这将导致数据库的效率大大降低。为了<strong>平衡数据库的效率和隔离性Isolation</strong>，我们提出了几种事务的隔离级别，也就是<strong>并发事务之间相互影响的程度。</strong></p>
<p>隔离级别<strong>从低到高</strong>：</p>
<ul>
<li><strong>READ Uncommitted未提交读</strong>：事务中的修改，即使<strong>未提交</strong>，对其他事务也都<strong>是可见</strong>的；本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也会导致<strong>脏读（Dirty Read）</strong>。</li>
<li><strong>Read Committed提交读</strong>：一个事务<strong>从开始直到提交之前</strong>，所做的任何修改对其他事务都是<strong>不可见</strong>的；<strong>大多数数据</strong>库默认采用此级别；也就是说：<strong>一个事务只能看见已经提交事务所做的改变</strong>。但是，该级别未解决<strong>不可重复读</strong>的问题，因为同一事务的多次读数据之间，别的事务对该数据的修改也可能进行提交，导致数据不一致。</li>
<li><strong>Repeatable Read可重复读</strong>（<strong>MYSQL默认</strong>)：解决了<strong>脏读问题和不可重复读问题</strong>；该级别保证了在<strong>同一事务中多次读取同样记录的结果是一致的</strong>；<strong>MySQL默认为此级别；</strong>但是，此级别<strong>没有解决幻读问题</strong>，如果其它事务插入或者删除了记录。（MySQL的InnoDB引擎使用<strong>快照读的机制</strong>使得可重复读隔离级别也解决了幻读）</li>
<li><strong>Serializable可串行化</strong>：<strong>最高</strong>的隔离级别。该级别会在读取的<strong>每一行数据</strong>上都加锁，导致大量的<strong>超时和锁争用</strong>的问题。但用的比较少，只有在<strong>非常需要确保数据的一致性而且可以接受没有并发</strong>的情况下，才考虑此级别。它解决了<strong>幻读问题</strong>。</li>
</ul>
<p>√: 可能出现  ×: 不会出现</p>
<table>
<thead>
<tr>
<th></th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommitted</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable read</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p><strong>我们需要平衡数据库的安全性和效率，选择当前场景最优的事务隔离级别。</strong></p>
<p>MySQL默认：<strong>可重复读Repeatable read</strong>。</p>
<h2 id="MySQL锁机制"><a href="#MySQL锁机制" class="headerlink" title="MySQL锁机制"></a>MySQL锁机制</h2><h3 id="锁的概念"><a href="#锁的概念" class="headerlink" title="锁的概念"></a>锁的概念</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。锁保证数据并发访问的一致性、有效性；锁冲突也是影响数据库并发访问性能的一个重要因素。<strong>锁是Mysql在服务器层和存储引擎层的的并发控制</strong>。</p>
<p>加锁是<strong>消耗资源</strong>的，锁的各种操作，包括<strong>获得锁、检测锁是否是否已解除、释放锁</strong>等。</p>
<h3 id="Latch和Lock"><a href="#Latch和Lock" class="headerlink" title="Latch和Lock"></a>Latch和Lock</h3><p>有两种锁，一种是<strong>Latch闩锁（轻量级的锁）</strong>，它要求锁定的时间非常短，若持续时间长，则其应用性能会很差（<strong>有点类似于OS中的自旋锁，会忙等</strong>）。在InnoDB引擎中，Latch分为<strong>rwlock（读写锁）和mutex（互斥锁）</strong>，其目的是用来保证<strong>并发线程操作临界资源的正确性</strong>，并且通常<strong>没有死锁检测的机制</strong>。</p>
<p>还有一种是<strong>Lock</strong>，它的对象是<strong>事务</strong>，用来<strong>锁定数据库中的对象</strong>，如<strong>表、页、行</strong>。并且lock的对象<strong>commit或rollback后进行释放</strong>（不同事物隔离级别释放的时间可能不同）。</p>
<p>在MySQL中的引擎中主要是<strong>Lock</strong>。</p>
<h3 id="按照粒度划分锁"><a href="#按照粒度划分锁" class="headerlink" title="按照粒度划分锁"></a>按照粒度划分锁</h3><p>Lock锁根据粒度主要分为<strong>表锁、行锁、页锁</strong>，不同的存储引擎拥有的锁粒度都不同。</p>
<ol>
<li><p><strong>表锁</strong>：表级锁就是一次会将<strong>整个表</strong>进行锁定，是个存储引擎中最大颗粒度的锁机制；它的特点是<strong>实现逻辑简单，资源消耗较少，获取锁和释放锁的速度很快，很好的解决了死锁问题</strong>。使用表锁的主要是<strong>MyISAM、MEMORY，CSV</strong>等一些<strong>非事务性存储引擎</strong>。但是，它<strong>发生锁冲突的概率最高，并发度最低。</strong></p>
<ol>
<li>表级锁更适合于<strong>以查询为主，并发用户少，只有少量按索引条件更新数据的应用</strong>，如Web 应用</li>
</ol>
</li>
<li><p><strong>行锁</strong>：MySQL中<strong>锁定粒度最小</strong>的锁机制，特点是<strong>发生锁定资源争用的概率小，能给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能</strong>，但<strong>资源消耗较大，且可能会产生死锁</strong>。使用行锁的主要是<strong>InnoDB引擎</strong>。</p>
<ol>
<li>行级锁更适合于有<strong>大量按索引条件并发更新少量不同数据，同时又有并发查询的应用</strong>，如一些在线事务处理（OLTP）系统.</li>
</ol>
</li>
<li><p><strong>页锁</strong>：它的锁定颗粒度介于<strong>表锁和行锁之间</strong>，它的并发能力与资源开销也是<strong>介于两者之间</strong>，另外，它与行锁一样，<strong>会发生死锁</strong>。使用页锁的主要是<strong>BerkeleyDB存储引擎</strong>。</p>
</li>
</ol>
<p>默认情况下，<strong>表锁和行锁都是自动获得的， 不需要额外的命令</strong>。</p>
<p>但是在有的情况下， 用户需要明确地<strong>进行锁表或者进行事务的控制</strong>， 以便确保<strong>整个事务的完整性</strong>，这样就需要使用<strong>事务控制和锁定语句</strong>来完成。</p>
<h3 id="按照共享性划分锁"><a href="#按照共享性划分锁" class="headerlink" title="按照共享性划分锁"></a>按照共享性划分锁</h3><p>从类别上锁分为：<strong>共享锁（S Lock）和排它锁（X Lock）</strong>。</p>
<p><strong>共享锁</strong>: 又叫做<strong>读锁</strong>。 当用户要<strong>进行数据的读取</strong>时，对数据加上<strong>共享锁</strong>。共享锁可以<strong>同时加上多个</strong>。加了共享锁的数据对象<strong>可以被其他事务读取，但不能修改。</strong></p>
<p><strong>排他锁</strong>: 又叫做<strong>写锁</strong>。 当用户要<strong>进行数据的写入</strong>时，对数据加上<strong>排他锁</strong>。排他锁<strong>只可以加一个</strong>，他和其他的<strong>排他锁，共享锁都相斥</strong>。</p>
<p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的<strong>意向锁（Intention Locks）</strong>，这两种意向锁都是<strong>表锁</strong>：</p>
<ul>
<li><strong>意向共享锁（IS）</strong>：事务打算给数据行加<strong>行共享锁</strong>，事务在给一个数据行加共享锁前必须先取得<strong>该表的 IS 锁。</strong></li>
<li><strong>意向排他锁（IX）</strong>：事务打算给数据行加<strong>行排他锁，</strong>事务在给一个数据行加排他锁前必须先取得<strong>该表的 IX 锁。</strong></li>
</ul>
<p>InnoDB引擎的表意向锁之间<strong>互相兼容。</strong></p>
<p><img src="InnoDB%E9%94%81%E6%A8%A1%E5%BC%8F.png" alt="InnoDB锁模式"></p>
<h3 id="InnoDB加锁机制"><a href="#InnoDB加锁机制" class="headerlink" title="InnoDB加锁机制"></a>InnoDB加锁机制</h3><p><strong>隐式加锁</strong>：</p>
<ul>
<li>首先，意向锁是 InnoDB 在行锁之前<strong>自动加</strong>的， 不需用户干预。</li>
<li>对于 UPDATE、 DELETE 和 INSERT 语句（<strong>写操作</strong>）， InnoDB会<strong>自动</strong>给涉及数据集加<strong>排他锁（X)</strong></li>
<li>对于普通 SELECT 语句，<strong>InnoDB 不会加任何锁</strong></li>
</ul>
<p><strong>显式加锁</strong>：</p>
<ul>
<li><p>事务可以通过以下语句<strong>显式</strong>给记录集加共享锁或排他锁：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">select ... lock in share mode //共享锁 
select ... for update //排他锁 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ul>
<p><strong>性能影响</strong>：</p>
<ul>
<li>select for update 语句，相当于一个 update 语句。在业务繁忙的情况下，<strong>如果事务没有及时的commit或者rollback 可能会造成其他事务长时间的等待，从而影响数据库的并发使用效率。</strong></li>
<li>select lock in share mode 语句是一个给查找的数据上一个共享锁（S 锁）的功能，它允许其他的事务也对该数据上S锁，但是<strong>不能够允许对该数据进行修改</strong>。<strong>如果不及时的commit 或者rollback 也可能会造成大量的事务等待。</strong></li>
</ul>
<h3 id="InnoDB行锁的实现"><a href="#InnoDB行锁的实现" class="headerlink" title="InnoDB行锁的实现"></a>InnoDB行锁的实现</h3><p>虽然<strong>InnoDB默认使用行锁</strong>，但是InnoDB 行锁是通过给<strong>索引上的索引项加锁</strong>来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：<strong>只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</strong></p>
<pre class="line-numbers language-mysql"><code class="language-mysql">select * from tab_with_index where id = 1 for update
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>如果上述id列不是索引键，那么InnoDB只能创建表锁，并发性将大打折扣。</strong></p>
<p>MySQL InnoDB支持三种行锁定方式：</p>
<ul>
<li><strong>行锁（Record Lock）</strong>:锁直接加在<strong>索引记录</strong>上面，<strong>锁住的是key。</strong></li>
<li><strong>间隙锁（Gap Lock）</strong>:锁定<strong>索引记录间隙</strong>，<strong>确保索引记录的间隙不变</strong>。间隙锁是针对事务隔离级别为<strong>可重复读以上级别</strong>而言的。目的：<strong>gap lock的机制主要是解决可重复读模式下的幻读问题</strong></li>
<li><strong>Next-Key Lock</strong> ：<strong>行锁和间隙锁</strong>组合起来就叫Next-Key Lock；InnoDB对于<strong>行的查询</strong>都是采用这种锁定算法，既锁定间隙和锁定行。</li>
</ul>
<h3 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h3><p>InnoDB在事务执行过程中，使用<strong>两阶段锁协议</strong>：</p>
<ul>
<li><strong>随时都可以执行锁定</strong>，InnoDB会根据隔离级别在需要的时候自动加锁；</li>
<li>锁只有在执行<strong>commit或者rollback</strong>的时候才会释放，并且所有的锁都是在<strong>同一时刻</strong>被释放。</li>
</ul>
<p>两阶段锁协议将一个事务分为两阶段。第一阶段为<strong>加锁阶段</strong>，只可以申请锁，当释放的一个锁后进入<strong>解锁阶段</strong>，只可以释放锁。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p> 指<strong>多个事务在执行过程中因为争夺锁资源而产生的相互等待现象。</strong></p>
<p>死锁的原因：</p>
<ul>
<li><strong>真正的数据冲突</strong>；</li>
<li><strong>存储引擎的实现方式</strong>。</li>
</ul>
<p><strong>检测死锁：</strong>数据库系统实现了各种<strong>死锁检测和死锁超时</strong>的机制。InnoDB存储引擎能检测到死锁的循环依赖并<strong>立即返回一个错误</strong>。</p>
<p><strong>死锁恢复：</strong>死锁发生以后，只有<strong>部分或完全回滚其中一个事务</strong>，才能打破死锁，InnoDB目前处理死锁的方法是，将持有<strong>最少行级排他锁的事务进行回滚</strong>。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p>
<p><strong>外部锁的死锁检测：</strong>发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置<strong>锁等待超时参数 innodb_lock_wait_timeout 来解决</strong>（<strong>外部死锁不通过死锁检测，而是死锁超时机制控制</strong>）</p>
<p><strong>死锁影响性能：</strong>死锁会影响性能而不是会产生严重错误，<strong>因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务</strong>。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，<strong>禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，</strong>这时可以依赖innodb_lock_wait_timeout设置进行事务回滚。（等待时间超过限制，就进行事务回滚，实现简单，开销小）</p>
<h3 id="优化锁的性能"><a href="#优化锁的性能" class="headerlink" title="优化锁的性能"></a>优化锁的性能</h3><ul>
<li>尽量使用<strong>较低的隔离级别</strong>；</li>
<li><strong>精心设计索引</strong>， 并尽量<strong>使用索引访问数据</strong>， 使加锁更精确， 从而减少锁冲突的机会</li>
<li>选择<strong>合理的事务大小</strong>，小事务发生锁冲突的几率也更小</li>
<li>给记录集显示加锁时，最好<strong>一次性请求足够级别的锁</strong>。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁</li>
<li>不同的程序访问一组表时，应尽量<strong>约定以相同的顺序访问各表</strong>，对一个表而言，尽可能<strong>以固定的顺序存取表中的行</strong>。这样可以大大减少死锁的机会</li>
<li>尽量用<strong>相等条件</strong>访问数据，这样可以避免<strong>间隙锁对并发插入的影响</strong></li>
<li>不要申请<strong>超过实际需要的锁级别</strong></li>
<li>除非必须，<strong>查询时不要显式加锁</strong>。 MySQL的<strong>MVCC（多版本并发控制机制）</strong>可以实现事务中的查询不用加锁，优化事务性能；MVCC只在COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作</li>
<li>对于一些特定的事务，可以使用<strong>表锁</strong>来提高处理速度或减少死锁的可能</li>
</ul>
<h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><h4 id="乐观锁（不加锁，直到提交时再检查是否有“写-写”冲突）"><a href="#乐观锁（不加锁，直到提交时再检查是否有“写-写”冲突）" class="headerlink" title="乐观锁（不加锁，直到提交时再检查是否有“写-写”冲突）"></a>乐观锁（不加锁，直到提交时再检查是否有“写-写”冲突）</h4><p><strong>乐观锁（Optimistic Lock）</strong>：从名字上看，就是很乐观，每次去<strong>拿数据的时候认为别人不会改，所以不会上锁</strong>，但是在<strong>提交更新的时候会判断一下在此期间别人有没有去更新数据</strong>，乐观也严谨。乐观锁适用于<strong>读多写少</strong>的场景，这样可以提高<strong>吞吐量</strong>。乐观锁总是假设<strong>不会发生并发冲突</strong>，只在提交操作时检查是否<strong>违反数据完整性（覆盖写）</strong>。</p>
<p>乐观锁通过使用<strong>数据版本（Version）记录机制（最常用）和时间戳（timestamp）</strong>来实现。确保<strong>事务提交之前，所读取的数据没有被更新。</strong></p>
<p><strong>数据版本机制</strong>：是通过为数据库表增加一个数字类型“version”字段来实现。当读取数据时，将version字段的值一同读出，数据没更新一次，version值加1.当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，<strong>如果数据库表当前版本号与第一次取出来的version值相等，则予以更新</strong>，否则认为是过期数据。</p>
<p><strong>时间戳机制</strong>：时间戳的方式与前者实现方式差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是<strong>在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比</strong>，如果一致则OK，否则就是版本冲突。</p>
<h4 id="悲观锁（操作之前先加锁，避免一切冲突）"><a href="#悲观锁（操作之前先加锁，避免一切冲突）" class="headerlink" title="悲观锁（操作之前先加锁，避免一切冲突）"></a>悲观锁（操作之前先加锁，避免一切冲突）</h4><p><strong>悲观锁（Pessimistic Lock）</strong>：就是比较悲观，每次去<strong>拿数据的时候都认为别人会修改</strong>，所以<strong>每次拿数据的时候都会对数据上锁</strong>，这样别人想拿这个数据的时候就会先block，然后获得锁之后再对数据进行操作。总的来说就是<strong>悲观锁总是假定会发生并发冲突，然后屏蔽一切可能违反数据完整性的操作。</strong></p>
<p>悲观锁大多数情况下依靠<strong>数据库的锁机制</strong>实现，例如使用Select … for update语句，以<strong>保证操作最大程度的独占性</strong>。但如果采用悲观锁，则整个操作过程中，<strong>数据库始终处于加锁状态</strong>（从操作员读出数据、开始修改直至提交修改结果的全过程，甚至还包括操作员中途去煮咖啡的时间），而面对成百上千万的并发，就会导致灾难性的后果，因此采用悲观锁进行控制时要考虑清楚。</p>
<h3 id="MVCC机制（无锁并发控制，基于快照）"><a href="#MVCC机制（无锁并发控制，基于快照）" class="headerlink" title="MVCC机制（无锁并发控制，基于快照）"></a>MVCC机制（无锁并发控制，基于快照）</h3><p>多版本并发控制（MVCC）是一种用来<strong>解决读-写冲突</strong>的<strong>无锁并发控制</strong>，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读<strong>该事务开始前的数据库的快照</strong>（<strong>快照读</strong>）。 这样在<strong>读操作不用阻塞写操作，写操作不用阻塞读操作</strong>的同时，避免了<strong>脏读和不可重复读。</strong></p>
<p>MVCC机制只能应用在<strong>RC和RR两种事务隔离级别</strong>下，由于使用了<strong>快照读</strong>机制，读取的内容始终是<strong>事务开始前的数据库快照</strong>，所以其它事务的修改和回滚对它没有影响，解决了<strong>脏读和不可重复读。</strong></p>
<h2 id="MySQL视图机制"><a href="#MySQL视图机制" class="headerlink" title="MySQL视图机制"></a>MySQL视图机制</h2><h3 id="什么是视图"><a href="#什么是视图" class="headerlink" title="什么是视图"></a>什么是视图</h3><p><strong>视图（View）</strong>是从<strong>一个或多个基本表（或视图）导出的表</strong>，它与基本表不同，是一个<strong>虚表</strong>，数据库中只存放<strong>视图的定义</strong>，而<strong>不存放视图对应的数据</strong>；当基本表中的数据发生变化，从视图中查询出的数据也就随之改变；</p>
<ul>
<li><strong>单表视图</strong>：一般用于<strong>查询和修改</strong>，会<strong>改变</strong>基本表的数据；</li>
<li><strong>多表视图</strong>：一般用于<strong>查询</strong>，<strong>不会改变</strong>基本表的数据。</li>
</ul>
<h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><p>1.视图能够<strong>简化</strong>用户的操作；</p>
<p>2.视图使用户能以<strong>多种角度</strong>看待同一数据；</p>
<p>3.视图对重构数据库提供了一定程度的<strong>逻辑独立性</strong>；</p>
<p>4.视图能够对机密数据提供<strong>安全</strong>保护；</p>
<p>具体到实际应用中，视图的优点有：</p>
<ul>
<li><strong>提高了重用性，就像一个函数</strong>。如果需要频繁获取特定的数据集，只需要创建对应的视图即可。（对应上述第二点）</li>
<li><strong>对数据库重构，却不影响程序的运行</strong>。对于删除的表，可以创建一个对应的视图，保证程序中读取它不会出错。（对应上述第三点）</li>
<li><strong>提高了安全性能。可以对不同的用户，设定不同的视图。</strong>（对应上述第四点）</li>
</ul>
<p>当需要多次重复输入相同的语句、需要不同的表字段聚合，进行信息重组、安全需要或需要兼容老的表等情况，就可以利用视图来<strong>简化sql查询，提高开发效率</strong>。</p>
<p>不过事物皆有两面性，视图也存在它的缺点：</p>
<ul>
<li><strong>视图的性能差</strong>，数据库必须<strong>把视图查询转化成对基本表的查询（视图不存放数据，只存定义）</strong>，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也要把它变成一个复杂的结合体，需要花费一定的时间。</li>
<li><strong>视图也存在着修改限制</strong>，当用户试图修改视图的某些信息时，数据库必须<strong>把它转化为对基本表的某些信息的修改</strong>，对于简单的视图来说，这是很方便的，但是，对于比较复杂的试图，<strong>可能是不可修改的</strong>。</li>
</ul>
<h2 id="MySQL存储过程"><a href="#MySQL存储过程" class="headerlink" title="MySQL存储过程"></a>MySQL存储过程</h2><p><strong>MySQL 5.0 版本</strong>开始支持存储过程。</p>
<p>存储过程是用户定义的一系列<strong>SQL语句的集合</strong>，<strong>涉及特定表或其他对象</strong>（表、视图、索引、序列、目录、同义词、数据库用户、存储过程、函数、触发器等）的任务，用户可以<strong>调用存储过程进行对表或其他对象的操作。</strong></p>
<p>存储过程思想上很简单，就是<strong>数据库 SQL 语言层面的代码封装与重用。</strong></p>
<p>存储过程定义的一个实例（需要使用<strong>execute调用</strong>）：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">mysql> delimiter $$　　#将语句的结束符号从分号;临时改为两个$$(可以是自定义)
mysql> CREATE PROCEDURE delete_matches(IN p_playerno INTEGER)
    -> BEGIN
    -> 　　DELETE FROM MATCHES
    ->    WHERE playerno = p_playerno;
    -> END$$
Query OK, 0 rows affected (0.01 sec)

mysql> delimiter;　　#将语句的结束符号恢复为分号
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>存储过程<strong>可封装</strong>，并隐藏<strong>复杂的商业逻辑</strong>。</li>
<li>存储过程可以<strong>回传值</strong>，并可以<strong>接受参数</strong>。</li>
<li>存储过程<strong>无法使用 SELECT 指令</strong>来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。</li>
<li>存储过程可以用在<strong>数据检验，强制实行商业逻辑</strong>等。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>存储过程，往往定制化于<strong>特定的数据库</strong>上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要<strong>重写原有的存储过程。</strong></li>
<li>存储过程的性能调校与撰写，<strong>受限于各种数据库系统。</strong></li>
</ul>
<h3 id="存储过程和MySQL函数的区别"><a href="#存储过程和MySQL函数的区别" class="headerlink" title="存储过程和MySQL函数的区别"></a>存储过程和MySQL函数的区别</h3><ul>
<li>存储过程<strong>涉及表或者其他对象</strong>，而函数通常<strong>不涉及特定的用户表。</strong></li>
<li>存储过程<strong>功能复杂强大</strong>，可以执行包括<strong>修改表</strong>等一系列数据库操作；而函数实现的功能<strong>针对性比较强；</strong></li>
<li>对于存储过程来说可以<strong>返回参数</strong>，如记录集，而函数只能<strong>返回值或者表对象</strong>。</li>
<li>函数只能返回<strong>一个变量</strong>；而存储过程可以<strong>返回多个</strong>。</li>
<li>存储过程的参数可以有<strong>IN,OUT,INOUT三种类型</strong>，而函数只能有<strong>IN类</strong>；<ul>
<li><strong>IN 输入参数</strong>：表示调用者向过程<strong>传入值</strong>（<strong>传入值可以是字面量或变量</strong>）</li>
<li><strong>OUT 输出参数</strong>：表示过程向调用者<strong>传出值</strong>(可以返回多个值)（<strong>传出值只能是变量</strong>）</li>
<li><strong>INOUT 输入输出参数</strong>：既表示<strong>调用者向过程传入值，又表示过程向调用者传出值</strong>（<strong>值只能是变量</strong>）</li>
</ul>
</li>
<li>存储过程可以使用<strong>非确定函数</strong>，而不允许用户在函数定义<strong>非确定函数</strong>；</li>
<li>存储过程一般作为一个<strong>独立的部分</strong>来执行（<strong>EXECUTE语句执行</strong>），而函数可以作为<strong>查询语句的一部分</strong>来调用（<strong>SELECT调用</strong>）；</li>
</ul>
<h2 id="MySQL触发器"><a href="#MySQL触发器" class="headerlink" title="MySQL触发器"></a>MySQL触发器</h2><p>例如在数据库中有两个表，一个用户信息表，一个账号表，账号表用来账号的注册，密码的修改等操作，信息表用来保存用户 的信息（姓名、年龄等）；当账号在账号表中注册成功后，如何在用户表中同时添加用户的相关信息以保证数据的准确性和实时性呢。通常我们在注册成功时可以insert用户的信息到用户信息表中，但如果用户数量过多，SQL语句则过于繁琐，怎么办。这时我们就可以使用触发器。</p>
<p><strong>触发器（trigger）是一种特殊的存储过程</strong>，它可以在对一个表上<strong>进行INSERT、UPDATE和DELETE操作中的任一种或几种操作时被自动调用执行</strong>。它SQL server 提供给程序员和数据分析员来保证<strong>数据完整性</strong>的一种方法。</p>
<p>当需要<strong>实现多个表的级联更改或实时监控表中字段的更改作出处理时</strong>就可以使用触发器来完成。</p>
<h3 id="MySQL中都有哪些触发器"><a href="#MySQL中都有哪些触发器" class="headerlink" title="MySQL中都有哪些触发器"></a>MySQL中都有哪些触发器</h3><p>Before Insert、After Insert、Before Update、After Update、Before Delete、After Delete</p>
<h2 id="MySQL数据库优化"><a href="#MySQL数据库优化" class="headerlink" title="MySQL数据库优化"></a>MySQL数据库优化</h2><p>随着系统规模的不断增加，数据量和并发量不断增大，整个系统架构中最先受到冲击而形成瓶颈的，定然是数据库，数据库中数据存储的位置（<strong>磁盘而非内存</strong>），数据量的大以及系统的吞吐量都影响了数据的访问速度和读写速度，因此数据库层面的优化也显得尤为重要。</p>
<h3 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h3><ul>
<li>当只有一行数据时使用<strong>limit 1</strong>。查询时如果已知<strong>只会得到一条数据</strong>，则加上limit 1会<strong>提高效率</strong>。因为mysql数据库引擎会在找到一条结果后停止搜索，而不是继续查询下一条或直至所有记录查询完毕。</li>
<li><strong>选择正确的数据库引擎</strong>。MySQL中都MyISAM和InnoDB都各有利弊，因此选择正确的引擎很重要。MyISAM适用于<strong>读多写少</strong>的应用，而且它对于<strong>select count(*)类似操作（会使用专门变量存放记录数目）</strong>速度非常快；InnoDB是一个复杂的存储引擎，它在<strong>写多的应用中</strong>占优势，并且它支持很多<strong>高级应用（事务等）</strong>。</li>
<li><strong>用not exists代替not in。</strong>Not exists用到了连接，能够发挥<strong>已经建立好的索引的作用</strong>，not in<strong>不能使用索引</strong>。Not in是最慢的方式<strong>要同每条记录比较</strong>，在数据量比较大的操作中不建议使用这种方式。</li>
<li>对操作符的优化，尽量<strong>不采用不利于索引的操作符</strong>。如：<strong>in、not in、is null、is not null、&lt;&gt; 等</strong></li>
<li><strong>选取最适用的字段属性</strong>。例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。</li>
<li><strong>使用连接（JOIN）来代替子查询(Sub-Queries)</strong>。连接（JOIN）之所以更有效率一些，是因为MySQL不需要<strong>在内存中创建临时表</strong>来完成这个逻辑上的需要两个步骤的查询工作。</li>
<li><strong>使用联合(UNION)来代替手动创建的临时表</strong>。</li>
<li><strong>多使用事务，它具有ACID特性</strong>。尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。</li>
<li><strong>创建索引。</strong>对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。</li>
<li><strong>复合索引。</strong>比如有一条语句是这样的：select * from users where area=’beijing’ and age=22;<br>如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age, salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。</li>
<li><strong>索引不会包含有NULL值的列。</strong>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</li>
<li><strong>使用短索引。</strong>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</li>
<li><strong>排序的索引问题。</strong>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</li>
<li><strong>like语句操作。</strong>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。</li>
<li><strong>不要在列上进行运算。</strong>select <em> from users where YEAR(adddate)&lt;2007;将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成select </em> from users where adddate&lt;‘2007-01-01’;</li>
<li><strong>不使用NOT IN和&lt;&gt;操作。</strong>NOT IN和&lt;&gt;操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替，id&lt;&gt;3则可使用id&gt;3 or id&lt;3来代替。</li>
</ul>
<h3 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h3><ul>
<li><strong>将字段很多的表分解成多个表</strong>。因为字段很多的表中存在一些使用频率低的字段，这些字段的存在就会大大影响访问速度；</li>
<li><strong>增加一些中间表</strong>。对于需要经常联合多个表进行查询时，可以建立一个中间表，将需要通过联合查询的数据插入到中间表，来提高效率；</li>
<li><strong>读写分离</strong>。在数据库并发大的情况下，最好的做法就是进行横向扩展，增加机器，以提升抗并发能力，而且还兼有数据备份功能。</li>
</ul>
<h2 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h2><p>所谓SQL注入，就是通过<strong>把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串</strong>，最终达到<strong>欺骗服务器执行恶意的SQL命令</strong>。</p>
<p>我们永远不要信任用户的输入，我们必须认定用户输入的数据都是不安全的，我们都需要对用户输入的数据进行过滤处理。</p>
<p>防止SQL注入，我们需要注意以下几个要点：</p>
<ul>
<li><strong>永远不要信任用户的输入</strong>。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双”-“进行转换等。</li>
<li><strong>永远不要使用动态拼装sql</strong>，可以使用<strong>参数化的sql或者直接使用存储过程进行数据查询存取</strong>。</li>
<li>永远不要使用<strong>管理员权限</strong>的数据库连接，<strong>为每个应用使用单独的权限有限的数据库连接</strong>。</li>
<li><strong>不要把机密信息直接存放</strong>，加密或者hash掉密码和敏感的信息。</li>
<li><strong>应用的异常信息应该给出尽可能少的提示</strong>，最好使用自定义的错误信息对原始错误信息进行包装</li>
<li>sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。</li>
</ul>
<p>一个mysql注入攻击的例子：在用户名输入框中输入:’ or 1=1#,密码随便输入.</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">select * from users where username='' or 1=1#' and password=md5('') 
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>语义分析：“#”在mysql中是注释符，这样井号后面的内容将被mysql视为注释内容，这样就不会去执行了，导致黑客会成功登陆网站。</p>

            </div>
            <hr />

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《数据库复习——基于MySQL》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2020/05/29/shu-ju-ku-fu-xi-ji-yu-mysql/" property="cc:attributionName"
               rel="cc:attributionURL">
                HillZhang
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: 'uCuovwWUzxnygDdXy6SPs97E-gzGzoHsz',
        appKey: 'oroAoITTPFXepwWrR1qGq7b7',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '欢迎和我一起交流！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/05/29/linux-wang-luo-pei-zhi-gong-ju/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="Linux网络配置工具">
                        
                        <span class="card-title">Linux网络配置工具</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Linux网络配置与网络工具Linux网络简介Linux的网络支持Linux支持各种协议类型的网络：

TCP/IP、NetBIOS/NetBEUI、IPX/SPX、AppleTake等
在网络底层也支持Ethernet、Token Rin
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2020-05-29
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux/" class="post-category" target="_blank">
                                    Linux
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Linux/" target="_blank">
                        <span class="chip bg-color">Linux</span>
                    </a>
                    
                    <a href="/tags/操作系统/" target="_blank">
                        <span class="chip bg-color">操作系统</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/05/29/shu-ju-jie-gou-fu-xi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="数据结构复习">
                        
                        <span class="card-title">数据结构复习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2020-05-29
                            </span>
                        <span class="publish-author">
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: HillZhang的博客<br />'
            + '作者: HillZhang<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2019-2020 章岳. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">291.1k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/HillZhang1999" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:471791641@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>





    <a href="http://wpa.qq.com/msgrd?v=3&uin=471791641&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>





    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 80000;
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2020, 03, 11, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    

    <!-- 雪花特效 -->
    

</body>

</html>