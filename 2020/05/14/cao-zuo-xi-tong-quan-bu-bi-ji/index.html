<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="操作系统全部笔记, 章岳 学习笔记 计算机 算法 程序">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="操作系统笔记本文是我在学习操作系统过程中的总结与笔记。
操作系统基本知识操作系统简介操作系统是管理计算机硬件的程序，它为应用程序提供基础，并且充当计算机用户和计算机硬件的中介（可以看做是一种资源分配器）
它的具体定义为：

操作系统是一直运">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>操作系统全部笔记 | HillZhang的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">HillZhang的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">HillZhang的博客</div>
        <div class="logo-desc">
            
            苏州大学 | 计算机科学与技术学院 | 软件工程
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/5.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        操作系统全部笔记
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/操作系统/" target="_blank">
                            <span class="chip bg-color">操作系统</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/操作系统/" class="post-category" target="_blank">
                            操作系统
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-05-14
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    HillZhang
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    30.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    104 分
                </div>
                
                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="操作系统笔记"><a href="#操作系统笔记" class="headerlink" title="操作系统笔记"></a>操作系统笔记</h1><p>本文是我在学习操作系统过程中的总结与笔记。</p>
<h2 id="操作系统基本知识"><a href="#操作系统基本知识" class="headerlink" title="操作系统基本知识"></a>操作系统基本知识</h2><h3 id="操作系统简介"><a href="#操作系统简介" class="headerlink" title="操作系统简介"></a>操作系统简介</h3><p>操作系统是<strong>管理计算机硬件</strong>的程序，它为<strong>应用程序</strong>提供基础，并且充当<strong>计算机用户和计算机硬件</strong>的中介（可以看做是一种<strong>资源分配器</strong>）</p>
<p>它的具体定义为：</p>
<blockquote>
<p>操作系统是<strong>一直运行在计算机上</strong>的程序（通常称为<strong>内核</strong>，kernel，<strong>常驻于内存</strong>）， 除了内核部分外，还有其他两类程序，分别是<strong>系统程序</strong>（与系统运行有关的程序，如某些驱动程序）和<strong>应用程序</strong>（与系统运行无关的程序，如 QQ 等） </p>
</blockquote>
<p>下图为计算机系统组件的抽象层次结构：</p>
<p><img src="%E6%8A%BD%E8%B1%A1%E5%B1%82%E6%AC%A1.png" alt="计算机系统组件抽象层次结构"></p>
<p>可以看到，从底层到顶层依次为：</p>
<p>计算机硬件——&gt;<strong>操作系统-</strong>——&gt;系统程序和应用程序——–&gt;用户</p>
<p>所以操作系统是计算机硬件和用户的媒介，是应用程序和系统程序的基础。</p>
<h3 id="操作系统设计目的"><a href="#操作系统设计目的" class="headerlink" title="操作系统设计目的"></a>操作系统设计目的</h3><p>操作系统的设计目的主要分为：</p>
<ul>
<li>核心目标：<strong>运行用户程序</strong></li>
<li>面向用户：<strong>方便性</strong></li>
<li>面向系统：<strong>高效性</strong></li>
</ul>
<p>需要注意的是，不同操作系统具有不同的设计目的，例如：</p>
<ul>
<li>PC用户：关注方便性、易用性、高性能，而不关注资源利用率。</li>
<li>主机用户：关注资源利用率，因为要同时满足所有用户需求。</li>
<li>工作站用户：性能和资源利用率折中。</li>
<li>手持设备用户：方便、续航时间。</li>
<li>……</li>
</ul>
<h3 id="现代计算机系统的组成"><a href="#现代计算机系统的组成" class="headerlink" title="现代计算机系统的组成"></a>现代计算机系统的组成</h3><p>现代计算机系统由以下几个主要部分组成：</p>
<ul>
<li>一个或多个中央处理器<strong>CPU</strong></li>
<li>若干个<strong>设备控制器</strong>（如磁盘控制器，图形适配器，USB控制器等）</li>
<li><strong>总线</strong></li>
</ul>
<p>多个设备控制器可以<strong>并行工作</strong>，竞争访问内存，需要<strong>内存控制器</strong>的协调。</p>
<p>每个设备控制器都有一个<strong>缓冲</strong>（Buffering)，用于：</p>
<ul>
<li>解决设备间传输速度的不匹配</li>
<li>减少中断频率</li>
<li>提高并行性</li>
</ul>
<p>CPU在<strong>内存和本地缓冲</strong>之间传输数据，I/O控制器从<strong>设备和本地缓冲</strong>之间传输数据。I/O控制器可以通过<strong>调用中断</strong>通知CPU完成了操作。</p>
<p>操作系统是<strong>中断驱动</strong>的。</p>
<h3 id="现代计算机系统的体系结构"><a href="#现代计算机系统的体系结构" class="headerlink" title="现代计算机系统的体系结构"></a>现代计算机系统的体系结构</h3><ul>
<li><p><strong>单</strong>处理器系统：只有<strong>一个</strong>通用CPU。</p>
</li>
<li><p><strong>多</strong>处理器系统：也叫多核系统或者并行系统，有<strong>两个或多个CPU</strong>紧密通信，共享计算机总线、时间、内设和外存。是<strong>紧耦合</strong>的，只有<strong>一个</strong>独立系统。</p>
<ul>
<li>优点：<ul>
<li>增加<strong>吞吐量</strong>。</li>
<li><strong>规模经济</strong>。</li>
<li>增加<strong>可靠性</strong>。（一台电脑多个CPU，肯定比多台单CPU电脑要便宜，且更可靠）</li>
</ul>
</li>
<li>类型：<ul>
<li><strong>ASMP非对称处理</strong>：CPU具有主从关系，主处理器用户协调各从处理器。</li>
<li><strong>SMP对称处理</strong>：所有CPU参与操作系统的全部任务</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>集群</strong>系统：也是一种类型的多处理器系统，但是它是通过将<strong>多个</strong>独立的计算机系统通过<strong>网络</strong>相连接，进行<strong>并行计算</strong>，从而提高处理性能。它是<strong>松耦合</strong>的。</p>
<p>（集群系统和多处理器系统的区别）</p>
</li>
</ul>
<h3 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h3><ul>
<li><p>批处理系统：</p>
<ul>
<li><p>单道程序系统：内存中同时只能驻留<strong>一个</strong>外部应用程序，当进程需要进行I/O操作，CPU一直进入等待状态，<strong>CPU利用率低</strong>。</p>
</li>
<li><p>多道程序系统：内存中同时存在<strong>多道</strong>作业，通过管理程序控制<strong>穿插运行</strong>（CPU调度），使得 CPU 总有一个执行作业，从而<strong>提高 CPU 利用率</strong>。</p>
<blockquote>
<p>操作系统先将作业（进程）保存在磁盘上的<strong>作业池</strong>中，内存中的作业集为磁盘上的作业集的<strong>子集</strong>。操作系统从内存的作业集中选择一个执行。对于单道程序系统，当CPU执行到某个作业的某些任务，例如I/O操作时，需要使CPU进入等待状态，等待该任务的执行完成，从而陷入空闲的状态。而多道程序系统会自动在等待时切换到另一个作业，使CPU始终有作业在执行。</p>
</blockquote>
<p>（这里是<strong>并发作业</strong>，而非并行作业！并行指的是多处理器系统）</p>
<p>（单道程序系统和多道程序系统都属于：批处理系统，缺点是<strong>缺少交互性</strong>）</p>
</li>
</ul>
</li>
<li><p><strong>分时系统</strong>：分时系统是多道程序设计的自然延伸。采用<strong>时间片轮转（RR）</strong>的方式同时为<strong>多个用户</strong>服务，经常用于<strong>服务器</strong>。一种<strong>联机的多用户交互式的操作系统</strong>。每个用户获得一个时间片并运行，保证用户获得足够小的响应时间，并提供<strong>交互能力</strong>。若某个作业在分配的时间片用完之前计算还未完成，该作业就暂时中断，等待下一轮;此时，处理机让给另一个作业使用。每个用户好象实时独占一台计算机。（由于时间片小，但其实只是用户的错觉，并不是实时独占的）切换频率很高（响应时间小于 1s）。</p>
<p>​    （Unix就是一种著名的分时系统，所以服务器上经常使用Unix系统。）</p>
</li>
</ul>
<h3 id="并发VS并行"><a href="#并发VS并行" class="headerlink" title="并发VS并行"></a>并发VS并行</h3><p>并发：<strong>多个作业</strong>在<strong>同一时间间隔</strong>内在<strong>同一处理器</strong>上<strong>交替</strong>运行。常见于<strong>多道程序设计</strong>。</p>
<p>并行：<strong>多个作业</strong>在<strong>同一时刻</strong>在<strong>不同处理器</strong>上<strong>同时</strong>运行，常见于<strong>多处理器系统</strong>。</p>
<h3 id="操作系统的主要操作和功能"><a href="#操作系统的主要操作和功能" class="headerlink" title="操作系统的主要操作和功能"></a>操作系统的主要操作和功能</h3><p>操作系统的主要操作有：</p>
<ul>
<li>双模式</li>
<li>I/O和内存保护</li>
<li>定时器</li>
</ul>
<p>操作系统的主要功能有：</p>
<ul>
<li>进程管理</li>
<li>内存管理</li>
<li>文件管理</li>
<li>I/O系统管理</li>
</ul>
<h4 id="双模式"><a href="#双模式" class="headerlink" title="双模式"></a>双模式</h4><p>双模式将操作系统的运行模式分为了两种模式，使用<strong>模式位</strong>来控制：</p>
<ul>
<li><strong>用户模式</strong>（用户态）：执行用户代码。</li>
<li><strong>内核模式</strong>（核心态）：执行系统代码。</li>
</ul>
<p>双模式的作用是<strong>确保操作系统正确运行</strong>，区分系统代码和用户代码的执行，防止操作系统受到错误应用程序的损害而崩溃。</p>
<p>双模式最主要的用处是<strong>将特权指令放在内核模式下运行</strong>，从而保证了内核的安全。</p>
<p>特权指令是：<strong>可能引起损害的机器指令</strong>，如：I/O操作、定时器管理、中断管理等。</p>
<p>常用的使用特权指令的方法为：<strong>系统调用（System Call）</strong>。一般视为<strong>软件中断</strong>，是操作系统封装好的方法。从用户模式切换至内核模式（陷阱模式位=0），执行完特权指令后再从内核模式返回至用户模式（返回模式位=1）（2 次切换） </p>
<p><img src="%E5%8F%8C%E6%A8%A1%E5%BC%8F.png" alt="系统调用"></p>
<p>系统调用是一种软件中断，提供操作系统服务<strong>编程接口</strong>，只能在<strong>核心态</strong>运行。这些调用通常以 C 或 C++编写， 如果是底层任务通常以汇编语言指令编写。主要包括：进程控制、 文件管理、设备管理、信息维护、通信、保护。（java 系统调用在不同的操作系统中不用改变指令，是因为它采用了 JVM 技术） </p>
<p>常见的系统调用API有：</p>
<ul>
<li>Windows的<strong>Win32 API</strong></li>
<li>POSIX系统（包括所有版本的Unix、Linux、Mac os）的<strong>POSIX API</strong></li>
<li>JVM的<strong>Java API</strong></li>
</ul>
<h4 id="I-O保护"><a href="#I-O保护" class="headerlink" title="I/O保护"></a>I/O保护</h4><p>目的：防止用户程序执行非法I/O。</p>
<p>做法：将所有I/O指令设置为特权指令，只能通过系统调用在核心态运行。</p>
<h4 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h4><p>目的：防止内存非法访问。</p>
<p>做法：存储保护机制、硬件支持。</p>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>目的：防止用户程序进入死循环，或者不执行系统调用且不将控制权返还给操作系统。</p>
<p>做法：使用固定速率的时钟或者计数器实现，在指定周期后中断计算机。</p>
<h3 id="操作系统的主要服务"><a href="#操作系统的主要服务" class="headerlink" title="操作系统的主要服务"></a>操作系统的主要服务</h3><p>操作系统的服务：（两类） ：</p>
<ul>
<li><p>用户功能服务（基本服务）： </p>
<ul>
<li>用户界面 （第一个GUI系统：<strong>Xerox Alto</strong>)</li>
<li>I/O 操作 </li>
<li>文件系统操作 </li>
<li>通信 </li>
<li>错误检测 </li>
</ul>
</li>
<li><p>操作系统服务（增值服务）：  </p>
<ul>
<li>资源分配 </li>
<li>记账 </li>
<li>保护与安全c） </li>
</ul>
</li>
<li><p>服务形式： </p>
<ul>
<li>系统调用(System Call) </li>
<li>用户接口(User Interface) </li>
<li>系统程序(System Program)</li>
</ul>
</li>
</ul>
<h3 id="操作系统主要的设计思想"><a href="#操作系统主要的设计思想" class="headerlink" title="操作系统主要的设计思想"></a>操作系统主要的设计思想</h3><ul>
<li><p>简单结构：</p>
<ul>
<li><strong>MS-DOS</strong>是最早的操作系统，采用了简单结构，没有很好的区分接口和层次，导致很容易崩溃。</li>
<li>单片结构：操作系统由<strong>内核和系统程序</strong>两个独立的部分组成，<strong>系统调用接口和内核通信</strong>开销较小，UNIX、LINUX、Windows操作系统中都有采用。</li>
</ul>
</li>
<li><p>分层结构：</p>
<ul>
<li>操作系统划分为<strong>若干层</strong>，每层只使用更底层的功能和服务，最底层为硬件层，最高层为用户层，类似于计算机网络OSI分层体系。</li>
<li>好处是<strong>简化了系统的设计与实现，便于调试和升级维护</strong>。</li>
<li>缺点是<strong>效率较差</strong>。</li>
<li>MAC OS X 中有采用，THE系统有采用。</li>
</ul>
</li>
<li><p>微内核：</p>
<ul>
<li>将<strong>不必要的功能</strong>从内核中移除，将其作为系统级和用户级的程序实现。内核只提供<strong>最小的进程、内存管理和通信等功能</strong>。</li>
<li>好处是便于扩充微内核，便于移植操作系统到新架构系统上，更稳定（更少的代码运行在核心态），更安全。</li>
<li>缺点是<strong>通信开销增加</strong>，性能受损。（微内核采用<strong>消息传递机制</strong>进行缓解）</li>
<li>Mac OS X中使用了Mach微内核、QNX采用，WindowsNT及后续版本采用。</li>
</ul>
</li>
<li><p>模块化：</p>
<ul>
<li>采用<strong>可加载的模块</strong>，内核只提供核心服务，其他服务采用<strong>模块链接</strong>的方式实现。</li>
<li>优点：<ul>
<li>类似于分层系统，其中每个内核部分都有接口。但它更加<strong>灵活</strong>，因为每个内核模块都可以调用其他模块，而非只能上层模块调用下层模块。</li>
<li>利用<strong>动态链接</strong>服务，优于直接添加服务至内核中，不需要重新编译内核。</li>
<li>类似于微内核系统，内核只提供核心服务，并知道如何加载模块以及如何让模块进行通信。但更为有效，无需利用消息传递来进行通信，而是<strong>直接动态加载模块。</strong> </li>
</ul>
</li>
<li>Solaris系统、现代Unix和Windows中都采用了模块化思想。</li>
</ul>
</li>
<li><p>混合结构：</p>
<ul>
<li>实际上，几乎所有操作系统都使用了混合的设计结构。例如：Linux 和 Solaris 既采用单片结构，也采用模 块化。Windows 采用了单片、模块化、微内核等。</li>
</ul>
</li>
</ul>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>虚拟机是：通过<strong>软件模拟</strong>实现，具有<strong>完整硬件系统功能</strong>，运行在一个<strong>完全隔离的环境</strong>中的完整计算机系统。</p>
<p>常见的虚拟机有以下几类：</p>
<ul>
<li><strong>高级语言虚拟机</strong>：提供高级语言执行的<strong>环境</strong>，用于<strong>跨平台</strong>。常见的有：JVM（java虚拟机）。</li>
<li><strong>工作站虚拟机</strong>：用于工作站或者PC机上，实现了<strong>一个宿主操作系统上可以运行多个客户操作系统</strong>。也是我们通常所说的“虚拟机”。</li>
<li><strong>服务器虚拟机</strong>：用在服务器上，实现了多用户、多操作系统并存，将<strong>一个物理服务器虚拟化为多个服务器。</strong></li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h3><ul>
<li><strong>作业</strong>：被组装成一个整体的一组计算步骤，既可以指进程，也可以指线程。</li>
<li><strong>任务</strong>：Linux中不区分线程和进程，统一称为任务（jobs）。</li>
<li><strong>进程</strong>：一个程序在一个数据集上的一次运行，是<strong>执行的程序</strong>，是程序的<strong>实例</strong>。它包括：<ul>
<li>代码</li>
<li>当前活动：<ul>
<li><strong>程序计数器</strong>：指向当前要执行的指令地址</li>
<li><strong>栈</strong>：存放函数参数、临时变量等临时数据</li>
<li><strong>堆</strong>：动态分配内存</li>
<li><strong>数据</strong>：全局变量、要处理的文件等</li>
</ul>
</li>
</ul>
</li>
<li><strong>程序</strong>：是进程的代码部分。</li>
</ul>
<p>进程与程序的区别在于：</p>
<ul>
<li>程序是<strong>被动实体</strong>，存放在<strong>外存</strong>上，是<strong>静止</strong>的。</li>
<li>进程是<strong>活动实体</strong>，存放在<strong>内存</strong>中，是<strong>活动</strong>的，具有程序计数器和一组相关资源。</li>
</ul>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>进程的<strong>五状态图</strong>（非常重要）：</p>
<p><img src="%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="进程状态"></p>
<p>进程主要有以下五种状态：</p>
<ul>
<li><strong>新建</strong>（new）：进程正在被创建，位于<strong>外存</strong>上。</li>
<li><strong>就绪</strong>（ready）：进程<strong>等待分配CPU</strong>。主要有三种转移：<ul>
<li>新建到就绪：操作系统将被创建好的进程调入<strong>内存</strong>中（<strong>长程调度</strong>）（admitted)</li>
<li>运行到就绪：进程被<strong>中断</strong>（interrupt）</li>
<li>等待到就绪：进程等待的I/O操作或者事件被完成</li>
</ul>
</li>
<li><strong>运行</strong>（running）：进程正在CPU上执行。主要由就绪态的进程，通过操作系统的进程调度，分配处理器并执行。</li>
<li><strong>等待</strong>（waiting）：进程等待I/O或事件的完成。</li>
<li><strong>终止</strong>（terminated）：进程结束执行。</li>
</ul>
<h3 id="进程数据结构"><a href="#进程数据结构" class="headerlink" title="进程数据结构"></a>进程数据结构</h3><p><strong>进程控制块</strong>：操作系统中的进程表示方式采用PCB，即进程控制块。进程的所有信息存放在进程控制块中，每个进程都有一个进程控制块。<strong>Linux中，使用进程创建原语创建进程，本质上就是为一个进程创建PCB。</strong>Linux使用<strong>task_struct的双向链表</strong>表示进程控制块。可用于<strong>进程上下文切换的保存现场和恢复现场</strong>。</p>
<p><img src="PCB" alt="PCB中的信息"></p>
<p><strong>进程环境块</strong>：PEB，位于<strong>用户空间</strong>中，存放进程的运行环境。</p>
<h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>进程上下文切换指<strong>切换 CPU 到另一个进程需要保存当前进程状态和恢复另一个进程的状态</strong>。</p>
<ul>
<li>中断导致 CPU 从执行当前任务改变到执行内核程序。进程上下文切换采用进程 PCB 表示。先通过执行状态保存，保存 CPU 当前状态（包括内核模式和用户模式）之后，状态恢复重新开始运行。</li>
<li>速度与硬件支持密切相关。</li>
<li>单任务操作系统不需要进行进程上下文切换，因为只有一个进程。</li>
</ul>
<h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>进程在运行过程中可以创建多个进程，创建进程为父进程，被创建的进程为子进程：</p>
<ul>
<li>子进程和父进程的进程标识符PID不一样。<strong>每个进程的PID唯一</strong>。</li>
<li>资源可能：<strong>子进程的资源可以直接获得，也可以是父进程的子集。</strong>限定子进程只分配父进程的资源子集，可以防止创建过多进程而导致系统超载。</li>
<li>执行可能：子进程可以与父进程<strong>并发执行</strong>，也可以让父进程<strong>等待</strong>子进程执行完毕，再将其资源释放（<strong>wait函数</strong>）。</li>
<li>地址空间可能：<ul>
<li>子进程是父进程的复制品。（类UNIX操作系统）</li>
<li>子进程加载另一个新程序。（Windows）</li>
</ul>
</li>
</ul>
<p>Linux中与进程创建相关的函数有：</p>
<ul>
<li>fork函数：类UNIX系统采用<strong>fork函数</strong>创建子进程，fork函数创建的子进程的地址空间完全是父进程的共享。但类UNIX系统支持<strong>写时拷贝（COW）</strong>，即：起初父子进程除了PID不同，其余大部分资源都是由父进程共享给子进程的。<strong>而当子进程想要修改地址空间时，操作系统会分配新的地址空间给它。</strong><ul>
<li>fork函数一次调用，两次返回：<ul>
<li>在父进程中返回的值为子进程的PID</li>
<li>在子进程中返回的值为0</li>
<li>创建子进程失败则为-1</li>
</ul>
</li>
</ul>
</li>
<li>vfork函数：使用vfork函数创建子进程，子进程的资源完全共享自父进程的资源，<strong>修改子进程的地址空间，会使父进程的地址空间也发生改变。</strong></li>
<li>wait函数：wait函数一般用在父进程中，用于<strong>等待子进程执行完成</strong>。当子进程执行完毕后，会调用系统调用<strong>exit函数</strong>请求系统删除自身的相关资源。此时父进程的wait函数可以接收到其状态值的返回，并<strong>将子进程在PCB表中的条目完全释放</strong>。</li>
<li>abort函数：父进程可以使用abort函数<strong>终止</strong>子进程的执行。</li>
</ul>
<p>三种资源拷贝方式：</p>
<ul>
<li>共享：共享同一资源，如虚存空间、文件等。仅增加有关描述符的用户计数器。类似于Python中的引用。</li>
<li>直接拷贝：相同的结构，原样复制。类似于Python中的深拷贝。</li>
<li>写时复制COW：一开始引用，在需要的时候才深拷贝。</li>
</ul>
<h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>当进程执行完最后的语句并且通过<strong>系统调用 exit函数</strong>请求操作系统删除自身时， 即为<strong>进程终止</strong>。此时，利用父进程的系统调用 wait函数可以接收到其状态值的返回。</p>
<ul>
<li><strong>级联终止</strong>：有些系统中，一旦父进程终止，所有子进程都要被终止。</li>
<li><strong>僵尸进程</strong>：一个子进程在终止后，会调用exit函数释放自己占用的资源。<strong>但它在PCB表中的条目依然还是存在的，这需要父进程使用wait函数将其释放</strong>。如果一个子进程结束后，其父进程没有及时调用wait函数释放它在PCB表中的条目，在这段时间里，子进程处于僵尸进程状态。子进程需要等待父进程终止后，<strong>被跟进程init收管并释放</strong>。<ul>
<li><strong>僵尸进程的父进程必然是存在的</strong>，否则它将变为孤儿进程。所以解决僵尸进程的办法是<strong>杀死它的父进程。</strong></li>
<li>由于僵尸进程在PCB中占用了大量条目，所以如果大量的产生僵尸进程，将因为没有<strong>可用的进程号</strong>而导致系统不能产生新的进程 。</li>
</ul>
</li>
<li><strong>孤儿进程</strong>：如果子进程还在执行时，父进程已经提前终止了，那么此时子进程处于孤儿进程状态。Linux系统会自动将孤儿进程收养为跟进程init的子进程，并由它定时释放孤儿进程。</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>如果一个进程与其他进程不能相互影响，则它是独立的；反之它是协作的。协作的目的主要有：<strong>信息共享、计算加速、模块化、方便</strong>。协作进程需要有一种进程间通信机制（IPC），以<strong>允许进程相互交换数据与信息</strong>。</p>
<p>进程通信的主要方式有：</p>
<ul>
<li><p><strong>共享内存</strong>：利用<strong>通信进程</strong>创建<strong>共享内存区域</strong>，由其他想要进行通信的进程将其附加到自己的逻辑内存空间。需要进行<strong>访问控制</strong>，通常与<strong>信号量</strong>搭配使用。（一般用于<strong>大数据通信</strong>，<strong>远程通信无法采用共享内存</strong>）</p>
<ul>
<li>不需要频繁地进行内核态和用户态的切换，<strong>速度最快</strong>，但共享内存是<strong>临界资源</strong>，需要保持同步控制。</li>
<li>可实现<strong>双向通信</strong>。</li>
</ul>
</li>
<li><p><strong>消息传递</strong>：操作系统提供机制，在进程之间创建通信链路，从而进行消息传递。可以用于<strong>远程通信</strong>。消息传递分为<strong>直接通信</strong>和<strong>间接通信</strong>两种方式。直接通信不需要中间媒介，直接传输，但会造成<strong>有限模块化</strong>的缺点，因为需要显式地声明接收者和发送者的进程ID。间接通信一般使用共享的<strong>邮箱或者端口</strong>进行信息传递。一般可以使用共享的<strong>消息队列</strong>实现间接通信。</p>
<ul>
<li>消息队列可以认为是一个<strong>全局的一个链表</strong>，链表节点钟存放着数据报的类型和内容，有消息队列的标识符进行标记。 </li>
<li>消息队列允许一个或多个进程<strong>写入或者读取消息</strong>，可以是同步地（阻塞）也可以是异步地（非阻塞）。</li>
<li>消息队列可实现<strong>双向通信，容量有限</strong>。  </li>
</ul>
</li>
<li><p><strong>管道</strong>（PIPE）：管道可以看作是一种<strong>特殊的文件</strong>，对于它的读写也可以使用read、write等方式，但它本质上只存在于<strong>内存</strong>中，而不是文件系统中。管道主要分为：</p>
<ul>
<li><strong>匿名管道</strong>：在内存中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，<strong>没有名称</strong>，只能用于<strong>父子进程</strong>之间通信。</li>
<li><strong>命名管道</strong>（FIFO）： 在内存中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，但有独特的名称，可以用于<strong>不相关进程</strong>的通信。</li>
<li><strong>管道面向字节流，自带同步互斥机制，且是单向的。它速度较慢且容量有限</strong></li>
</ul>
</li>
<li><p><strong>套接字</strong>（Socket）：通常用于进程之间的网络通信，可以用在不同机器之间。需要指明IP地址和端口。</p>
</li>
<li><p><strong>信号量</strong>（semophore）： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种<strong>锁机制</strong>，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 </p>
</li>
<li><p><strong>远程过程调用</strong>（RPC）：也是一种进程网络通信的方式。</p>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是<strong>CPU调度的基本单位</strong>，在Linux中，它被认为是一种<strong>轻量级的进程</strong>。</p>
<p>线程（Thread）<strong>由进程</strong>（Process）创建而来，同一进程中的多个线程共享：</p>
<ul>
<li>代码</li>
<li>数据</li>
<li>其他操作系统资源</li>
</ul>
<p>同一进程中的多个线程独占：</p>
<ul>
<li><p>线程ID</p>
</li>
<li><p>堆栈</p>
</li>
<li><p>寄存器组</p>
</li>
<li><p>程序计数器</p>
</li>
</ul>
<p><strong>可以看到，那些在程序运行过程中需要频繁改变的资源，往往是各线程独占的，而不变的资源，往往是线程共享的，位于进程之上。</strong></p>
<p>线程的优点在于<strong>切换开销小</strong>，同一进程的多个线程之间相互切换，不需要切换资源。</p>
<h4 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h4><p>线程和进程的区别主要在于：</p>
<ul>
<li>代码：进程往往包含线程，<strong>线程往往是进程中的一段代码。</strong></li>
<li>资源：<strong>进程是资源分配的基本单位</strong>；<strong>线程不拥有资源</strong>，而是通过进程向 CPU 申请</li>
<li>调度：同一进程中的线程切换不会引起进程切换；<strong>线程是 CPU 的基本调度单位</strong></li>
<li>切换：进程上下文切换<strong>开销大</strong>，线程因为资源共享，所以上下文切换<strong>开销小</strong></li>
<li>生命周期：进程撤销会导致它的所有线程撤销；线程撤销不会导致进程撤销 </li>
</ul>
<h4 id="多线程编程的优点"><a href="#多线程编程的优点" class="headerlink" title="多线程编程的优点"></a>多线程编程的优点</h4><ol>
<li><strong>响应度高</strong>：因为线程创建和切换的速度快，例如Web浏览器的多个窗口。</li>
<li><strong>资源共享</strong>：进程中的线程可以共享进程资源。</li>
<li><strong>经济性</strong>：线程创建、上下文切换比进程快，开销更小。</li>
<li><strong>可伸缩性</strong>。</li>
</ol>
<h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p>提供线程支持的方法主要有：</p>
<ul>
<li><strong>用户线程</strong>：位于<strong>用户空间</strong>，它的创建和管理无需内核支持，对内核是不可见的。常见的用户线程库有：<strong>Pthreads（类UNIX系统）和Java线程库。</strong></li>
<li><strong>内核线程</strong>：位于<strong>内核空间</strong>，由操作系统内核直接进行支持和管理，现代操作系统均支持内核线程。常见的内核线程库有：<strong>Win32线程库</strong>。</li>
</ul>
<p>常见的操作系统多线程模型有：</p>
<ul>
<li><strong>多对一模型</strong>：<ul>
<li><strong>多个用户线程对应一个内核进程</strong>。进程中的用户线程由进程自己管理。一个进程中的多个线程只能运行在一个处理器上，<strong>并发性较差</strong>。</li>
<li>进程内线程切换不会导致进程切换。<strong>一个线程的阻塞系统调用会导致整个进程阻塞</strong>。并且，多对一模型不支持多处理核系统，一般用于不支持内核线程的单核操作系统。</li>
<li>例子：<ul>
<li>Solaris Green Threads </li>
<li>GNU Portable Threads</li>
</ul>
</li>
</ul>
</li>
<li><strong>一对一模型</strong>：<ul>
<li><strong>一个用户线程映射到一个内核线程</strong>。</li>
<li><strong>并发性好</strong>，允许线程并行允许在多处理核系统上。</li>
<li>是创建一个用户线程就要创建一个内核线程，<strong>开销较大</strong>。</li>
<li>例子：<ul>
<li>Windows</li>
</ul>
</li>
</ul>
</li>
<li><strong>多对多模型</strong>：<ul>
<li><strong>多个用户线程映射为相等或更小数目的内核线程</strong>，并发性和效率兼顾， 但<strong>增加了复杂度</strong>。</li>
</ul>
</li>
</ul>
<h3 id="多进程编程与多线程编程的对比"><a href="#多进程编程与多线程编程的对比" class="headerlink" title="多进程编程与多线程编程的对比"></a>多进程编程与多线程编程的对比</h3><table>
<thead>
<tr>
<th>维度</th>
<th>多进程</th>
<th>多线程</th>
</tr>
</thead>
<tbody><tr>
<td>数据共享、同步</td>
<td>各进程之间数据独立，共享复杂，需要进行IPC。同步简单。</td>
<td>各线程之间共享数据，共享简单。同步复杂。</td>
</tr>
<tr>
<td>内存、CPU</td>
<td>占用内存多、切换开销大，CPU利用率低。</td>
<td>占用内存少、切换开销小，CPU利用率高。</td>
</tr>
<tr>
<td>创建销毁、切换</td>
<td>创建销毁、切换开销大，复杂</td>
<td>创建销毁、切换开销小，简答</td>
</tr>
<tr>
<td>编程调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂（难以定位是哪个线程出现问题）</td>
</tr>
<tr>
<td>可靠性</td>
<td>进程间不会相互影响</td>
<td>线程间会相互影响，一个线程的崩溃会导致所有线程的崩溃</td>
</tr>
<tr>
<td>分布式</td>
<td>适用于多核分布，也适用于多机分布的集群系统</td>
<td>只适用于多核分布</td>
</tr>
</tbody></table>
<h3 id="Java多线程编程的方式"><a href="#Java多线程编程的方式" class="headerlink" title="Java多线程编程的方式"></a>Java多线程编程的方式</h3><h4 id="继承Thread类，实现多线程"><a href="#继承Thread类，实现多线程" class="headerlink" title="继承Thread类，实现多线程"></a>继承Thread类，实现多线程</h4><p> java里面提供了一个<strong>java.lang.Thread</strong>的程序类，那么一个类只要继承了此类就表示这个类为线程的主体类，<br>但是并不是说这个类就可以实现多线程处理了，因为还需要重写Thread类中提供的一个run（）方法（public void run（）），而这个方法就属于线程的主方法。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//线程主体类</span>
    <span class="token keyword">private</span> String title<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">MyThread</span><span class="token punctuation">(</span>String title<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//线程的主体方法</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">+</span> <span class="token string">"运行，x = "</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 多线程要执行的功能，都应该在run（）方法中进行定义，但是需要说明的是：在正常情况下，如果要想使用一个类中的方法，那么肯定要产生实例化对象，而后去调用类中提供的方法，但是run()方法不能直接调用的，因为这牵扯到<strong>一个操作系统的资源调度问题</strong>，所以要想启动多线程必须使用<strong>start（）</strong>方法。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"线程A"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"线程B"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"线程C"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用start（）方法的原因是：它的源代码中定义了异常，<strong>可以防止一个线程被重复启动</strong>。</p>
<pre class="line-numbers language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>threadStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 判断线程的状态</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 抛出一个异常</span>
        group<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> started <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token function">start0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//  在start（）中调用了start0（）</span>
            started <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>started<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    group<span class="token punctuation">.</span><span class="token function">threadStartFailed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
 <span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">start0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="Thread.png" alt="Thread的执行分析"></p>
<h4 id="基于Runnable接口实现多线程"><a href="#基于Runnable接口实现多线程" class="headerlink" title="基于Runnable接口实现多线程"></a>基于Runnable接口实现多线程</h4><p> 虽然可以通过Thread类的继承来实现多线程的定义，但是在Java程序里面对于继承永远都是存在有<strong>单继承局限</strong>的，所以在Java里面又提供有第二种多线程的主体定义结构形式：实现<strong>java.lang.Runnable接口</strong>，此接口定义如下： </p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span>    <span class="token comment" spellcheck="true">// 从JDK1.8引入了Lambda 表达式之后就变为了函数式接口</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p> 通过Runnable 实现多线程的主体类 ：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//线程主体类</span>
    <span class="token keyword">private</span> String title<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">MyThread</span><span class="token punctuation">(</span>String title<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//线程的主体方法</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">+</span> <span class="token string">"运行，x = "</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个实现了Runnable接口的线程主体类不能直接启动线程，它只能<strong>作为Thread类的构造函数 public Thread(Runnable target)的参数</strong>，实例化一个Thread对象，然后使用start（）方法启动线程。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Thread threadA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"线程A"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread threadB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"线程B"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread threadC <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"线程C"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        threadA<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        threadB<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        threadC<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>基于Runnable接口的多线程，相当于兜了一个圈子<strong>解决了Java语言单继承的局限性</strong>，应该被优先考虑。</p>
<p>从JDK1.8开始，Runnable接口使用了<strong>函数式接口定义</strong>，所以也可以直接利用<strong>Lambda表达式</strong>进行线程类的实现定义。 </p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">3</span> <span class="token punctuation">;</span> x <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            String title <span class="token operator">=</span> <span class="token string">"线程对象-"</span> <span class="token operator">+</span> x<span class="token punctuation">;</span>
                Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>
                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> y <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>title <span class="token operator">+</span> <span class="token string">"运行，y = "</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
                <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Thread-与-Runnable-的关系"><a href="#Thread-与-Runnable-的关系" class="headerlink" title="Thread 与 Runnable 的关系"></a>Thread 与 Runnable 的关系</h4><p><strong>Thread类其实也是Runnable 接口的子类</strong>，那么在之前继承Thread类的时候对run方法的重写实际上<strong>等同于在实现Runnable接口的run方法</strong>。 </p>
<p>多线程的设计之中，使用了代理设计模式的结构，用户自定义的线程主体只是负责项目核心功能的实现，而所有的辅助实现全部交给Thread类来处理。 </p>
<p> 多线程开发的本质实质上是在于多个线程可以进行共享资源的抢占，那么<strong>Thread主要描述的是线程，那么资源的描述是通过Runnable完成的</strong>。 </p>
<p><img src="%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt="代理模式"></p>
<h3 id="Callable实现多线程"><a href="#Callable实现多线程" class="headerlink" title="Callable实现多线程"></a>Callable实现多线程</h3><p>从最传统的开发来讲如果要进行多线程的实现肯定依靠的就是Runnable，但是Runnable接口有一个缺点：<strong>当线程执行完毕后，我们无法获取一个返回值</strong>，所以从JDK1.5之后就提出了一个新的线程实现接口：<strong>java.util.concurrent.Callable接口</strong>。首先观察这个接口的定义：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span> V <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以发现Callbale定义的时候可以设置一个泛型，此泛型的类型就是返回数据的类型，这样的的好处是可以避免向下转行所带来的安全隐患。 </p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread2</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> x <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"******线程执行，x = "</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token string">"线程执行完毕！"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">demo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>
        FutureTask futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程返回值："</span> <span class="token operator">+</span> futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Runable与Callable接口的区别是：</p>
<ul>
<li>Runable接口只有Run方法，<strong>且返回值类型为Void类型，没有返回值</strong>。</li>
<li>Callable接口支持Call方法，<strong>返回值类型可以自己设置，线程执行完毕后我们可以得到一个返回值。</strong></li>
</ul>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h3><p><strong>周转时间</strong>：进程从<strong>提交</strong>（新建队列到就绪队列）到结束运行的全部时间（提交不等于开始运行，可能还需要等待一段时间）</p>
<p><strong>等待时间</strong>：进程在<strong>就绪队列</strong>中等待所花时间之和。（可能有多段时间）</p>
<p><strong>响应时间</strong>：进程从提交到<strong>第一次运行</strong>的时间。</p>
<p><strong>CPU利用率</strong>：固定时间内CPU运行时间的比例。</p>
<p><strong>吞吐量</strong>：单位时间内完成进程的数量。</p>
<p>周转时间 = 等待时间 + 运行时间</p>
<p>我们进行进程调度的准则是：<strong>最大化吞吐量和CPU利用率，最小化周转时间、等待时间、响应时间。</strong></p>
<h3 id="调度类型"><a href="#调度类型" class="headerlink" title="调度类型"></a>调度类型</h3><p>进程调度的类型有：</p>
<ul>
<li><strong>长程调度</strong>：又叫作业调度、高级调度，发生在进程由“<strong>新建</strong>”状态转移到“<strong>就绪</strong>状态”的过程中。通过调度程序选择，将进程从外存调入内存，<strong>控制多道程序的道数</strong>。开销大，切换频率低。</li>
<li><strong>中程调度</strong>：又称<strong>交换</strong>（swap），是<strong>内存扩容</strong>的方法之一。中程调度将进程在内存和外存之间换进换出，从而使计算机可以执行大于内存容量的进程。（虚拟内存技术以<strong>页</strong>为单位）</li>
<li><strong>短程调度</strong>：又叫CPU调度、低级调度，发生在进程由“<strong>就绪</strong>”转移到“<strong>运行</strong>”状态的过程中。通过调度程序选择下一个需要执行的进程。开销小，切换频率高。</li>
</ul>
<p>调度程序的作用就是根据某种策略在就绪队列中选择CPU下一个运行的进程。</p>
<p>我们后文所说的进程调度都是指“<strong>短程调度</strong>”。</p>
<h3 id="调度的方式"><a href="#调度的方式" class="headerlink" title="调度的方式"></a>调度的方式</h3><p>调度根据是否<strong>发生抢占</strong>，可以分为：</p>
<ul>
<li><strong>非抢占式调度</strong>：如果一个进程分配到CPU，那么将一直占用该CPU执行，直到这个进场终止或者切换到等待到等待状态。<ul>
<li>优点：<strong>易实现，调度开销小，适合批处理系统。</strong></li>
<li>缺点：<strong>响应时间长，不适合交互式系统。</strong></li>
</ul>
</li>
<li><strong>抢占式调度</strong>：调度程序可以根据某种原则暂停某个正在执行的进程，将它的CPU分配给其他的进程。<ul>
<li>优点：<strong>相应时间短，适合交互式系统，可防止某一进程长时间独占CPU。</strong></li>
<li>缺点：<strong>实现困难，调度开销大。</strong></li>
</ul>
</li>
<li>如何区分是否抢占：<strong>进程是否自愿放弃CPU</strong>，比如终止或者进入等待状态。</li>
<li>只有抢占式调度的算法：时间片轮转调度算法RR</li>
<li>只有非抢占式调度的算法：先到先服务算法FCFS</li>
<li>既可以抢占也可以非抢占的算法：短作业优先算法SJF，优先级调度算法PR</li>
</ul>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="FCFS先到先服务算法"><a href="#FCFS先到先服务算法" class="headerlink" title="FCFS先到先服务算法"></a>FCFS先到先服务算法</h4><p>按<strong>进程请求CPU的先后顺序</strong>为他们分配CPU，较为<strong>公平</strong>，只能是<strong>非抢占式</strong>的。</p>
<p>适用于<strong>长程调度、后台批处理系统的短程调度</strong>。</p>
<p>对<strong>CPU密集型进程</strong>有利（执行时间短），对<strong>IO密集型进程</strong>不利（执行时间长）。</p>
<ul>
<li>优点：实现简单（FIFO先进先出队列实现），容易理解，公平</li>
<li>缺点：<strong>平均等待时间长（</strong>比如一个运行时间很长的CPU密集型进程先到了，那么短进程都需要先等待它执行完毕才能执行）</li>
</ul>
<h3 id="SJF最短作业优先算法"><a href="#SJF最短作业优先算法" class="headerlink" title="SJF最短作业优先算法"></a>SJF最短作业优先算法</h3><p>按照<strong>进程下次CPU运行时间的长短</strong>进行调度，越短的进程越先被分配CPU并执行。常用于<strong>长程调度</strong>。</p>
<p>实际过程中难以得知CPU的下次运行时间，需要通过以往运行时长的<strong>指数平均</strong>来计算。</p>
<ul>
<li>优点：<strong>平均等待时间最短</strong></li>
<li>缺点：<strong>存在饥饿问题</strong></li>
</ul>
<p>调度模式：</p>
<ul>
<li>非抢占式</li>
<li>抢占式：如果有比当前进程剩余执行时间更短的执行时间的进程到达时，将当前进程中止，并将CPU分配给新进程。也叫<strong>最短剩余时优先间调度算法SRTF。</strong></li>
</ul>
<p>什么是<strong>饥饿</strong>：稳定的<strong>更高优先级</strong>的进程流会导致低优先级的进程<strong>始终无法被执行</strong>。</p>
<p>SJF本质上是PR的一种特例。</p>
<h3 id="PR优先级算法"><a href="#PR优先级算法" class="headerlink" title="PR优先级算法"></a>PR优先级算法</h3><p>基于进程的紧迫程度，由外部赋予每个进程相应的优先级，CPU 分配给最高优先级的进程。 </p>
<ul>
<li>优点：实现<strong>简单</strong>，考虑了进程的紧迫程度；<strong>灵活</strong>，可模拟其它算法。</li>
</ul>
<p>调度模式也可以有两种。</p>
<p>优先级有两种类型：</p>
<ul>
<li><strong>静态优先级</strong>：<ul>
<li>进程创建时确定，在运行期间<strong>不变</strong></li>
<li>简单易行，<strong>系统开销小</strong></li>
<li>不够精确，可能会出现<strong>饥饿</strong>问题（稳定的更高优先级的进程流可以阻止低优先级的进程执行）</li>
</ul>
</li>
<li><strong>动态优先级</strong>：<ul>
<li>进程创建时的优先级随进程推进或等待时间增加而改变，<strong>解决了饥饿</strong>，例如：<strong>老化，即逐渐增加在系统中等待很久的进程的优先级</strong></li>
<li>现代操作系统常采用<strong>基于动态优先数的抢占式调度算法</strong>，缺点是<strong>每次调度之前，都需要计算优先数，增加系统开销</strong></li>
</ul>
</li>
</ul>
<h3 id="RR时间片轮转调度算法"><a href="#RR时间片轮转调度算法" class="headerlink" title="RR时间片轮转调度算法"></a>RR时间片轮转调度算法</h3><p>专门为<strong>分时系统</strong>设计，类似于 <strong>FCFS</strong>，但增加了抢占以切换进程。为每个进程分配<strong>不超过一个时间片的 CPU</strong>。时间片用完后， 该进程将被抢占并插入就绪队列末尾，<strong>循环执行</strong>。若进程提前执行完成，则自动释放 CPU。 </p>
<p>性能很大程度上取决于时间片大小，所以要合理设计时间片大小：</p>
<ul>
<li>时间片过大，RR退化为FCFS</li>
<li>时间片过小，导致上下文切换开销大大增加</li>
</ul>
<h3 id="MLQ多级队列调度算法"><a href="#MLQ多级队列调度算法" class="headerlink" title="MLQ多级队列调度算法"></a>MLQ多级队列调度算法</h3><p>系统中存在多个就绪队列，每个队列有自己的调度算法。队列之间也有调度算法，通常采用<strong>固定优先级</strong>（可能会导致<strong>饥饿</strong>，低优先级的队列中的进程始终无法被执行）抢占调度。<strong>不允许进程在多个队列之间流动</strong>。</p>
<p>例子：操作系统的<strong>前台队列和后台队列</strong></p>
<h3 id="MFLQ多级反馈队列调度算法"><a href="#MFLQ多级反馈队列调度算法" class="headerlink" title="MFLQ多级反馈队列调度算法"></a>MFLQ多级反馈队列调度算法</h3><p>在 MLQ 的基础上，<strong>进程能在不同队列间移动</strong>。解决了 MLQ的饥饿现象。</p>
<p><strong>Unix，Solaris，Windows 的调度算法一定程度上都是 MLFQ 的变种</strong> </p>
<h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><h3 id="多线程-多进程编程可能带来的问题"><a href="#多线程-多进程编程可能带来的问题" class="headerlink" title="多线程/多进程编程可能带来的问题"></a>多线程/多进程编程可能带来的问题</h3><p>共享数据如果同时被多个进程或者线程并发或者并行访问，可能会导致：<strong>数据不一致性，又称不可再现性</strong>。即同一进程在同一批数据上多次运行的结果不一样。 </p>
<p>为了解决数据不一致性问题，我们要采取：<strong>同步（互斥）机制</strong>。其中，互斥机制是同步机制的一种特殊情况。</p>
<p>一个数据不一致性的例子：counter</p>
<blockquote>
<p>n 个缓冲区的有界缓冲问题，生产者进程和消费者进程同时对共享资源 counter 进行修改，产生了错误的结果。解决方案：counter–与 counter++必须作为原子操作，建立互斥机制，将 counter 变为临界资源。</p>
</blockquote>
<p><strong>原子操作</strong>：操作执行的过程中必须是连续的。</p>
<h3 id="同步与互斥的概念"><a href="#同步与互斥的概念" class="headerlink" title="同步与互斥的概念"></a>同步与互斥的概念</h3><p>同步指的是<strong>协调进程的执行次序</strong>，使并发进程间能有效地共享资源和相互合作，<strong>保证数据一致性</strong>。</p>
<p><img src="%E5%90%8C%E6%AD%A5.png" alt="同步"></p>
<p>互斥指的是进程<strong>排他性</strong>地运行某段代码，任何时候只有一个进程能够运行。多个进程<strong>互斥地访问只允许被独占的资源。</strong>但是，互斥无法保证进程的执行次序。</p>
<p>互斥的特点：</p>
<ul>
<li>原子性</li>
<li>排他性</li>
<li>唯一性</li>
</ul>
<p><img src="%E4%BA%92%E6%96%A5.png" alt="互斥"></p>
<h3 id="临界的概念"><a href="#临界的概念" class="headerlink" title="临界的概念"></a>临界的概念</h3><p>临界是<strong>互斥控制</strong>中的重要概念。</p>
<p>临界资源：<strong>一次只允许一个进程使用的资源</strong>，又称互斥资源、独占资源或共享资源。许多物理设备都属于临界资源，如输入机、打印机、磁带机等 </p>
<p>临界区：<strong>涉及临界资源的代码段</strong>，若保证互斥进入关联的临界区，可实现对临界资源的互斥访问。</p>
<ul>
<li>临界区属于代码片段，它的特征是包含临界资源。</li>
<li>临界区的使用准则：<ul>
<li><strong>互斥</strong>：有相同临界资源的临界区需要互斥，<strong>同一时刻只能有一个进程的临界区访问临界资源</strong>，其他进程需要在临界区外等待。而无相同临界资源的临界区不需要互斥。</li>
<li><strong>有空让进（进步）</strong>：临界区内无进程执行时，不能无限期地延长下一个要进临界区进程的等待时间，应及时选择不在剩余区中执行的进程进入临界区 。</li>
<li><strong>有限等待</strong>：<strong>每个进程进入临界区前的等待时间必须有限</strong>，不能无限等待。其他进程允许进入临界区的次数应有上限。</li>
</ul>
</li>
</ul>
<p><img src="%E4%B8%B4%E7%95%8C%E5%8C%BA.png" alt="临界区"></p>
<p>原则：<strong>在进入区实现互斥准则；在退出区实现有空让进准则 ；每个临界区不能过大，从而实现有限等待准则。</strong></p>
<h3 id="信号量的概念"><a href="#信号量的概念" class="headerlink" title="信号量的概念"></a>信号量的概念</h3><p>同步机制的<strong>软件解决方案</strong>之一。在进入关键代码段前，进程必须获取一个信号量，否则不能运行。执行完该关键代码段，必须释放信号量。</p>
<h4 id="信号量的基本操作"><a href="#信号量的基本操作" class="headerlink" title="信号量的基本操作"></a>信号量的基本操作</h4><p>信号量S除了定义以外，提供了两个不可分割的<strong>原子操作</strong> <strong>wait（S）</strong>（又称 P（S））和 <strong>signal（S）</strong>（又称 V（S））。</p>
<ul>
<li>wait操作申请并占用一个信号量，signal操作释放一个占用的信号量。</li>
</ul>
<h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p>整型信号量的取值范围是<strong>非负整数</strong>，主要有两种，分别为：</p>
<ul>
<li><p><strong>计数信号量</strong>：</p>
<ul>
<li>取值范围：<strong>没有限制的非负整数</strong>，计数信号量的值等于系统中<strong>可用的资源数目</strong>。</li>
<li>也叫作同步信号量，主要用于<strong>同步控制</strong>。</li>
</ul>
<p><img src="%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F.png" alt="计数信号量实现同步控制"></p>
</li>
<li><p><strong>二值信号量</strong>：</p>
<ul>
<li>取值范围：<strong>0或者1</strong>。</li>
<li>也叫作互斥信号量，主要用于在没有互斥锁的系统中实现<strong>互斥控制</strong>。</li>
</ul>
<p><img src="%E4%BA%92%E6%96%A5%E4%BF%A1%E5%8F%B7%E9%87%8F.png" alt="互斥信号量实现互斥控制"></p>
</li>
</ul>
<p>整型信号量的缺陷主要为：当使用wait操作申请信号量，而信号量值为0时，进程或者线程将处于<strong>忙等待</strong>。</p>
<p>忙等待：进程或者线程使用While循环或者其他循环操作，<strong>不断阻塞循环查询信号量的值</strong>，直到信号量可用。效率很差，因为进程或者线程一直处于运行状态，占用CPU资源。</p>
<h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>当一个进程执行 wait（S）时，当系统中没有可用的资源（S&lt;=0），不需要再循环查询信号量值，而是将自己阻塞（调用 block（）），由运行状态切换为<strong>等待状态</strong>，并<strong>将自己放入一个与信号量相关的等待队列</strong>中。当另一个进程执行 signal（S）时，当存在等待进程时，从等待进程队列中唤醒一个进程（wakeup（P））使其继续运行。</p>
<p><img src="%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F.png" alt="记录型信号量"></p>
<p>记录型信号量的值：</p>
<ul>
<li>大于0：可用资源数目</li>
<li>等于0：无资源可用</li>
<li>小于0：等待的进程或者线程数目</li>
</ul>
<p>与整型信号量相比：</p>
<ul>
<li>解决了<strong>忙等待</strong>问题。当进程或者线程无法获得想要的信号量时，不会循环在运行状态查询，占用CPU资源，而是转至等待状态，提高了CPU利用率。</li>
<li>信号量的值可以<strong>为负数</strong>，其绝对值等于该信号量上阻塞的进程数目。</li>
</ul>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>在多任务操作系统中，同时运行的多个任务可能都需要使用同一种资源。这个过程有点类似于，公司部门里，我在使用着打印机打印东西的同时（还没有打印完），别人刚好也在此刻使用打印机打印东西，如果不做任何处理的话，打印出来的东西肯定是错乱的。<br>在线程里也有这么一把锁——<strong>互斥锁（mutex）</strong>，互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态,即<strong>上锁( lock )和解锁( unlock )</strong>。<br>互斥锁的基本作用和<strong>二值型信号量</strong>一致，但当申请互斥锁失败后，进程或者线程会<strong>自动阻塞睡眠，进入等待状态</strong>。这一点与记录型信号量类似。</p>
<p>特点：</p>
<ul>
<li>原子性</li>
<li>排他性</li>
<li>唯一性</li>
<li>非忙等</li>
</ul>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁与互斥锁功能一样，唯一一点不同的就是<strong>互斥锁阻塞后休眠让出CPU，而自旋锁阻塞后不会让出CPU</strong>，会一直忙等待，直到得到锁。 就像整型信号量和记录型信号量的区别。</p>
<p>自旋这个名字非常形象，因为申请锁失败后的进程或者线程会忙等，循环查询锁的状态，就像一直在旋转一样。</p>
<h3 id="自旋锁和互斥锁（整型信号量和记录型信号量）的使用场景"><a href="#自旋锁和互斥锁（整型信号量和记录型信号量）的使用场景" class="headerlink" title="自旋锁和互斥锁（整型信号量和记录型信号量）的使用场景"></a>自旋锁和互斥锁（整型信号量和记录型信号量）的使用场景</h3><ul>
<li>自旋锁和整型信号量会产生<strong>忙等待</strong>，当<strong>锁的持有时间较长</strong>时，这段时间内进程或者线程将一直占用CPU，降低CPU利用率。但它也并非一无是处。当锁的持有时间很短，特别是<strong>短到小于两次上下文切换时间</strong>（运行-等待，等待-运行）时，适合使用自旋锁和整型信号量。</li>
<li>互斥锁和记录型信号量当<strong>锁的持有时间较长</strong>时，能够提高CPU利用率，更适合。</li>
</ul>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁与互斥量类似，不过读写锁允许<strong>更改并行性</strong>，也叫共享互斥锁。互斥量要么是锁住状态，要么就是不加锁状态，而且一次只有一个线程可以对其加锁。读写锁可以有3种状态：<strong>读模式下加锁状态、写模式加锁状态、不加锁状态。</strong></p>
<p>一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁（允许多个线程读但只允许一个线程写）。因为<strong>多个读者同时读不会产生并发问题</strong>，其余情况都可能导致并发问题。</p>
<p> 读写锁适合于对数据结构的<strong>读次数比写次数多得多</strong>的情况。 </p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>与互斥锁不同，条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直 到某特殊情况发生为止。通常条件变量<strong>和互斥锁同时使用</strong>。<br>条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作： </p>
<ul>
<li>一个线程等待”<strong>条件变量的条件成立</strong>“而挂起；</li>
<li>另一个线程使 “<strong>条件成立”</strong>（给出条件成立信号）。</li>
</ul>
<h3 id="并发控制经典问题"><a href="#并发控制经典问题" class="headerlink" title="并发控制经典问题"></a>并发控制经典问题</h3><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><p><img src="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85.png" alt="生产者消费者问题"></p>
<p>生产者消费者问题是一个<strong>有界缓冲</strong>问题，是一个经典的并发控制问题。</p>
<ul>
<li>生产者（M个）：生产产品，并并放入有界缓冲区。</li>
<li>消费者（N个）：从有界缓冲区取出产品。</li>
<li>问题：如何实现生产者与消费者之间的同步与互斥</li>
</ul>
<p><strong>互斥</strong>问题：</p>
<ul>
<li><p>互斥问题的基本研究方法：</p>
<p><img src="%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98.png" alt="互斥问题"></p>
</li>
<li><p>本问题中的临界资源：</p>
<ul>
<li>生产者进程：<ul>
<li>把产品放入指定缓冲区的代码需要使用 in 指针存放生产者放入的位置（这里我们在缓冲区内使用<strong>队列数据结构</strong>），使用counter指针存放当前资源数目</li>
<li>in:所有的生产者对 in 指针需要互斥</li>
<li>counter：所有生产者消费者进程对 counter 互斥 </li>
</ul>
</li>
<li>消费者进程：<ul>
<li>把从指定缓冲区取出产品的代码需要使用 out 指针存放消费者取出的位置，使用counter指针存放当前资源数目</li>
<li>out:所有的消费者对 out 指针需要互斥</li>
<li>counter：所有生产者消费者进程对 counter 互斥 </li>
</ul>
</li>
</ul>
</li>
<li><p>对于含有上述临界资源的代码段，我们将其视为临界区，并使用互斥信号量或者互斥锁进行互斥控制。</p>
</li>
</ul>
<p><strong>同步</strong>问题</p>
<ul>
<li><p>同步问题的基本研究方法：</p>
<p><img src="%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98.png" alt="同步问题"></p>
</li>
<li><p>需要同步的部分：</p>
<ul>
<li>生产者：把产品放入空缓冲区。</li>
<li>消费者：把产品放入满缓冲区。 </li>
</ul>
</li>
<li><p>不同执行次序：</p>
<ul>
<li>当<strong>没有空缓冲区</strong>时，生产者进程阻塞，等待消费者进程先执行。 </li>
<li>当<strong>没有满缓冲区</strong>时，消费者进程阻塞，等待生产者进程先执行。 </li>
<li>当空缓冲区和满缓冲区都存在时，<strong>二者可并行</strong>。 </li>
</ul>
</li>
</ul>
<p>解决方案：使用三个信号量，两个信号量用于同步，值分别为满缓冲区和空缓冲区的可用资源数目。一个信号量进行互斥，控制临界区的访问。</p>
<p><img src="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.png" alt="生产者消费者问题解决"></p>
<h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><p>问题描述：两组并发进程读者和写者共享一组数据区进行读写。要求：允<strong>许多个读者同时读，不允许读者、写者同时读写，不允许多个写者同时写。</strong>例子：对文件的读写操作。</p>
<p>Linux内置<strong>读写锁</strong>进行并发控制。</p>
<p>如果我们仅仅使用互斥信号量，使得所有读者和写者进程对于数据的访问都是互斥的，那么将不符合多个读者同时读的要求。</p>
<p>解决方法：额外为读者进程设置<strong>计数变量</strong>，当其为 1 时（第一个进入的读者进程）执行 P 操作占用互斥信号量，当其为 0 时（最后一个离开的读者进程）执行 V 操作释放互斥信号量。换句话说：<strong>只有第一个读者需要申请信号量，只有最后一个读者需要释放信号量</strong></p>
<p>需要注意的是：<strong>计数变量本身是一个互斥资源，包含它的代码段必须被声明为临界区。</strong></p>
<p><img src="%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.png" alt="读者写者问题解决"></p>
<h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p>问题描述：5 个哲学家，5 根筷子。哲学家左右各有一根筷子，哲学家只有<strong>拿起左右两个筷子</strong>才能吃饭。</p>
<p>存在死锁的解决方法：将筷子视为<strong>临界资源</strong>。但如果当五个哲学家同时想要吃饭，先拿起左边筷子时，他们<strong>会因为在拿起右边筷子时互相等待而陷入死锁</strong>。 （符合死锁条件中的互斥、非抢占、持有并等待、循环等待）</p>
<p>解决措施：</p>
<ul>
<li><p><strong>最多允许四个哲学家同时就坐</strong>。方法：设置 seat 信号量，初始值为 4，每个哲学家就餐前后先对 seat 信号量执行 P、V 操作占用一个座位。</p>
</li>
<li><p><strong>非对称策略</strong>。方法：为哲学家编号。奇数哲学家先拿起左侧的筷子，后拿起右侧的筷子。偶数哲学家先拿起右侧的筷子，再拿起左侧的筷子。</p>
</li>
<li><p><strong>只有左右两侧筷子均可拿起时，才会拿起筷子。</strong>方法：设置哲学家分为 3 个状 态：int <em>state={Thinking, hungry, eating};设置 5 个信号量，对应 5 个哲学家，初始值为 0。设计 test 函数，当<strong>左右两侧哲学家均不在吃饭（左右两侧筷子均可 拿起），且自己处于 hungry 时</strong>，把自己的状态设置为 eating 并将自己的信号 量加 1，从而拿起筷子吃饭，否则阻塞等待别人吃完。吃完饭后，将自己的状态设置为 thinking，并执 行两次 test 函数，查看左右两侧的哲学家是否因为自己的进食而处于 hungry 并等待，若有，<em>*将他们唤醒</em></em>。</p>
<p>实现方式：需要注意，test操作涉及临界资源state，需要互斥控制。</p>
<p><img src="%E5%93%B2%E5%AD%A6%E5%AE%B6%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.png" alt="哲学家问题解决"></p>
</li>
</ul>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>信号量机制的问题：</p>
<ul>
<li>需要程序员实现，编程困难。</li>
<li>维护困难。</li>
<li>容易出错：P、V 操作位置错或者不配对。</li>
</ul>
<p>管程<strong>将相应的数据结构和操作封装起来，由编程语言解决同步互斥问题</strong>。 一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。管程类型属于<strong>抽象数据类型 ADT。</strong> </p>
<p><img src="%E7%AE%A1%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="管程结构"></p>
<ul>
<li>互斥机制：管程中的变量只能由管程中的操作访问，<strong>同一时刻只能有一个进程在管程中</strong>，这一思想类似于临界区，由<strong>编译器</strong>实现，从而实现了互斥机制。（<strong>管程中不需要特地进行互斥控制</strong>）</li>
<li>同步机制：利用<strong>条件变量</strong>，以及每个条件变量的阻塞 wait()和唤醒 signal()操作来实现。（与<strong>信号量相比，不会出错，但无法计数，需要引入计数变量</strong>）每个条件变量都有一个条件队列，被阻塞的进程将在该条件队列上睡眠，直到被唤醒。在管程中可以自由选择当前进程阻塞到哪一个条件变量上。</li>
</ul>
<p><img src="%E7%AE%A1%E7%A8%8B%E5%AE%9E%E7%8E%B0.png" alt="哲学家就餐问题的管程实现"></p>
<h3 id="Linux和Windows的并发控制对比"><a href="#Linux和Windows的并发控制对比" class="headerlink" title="Linux和Windows的并发控制对比"></a>Linux和Windows的并发控制对比</h3><p>Linux 并发控制机制：</p>
<ul>
<li>使用禁止中断来实现短的临界区。（原子操作）</li>
<li>自旋锁：不会引起调用者阻塞。</li>
<li>条件变量。 </li>
<li>信号量。</li>
<li>互斥锁。</li>
</ul>
<p>Windows并发控制机制：</p>
<ul>
<li>事件：通过通知操作的方式来保持线程的同步。 </li>
<li>临界区。</li>
<li>互斥锁。</li>
<li>自旋锁。</li>
<li>信号量。</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p>死锁指的是：一组等待进程，其中每一个进程都<strong>持有</strong>资源，并且<strong>等待</strong>着由这个组中其他进程所持有的资源。所有死锁进程<strong>无法推进</strong>。</p>
<p>死锁的四个必要条件（同时满足就能发生死锁）：</p>
<ul>
<li><strong>互斥</strong>：至少有一个资源处于<strong>非共享模式</strong>，即一次只能有一个进程访问该资源。</li>
<li><strong>占有并等待</strong>：一个进程应占有至少一个资源，并等待另一个被<strong>其它进程</strong>占有的资源。</li>
<li><strong>无抢占</strong>：资源不能被抢占，只能被进程完成任务后<strong>自愿释放</strong>。</li>
<li><strong>循环等待</strong>：等待资源的进程之间存在环 [P0, P1, …, P0]。P0 等待 P1 占有的资源, P1 等待 P2 占有的资源, …, Pn–1 等待 Pn 占有的资源, Pn 等待 P0 占有的资源。 </li>
</ul>
<p>处理死锁的四大方法：</p>
<ul>
<li><strong>死锁预防</strong></li>
<li><strong>死锁避免</strong></li>
<li><strong>死锁检测</strong></li>
<li><strong>死锁恢复</strong></li>
</ul>
<h3 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h3><p>资源分配图：一个顶点的集合V和边的集合E。V被分为两个部分：P = {P1, P2, …, Pn}, 含有系统中全部的进程。R = {R1, R2, …, Rm}, 含有系统中全部的资源。</p>
<p><strong>请求边</strong>：有向边Pi–&gt;Rj 。进程到资源。</p>
<p><strong>分配边</strong>：有向边Ri–&gt;P j。资源到进程。</p>
<ul>
<li><p>如果资源分配图中<strong>不存在环</strong>：一定没有死锁。</p>
</li>
<li><p>如果资源分配图中<strong>存在环</strong>：</p>
<ul>
<li>如果每个资源<strong>只有一个实例</strong>，那么死锁发生。</li>
<li>如果一个资源<strong>有多个实例</strong>，那么死锁可能发生也可能不发生。</li>
</ul>
</li>
</ul>
<p><img src="%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png" alt="资源分配图"></p>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>死锁预防指的是：使死锁发生的四个必要条件（互斥、占有并等待、非抢占、循环等待）<strong>至少一个不成立</strong>。</p>
<p>死锁预防的副作用：<strong>设备使用率低和系统吞吐率低</strong>。</p>
<ul>
<li>使互斥不成立：通过<strong>虚拟化技术</strong>，<strong>将互斥资源转换为共享资源</strong>。然而，通常不能通过否定互斥条件来预防死锁，因为有的资源本身就是非共享的，例如<strong>互斥锁</strong>。</li>
<li>使占有并等待不成立：<strong>保证进程申请资源时不占有任何资源</strong>。然而，这种方法的资源利用率较低，也可带来饥饿。<ul>
<li>每个进程在执行前一次性申请并获得所有资源。</li>
<li>每个进程在申请资源时先释放掉占用的所有资源。</li>
</ul>
</li>
<li>使非抢占不成立：当一个进程占有资源并申请另一个不能立即被分配（不可用且不是其他等待进程的可抢占资源）的资源时，它占有的所有资源被<strong>隐式释放</strong>，均可被抢占。当它获得了申请的资源和在等待过程中被抢占的资源时，才可重新执行。</li>
<li>使循环等待不成立：对所有的资源类型排序进行<strong>总排序</strong>，并且要求进程按照<strong>递增顺序</strong>申请资源。</li>
</ul>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>死锁避免指的是系统理论上存在着死锁的可能，但在每次<strong>分配资源</strong>时，调用死锁避免算法，使死锁不可能成立。</p>
<p>死锁避免需要系统提供一些<strong>额外信息</strong>，如每一个进程声明它所需要的每种资源的最大数目。死锁避免算法动态检查<strong>资源分配状态</strong>，以确保循环等待不成立。资源分配状态包括：<strong>可用的资源、已分配的资源、资源的最大需求。</strong></p>
<p><strong>安全状态</strong>：只有存在一个<strong>安全序列</strong>，系统才处于安全状态。<strong>死锁状态是非安全状态的子集</strong>。死锁避免算法确保系统处于安全状态。</p>
<p><strong>安全序列</strong>：如果每一个进程Pi所申请的可以被满足的资源数加上当前其他进程所持有的该资源数小于系统总数。那么，进程序列&lt;P1, P2, …, Pn&gt;是安全的。也就是说，<strong>使得进程按照某个序列可以流畅地推进，不会产生死锁，那么该序列是安全的。</strong></p>
<h4 id="单实例：资源分配图法"><a href="#单实例：资源分配图法" class="headerlink" title="单实例：资源分配图法"></a>单实例：资源分配图法</h4><p>当系统中的资源都是单实例的时，我们可以使用资源分配图来进行死锁避免。<strong>因为单实例时，一旦资源分配图中存在环，则必然会产生死锁。</strong>所以，我们只需要判断资源分配是否可能导致资源分配图存在环，即可进行死锁避免。</p>
<p>判断图中是否存在环可以使用<strong>拓扑排序</strong>，时间复杂度：$O(n^2)$，n为进程数目。</p>
<ul>
<li><strong>需求边</strong>：需求边 Pi –&gt;Rj 表示 Pi 可能以后需要申请Rj资源，用虚线表示。</li>
<li><strong>请求边</strong>：Pi 申请Rj资源，需求边转换为请求边。</li>
<li><strong>分配边</strong>：请求边在资源分配后转换为分配边。</li>
<li>资源申请能够被满足的条件：<strong>把请求边转换为分配边后不会导致环存在。</strong></li>
</ul>
<h4 id="多实例：银行家算法"><a href="#多实例：银行家算法" class="headerlink" title="多实例：银行家算法"></a>多实例：银行家算法</h4><p>银行家算法，顾名思义，就是先借资源给某个进程，当他执行完毕后，将原先占有的资源，和所借的资源<strong>全部返还</strong>给系统，就像在银行借款一样。</p>
<ul>
<li>新进入进程要声明自己所需的各资源最大数目，且不能大于系统资源最大数目。</li>
<li>当进程请求资源时，可能要等待。</li>
<li>当一个进程获得所有需要的资源并执行时，必须在有限的时间释放它们。</li>
<li>数据结构：（<strong>n为进程数目，m为资源数目</strong>）<ul>
<li><strong>Available</strong>: 长度为 m的向量，表示每种资源的可用数目。如果available[j]=k,那么资源Rj有k个实例可用。</li>
<li><strong>Max</strong>: n x m 矩阵。 如果Max[i,j]=k,那么进程Pi最多需求k个资源Rj的实例。</li>
<li><strong>Allocation</strong>: n x m 矩阵。 如果Allocation[i,j]=k,那么进程Pi当前分配了k个资源Rj的实例。</li>
<li><strong>Need</strong>: n x m 矩阵。如果Need[i,j]=k,那么进程Pi还需要k个资源Rj的实例。Need [i,j] = Max[i,j] – Allocation [i,j]。</li>
</ul>
</li>
<li><strong>安全检测算法（银行家算法）</strong>： （时间复杂度：$O(m*n^2)$）<ol>
<li>让<strong>Work</strong>和<strong>Finish</strong>作为长度为m和n的向量初始化：Work := Available，Finish [i] = false。（初始化work矩阵用于模拟<strong>执行过程中的available矩阵</strong>，finish矩阵记录<strong>模拟执行过程中进程是否执行完成</strong>）</li>
<li>循环遍历查找i，使其满足：（查找可被满足需求的进程并执行）<ol>
<li>Finish [i] = false（<strong>第 i 个进程尚未被执行</strong>）</li>
<li>Need[i]&lt;=Work（<strong>第 i 个进程可以被执行</strong>）</li>
<li>如果不存在这样的i，直接跳转步骤4.</li>
</ol>
</li>
<li>Work := Work + Allocation[i]；Finish[i] := true；go to step 2.（<strong>释放进程i的资源，以便其他等待进程执行</strong>）</li>
<li>如果对于所有进程i，都可以执行，那么系统处于安全状态，其中i的访问次序即为安全序列（<strong>安全序列不唯一</strong>）。否则，系统处于不安全状态。</li>
</ol>
</li>
<li><strong>资源请求算法</strong>：Request[i] =进程 Pi 的资源请求向量. 如果Request[i ,m] = k 则进程Pi想要资源类型为Rj[m]的k个实例。<ol>
<li>如果 Request[i]&lt;=Need[i]转 step 2. 否则报错, <strong>因为进程请求超出了其声明的最大值</strong>。<ol start="2">
<li>如果 Request[i] &lt;=Available, 转 step 3. 否则 Pi 必须等待, <strong>因为资源暂时不可用</strong>.<pre><code>  3. 通过修改下列状态来分配请求的资源给进程Pi :
  1. Available[i] := Available[i] - Request[i];
     2. Allocation[i]:= Allocation[i] + Request[i];
        3. Need[i]:= Need[i] – Request[i]
        4. 调用安全检测算法（银行家算法）检测执行请求后的新资源分配状态是否安全，**若安全则通过请求，否则需要回滚**。</code></pre></li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>死锁检测指的是<strong>系统允许进入死锁状态</strong>，定时调用死锁检测算法，判断当前系统中是否存在死锁，如果存在则进行死锁恢复。</p>
<p>调用死锁检测算法的频率取决于：</p>
<ul>
<li><strong>死锁可能发生的概率</strong></li>
<li><strong>死锁发生时可能有多少进程受影响</strong></li>
</ul>
<h4 id="单实例：等待图法"><a href="#单实例：等待图法" class="headerlink" title="单实例：等待图法"></a>单实例：等待图法</h4><p>等待图是资源分配图的简化，省略了资源类型结点，合并了边。Pi–&gt;Pj表明Pi在等待Pj的资源。系统维护等待图，并定时调用算法检测是否存在环。</p>
<h4 id="多实例：银行家算法-1"><a href="#多实例：银行家算法-1" class="headerlink" title="多实例：银行家算法"></a>多实例：银行家算法</h4><p>类似银行家算法。基本思路完全一致，如果无法找到安全序列，则系统死锁。需要注意的是，这里的need矩阵变为了request矩阵，如果进程的request被允许，则可以乐观的释放它的全部资源。</p>
<h3 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h3><p>死锁恢复指的是系统产生死锁后将死锁状态解除的算法。</p>
<ul>
<li><strong>人工恢复</strong>：通知操作员人工处理，代价小，是目前操作系统常用的方法。</li>
<li><strong>自动恢复</strong>：<ul>
<li><strong>进程终止</strong>：<ul>
<li><strong>中止所有死锁进程</strong>：代价大，但肯定可以解决死锁。</li>
<li><strong>一次中止一个进程</strong>：开销大，每中止一个进程都要调用死锁检测算法。</li>
</ul>
</li>
<li><strong>资源抢占</strong>：抢占一些进程的资源给其他进程使用，直到死循环被打破。<ul>
<li>选择一个牺牲进程：于进程中止类似，需要选择合适的被抢占进程序列来最小化代价。</li>
<li><strong>回滚</strong>：使被抢占资源的进程返回到安全的状态，然后重新开始进程。</li>
<li><strong>饥饿</strong>：同样进程的可能总是被牺牲。需要防止同一个进程总是被选中抢占资源，应在代价因素中加入<strong>回滚次数</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="基本硬件"><a href="#基本硬件" class="headerlink" title="基本硬件"></a>基本硬件</h3><ul>
<li>程序必须<strong>装入内存</strong>才可以执行。</li>
<li>CPU可以直接访问的存储器只有<strong>主存高速缓存</strong>和<strong>寄存器</strong>。</li>
<li>CPU内置的寄存器通常只需要一个（或少于一个）CPU时钟周期内就可以完成访问。而内存通常需要多个CPU时钟周期来访问。所以CPU在已读入指令但尚未从内存读取完数据时，会暂停。</li>
<li>为了解决CPU的暂停，提高CPU利用率，在内存和CPU之间引入了<strong>高速缓存Cache</strong>。其主要的功能是<strong>协调CPU和内存的访问速度差异，通常位于CPU芯片上</strong>。高速缓存Cache将频繁需要读取的数据从内存暂存到Cache内，从而加快CPU的访问速度。</li>
<li>内存保护需要保证正确的操作。</li>
</ul>
<h3 id="缓冲-VS-缓存"><a href="#缓冲-VS-缓存" class="headerlink" title="缓冲 VS 缓存"></a>缓冲 VS 缓存</h3><p> <strong>Buffer</strong>（缓冲区）是系统两端处理<strong>速度平衡</strong>（从长时间尺度上看）时使用的。它的引入是为了减小短期内突发I/O的影响，起到<strong>流量整形</strong>的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。例如：观看视频时的缓冲。</p>
<p>Buffer可以将突发的大数量较小规模的 I/O 整理成平稳的小数量较大规模的 I/O，以<strong>减少响应次数</strong> 。例如：下载电影时，不可能每下载几个字节就存入硬盘，效率会非常低下，通常需要积攒一定量的数据才能够存入硬盘。</p>
<p><strong>Cache</strong>（缓存）则是系统两端处理<strong>速度不匹配</strong>时的一种<strong>折衷策略</strong>。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的<strong>局部性</strong>（locality）特征，通过使用<strong>存储系统分级</strong>（memory hierarchy）的策略来减小这种差异带来的影响。 </p>
<p>Cache 是为了弥补<strong>高速设备和低速设备</strong>的鸿沟而引入的中间层，最终起到<strong>加快访问速度</strong>的作用。 可以将常用的数据存在高速缓存中，以提高存取速度，提升性能。</p>
<p><strong>Buffer和Cache在一般情况下其实可以混用。Buffer一般用于内存与外部设备之间，Cache一般用于CPU和内存之间。Buffer是顺序存取的，而Cache是随机存取的。</strong></p>
<h3 id="内存管理的目的"><a href="#内存管理的目的" class="headerlink" title="内存管理的目的"></a>内存管理的目的</h3><p>目的：</p>
<ul>
<li>提高<strong>内存利用率</strong>。</li>
<li>提高<strong>指令执行速度</strong>。</li>
<li>保证指令<strong>安全运行</strong>。</li>
</ul>
<p>功能：</p>
<ul>
<li>内存<strong>分配</strong></li>
<li>内存<strong>回收</strong></li>
<li>地址<strong>转换</strong></li>
<li>存储<strong>保护</strong></li>
<li>内存<strong>共享</strong></li>
</ul>
<h3 id="逻辑地址与物理地址"><a href="#逻辑地址与物理地址" class="headerlink" title="逻辑地址与物理地址"></a>逻辑地址与物理地址</h3><ul>
<li>逻辑地址：<ul>
<li>在CPU内产生</li>
<li>在进程内的<strong>相对地址</strong></li>
<li>也称<strong>虚地址、相对地址、程序地址</strong>。</li>
<li>逻辑地址空间：由程序所生成的所有逻辑地址的集合。</li>
</ul>
</li>
</ul>
<p><img src="%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80.png" alt="逻辑地址"></p>
<ul>
<li>物理地址：<ul>
<li>内存中的地址</li>
<li><strong>所有内存统一编址</strong></li>
<li>也称<strong>实地址、绝对地址</strong>。</li>
<li>物理地址空间：由逻辑地址所对应的所有物理地址的集合。</li>
</ul>
</li>
</ul>
<p><img src="%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80.png" alt="物理地址"></p>
<p>使用逻辑地址，可以方便地通过<strong>重定位机制</strong>修改进程在内存中的位置。</p>
<p><img src="%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="地址转换"></p>
<p>用户程序所对应到的是逻辑地址，物理地址对它从来都<strong>不可见</strong>。</p>
<h3 id="地址绑定"><a href="#地址绑定" class="headerlink" title="地址绑定"></a>地址绑定</h3><p>每个进程<strong>独立拥有</strong>一个内存空间：</p>
<p><img src="%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.png" alt="内存空间"></p>
<ul>
<li><strong>基地址寄存器</strong>：位于CPU上，存储CPU正在运行的进程最小的合法物理内存地址，主要用于<strong>地址转换</strong>。</li>
<li><strong>界限地址寄存器</strong>：位于CPU上，存储CPU正在运行的进程内存的范围，主要用于<strong>地址合法性检验</strong>。</li>
<li>CPU在执行指令时，需要进行<strong>地址合法性验证</strong>。</li>
</ul>
<p><img src="%E5%9C%B0%E5%9D%80%E5%90%88%E6%B3%95%E6%80%A7.png" alt="地址合法性"></p>
<p><strong>地址绑定</strong>：编译器将源程序中的指令和数据绑定到<strong>可重定位的地址（逻辑地址）</strong>，链接程序或加载程序再<strong>将逻辑地址绑定到物理地址</strong>。</p>
<p>一个程序运行的流程：<strong>编译（编译成机器码）–&gt;链接（链接外部模块）–&gt;加载（加载进内存）–&gt;执行</strong>。</p>
<p><strong>地址绑定的时机</strong>：</p>
<ul>
<li><strong>编译时</strong>：若编译时已知进程在内存中驻留的地址，即可生成绝对代码。如果未来地址发送变化，程序需要<strong>重新编译</strong>。例如：MS-DOS的.COM格式程序再编译时完成地址绑定。（<strong>静态重定位，不需要硬件支持</strong>）</li>
<li><strong>加载时</strong>：如果编译时不知道进程即将驻留的地址，可以编译生成可重定位代码。加载时再进行绑定，此时若内存地址发生变化，只需要<strong>重新加载程序</strong>。（<strong>静态重定位，不需要硬件支持</strong>）</li>
<li><strong>运行时</strong>：如果一个进程在运行时可从一个内存段移到另一个内存段，那么绑定将延迟到运行时进行。如果要改变内存地址，只需要改变基址寄存器的值即可。（<strong>动态重定位，需要硬件支持，如基址寄存器和界限地址寄存器和MMU，为大多数操作系统采用</strong>）</li>
</ul>
<p>动态重定位的地址绑定是在<strong>每次执行指令</strong>时才进行的。每次移动进程时只是改变<strong>重定位寄存器</strong>里的内容，不进行地址变换。</p>
<p>一般而言，<strong>静态重定位适合于内存地址不发生改变的存储管理方式</strong>，如：<strong>固定分区存储管理。</strong></p>
<p><strong>动态重定位适合于内存地址常常需要动态改变的存储管理方式</strong>，如：<strong>分段式存储、分页式存储、可变分区存储（紧缩）等。</strong></p>
<h3 id="内存管理单元MMU"><a href="#内存管理单元MMU" class="headerlink" title="内存管理单元MMU"></a>内存管理单元MMU</h3><ul>
<li>完成从逻辑地址到物理地址的<strong>运行时映射（动态重定位）</strong>。</li>
<li>是CPU用来管理内存的<strong>控制线路</strong>。</li>
<li>在MMU策略中，基址寄存器（重定位寄存器）中的值在其送入内存的时候被加入到由一个用户进程所产生的每个地址中。</li>
</ul>
<p><img src="MMU.png" alt="MMU"></p>
<h3 id="动态加载和动态链接机制"><a href="#动态加载和动态链接机制" class="headerlink" title="动态加载和动态链接机制"></a>动态加载和动态链接机制</h3><p>一个程序运行的流程：<strong>编译（编译成机器码）–&gt;链接（链接外部模块）–&gt;加载（加载进内存）–&gt;执行</strong>。但链接和加载有时也可以在执行时动态进行。</p>
<ul>
<li>动态链接（运行时链接）：将链接（多个代码文件合并为一个单一的文件）延迟到运行时执行。需要操作系统的支持。</li>
<li>动态加载（运行时加载）：将不常用的代码（例如用于异常处理的代码）写入到模块程序中，只有当需要时才会加载进入内存。优点是<strong>提高了内存空间利用率</strong>。它不需要系统提供特别的支持，通常是程序员实现。例子：<strong>Windows操作系统的各种DLL库</strong>。</li>
</ul>
<h3 id="存储保护机制"><a href="#存储保护机制" class="headerlink" title="存储保护机制"></a>存储保护机制</h3><p>存储保护机制主要是为了防止程序相互<strong>越界访问</strong>：</p>
<ul>
<li>访问<strong>超过限长</strong>的内存。</li>
<li>访问<strong>不在自己逻辑地址空间内</strong>的内存。</li>
</ul>
<h3 id="内存存储管理机制"><a href="#内存存储管理机制" class="headerlink" title="内存存储管理机制"></a>内存存储管理机制</h3><h4 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h4><p>碎片主要指的是<strong>因为某些原因导致的不可用内存空间</strong>，会导致内存利用率下降。</p>
<ul>
<li><strong>外部碎片</strong>：虽然整个可用内存空间可以用来满足一个进程的请求，但它<strong>不是连续</strong>的。这些不连续的小孔就是外部碎片，会被浪费。主要出现在：<strong>可变分区内存分配、分段式内存分配</strong>等。</li>
<li><strong>内部碎片</strong>：分配给进程的内存是固定大小的分区，<strong>有可能大于进程申请的内存</strong>，那么多出来的内存将被浪费。主要出现在：<strong>固定分区内存分配、分页式内存分配等</strong>。</li>
</ul>
<h4 id="连续内存分配机制"><a href="#连续内存分配机制" class="headerlink" title="连续内存分配机制"></a>连续内存分配机制</h4><p>连续内存分配：为一个用户程序分配一个<strong>连续的内存空间</strong>。是<strong>早期</strong>的内存分配方式，适用于<strong>内存容量较小</strong>的系统。缺点：<strong>内存利用率低，存在很多碎片。</strong>一个进程的逻辑地址空间必须被分配一块连续的物理内存。</p>
<h5 id="单一连续内存分配"><a href="#单一连续内存分配" class="headerlink" title="单一连续内存分配"></a>单一连续内存分配</h5><p><strong>单道程序环境</strong>下，仅装有一道用户程序，即只在内存中装入一个程序，整个内存的用户空间由该程序独占。例子：CP/M、MS-DOS、RT11。</p>
<h5 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h5><ul>
<li>最早的、也是最简单的一种可运行<strong>多道程序</strong>的存储管理方式</li>
<li>预先把可分配的主存空间分割成<strong>若干个连续区域</strong>，称为一个<strong>分区</strong></li>
<li>每个分区的大小<strong>可以相同也可以不同</strong>。但分区大小<strong>固定不变</strong>，每个分区装一个且只能装一个连续的程序<ul>
<li>分区大小相同：<ul>
<li>缺乏灵活性，程序太大装不下，程序太小浪费内存。</li>
<li>某些情况下可用，例如管理多个相同对象。</li>
</ul>
</li>
<li>分区大小不同：<ul>
<li>许多小分区</li>
<li>适量中分区</li>
<li>少量大分区</li>
</ul>
</li>
</ul>
</li>
<li><strong>存在内碎片，不存在外碎片。</strong></li>
</ul>
<p><img src="%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA.png" alt="固定分区分配"></p>
<h5 id="可变分区分配"><a href="#可变分区分配" class="headerlink" title="可变分区分配"></a>可变分区分配</h5><p>与固定分区分配的区别在<strong>分区大小是否可以动态改变</strong>。</p>
<ul>
<li>分区(孔、Hole)—可用的内存块，不同大小的分区分布在整个内存中</li>
<li>当一个进程到来的时候，它将从一个足够容纳它分区中分配内存。如果这个分区太大，可以将其分为两块，<strong>一块分配给进程，一块还给空闲分区表</strong>。当进程使用完毕后，将返还分配给它的分区给孔集合。分配策略：<ul>
<li><strong>首次适应</strong>：分配首个足够大的孔</li>
<li><strong>最优适应</strong>：分配最小的足够大的孔</li>
<li><strong>最差适应</strong>：分配最大的足够大的孔</li>
<li>在速度和存储空间的利用上，首次适应和最佳适应要好于最差适应。首次使用在速度上比最有适应更快。</li>
</ul>
</li>
<li>操作系统包含以下信息：<ul>
<li>已分配的分区-<strong>已分配分区表</strong></li>
<li>空的分区-<strong>空闲分区表</strong></li>
</ul>
</li>
<li>内存回收：新孔产生时（被分出来或者被返还），需要进行<strong>内存回收</strong>，当新孔与其他孔相邻，可以将这些孔<strong>合并</strong>为更大的孔。</li>
<li><strong>存在外碎片，不存在内碎片</strong>。</li>
<li>解决外部碎片的方法：<strong>紧缩</strong>。移动内存内容，<strong>将外部碎片合并为一整块内存空间</strong>。只有当重定位是动态且在运行时进行，才可以紧缩。紧缩是运行时动态进行的。<strong>开销很大，现在一般使用非连续内存分配解决外碎片</strong>。</li>
</ul>
<p><img src="%E7%B4%A7%E7%BC%A9.png" alt="紧缩"></p>
<h4 id="非连续内存分配机制"><a href="#非连续内存分配机制" class="headerlink" title="非连续内存分配机制"></a>非连续内存分配机制</h4><p>非连续内存分配最大的特点是<strong>允许分配给进程的内存空间是不连续的</strong>，只要有可用的内存就可以分配给进程，大大提高了内存利用率。</p>
<h5 id="分页式内存分配"><a href="#分页式内存分配" class="headerlink" title="分页式内存分配"></a>分页式内存分配</h5><p><img src="%E5%88%86%E9%A1%B5%E6%A8%A1%E5%9E%8B.png" alt="分页模型"></p>
<ul>
<li><p>分页：把<strong>物理内存</strong>分成<strong>等大小</strong>的块，叫做<strong>帧（frame）或页帧（还可以叫页框）</strong>。大小通常由硬件决定，<strong>是2的幂</strong>。把<strong>逻辑内存</strong>分成<strong>大小相同</strong>的块，叫做<strong>页（page）或页面</strong>。把<strong>备份存储</strong>分成<strong>大小相同或整数倍</strong>的<strong>块（block，也叫物理块)</strong>，主要用于<strong>虚拟内存</strong>技术。</p>
</li>
<li><p>当需要执行一个进程时，它的页从<strong>文件系统或备份存储</strong>中，加载至内存的<strong>可用帧</strong>。系统通过<strong>帧表</strong>保留所有的空闲帧。逻辑内存到物理内存的映射由<strong>页表</strong>实现。每一个进程都拥有一个自己的页表，<strong>存放着自己的逻辑地址空间（页）与物理地址空间（帧）的映射。</strong></p>
</li>
<li><p>分页使逻辑内存完全<strong>独立</strong>于物理内存。它<strong>解决了外部碎片，但仍有内部碎片</strong>。</p>
</li>
<li><p>分页与分段相比：</p>
<ul>
<li>优点：避免了<strong>外部碎片和紧缩</strong>，也避免了<strong>将不同大小的内存块匹配到交换空间的麻烦问题（虚拟内存，调页机制）</strong>。</li>
<li>缺点：<strong>不方便共享内存</strong>，因为页在逻辑上没有意义。而段在逻辑上有意义，例如代码段、堆栈段、数据段、附加段等。</li>
</ul>
</li>
<li><p>地址转换机制：</p>
<ul>
<li>一个数据的<strong>逻辑地址</strong>表示通常为：<strong>页码+页偏移</strong>。</li>
<li>页码用来作为<strong>页表的索引</strong>，我们通过页码在页表中找到页对应的帧号。</li>
<li>页偏移表示<strong>数据在当前页内的偏移值</strong>。通过页偏移和帧号，我们可以最终获取该逻辑地址所在的物理地址。</li>
</ul>
<p><img src="%E5%88%86%E9%A1%B5%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80.png" alt="分页逻辑地址"></p>
</li>
</ul>
<p><img src="%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="逻辑地址转换"></p>
<ul>
<li>空闲帧的分配：优先选择帧表中<strong>靠前</strong>的空闲帧分配给新进程</li>
<li>共享页:<ul>
<li>分页的优点之一是可以<strong>共享公共代码</strong>。</li>
<li>如果代码是<strong>可重入代码或者纯代码</strong>，那么它可以被共享。可重入代码是不能自我修改（只读）的代码，它在执行期间不会改变。因此多个进程可以执行相同的代码。需要注意的是共享代码在进程的逻辑地址空间内的位置需要一致。</li>
<li>私有代码和数据不可以被共享，存有私有数据和代码的页能够出现在逻辑地址空间的任意位置。</li>
</ul>
</li>
</ul>
<h5 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h5><ul>
<li><p>页表的实现：</p>
<ul>
<li>早期实现：把页表作为一组专用的<strong>寄存器</strong>，适用于<strong>页表条目很少</strong>的情况。</li>
<li>现代：由于页表条目现在非常大，需要将它放在<strong>内存</strong>中，并将<strong>页表基地址寄存器（PTBR）</strong>指向它的基地址。<strong>页表限长寄存器(PRLR)</strong>表明页表的长度。</li>
</ul>
</li>
<li><p>页表的读取：</p>
<ul>
<li><p>直接访问内存中的页表，再访问所需数据/指令：需要<strong>两次</strong>内存访问，延迟较高。</p>
</li>
<li><p>使用<strong>转换表缓冲区（TLB，也称联想寄存器）</strong>：它是<strong>高速硬件Cache</strong>（实际上，TLB起名时出错了，不应该叫Buffer，按照功能它叫做Cache更为合理），存储<strong>少数频繁访问的页表条目</strong>，它的访问几乎不需要额外的开销，将内存访问次数由两次减少到<strong>一次</strong>。</p>
<ul>
<li><p>所需条目在TLB中：直接读取帧号，计算物理地址并访问。</p>
</li>
<li><p>所需条目不在TLB中：从内存中的页表读取帧号，并将页码和帧号存入TLB，若TLB已满可采用相应的替换策略。</p>
<p><img src="TLB.png" alt="TLB"></p>
</li>
<li><p><strong>有效访问时间</strong>：假设从在TLB中查找一次平均需要a微秒，从内存中存取一次平均需要b微秒，命中率$\lambda$为在TLB中找到页号的百分比，比率与<strong>TLB的大小</strong>有关。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>页表的保护：</p>
<ul>
<li>超过页表限长：将页号与页表限长寄存器PTLR比较。</li>
<li>不在进程指定的逻辑内存空间内：在页表的项中加入一个有效-无效位，有效表示该页合法且在进程的逻辑地址空间内，无效表示不在进程的逻辑地址空间内。</li>
</ul>
</li>
<li><p>页表的结构：</p>
<ul>
<li><p>由于原始的单级页表需要<strong>连续存储</strong>，且目前的页表条目都很多，所以需要<strong>大量连续的内存空间</strong>来存储（页表必须加载进内存）。使用合适的页表结构可以减少占用的连续存储空间。</p>
</li>
<li><p><strong>层次页表</strong>：将页表再分页。使用时先利用外部页表的页码和外部页表的页偏移获取内部页表中的帧号，再计算物理地址，存取数据。<strong>（向前映射页表）</strong>除了二级页表以外，还支持三级页表甚至四级页表等。</p>
<p><img src="%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8.png" alt="二级页表"></p>
</li>
<li><p><strong>哈希页表</strong>：处理大于32位地址空间，防止存储时稀疏问题，解决了浪费。</p>
<ul>
<li>将虚拟页码哈希到哈希表，每个哈希表的条目中存储了一个<strong>链表</strong>（<strong>拉链法解决哈希时的碰撞</strong>），链表每个元素含有三个字段：（1）虚拟页码（2）帧号（3）指向下个元素的指针。</li>
<li>将虚拟页码与哈希表中第一个元素的第一个字段比较，如果相同，那么取出帧号计算物理地址。否则利用指针访问下个元素，再次比较。</li>
</ul>
<p><img src="%E5%93%88%E5%B8%8C%E9%A1%B5%E8%A1%A8.png" alt="哈希页表"></p>
</li>
<li><p><strong>倒置页表（反向页表）</strong>：通常，每个进程拥有一个页表，页表按照虚拟地址（页码）排序，操作系统通过页码可以直接访问页表的条目。但是这种方法<strong>对于每个进程创建一个页表，占用了大量物理内存，特别是对于虚拟内存技术</strong>。所以，可以使用倒置页表，<strong>为每个物理内存帧创建一个对应页的条目</strong>，使页表按照物理内存排序，所有进程共享一张页表。（倒排索引的思想）</p>
<ul>
<li>倒置页表不再包括<strong>进程逻辑地址空间的完整信息</strong>，每个进程必须将完整信息保存在外存上的<strong>外部页表</strong>中。外部页表按需调入内存。</li>
<li>优点：减少了物理内存的占用。</li>
<li>缺点：进程较少时，检索时间较长<strong>（原先直接访问，现在需要遍历搜索）</strong>。实现共享内存困难。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="分段式内存分配"><a href="#分段式内存分配" class="headerlink" title="分段式内存分配"></a>分段式内存分配</h5><p><img src="%E5%88%86%E6%AE%B5.png" alt="分段"></p>
<p>分段：不将内存看作是一个线性数组，而将其看成是不同区域组成的。逻辑地址由<strong>段号和段偏移</strong>组成。由逻辑地址到物理地址的映射由<strong>段表</strong>来实现，段表中的每个条目包含<strong>段基址和段界限</strong>。</p>
<ul>
<li>分段与分页最大的区别在于：<strong>段的大小不固定，而页的大小固定</strong>。</li>
<li>分段无法解决外部碎片，<strong>因为碎片大小可能会比所有请求的段大小更小</strong>。而分页可以解决外部碎片，因为进程的内存请求以固定大小的页为单位，孔至少是一个页，能够被分配给进程。</li>
<li>分段不存在内部碎片问题，因为分配给进程的内存块大小不是固定的。</li>
<li>分段的好处是易于共享内存，因为段具有实际意义。不同进程共享的段具有同样的段号。</li>
<li><strong>非连续内存存储才支持共享内存，连续内存存储每个进程的内存区域都是唯一的</strong>。</li>
</ul>
<h5 id="段页式内存分配"><a href="#段页式内存分配" class="headerlink" title="段页式内存分配"></a>段页式内存分配</h5><p>段页式：先分段，再分页，<strong>每个段的大小为页大小的整数倍</strong>。<strong>解决了单纯分段的外部碎片问题</strong>。</p>
<ul>
<li>逻辑地址：&lt;段号，页号，页内偏移&gt;。</li>
<li>两级分页中，<strong>外部页表中的内部页表数目固定，而段页式不固定。</strong></li>
<li>例子：intel 386.</li>
</ul>
<p><img src="%E6%AE%B5%E9%A1%B5%E5%BC%8F.png" alt="段页式"></p>
<h2 id="内存扩容技术"><a href="#内存扩容技术" class="headerlink" title="内存扩容技术"></a>内存扩容技术</h2><p>逻辑地址空间——用户希望看到的内存。物理地址空间——实际的内存。<strong>当逻辑地址空间大于物理地址空间，即在较小的内存中运行较大的进程时，需要进行内存扩容。</strong></p>
<p>原理：<strong>局部性原理</strong>，即程序往往不需要全部装入也可正常运行。与<strong>动态加载技术思想</strong>类似，运行时动态加载模块程序。</p>
<p>我们需要采用<strong>以时间换空间</strong>的方法，进行内存扩容。</p>
<h3 id="紧缩"><a href="#紧缩" class="headerlink" title="紧缩"></a>紧缩</h3><p>属于可变分区连续内存分配的一种<strong>减少外部碎片</strong>的方式，定期移动进程，使进程占用的内存空间集中在一头，从而扩大可用的内存容量。</p>
<h3 id="覆盖Overlaying"><a href="#覆盖Overlaying" class="headerlink" title="覆盖Overlaying"></a>覆盖Overlaying</h3><ul>
<li>解决问题：程序总大小超过物理内存大小。</li>
<li>解决方案：程序执行时，只在内存中常驻那些无论何时都需要的指令和数据。<strong>其余不必要的部分在程序执行时相互替换（覆盖）。</strong></li>
<li>解决人员：<strong>程序员</strong>设计覆盖方案，覆盖程序往往十分<strong>复杂</strong>，只应用于早期操作系统。</li>
</ul>
<h3 id="交换Swapping"><a href="#交换Swapping" class="headerlink" title="交换Swapping"></a>交换Swapping</h3><p><img src="%E4%BA%A4%E6%8D%A2.png" alt="交换"></p>
<ul>
<li><p>解决问题：在内存中的某些进程由于某事件尚未发生而被<strong>阻塞运行</strong>，但它却占用了大量的内存空间，导致许多进程在外存上等待，浪费资源、降低系统吞吐量。通过交换，可以使程序总大小超过实际物理内存大小。（其实就是<strong>进程调度中的中程调度</strong>）</p>
</li>
<li><p>解决方案：一个进程可以<strong>暂时</strong>被交换（swap）到内存外的一个<strong>备份区</strong>，随后可以被换回内存继续执行。备份区是一个<strong>固定的足够大的可以容纳所有用户内存映像拷贝的快速磁盘</strong>；必须提供对这些内存映像的直接访问。</p>
</li>
<li><p>滚入，滚出(Roll out, roll in )：交换由于基于优先级的算法而不同，低优先级的进程被换出，这样高优先级的进程可以被装入和执行。</p>
</li>
<li><p>交换时间的主要部分是转移时间，总的转移时间直接同交换的内存的数量成正比。交换较为耗时，通常100MB需要4ms。</p>
</li>
<li><p>考虑到性价比，一般只有当空闲内存不够时才可以采用交换。并且一般不会换出正在等待的进程。</p>
</li>
<li><p>交换与虚拟内存技术的区别在于：<strong>交换技术以一整个进程为单位，而虚拟内存技术以页为单位。</strong></p>
</li>
</ul>
<h3 id="虚拟内存技术"><a href="#虚拟内存技术" class="headerlink" title="虚拟内存技术"></a>虚拟内存技术</h3><p>虚拟内存技术：当进程运行时，<strong>先将其一部分装入内存，另一部分暂留在磁盘上的备份区</strong>，当要执行的指令或访问的数据不在内存时，由操作系统自动完成将它们从磁盘调入内存执行。</p>
<ul>
<li>虚拟地址空间：分配给进程的虚拟内存。</li>
<li>虚拟地址：在虚拟内存中指令或数据的位置。</li>
<li>虚拟内存：把内存和磁盘结合起来使用，得到一个容量很大的“内存”，即虚存。其中，物理内存上的数据可以通过页表直接被访问，但<strong>如果访问到磁盘上的数据，即备份数据，需要先将其调入到内存上的空闲帧</strong>，若无空闲帧，则需要先将其利用<strong>置换算法</strong>与内存中的某个帧交换，再更新<strong>页表的项目</strong>，并<strong>重启指令</strong>执行访问。</li>
</ul>
<p>虚拟内存的大小决定因素：</p>
<ul>
<li><strong>操作系统字长</strong>：决定了逻辑地址的最大长度，自然也决定了虚拟内存的大小。如果操作系统字长不够大，那么内存再大，也无法被正确寻址并使用。例如：32位字长的操作系统最大只支持4GB的内存，现已被逐渐淘汰。</li>
<li><strong>内存外存容量和</strong></li>
</ul>
<p>虚拟内存的实现手段主要有：</p>
<ul>
<li><strong>虚拟页式</strong>（虚拟存储技术+页式存储管理）<ul>
<li><strong>请求调页</strong>（ Demand paging ）：进程运行开始前，只装入<strong>0个或1个页面</strong>，其余页面动态调入</li>
<li><strong>预调页</strong>（Prepaging）：进程运行开始前，将<strong>所有的页面</strong>一次性装入</li>
</ul>
</li>
<li><strong>虚拟段式</strong>（虚拟存储技术+段式存储管理）</li>
</ul>
<p><strong>虚拟页式+请求调页机制</strong>是目前虚拟内存技术最为常用的方法。</p>
<h4 id="请求调页机制"><a href="#请求调页机制" class="headerlink" title="请求调页机制"></a>请求调页机制</h4><p>进程运行开始时，仅装入<strong>一个或零个页面</strong>，所有的数据和指令大都存放在<strong>备份存储（外存）</strong>而非内存中。当进程执行过程中，根据进程的需求，动态装入页面，即<strong>将外存中固定块的内容装入内存中的某一帧，并更新页表</strong>。当内存已满时，需要利用<strong>页面置换</strong>算法，将<strong>低优先级的页面置换出去</strong>。如果事先只装入零个页面，则叫做<strong>纯请求分页</strong>。</p>
<p>请求调页机制的优点：</p>
<ul>
<li><strong>I/O操作少</strong></li>
<li><strong>需要很少的内存</strong></li>
<li><strong>快速响应</strong></li>
<li><strong>多用户</strong></li>
</ul>
<p>请求调页机制使用<strong>惰性（lazy）</strong>的<strong>调页程序（pager）</strong>，即只调入被需要的页面。</p>
<p><img src="%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5.png" alt="请求调页"></p>
<p>每一个页表的表项有一个<strong>有效-无效位</strong>相关联：</p>
<ul>
<li>1代表有效，即该页面<strong>在内存中并且合法</strong>。</li>
<li>0代表无效，有两种情况：<ul>
<li><strong>页面合法但不在内存中</strong>（可以利用调页程序调入），</li>
<li><strong>页面不合法</strong>（超过限长或不在逻辑地址空间内）。</li>
</ul>
</li>
</ul>
<p><strong>缺页中断</strong>：对一个页面的首次访问，需要陷入操作系统的<strong>缺页中断</strong>。（中断指的是操作系统中止CPU中正在执行的程序，转向中断服务程序进行执行，完成后再恢复原程序的执行。分为软中断和硬中断。系统调用属于软中断。）</p>
<p><strong>缺页中断的过程</strong>（6步，非常重要）：</p>
<ol>
<li>访问指令或数据，如果对应的页表有效-无效位为1，则直接访问对应的帧。否则，进入第2步。</li>
<li>查看操作系统中的另一个表来判断：<ol>
<li>页面合法但不在内存中：进入第3步。</li>
<li>页面不合法：终止，报错。</li>
</ol>
</li>
<li>找到页在备份存储中的位置。</li>
<li>查看帧表：<ol>
<li>如果无空闲帧，那么使用页面置换算法换出一个低优先级的帧，并且：<ol>
<li>如果这个帧自从调入内存以来没有被修改过，那么直接覆盖。</li>
<li>如果这个帧被修改过，需要先将其写入到备份区，再覆盖。</li>
</ol>
</li>
<li>如果有空闲帧，直接将当前页调入该帧内。</li>
</ol>
</li>
<li>重新设置页表，将对应页的有效位置1。</li>
<li>重启指令。</li>
</ol>
<p><img src="%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD.png" alt="缺页中断"></p>
<p>一条指令可能导致多个缺页中断（涉及多个页面）</p>
<p><img src="%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2.png" alt="需要页面置换的情况"></p>
<p><strong>硬件支持</strong>：</p>
<ul>
<li>带有效无效位的页表。</li>
<li>交换空间。</li>
<li>指令重启。</li>
</ul>
<p><strong>请求调页时内存的有效访问时间</strong>：</p>
<ul>
<li>缺页率（缺页的概率）：0 &lt;=p&lt;= 1.0（纯请求调页机制，进程刚开始时缺页率为100%）</li>
<li><strong>有效访问时间：EAT=(1-p) <em> 内存访问时间+P </em> 缺页错误处理时间</strong></li>
<li><strong>缺页错误处理时间=处理缺页中断+ [页交换出去时间 ]+ 读入页时间+ 重启进程开销。</strong>（因为对于在被调入后没有被修改过的页面，将它再次换出没有任何意义，所以可以不换出，从而减少缺页错误时间）</li>
<li><img src="%E7%BC%BA%E9%A1%B5%E9%94%99%E8%AF%AF.png" alt="缺页错误"></li>
</ul>
<p><strong>请求调页的性能优化</strong>：</p>
<ul>
<li>页面转换时采用交换空间，而不是文件系统：交换区的块大，比文件系统服务快速。</li>
<li>在进程装载时，把整个进程拷贝到交换区，基于交换区调页，早期的 BSD Unix。</li>
<li>利用文件系统进行交换：Solaris和当前的BSD，部分内容仍旧需要交换区（堆栈等）</li>
</ul>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>页面置换：当<strong>需要调入新的页面而内存中无空闲帧</strong>时，要将内存中不常使用的页面换出（<strong>牺牲</strong>）。同一页面可能被装入内存多次。</p>
<p>如果发生页置换，则缺页处理时间加倍，使用<strong>修改位modify bit或脏位 (dirty bit)</strong> 来防止页面转移过多：<strong>只有在被读入内存后被修改的页面才写入磁盘。</strong></p>
<p>页面置换算法的目的：找出一个<strong>最小缺页率</strong>的访问算法，<strong>减少缺页中断次数</strong>。</p>
<h5 id="先进先出（FIFO）算法"><a href="#先进先出（FIFO）算法" class="headerlink" title="先进先出（FIFO）算法"></a>先进先出（FIFO）算法</h5><ul>
<li>置换在内存中<strong>停留时间最久</strong>的页面。</li>
<li>使用FIFO队列完成，<strong>容易理解和实现，但性能不总是很好</strong>。（类似于<strong>FCFS</strong>进程调度算法）</li>
<li>FIFO算法可能导致<strong>Belady异常，即给进程分配的帧数越多，但缺页次数并没有下降。</strong></li>
</ul>
<blockquote>
<p> 先进先出的置换算法，完全不考虑使用频率，即使增加了帧数，多贮存的部分接下来常访问可能性也不一定大（看运气），也就并不一定能增加命中率。 </p>
</blockquote>
<p><img src="FIFO.png" alt="FIFO"></p>
<h5 id="最优置换选择（OPT）算法"><a href="#最优置换选择（OPT）算法" class="headerlink" title="最优置换选择（OPT）算法"></a>最优置换选择（OPT）算法</h5><ul>
<li>置换在<strong>最远的将来才需要被使用或未来不需要再使用</strong>的页面。</li>
<li><strong>缺页错误率最低，不会产生Belady异常，但是难以实现</strong>，因为<strong>需要未来知识</strong>（SJF进程调度算法同理），通常只用于在实验中比较研究。</li>
</ul>
<p><img src="OPT.png" alt="OPT"></p>
<h5 id="最近最少使用（LRU）算法"><a href="#最近最少使用（LRU）算法" class="headerlink" title="最近最少使用（LRU）算法"></a>最近最少使用（LRU）算法</h5><ul>
<li>置换<strong>最长时间没有被使用</strong>的页面。</li>
<li>性能近似于OPT，但是需要硬件的支持：<strong>计数器或堆栈</strong>，<strong>开销较大</strong>。</li>
<li>Leetcode上的算法题使用双向链表加哈希表实现LRU。</li>
</ul>
<p><img src="LRU.png" alt="LRU"></p>
<h5 id="近似LRU算法——二次机会法"><a href="#近似LRU算法——二次机会法" class="headerlink" title="近似LRU算法——二次机会法"></a>近似LRU算法——二次机会法</h5><ul>
<li><p>当操作系统不提供硬件支持时，可以使用<strong>引用位</strong>实现近似LRU算法。</p>
</li>
<li><p>二次机会法：</p>
<ul>
<li>初始时，将所有内存中的页面的引用位设为0。</li>
<li>当页面被引用时，将其引用位设为1。</li>
<li>当需要置换时，顺时针遍历内存中所有页面。如果找到的页的引用位为0，那么将其置换；为1，则将其改为0，继续遍历。<strong>（频繁被引用的页，其引用位总是会被置为1，所以会被后置换）</strong></li>
<li>当所有页的引用位都为1时，二次机会法退化为FIFO算法。</li>
</ul>
<p><img src="%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E6%B3%95.png" alt="二次机会法"></p>
</li>
<li><p>增强二次机会法：</p>
<ul>
<li>在二次机会法的基础上增加<strong>修改位</strong>。</li>
<li>选取优先级最高的先置换，<strong>最近没有被使用且没有被修改的页优先级最高</strong>。减少了IO次数。</li>
</ul>
</li>
</ul>
<h4 id="页框分配"><a href="#页框分配" class="headerlink" title="页框分配"></a>页框分配</h4><p>每个进程所需要的最小帧数由<strong>计算机架构</strong>决定：</p>
<ul>
<li>例子：IBM370的SS-MOV指令：<ul>
<li>指令是6个字节，并可能跨越2个页面</li>
<li>存储来源（from）可能需要2个页面</li>
<li>目的区域（to）可能需要2个页面</li>
<li>所以这个指令需要的最小帧数为6</li>
</ul>
</li>
</ul>
<p><strong>固定分配</strong>：</p>
<ul>
<li><strong>平均分配</strong>：如果有100个帧，和5个进程，则每个进程分给20个帧。</li>
<li><strong>比例分配</strong>：按照每个进程的大小分配。</li>
<li><strong>优先级分配</strong>：根据优先级而不是进程大小来使用比率分配策略</li>
</ul>
<h4 id="置换方式"><a href="#置换方式" class="headerlink" title="置换方式"></a>置换方式</h4><p><strong>全局置换</strong>：每个进程可以从<strong>所有帧的集合</strong>中选择一个进行页面置换，而不用管该帧是否已分配给其它进程。<strong>高优先级进程可以选择低优先级进程的帧来置换</strong>。</p>
<p><strong>局部置换</strong>：每个进程只能在<strong>自己的帧中</strong>进行选择。</p>
<p>全局置换往往具有<strong>更好的系统吞吐量</strong>，更为常用。</p>
<h4 id="颠簸"><a href="#颠簸" class="headerlink" title="颠簸"></a>颠簸</h4><p>颠簸（抖动）:一个进程的页面<strong>经常换入换出</strong>。</p>
<ul>
<li>原因：<ul>
<li>进程分配的<strong>帧数不足</strong>，小于局部大小之和。、<ul>
<li><strong>增大内存</strong>。</li>
<li><strong>减少多道程序道数</strong>。</li>
</ul>
</li>
<li>页面置换算法<strong>不合理</strong>。<ul>
<li>更换算法。</li>
</ul>
</li>
</ul>
</li>
<li>后果：<ul>
<li>CPU利用率低，而分页磁盘（即备份存储，用于存储尚未调入内存时逻辑内存中的页面）利用率很高，因为此时系统频繁进行页面置换，CPU需要等待。</li>
<li>由于此时CPU利用率很低，操作系统认为需要增加多道程序的道数，调入新进程，进而导致更多的缺页错误和更长的调页设备队列。<strong>恶性循环</strong>。</li>
</ul>
</li>
<li>使用<strong>局部置换策略</strong>或者<strong>优先级置换策略</strong>，可以限制系统的抖动，防止一个抖动进程使用其他运行中的进程的帧进行页面置换，从而导致抖动的扩散。</li>
<li>局部模型：<strong>进程由一个局部转向另一个局部</strong>。</li>
<li><strong>工作集模型</strong>基于局部模型，认为进程始终只使用到一部分页面。是解决颠簸问题的一个方法。<ul>
<li>检查最近$\delta$个页面引用，这些页面引用的页面集合就是工作集。</li>
<li>系统监视每个进程的工作集，并为它分配<strong>大于其工作集帧数的帧</strong>。</li>
<li>当所有进程的工作集帧数之和大于当前系统可用帧数时，系统将发生抖动，<strong>需要暂停一个进程</strong>。</li>
<li>困难：<strong>跟踪工作集</strong>。</li>
</ul>
</li>
<li><strong>缺页率（PFF）策略</strong>：设置可接受的缺页率。<ul>
<li>如果缺页率太低，回收一些进程的页框。</li>
<li>如果缺页率太高，就分给进程一些页框。</li>
</ul>
</li>
</ul>
<h3 id="内核内存分配"><a href="#内核内存分配" class="headerlink" title="内核内存分配"></a>内核内存分配</h3><p> 用户态的内存分配和内核态的内存分配不一样：</p>
<ul>
<li><p>内核需要为不同大小的数据结构请求内存，其中有的小于一页。因此，内核应<strong>保守</strong>地使用内存，并努力<strong>最小化碎片浪费</strong>。</p>
</li>
<li><p>内核内存分配可能需要<strong>连续的物理内存</strong>。</p>
<p>内核内存分配的特点：</p>
</li>
<li><p>内存块<strong>尺寸小</strong>；</p>
</li>
<li><p>占用内存块的<strong>时间短</strong>；</p>
</li>
<li><p>要求<strong>快速</strong>完成分配和回收；</p>
</li>
<li><p><strong>不参与交换</strong>；</p>
</li>
<li><p>频繁使用<strong>尺寸相同</strong>的物理块，存放同样大小的数据；</p>
</li>
<li><p>要求<strong>动态</strong>分配和回收。</p>
</li>
</ul>
<p>内核内存管理策略：</p>
<ul>
<li><p><strong>伙伴系统</strong>：</p>
<ul>
<li>主要用于<strong>Linux早期版本</strong>中内核底层内存管理；</li>
<li>从<strong>物理上连续的大小固定的段</strong>上分配内存；</li>
<li>主要思想：内存按2的幂的大小进行划分，即4KB、8KB等，组成若干空闲块链表；查找链表找到满足进程需求的最佳匹配块<ul>
<li>首先将整个可用空间看作一块: 2^n</li>
<li>假设进程申请的空间大小为s，如果满足2^n-1&lt;s&lt;=2^n，则分配整个块</li>
<li>否则，将块划分为两个大小相等的伙伴，大小为2^n-1,一直划分下去直到产生大于或等于s的最小块</li>
</ul>
</li>
<li>优点：通过合并的技术，可以将相邻的伙伴<strong>迅速组合</strong>以形成更大的分段；</li>
<li>缺点：由于圆整到下一个2的幂，所以很可能造成<strong>内部碎片</strong>浪费。</li>
</ul>
<p><img src="%E4%BC%99%E4%BC%B4.png" alt="伙伴"></p>
</li>
<li><p><strong>slab分配</strong>:</p>
<ul>
<li>本质上仍然是分页，但物理页面在内存中是连续的，我认为有些类似于分页的可变分区分配</li>
<li>Slab 是由一个或多个物理上<strong>连续的页</strong>组成</li>
<li>Cache 含有一个或多个 slab</li>
<li>每个内核数据结构都有一个cache，用于存储内核数据结构对象<strong>实例</strong>（<strong>每个数据结构一个Cache，每个Cache一个或多个Slab，每个Slab一个或多个物理连续的页</strong>）</li>
<li>优点：<ul>
<li>没有因碎片而引起内存浪费；</li>
<li>可以快速满足内存请求。</li>
</ul>
</li>
</ul>
<p><img src="slab.png" alt="slab"></p>
</li>
</ul>
<h3 id="虚拟内存技术拓展"><a href="#虚拟内存技术拓展" class="headerlink" title="虚拟内存技术拓展"></a>虚拟内存技术拓展</h3><h4 id="预调页"><a href="#预调页" class="headerlink" title="预调页"></a>预调页</h4><p>① 纯请求调页时，当进程启动时，会产生大量的缺页中断。</p>
<p>② 预调页是在进程开始时，调入进程所需的全部或部分页面，减少了开始阶段的<strong>缺页错误</strong>。有的操作系统对于<strong>小文件</strong>采用预调页，如Solaris。</p>
<p>③ 优点：减少了处理缺页错误的成本。</p>
<p>④ 缺点：如果预先调入的页面不被使用，则会造成内存浪费。</p>
<h4 id="页大小"><a href="#页大小" class="headerlink" title="页大小"></a>页大小</h4><p>没有最佳答案，总的来说，趋向<strong>更大的页</strong>。</p>
<p>① 减少内部碎片 – 需要小的页</p>
<p>② 减少页表大小 – 需要大的页</p>
<p>③ 减少读取或写入页面的I/O 开销 – 需要大的页</p>
<p>④ 每个页面更精确地匹配程序的局部性 – 需要小的页</p>
<p>⑤ 减少缺页次数 – 需要大的页</p>
<h4 id="TLB范围"><a href="#TLB范围" class="headerlink" title="TLB范围"></a>TLB范围</h4><p>① TLB 范围 – 通过TLB所访问的内存量</p>
<p>② TLB 范围 = (TLB 大小) X (页大小)</p>
<p>③ 理想情况：<strong>一个进程的工作集应存放在TLB中</strong></p>
<p>④ 增大TLB范围的方法（更快的读取页面）：</p>
<ul>
<li><strong>增大页的大小</strong>，但这可能导致内部碎片的增加;</li>
<li><strong>提供多种大小的页</strong>：这允许需要大页的应用程序有机会使用大页而不增加碎片的大小。</li>
</ul>
<h4 id="I-O互锁"><a href="#I-O互锁" class="headerlink" title="I/O互锁"></a>I/O互锁</h4><p>① 允许某些页在内存中被锁住；</p>
<p>② I/O时，正在进行I/O的页面不允许被置换算法置换出内存。</p>
<h4 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h4><p>① 程序结构可能影响系统性能</p>
<p>② 例子：</p>
<ul>
<li>array A[1024, 1024] of integer，数组的每行保存在一个页面中，创建一个进程遍历这个数组，为该进程分配一个帧。<ul>
<li><img src="%E7%A8%8B%E5%BA%8F1.png" alt="程序1"></li>
<li>程序1：1024 x 1024 缺页（每一次换一行访问，导致每一次遍历都需要产生缺页中断，进行页面置换）</li>
<li><img src="%E7%A8%8B%E5%BA%8F2.png" alt="程序2"></li>
<li>程序2：1024 次缺页（每一次访问完一个页面才会访问下一个）</li>
</ul>
</li>
<li>优先访问当前页面内的数据。</li>
</ul>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件概念"><a href="#文件概念" class="headerlink" title="文件概念"></a>文件概念</h3><p>文件：是计算机中<strong>信息存储</strong>的基本组织形式，是存储设备的<strong>逻辑存储单位</strong>，是记录在<strong>外存中</strong>的相关信息的命名组合。<strong>具有文件名</strong>。</p>
<p>文件名：文件系统的方便性体现在<strong>按名存取</strong>，方便人类用户的使用。通过文件的名称，可以访问文件的存储位置。文件名由一串ASCII码或(和)汉字构成，8.3规则规定文件名8个字符，类型3个字符，之间有“.”分割。长文件名规定可以最多输入255多个字符作为文件名。文件名可能大小写敏感。</p>
<p>文件结构：</p>
<ul>
<li>目的：<strong>便于程序理解文件内容</strong></li>
<li>文件结构：<ul>
<li><strong>无结构</strong>：文字流、字节流等</li>
<li><strong>简单记录结构</strong>：线性、固定长度、可变长度等</li>
<li><strong>复杂结构</strong>：格式化文档、多媒体文件等</li>
</ul>
</li>
<li>谁决定了文件结构<ul>
<li><strong>操作系统</strong></li>
<li><strong>程序</strong></li>
<li><strong>用户</strong></li>
</ul>
</li>
</ul>
<p>文件类型：</p>
<ul>
<li>文件类型一般由扩展名决定。文件扩展名也称文件后缀名，标识文件类型的一种机制。扩展名跟在主文件名后面，由一个分隔符“.”分隔。</li>
<li>Linux不严格区分文件类型。Windows严格区分。</li>
<li>例子：.txt,.exe,.doc…</li>
</ul>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>文件相关操作主要有：</p>
<ul>
<li>创建文件</li>
<li>写文件</li>
<li>读文件</li>
<li>在文件内重定位</li>
<li>删除文件</li>
<li>截断文件</li>
<li>打开文件：需要数据结构——<strong>打开文件表</strong>，存放文件指针、打开文件计数器、文件存储位置、访问权限等。</li>
<li>关闭文件<ul>
<li>为什么要进行打开文件、关闭文件：<ul>
<li>文件存放在外存上，打开文件操作将文件<strong>调入内存</strong>，</li>
<li><strong>方便文件共享</strong>。</li>
<li>提高<strong>文件存取效率</strong>，减少了<strong>调入内存的次数</strong>。</li>
</ul>
</li>
<li>打开、关闭是否必须：<strong>不必须</strong>，有的系统在每一次文件的读写操作都会<strong>隐式</strong>地进行打开文件和关闭文件，但这样效率很低，需要反复调入内存。</li>
</ul>
</li>
</ul>
<p><strong>创建文件、删除文件、打开文件、关闭文件</strong>等操作均不需要获知文件内容，只与目录有关。</p>
<p>而<strong>写文件、读文件、文件内重定位、截断文件</strong>等需要文件内容。</p>
<p>文件保护主要通过<strong>设置文件权限</strong>来进行。</p>
<h3 id="文件控制块FCB"><a href="#文件控制块FCB" class="headerlink" title="文件控制块FCB"></a>文件控制块FCB</h3><p>与线程、进程等类似，文件的管理也依赖于<strong>文件控制块FCB</strong>。文件控制块中，存放了文件相关的如下属性：</p>
<ul>
<li>文件名：<strong>人类可读</strong>的来保存的唯一信息。</li>
<li>文件标识符：<strong>人类不可读</strong>，通常为唯一的数字ID，用于给操作系统进行文件处理。</li>
<li><strong>文件位置</strong>：设备上文件位置的指针。<strong>（文件所在位置的索引）</strong></li>
<li>文件类型 ：文件的格式。</li>
<li>文件大小：文件当前大小。</li>
<li>保护：读、写、执行等访问控制信息。</li>
<li>时间、日期和用户标识：保护、安全和使用跟踪的数据。</li>
<li>……</li>
<li>文件属性保存在文件目录中的FCB。</li>
</ul>
<h3 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统包括：</p>
<ul>
<li><strong>文件逻辑结构</strong>（<strong>逻辑文件</strong>）：（每个文件<strong>内部</strong>记录的组织形式）<ul>
<li>文件内容的组织形式</li>
<li>面向<strong>用户</strong></li>
</ul>
</li>
<li><strong>目录（文件组织结构）</strong>：（每个文件整体<strong>之间</strong>的组织结构）<ul>
<li>文件的组织形式</li>
<li>存放了文件属性</li>
</ul>
</li>
<li><strong>文件物理结构（物理文件）</strong>：（文件在<strong>磁盘</strong>上的存储方式）<ul>
<li>文件的存储形式</li>
<li>面向<strong>系统</strong></li>
</ul>
</li>
</ul>
<h3 id="文件逻辑结构"><a href="#文件逻辑结构" class="headerlink" title="文件逻辑结构"></a>文件逻辑结构</h3><p>逻辑文件：</p>
<ul>
<li>文件内容信息<strong>呈现在用户面前</strong>的<strong>组织结构</strong></li>
<li>逻辑文件决定了文件存储的信息的<strong>访问方法</strong></li>
<li>是影响<strong>文件访问效率</strong>的重要因素。</li>
</ul>
<p>逻辑文件类型：</p>
<ul>
<li><p><strong>顺序访问（顺序文件）</strong>：文件信息<strong>按顺序</strong>（即一个接着一个记录）加以处理，依次访问数据，不能直接跳转到文件的指定位置。类似于<strong>磁带</strong>的访问方式。这种访问模式是最常见的，例如，<strong>编译器和编辑器</strong>以这种方式访问文件。还有<strong>日志文件</strong>也是顺序文件。</p>
<ul>
<li>优点：<strong>节省存储空间</strong>，不会有空间浪费。</li>
<li>缺点：<strong>访问效率较差。</strong>需要顺序遍历寻找，<strong>线性时间复杂度</strong>。</li>
</ul>
</li>
<li><p><strong>直接访问（直接文件）</strong>：又称随机访问、相对访问。文件信息以<strong>定长的分区</strong>形式存储，访问时，先计算记录所在的块，再直接读取相应的块。基于磁盘的访问方式，<strong>对于大数据的立即存取</strong>十分有用。例如，<strong>数据库</strong>通常使用这种方式。</p>
<ul>
<li>优点：<strong>访问效率较好。</strong>$O(1)$。</li>
<li>缺点：<strong>浪费存储空间（内部碎片）</strong>。</li>
</ul>
</li>
<li><p>索引文件：<strong>顺序文件存储+直接文件检索</strong></p>
<ul>
<li>文件内部的记录按照<strong>顺序访问</strong>进行存储，但是为记录建立<strong>可直接访问的索引表</strong>，存放记录号和记录所在位置的指针。访问时，先访问索引获取位置，再访问实际地址。</li>
</ul>
<p><img src="%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6.png" alt="索引文件"></p>
</li>
</ul>
<h3 id="目录（文件组织结构）"><a href="#目录（文件组织结构）" class="headerlink" title="目录（文件组织结构）"></a>目录（文件组织结构）</h3><p>目录项：存放文件的属性信息，在某些操作系统中，目录项中就是FCB，更多地采用<strong>iNode节点</strong>以减少目录项大小，<strong>从而提高检索效率。</strong></p>
<p>目录：</p>
<ul>
<li>包含着所有文件信息的<strong>节点集合</strong></li>
<li>根据文件名检索文件的<strong>桥梁</strong></li>
<li>目录项的<strong>有序集合</strong></li>
</ul>
<p>目录文件：</p>
<ul>
<li>目录的存在形式</li>
<li>目录以<strong>文件的方式</strong>存放在外存上的文件系统中，因为一个操作系统的文件系统往往包含着数百GB的文件，目录文件会非常大，如果全部调入内存会极大地占用空间。</li>
</ul>
<p>目录常见操作：</p>
<ul>
<li>搜索文件</li>
<li>创建文件</li>
<li>删除文件</li>
<li>列出目录</li>
<li>重命名文件</li>
<li>跟踪文件系统</li>
</ul>
<p>检索文件：<strong>遍历目录项</strong>（虽然目录项类似一种索引，但它由于<strong>经常变动</strong>，所以<strong>一般不排序</strong>，因此也无法直接访问，需要进行<strong>按文件名</strong>遍历）</p>
<p>① 打开目录文件</p>
<p>② 从磁盘读入该目录文件的1个(物理)块，该块包含若干个目录项</p>
<p>③ 根据文件名遍历内存中的该块，如找到对应的FCB则结束</p>
<p>④ 判断该目录文件是否还有物理块没有读入，如果是转2；否则，结束。表示该目录中没有此文件名的文件</p>
<p>目录性能：</p>
<ul>
<li><strong>物理块</strong>：外部存储被划分为和页、帧等大小或者倍数的物理块。<strong>内存和存储设备数据交换基本单位</strong>。一个物理块一般为4KB、8KB和16KB等</li>
<li>提高目录性能：检索时，读入<strong>尽可能少</strong>的物理块</li>
<li>如果：<ul>
<li>目录项大小= ds bytes</li>
<li>目录中最多文件数 = n</li>
<li>物理块大小 = b</li>
</ul>
</li>
<li>那么：<ul>
<li>目录文件大小 = ds*n bytes</li>
<li>目录文件需要的物理块数目 = ds*n/b</li>
<li>检索一个文件需要平均读入的块数=(ds*n/b+1)/2</li>
</ul>
</li>
<li>提高目录性能的方法<ul>
<li>减少目录中的文件数目（<strong>多级目录</strong>）</li>
<li>减少目录项的大小（<strong>iNode</strong>）</li>
</ul>
</li>
</ul>
<p>iNode：将目录项由较大的FCB变为较小的iNode，类似于索引，包含<strong>一个文件名和iNode号。</strong></p>
<ul>
<li>我们根据iNode号，可以进入一个iNode表（不含文件名）查询对应的FCB指针，通过FCB获取对应的文件。</li>
</ul>
<p><img src="iNode.png" alt="iNode"></p>
<h4 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h4><p>不同目录存在同名文件，为了区分引入了路径名，即<strong>从根目录开始到文件的路径</strong>，称为路径名。如/user4/a，/user1/a。<strong>./表示当前路径，../表示上一级</strong>。</p>
<p><strong>绝对路径</strong>：从根目录开始的路径。</p>
<p><strong>相对路径</strong>：从当前目录开始的路径。可以提高检索效率（当前目录和根目录位于内存中，不需要再检索）：</p>
<p><img src="%E8%B7%AF%E5%BE%84%E5%90%8D.png" alt="路径名"></p>
<h4 id="目录的逻辑结构"><a href="#目录的逻辑结构" class="headerlink" title="目录的逻辑结构"></a>目录的逻辑结构</h4><p>目录逻辑结构的设计目标：</p>
<ul>
<li><strong>效率（性能）</strong>：<ul>
<li>快速定位文件位置</li>
<li>提高文件访问效率</li>
</ul>
</li>
<li><strong>命名（方便性）</strong>：<ul>
<li>方便用户使用</li>
<li>同名的不同文件</li>
<li>不同名的相同文件</li>
</ul>
</li>
<li><strong>分组</strong>：<ul>
<li>文件分组（子目录）</li>
<li>兼顾效率和方便性</li>
</ul>
</li>
</ul>
<p><strong>单层目录</strong>：</p>
<ul>
<li>所有文件在<strong>同一目录</strong>中，只有一级目录：<strong>根目录</strong></li>
<li>优点：<strong>结构简单</strong></li>
<li>缺点：<ul>
<li><strong>效率差</strong></li>
<li><strong>不能有同名文件</strong></li>
<li><strong>不能分组</strong></li>
</ul>
</li>
</ul>
<p><img src="%E5%8D%95%E5%B1%82%E7%9B%AE%E5%BD%95.png" alt="单层目录"></p>
<p><strong>两级目录</strong>：</p>
<ul>
<li><strong>每个用户</strong>有自己的目录结构，即目录下的目录</li>
<li>优点：<ul>
<li><strong>不同用户可有相同文件名的文件</strong>；</li>
<li>比单层目录<strong>提高检索效率</strong>（文件分布在多个用户目录中）</li>
</ul>
</li>
<li>缺点：<ul>
<li>相同用户不能有同名文件;</li>
<li>相同用户无法给文件分组</li>
</ul>
</li>
</ul>
<p><img src="%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95.png" alt="两级目录"></p>
<p><strong>树形目录</strong>：</p>
<ul>
<li>两级目录的扩展，从两层变为<strong>多层</strong>。</li>
<li>特点：<ul>
<li>检索高效（子目录增多导致每个目录下文件减少）</li>
<li>可以分组</li>
<li>允许重名</li>
</ul>
</li>
</ul>
<p><strong>（有向）无环图目录</strong>:</p>
<ul>
<li>树形目录的扩展，允许目录中的多个不同的文件索引指向存储设备中的<strong>同一个</strong>物理文件。</li>
<li>实现了<strong>文件共享</strong>，如Windows中的快捷方式。<ul>
<li><strong>硬链接</strong>（Unix常用）：<ul>
<li>目录中的不同文件名的inode指向相同物理文件的FCB，<strong>共享FCB。</strong></li>
<li>本质上，采用硬链接共享的多个文件都是<strong>同一个文件</strong>。</li>
<li>只允许指向<strong>相同文件系统</strong>下的文件，不允许指向<strong>不存在</strong>的文件。</li>
</ul>
</li>
<li><strong>软链接</strong>（Windows常用）：<ul>
<li>目录中的不同文件名的inode指向<strong>不同的FCB</strong>，但快捷方式文件的文件内容是<strong>源文件的路径</strong>。</li>
<li>更加灵活，允许指向<strong>不存在的文件和不在同一文件系统下的文件</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>通用图目录（有环图目录）：</strong></p>
<ul>
<li><p>可能会导致死循环。</p>
</li>
<li><p>如何保证无环？</p>
<ul>
<li>仅允许指向文件的链接，不允许指向子目录的链接</li>
<li>垃圾回收</li>
<li>每当加入新链接时，使用环路检测算法判断是否正确</li>
<li>优化遍历目录算法，避免对环的重复搜索</li>
</ul>
</li>
</ul>
<h2 id="文件系统实现（物理文件）"><a href="#文件系统实现（物理文件）" class="headerlink" title="文件系统实现（物理文件）"></a>文件系统实现（物理文件）</h2><p>文件系统：提供高效和便捷的<strong>磁盘访问</strong>，以便允许轻松存储、定位、提取数据.</p>
<ul>
<li><p>定义：</p>
<ul>
<li>在存储设备上组织文件的方法和数据结构。</li>
<li>操作系统中负责管理和存储文件信息的模块。</li>
</ul>
</li>
<li><p>功能：</p>
<ul>
<li>系统角度：<ul>
<li>对存储设备的空间进行组织和分配</li>
<li>负责文件<strong>检索、读写</strong>等操作</li>
<li>目标：<strong>存取速度和存储空间效率</strong></li>
</ul>
</li>
<li>用户角度：<ul>
<li>提供<strong>按名存取</strong>的文件访问机制</li>
<li>文件的<strong>组织管理</strong></li>
<li>目标：<strong>方便的文件存取机制</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>结构：</p>
<p><img src="%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.png" alt="文件系统结构"></p>
</li>
<li><p>I/O控制层：</p>
<ul>
<li>设备驱动程序（Device Drivers）</li>
<li>中断处理程序</li>
</ul>
</li>
<li><p>基本文件系统（<strong>偏底层交互</strong>）：</p>
<ul>
<li>物理块读写</li>
<li>向设备驱动程序发送控制命令</li>
</ul>
</li>
<li><p>文件组织模块（<strong>分配空间与地址转换</strong>）：</p>
<ul>
<li>管理文件、逻辑块和物理块</li>
<li>把文件的逻辑地址转换为物理地址</li>
<li>管理空闲空间</li>
<li>为文件分配物理块</li>
</ul>
</li>
<li><p>逻辑文件系统（<strong>高层文件操作</strong>）：</p>
<ul>
<li>管理文件系统中的<strong>元数据</strong>（除了文件数据外的所有结构数据）</li>
<li>文件按名存取</li>
<li>文件目录组织管理</li>
<li>把文件名转换为文件ID，</li>
<li>文件句柄</li>
<li>管理FCB</li>
<li>存储保护</li>
</ul>
</li>
</ul>
<h3 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h3><p><strong>物理块（簇）</strong>：一个或多个（2n）<strong>扇区</strong>组成，<strong>基本文件读写单位</strong>。大小通常是<strong>页大小或整数倍</strong>。</p>
<p><strong>分区（物理）</strong>：可以使一个磁盘分为若干分区，也可以使一个分区由若干磁盘组成。 </p>
<ul>
<li><strong>主分区</strong>：可以安装操作系统的<strong>启动</strong>分区。</li>
<li><strong>扩展分区</strong>：不能安装操作系统，不能直接使用，必须先划分为若干<strong>逻辑分区（卷）</strong>。</li>
</ul>
<p><strong>卷（逻辑）</strong>：磁盘上的<strong>逻辑分区</strong>，建立在<strong>物理分区</strong>上。扩展分区必须划分为若干卷才能使用。一般一个卷可以安装一个<strong>文件系统</strong>。</p>
<p>常用的文件系统：</p>
<ul>
<li>Windows： <strong>FAT16、FAT32、NTFS</strong> </li>
<li>Linux： JFS、 ReiserFS、ext、ext2、<strong>ext3</strong>、ISO9660、XFS、Minx、MSDOS、UMSDOS、VFAT、NTFS、HPFS、NFS、 SMB、SysV、PROC </li>
</ul>
<h3 id="文件系统组成"><a href="#文件系统组成" class="headerlink" title="文件系统组成"></a>文件系统组成</h3><p><strong>磁盘文件系统</strong>（<strong>外存上的文件系统</strong>）：</p>
<ul>
<li><strong>引导控制块</strong>（Boot control block） ：包含了系统引导操作系统的各种信息，只有安装操作系统的分区才有。</li>
<li><strong>分区控制块</strong>（Partition control block）：包含分区信息。</li>
<li><strong>目录文件和FCB文件。</strong></li>
<li><strong>用户文件</strong>。</li>
</ul>
<p><img src="%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.png" alt="磁盘结构"></p>
<p><strong>内存文件系统</strong>（存放在内存）:</p>
<ul>
<li>包含:<ul>
<li><strong>分区表</strong>：所有安装分区信息</li>
<li><strong>目录缓存结构</strong>：保存最近访问的目录信息</li>
<li><strong>系统打开文件表</strong></li>
<li><strong>进程打开文件表</strong></li>
</ul>
</li>
<li>文件操作需要用到内存文件系统。（外存上的文件需要先读入到内存中才能继续读写操作（打开文件））</li>
<li>目的：<strong>通过缓存技术提高文件系统性能</strong></li>
</ul>
<p><strong>虚拟文件系统VFS</strong>：采用<strong>面向对象</strong>技术，屏蔽各文件系统之间的差异，提供<strong>统一的API</strong>。</p>
<p>网络文件系统NFS：用于通过<strong>LAN（或WAN）</strong>访问远程文件系统的软件系统的实现或规范。好处：<strong>节省存储空间，实现共享。</strong></p>
<p><strong>通用Internet文件系统CIFS</strong>：在Windows主机之间进行网络文件共享。</p>
<h3 id="文件物理结构"><a href="#文件物理结构" class="headerlink" title="文件物理结构"></a>文件物理结构</h3><p>物理块和逻辑块的关系类似于进程的逻辑地址和物理地址。</p>
<p><strong>物理块</strong>：（位于<strong>磁盘空间</strong>）</p>
<ul>
<li>读写存储设备的基本单位：<ul>
<li>文件读写操作<strong>按块</strong>进行。能够<strong>减少读写次数，提高效率</strong>。</li>
</ul>
</li>
<li>存储设备的基本分配单位：<ul>
<li>以物理块为单位为文件分配存储空间。</li>
</ul>
</li>
<li>与页面大小相匹配，通常为页面大小或者它的整数倍。</li>
</ul>
<p><strong>逻辑块</strong>：（<strong>文件空间</strong>）</p>
<ul>
<li>在文件空间中的块。</li>
<li>大小与物理块一致，<strong>一个逻辑块存放在一个物理块中</strong>。</li>
<li><strong>直接文件</strong>：一条记录占据一个逻辑块。</li>
<li>从0编号， 一维空间，可根据物理设备特性转换。</li>
</ul>
<p><img src="%E9%80%BB%E8%BE%91%E5%9D%97.png" alt="逻辑块"></p>
<p><strong>存储空间分配方式</strong>：为文件分配物理块。对应文件物理结构。（还有文件逻辑结构，文件目录结构）</p>
<ul>
<li><p><strong>连续分配</strong>（<strong>存储空间连续，顺序表</strong>）：</p>
<ul>
<li>每个文件在磁盘上占用一组<strong>连续</strong>的物理块。</li>
<li>FCB仅需给出文件的：<ul>
<li><strong>起始块号</strong>。</li>
<li><strong>长度</strong>。</li>
</ul>
</li>
<li>访问文件的某个字节的方法：<ul>
<li>利用该字节的逻辑地址LA（文件内相对地址，一维）除以物理块大小S，所得的商为逻辑块号Q，余数为块内偏移D。</li>
<li>看是否越界。不越界则将该文件的起始块号加上Q，得到所要访问的字节的物理块号B。</li>
<li>利用所要访问的字节的物理块号B和块内偏移D，即可取出该字节。</li>
</ul>
</li>
<li>优点：<ul>
<li>可<strong>随机访问</strong>。（可以直接计算出物理位置）</li>
<li><strong>存取速度快。</strong></li>
<li>适用<strong>一次性</strong>读写操作。（便于存取，不便于修改和删除）</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>浪费空间</strong>（连续分配导致的外部碎片）</li>
<li>文件不能<strong>动态增长</strong>。（需要移动之后所有的物理块）</li>
<li>不利于文件的插入和删除（需要移动数据）</li>
</ul>
</li>
<li>改进：<ul>
<li>基于扩展的文件系统（<strong>局部连续</strong>）</li>
</ul>
</li>
</ul>
<p><img src="%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8.png" alt="连续存储"></p>
</li>
<li><p><strong>链接分配（存储空间离散，单链表）</strong>：</p>
<ul>
<li>将文件信息存放在物理上<strong>不连续</strong>的物理块中，通过<strong>指针</strong>指明块之间的逻辑关系。</li>
<li>具体实现方案：<ul>
<li><strong>隐式链接</strong>（<strong>指针存放在每个物理块中，纯单链表</strong>）：<ul>
<li>FCB仅给出文件的<strong>首个</strong>物理块地址。</li>
<li>每个物理块都有指向<strong>下个</strong>物理块的指针。</li>
<li>文件终止于<strong>空指针</strong>。</li>
<li>由于需要存放指针，每个物理块能用于存放数据的空间<strong>变小</strong>。</li>
<li>访问某个字节的方式：<ul>
<li>利用该字节的逻辑地址LA（文件内相对地址，一维）除以物理块大小S减去指针占有空间P，所得的商为逻辑块号Q，余数为块内偏移D。</li>
<li>从物理块链表首部<strong>开始遍历</strong>，第Q块即为所要访问的物理块，利用块内偏移D取出该字节。</li>
</ul>
</li>
<li>优点：<ul>
<li>可以<strong>离散</strong>存放，提高<strong>磁盘利用率</strong>（<strong>解决了外部碎片</strong>）</li>
<li>可以<strong>动态扩充</strong>文件大小。</li>
<li>便于文件<strong>插入和删除</strong>。</li>
</ul>
</li>
<li>缺点：<ul>
<li>不可以随机访问，<strong>文件存取慢</strong>。（访问第i块，需要将它之前所有的块都访问一遍）</li>
<li>可靠性差。</li>
</ul>
</li>
<li>优化方法：多块集合成<strong>簇</strong>。（<strong>减少指针占用空间</strong>）</li>
</ul>
</li>
<li><strong>显式链接（所有指针存放于一张外部表中，单链表+索引）：</strong><ul>
<li>解决了隐式链接指针存放分散的问题，当随机访问某个逻辑块时，<strong>不需要遍历之前的所有物理块。</strong></li>
<li>设计一张<strong>链接表</strong>，为磁盘内所有物理块分配一个表项，内容为<strong>指向该物理块的next指针</strong>。访问时，先访问链接表得到物理块的地址，再直接访问。</li>
<li>优点：<strong>大大提高了检索速度。</strong></li>
<li>缺点：链接表需要在文件系统装载时，装入内存。当使用的是大容量磁盘时，需要的链接表也很大，会<strong>占用大量内存</strong>。（为许多空闲的物理块分配了表项，解决方案：<strong>索引分配</strong>）</li>
<li>例子：<strong>FAT文件分配表系统</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>索引分配（存储空间离散，单链表+多索引）</strong>：</p>
<ul>
<li>与显式链接分配的区别是：显式链接以链表形式存储文件的物理块，为磁盘上所有物理块的指针设计一张链接表，索引分配只为<strong>每个文件内部</strong>的逻辑块设计特有的索引表。（<strong>索引表类似于页表，而链接表类似于倒置页表</strong>）</li>
<li><strong>索引块（表）</strong>：存放指向文件每个物理块指针的物理块</li>
<li><strong>索引块（表）中的第i个项</strong>：存放当前文件内部的第i个逻辑块对应的物理块指针</li>
<li><strong>FCB中的文件位置指向该文件的索引块（表）</strong></li>
<li>优点：<ul>
<li>支持<strong>随机访问</strong>（先访问索引块，然后访问具体块）</li>
<li>离散存放，<strong>没有碎片</strong></li>
</ul>
</li>
<li>缺点：<ul>
<li>需要<strong>额外空间</strong>存放索引表（虽然相比链接存储已经节省了很多空间）</li>
<li><strong>磁盘访问时间</strong>增加（物理块分布在磁盘各地）</li>
</ul>
</li>
<li>访问某个字节的方式：<ul>
<li>利用该字节的逻辑地址LA（文件内相对地址，一维）除以物理块大小S，所得的商为逻辑块号Q，余数为块内偏移D。</li>
<li>访问索引表的第Q项，获取对应的物理块号，进行访问。</li>
</ul>
</li>
<li><strong>多级索引</strong>：<ul>
<li>解决问题：单个物理块中存放的索引项是有限的。对于大文件，<strong>单个物理块</strong>是不够用的。</li>
<li>链接索引：索引表存放在多个物理块中，每个物理块分出一块空间存放指向下一个物理块的指针。    </li>
<li>二级索引：为多个索引表设计一张<strong>外层索引表</strong>。</li>
<li>n级索引文件大小=(1K)^n*4KB</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="空闲磁盘空间管理"><a href="#空闲磁盘空间管理" class="headerlink" title="空闲磁盘空间管理"></a><strong>空闲磁盘空间管理</strong></h3><h4 id="空闲表（空闲块连续）"><a href="#空闲表（空闲块连续）" class="headerlink" title="空闲表（空闲块连续）"></a>空闲表（空闲块连续）</h4><p>空闲区：连续的未分配物理块集合。</p>
<p>空闲表适用<strong>连续分配的空闲区</strong>。</p>
<p>分配和回收方式：和<strong>内存的连续分配</strong>类似。</p>
<p>缺点：空闲块<strong>必须连续</strong>，需要<strong>额外空间</strong>存放空闲表。</p>
<p><img src="%E7%A9%BA%E9%97%B2%E8%A1%A8.png" alt="空闲表"></p>
<h4 id="空闲链表（空闲块不连续）"><a href="#空闲链表（空闲块不连续）" class="headerlink" title="空闲链表（空闲块不连续）"></a>空闲链表（空闲块不连续）</h4><p>将磁盘上所有空闲块链接在一个链表中。</p>
<p>优点：不需<strong>专用块</strong>存放管理信息，仅需分出一个指针。</p>
<p>缺点：<strong>增加I/O操作，得到连续空间难</strong>。</p>
<h4 id="位示图"><a href="#位示图" class="headerlink" title="位示图"></a>位示图</h4><p> 所有块都有一个二进制位与之对应，<strong>0代表该块不空闲，1代表该块空闲。</strong></p>
<p>存放在物理块中，比较容易得到连续的物理块，<strong>是Windows和Linux常用的方法。</strong></p>
<p><strong>一般从每个字节的高位到低位是物理块号低位到高位，符合从左到右的顺序。</strong></p>
<p>已知，第i个字节的第j位，则该位代表的块号为：i*8+(7-J)</p>
<p>已知物理块号K，则它在位示图中是[K/8]个字节的[7-K%8]</p>
<p><img src="%E4%BD%8D%E7%A4%BA%E5%9B%BE.png" alt="位示图"></p>
<h4 id="成组链接"><a href="#成组链接" class="headerlink" title="成组链接"></a>成组链接</h4><p>结合了空闲表和空闲链表，Unix系统常用。</p>
<p>将空闲块分成若干组，每100个块为一组。每一组的首块存放了以下信息：<strong>空闲块总数、当前组空闲块位置列表、下一组空闲块组首块地址。</strong></p>
<p>空闲块回收：新回收的空闲块放在首个空闲块组的首部，当首个空闲块组已满，则新建一个空闲块组，并设置好指针。</p>
<p><img src="%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5.png" alt="成组链接"></p>
<h4 id="一致性检查"><a href="#一致性检查" class="headerlink" title="一致性检查"></a>一致性检查</h4><p>将目录结构数据与磁盘空闲块结构相比较，纠正发现的不一致（一致的情况应是1、0或0、1）</p>
<ul>
<li>]空闲块在某个文件的物理块中（A） （1、1）</li>
<li>非空闲块不属于任意一个文件（B）（0、0）</li>
<li>一个物理块属于多个文件（C）（2、0）</li>
</ul>
<h4 id="空闲空间整理"><a href="#空闲空间整理" class="headerlink" title="空闲空间整理"></a>空闲空间整理</h4><p>把不连续的空闲块集合在一起</p>
<p>利于给文件分配连续的物理块</p>

            </div>
            <hr />

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《操作系统全部笔记》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2020/05/14/cao-zuo-xi-tong-quan-bu-bi-ji/" property="cc:attributionName"
               rel="cc:attributionURL">
                HillZhang
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: 'uCuovwWUzxnygDdXy6SPs97E-gzGzoHsz',
        appKey: 'oroAoITTPFXepwWrR1qGq7b7',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '欢迎和我一起交流！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/05/22/java-se-fu-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/4.jpg" class="responsive-img" alt="Java SE复习笔记">
                        
                        <span class="card-title">Java SE复习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            JavaSE复习笔记变量什么是变量？变量是用来命名一个数据的标识符。
Java的基本数据类型（8种）整型Java的整型主要有四类，分别为：

字节型byte：8位。
短整型short：16位。
整型int：32位。
长整形long：64位。
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2020-05-22
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/编程语言/" class="post-category" target="_blank">
                                    编程语言
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JavaSE/" target="_blank">
                        <span class="chip bg-color">JavaSE</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/05/14/linux-zhang-hu-guan-li/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/26.jpg" class="responsive-img" alt="Linux账户管理">
                        
                        <span class="card-title">Linux账户管理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2020-05-14
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux/" class="post-category" target="_blank">
                                    Linux
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Linux/" target="_blank">
                        <span class="chip bg-color">Linux</span>
                    </a>
                    
                    <a href="/tags/操作系统/" target="_blank">
                        <span class="chip bg-color">操作系统</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: HillZhang的博客<br />'
            + '作者: HillZhang<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2019-2020 章岳. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">247.2k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/HillZhang1999" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:471791641@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>





    <a href="http://wpa.qq.com/msgrd?v=3&uin=471791641&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>





    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 80000;
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2020, 03, 11, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    

    <!-- 雪花特效 -->
    

</body>

</html>