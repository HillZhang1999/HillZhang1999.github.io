<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="LeetCode每日两题, 章岳 学习笔记 计算机 算法 程序">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="每日算法(LEETCODE,PYTHON3)2020.3.2 （2 medium）第3题 无重复的字符的最长字串
思路1 动态规划我的最初思路：可以采用动态规划法（区间DP），从区间为2的子串开始计算无重复字符的长度，接着计算下个更大的区间">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>LeetCode每日两题 | HillZhang的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">HillZhang的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">HillZhang的博客</div>
        <div class="logo-desc">
            
            苏州大学 | 计算机科学与技术学院 | 软件工程
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/15.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        LeetCode每日两题
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/算法/" target="_blank">
                            <span class="chip bg-color">算法</span>
                        </a>
                        
                        <a href="/tags/leetcode/" target="_blank">
                            <span class="chip bg-color">leetcode</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/编程算法/" class="post-category" target="_blank">
                            编程算法
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-03-13
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    HillZhang
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    52.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    227 分
                </div>
                
                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="每日算法-LEETCODE-PYTHON3"><a href="#每日算法-LEETCODE-PYTHON3" class="headerlink" title="每日算法(LEETCODE,PYTHON3)"></a>每日算法(LEETCODE,PYTHON3)</h1><h2 id="2020-3-2-（2-medium）"><a href="#2020-3-2-（2-medium）" class="headerlink" title="2020.3.2 （2 medium）"></a>2020.3.2 （2 medium）</h2><h3 id="第3题-无重复的字符的最长字串"><a href="#第3题-无重复的字符的最长字串" class="headerlink" title="第3题 无重复的字符的最长字串"></a>第3题 无重复的字符的最长字串</h3><p><img src="3.png" alt="第3题 无重复的字符的最长字串"></p>
<h4 id="思路1-动态规划"><a href="#思路1-动态规划" class="headerlink" title="思路1 动态规划"></a>思路1 动态规划</h4><p>我的最初思路：可以采用动态规划法（区间DP），从区间为2的子串开始计算无重复字符的长度，接着计算下个更大的区间，依次类推，直到区间长度等于字符串长度。</p>
<ul>
<li><p>空间复杂度优化：这道题的动态规划状态矩阵中，可以发现有一半的空间（对角线以下）全部为0，所以可以压缩。</p>
</li>
<li><p>时间复杂度优化：分析后发现，这道题其实不需要动态规划，因为本质上没有重叠子问题。我尝试了两层循环遍历字符串的所有子串，一旦出现重复就可以跳出与当前最大长度比较，后面的子串不用再比较了，必有重复的字符。时间复杂度$O(N^2)$</p>
</li>
</ul>
<h4 id="思路2-滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）"><a href="#思路2-滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）" class="headerlink" title="思路2 滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）"></a>思路2 滑动窗口法（字符串题目的常用方法，之前在TCP协议中学习过）</h4><p>使用左右两个指针维护一个无重复字符的窗口，两个指针初始都在0处。通过右指针不断向右延伸添加新的字符，并记录当前窗口大小，每次与当前最大值比较，如果大于当前最大值，则可以更新。当窗口延伸至新字符已存在于窗口内时。把窗口左侧的字符不断移除（左指针收缩），直到当前窗口无重复子串。继续滑动窗口，直到右指针触及字符串尾部，此时可以输出当前最大长度即可。</p>
<p>滑动窗口法减少了对字符串的重复遍历。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> s<span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">#字符串为空的处理</span>
        left <span class="token operator">=</span> <span class="token number">0</span>
        lookup <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        n <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
        max_len <span class="token operator">=</span> <span class="token number">0</span>
        cur_len <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            cur_len <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> lookup<span class="token punctuation">:</span>
                pos<span class="token operator">=</span>len<span class="token punctuation">(</span>lookup<span class="token punctuation">)</span><span class="token operator">-</span>lookup<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#寻找重复字符出现在窗口内的最后一次位置，直接将左指针移动到该位置后面即可。</span>
                lookup<span class="token operator">=</span>lookup<span class="token punctuation">[</span>pos<span class="token punctuation">:</span><span class="token punctuation">]</span>
                left <span class="token operator">+=</span> pos
                cur_len <span class="token operator">-=</span> pos
            <span class="token keyword">if</span> cur_len <span class="token operator">></span> max_len<span class="token punctuation">:</span>max_len <span class="token operator">=</span> cur_len
            lookup<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> max_len<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第4题-寻找两个有序数组的中位数"><a href="#第4题-寻找两个有序数组的中位数" class="headerlink" title="第4题 寻找两个有序数组的中位数"></a>第4题 寻找两个有序数组的中位数</h3><p><img src="4.png" alt="第4题 寻找两个有序数组的中位数"></p>
<h4 id="思路1-指针遍历"><a href="#思路1-指针遍历" class="headerlink" title="思路1 指针遍历"></a>思路1 指针遍历</h4><p>我的方法：归并排序的思想，通过设置两个指针对两个有序数组进行归并排序，若已排序到中位数位置，则输入当前指针指向的数。</p>
<p>缺点：时间复杂度$O(M+N)$，较高。空间复杂度可以优化至$O(1)$，即只存当前数和前一个数。</p>
<p>要想获得log级别的时间复杂度，需要使用二分法或者堆。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>
        mid_pos<span class="token operator">=</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">+</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>
        p<span class="token operator">=</span><span class="token number">0</span>
        q<span class="token operator">=</span><span class="token number">0</span>
        li<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        count<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">and</span><span class="token punctuation">(</span>q<span class="token operator">!=</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                li<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span>
                count<span class="token operator">+=</span><span class="token number">1</span>
                p<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">>=</span>mid_pos<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> mid_pos<span class="token operator">%</span><span class="token number">1</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>
                        <span class="token keyword">return</span> <span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        <span class="token keyword">return</span> li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                li<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span>
                count<span class="token operator">+=</span><span class="token number">1</span>
                q<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">>=</span>mid_pos<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> mid_pos<span class="token operator">%</span><span class="token number">1</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>
                        <span class="token keyword">return</span> <span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        <span class="token keyword">return</span> li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">==</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>q<span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                li<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                count<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">>=</span>mid_pos<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> mid_pos<span class="token operator">%</span><span class="token number">1</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>
                        <span class="token keyword">return</span> <span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        <span class="token keyword">return</span> li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">elif</span> <span class="token punctuation">(</span>q<span class="token operator">==</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>p<span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                li<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                count<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">>=</span>mid_pos<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> mid_pos<span class="token operator">%</span><span class="token number">1</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>
                        <span class="token keyword">return</span> <span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        <span class="token keyword">return</span> li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="思路2-递归二分"><a href="#思路2-递归二分" class="headerlink" title="思路2 递归二分"></a>思路2 递归二分</h4><p>为了使时间复杂度指数倍地下降，我们以数组[1，3，4，9]和[1，2，3，4，5，6，7，8，9，10]为例。计算得知：（1+14）/2=7.5，所以二者合并后的中位数为：第7小数和第8小数的平均值。</p>
<p>首先，我们学习一种二分法求解两个有序数组合并后第k小的数的方法，我们以第7小数为例：</p>
<p>1.先计算7整除2的商为3，然后比较第一个数组和第二个数组的第3个数（如果某个数组的元素不足3个，则比较它的最后一个数）。将较小的那个数及之前所有的数从所在的数组中去除。（此时它们必在合并后前6小的数中，具体证明可以自己推导一遍）。</p>
<p>2.此时，求解第7小的数变为：在更新后的两个数组中求解第4小的数（因为已经确定了3个）。</p>
<p>3.计算4整除2的商为2，然后比较两个数组的第2个数，与第1步中类似，将较小的数及之前的所有数从所在数组中删除。</p>
<p>4.此时，求解第4小的数变为：在更新后的两个数组中求解第2小的数（因为又确定了2个）。</p>
<p>5.重复以上过程，直到问题变为求解第1小的数，这时比较两个数组中的第1个数，返回较小值即可。</p>
<p>通过以上算法，我们可以用二分删除法计算出合并后第7小数和第8小数，然后便可计算中位数。</p>
<ul>
<li>时间复杂度:每进行一次循环，我们就减少 k/2 个元素，所以时间复杂度是 $O(log(k))$，而 k=（m+n）/2，所以最终的复杂也就是 O（log（m+n））。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findk</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums1<span class="token punctuation">,</span>nums2<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#求解合并后第k小数</span>
        m<span class="token operator">=</span>k<span class="token operator">//</span><span class="token number">2</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">></span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#保证第一个数组较小</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>findk<span class="token punctuation">(</span>nums2<span class="token punctuation">,</span>nums1<span class="token punctuation">,</span>k<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果第一个数组为空，直接返回第二个数组的第k个数即可</span>
            <span class="token keyword">return</span> nums2<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span>
        i<span class="token operator">=</span>min<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#防止第一个数组长度不足m</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>k<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果求解第1小数，则直接比较二者第1个数即可</span>
            <span class="token keyword">return</span> min<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">></span>nums2<span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#删除第二个数组的前m个数，再递归查找</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>findk<span class="token punctuation">(</span>nums1<span class="token punctuation">,</span>nums2<span class="token punctuation">[</span>m<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>k<span class="token operator">-</span>m<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#删除第一个数组的前i个数，再递归查找</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>findk<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums2<span class="token punctuation">,</span>k<span class="token operator">-</span>i<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">+</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#数组总长为偶数</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>findk<span class="token punctuation">(</span>nums1<span class="token punctuation">,</span>nums2<span class="token punctuation">,</span>int<span class="token punctuation">(</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">+</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span>self<span class="token punctuation">.</span>findk<span class="token punctuation">(</span>nums1<span class="token punctuation">,</span>nums2<span class="token punctuation">,</span>int<span class="token punctuation">(</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">+</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#数组总长为奇数</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>findk<span class="token punctuation">(</span>nums1<span class="token punctuation">,</span>nums2<span class="token punctuation">,</span>int<span class="token punctuation">(</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">+</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>空间复杂度:O（1）。<strong>因为这里使用了尾递归！</strong></li>
</ul>
<h4 id="什么是尾递归"><a href="#什么是尾递归" class="headerlink" title="什么是尾递归"></a>什么是尾递归</h4><p>以递归方式实现阶乘函数的实现：</p>
<pre class="line-numbers language-python"><code class="language-python">int recsum<span class="token punctuation">(</span>int n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">|</span><span class="token operator">|</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> n <span class="token operator">*</span> fact<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以尾递归方式实现阶乘函数的实现：</p>
<pre class="line-numbers language-python"><code class="language-python">int tailrecsum<span class="token punctuation">(</span>int n<span class="token punctuation">,</span> int res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> facttail<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">+</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>非尾递归，下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。</p>
<p>尾递归，进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。</p>
<p><strong>尾递归的判断标准是函数运行最后一步是否调用自身，而不是是否在函数的最后一行调用自身。</strong></p>
<p>上述例子中：</p>
<ul>
<li><p>递归方式的倒数第二步是调用自身求解recsum（n-1），而最后一步是将recsum（n-1）的结果与n相乘并返回，所以rescum(n)的运算依赖于rescum（n-1）的运算。需要将本层函数压栈保存，当计算完最后一层后，再进行层层返回，得出结果。</p>
</li>
<li><p>尾递归方式的最后一步就是调用自身求解n-1时的结果，并将当前层的结果作为参数传入下一层，不需要再返回当前层进行运算。下层计算结果对上层“无用”（上一层运算已经做完，不依赖后续的递归），为了效率，可以直接将下一层需要的空间覆盖在上一层上。</p>
</li>
</ul>
<p>总结：</p>
<ul>
<li><p>尾递归，比线性递归多一个参数，这个参数是上一次调用函数得到的结果；所以，关键点在于，尾递归每次调用都在收集结果，避免了线性递归不收集结果只能依次展开消耗内存的坏处。</p>
</li>
<li><p>使用尾递归可以带来一个好处：因为进入最后一步后不再需要参考外层函数（caller）的信息，因此没必要保存外层函数的stack，递归需要用的stack只有目前这层函数的，因此避免了栈溢出风险。 </p>
</li>
</ul>
<p><strong>本题中，所有递归调用都是当前层递归的最后一步，所以不需要额外的栈空间保存当前层，时间复杂度为O（1）。</strong></p>
<h2 id="2020-3-3-（2-medium）"><a href="#2020-3-3-（2-medium）" class="headerlink" title="2020.3.3 （2 medium）"></a>2020.3.3 （2 medium）</h2><h3 id="第5题-最长回文子串"><a href="#第5题-最长回文子串" class="headerlink" title="第5题 最长回文子串"></a>第5题 最长回文子串</h3><p><img src="5.png" alt="第5题 最长回文子串"></p>
<h4 id="思路1："><a href="#思路1：" class="headerlink" title="思路1："></a>思路1：</h4><p>区间动态规划+状态空间压缩，利用区间首尾字符是否相等，且去除首尾字符后的子串是否为回文串，来判断当前区间是否为回文子串。</p>
<ul>
<li><p>时间复杂度：$O(N^2)$</p>
</li>
<li><p>空间复杂度：$O(N^2)$（可以压缩一半）</p>
</li>
</ul>
<h4 id="思路2："><a href="#思路2：" class="headerlink" title="思路2："></a>思路2：</h4><p>中心扩展法，不需要额外的状态矩阵。对于一个长度为n的字符串，有2n-1个中心（奇偶回文串分类讨论）可以选取，由中心向两侧扩散寻找该中心所能构成的最长回文子串，若大于当前最大值，则将最大值替换为当前长度。</p>
<ul>
<li><p>时间复杂度：$O(N^2)$</p>
</li>
<li><p>空间复杂度：$O(1)$</p>
</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>
        max_length<span class="token operator">=</span><span class="token string">''</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">!=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>expandcenter<span class="token punctuation">(</span>s<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span>len<span class="token punctuation">(</span>max_length<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    max_length<span class="token operator">=</span>self<span class="token punctuation">.</span>expandcenter<span class="token punctuation">(</span>s<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span>
                <span class="token keyword">if</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>expandcenter<span class="token punctuation">(</span>s<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span>len<span class="token punctuation">(</span>max_length<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    max_length<span class="token operator">=</span>self<span class="token punctuation">.</span>expandcenter<span class="token punctuation">(</span>s<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>expandcenter<span class="token punctuation">(</span>s<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span>len<span class="token punctuation">(</span>max_length<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    max_length<span class="token operator">=</span>self<span class="token punctuation">.</span>expandcenter<span class="token punctuation">(</span>s<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span>
        <span class="token keyword">return</span> max_length

    <span class="token keyword">def</span> <span class="token function">expandcenter</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>s<span class="token punctuation">,</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#中心扩展法向两侧搜索判断</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#奇回文串</span>
            length<span class="token operator">=</span><span class="token number">1</span>
            <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
                l<span class="token operator">-=</span><span class="token number">1</span>
                r<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">and</span><span class="token punctuation">(</span>r<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">and</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    length<span class="token operator">+=</span><span class="token number">2</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token keyword">return</span> s<span class="token punctuation">[</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>r<span class="token punctuation">]</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#偶回文串</span>
            length<span class="token operator">=</span><span class="token number">0</span>
            <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">and</span><span class="token punctuation">(</span>r<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">and</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    length<span class="token operator">+=</span><span class="token number">2</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token keyword">return</span> s<span class="token punctuation">[</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>r<span class="token punctuation">]</span>
                l<span class="token operator">-=</span><span class="token number">1</span>
                r<span class="token operator">+=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="进阶算法："><a href="#进阶算法：" class="headerlink" title="进阶算法："></a>进阶算法：</h4><p>Manacher算法，时间复杂度只有$O(N)$，但比较复杂。可以参考<a href="https://www.jianshu.com/p/392172762e55" target="_blank" rel="noopener">https://www.jianshu.com/p/392172762e55</a></p>
<h3 id="第6题-Z-字形变换"><a href="#第6题-Z-字形变换" class="headerlink" title="第6题 Z 字形变换"></a>第6题 Z 字形变换</h3><p><img src="6.png" alt="第6题 Z 字形变换"></p>
<h4 id="思路1：-1"><a href="#思路1：-1" class="headerlink" title="思路1："></a>思路1：</h4><p>通过观察变换前后的字符串，利用规律求解，直接使用下标运算。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">convert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> numRows<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>
        a<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>numRows<span class="token number">-2</span>
        result<span class="token operator">=</span><span class="token string">''</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> s
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>numRows<span class="token punctuation">)</span><span class="token punctuation">:</span>
            t<span class="token operator">=</span>i
            <span class="token keyword">while</span><span class="token punctuation">(</span>t<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                result<span class="token operator">+=</span>s<span class="token punctuation">[</span>t<span class="token punctuation">]</span>
                delta<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span><span class="token punctuation">(</span>numRows<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>t<span class="token operator">+</span>delta<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">and</span><span class="token punctuation">(</span>delta<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    result<span class="token operator">+=</span>s<span class="token punctuation">[</span>t<span class="token operator">+</span>delta<span class="token punctuation">]</span>
                t<span class="token operator">+=</span>a
        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>时间复杂度：$O(N)$</p>
</li>
<li><p>空间复杂度：$O(1)$</p>
</li>
</ul>
<h4 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h4><p>按顺序遍历字符串，并设置与行数相等的数组。遍历时，按照Z字形变化的格式放入对应的数组（行数先加1，遍历到底部再减1，遍历到顶部再加1，直到遍历完）</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">convert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> numRows<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>
        <span class="token keyword">if</span> numRows <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token keyword">return</span> s
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">""</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>numRows<span class="token punctuation">)</span><span class="token punctuation">]</span>
        i<span class="token punctuation">,</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>
            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> c
            <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> i <span class="token operator">==</span> numRows <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span> flag <span class="token operator">=</span> <span class="token operator">-</span>flag
            i <span class="token operator">+=</span> flag
        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-3-4-（1-hard-1-medium）"><a href="#2020-3-4-（1-hard-1-medium）" class="headerlink" title="2020.3.4 （1 hard 1 medium）"></a>2020.3.4 （1 hard 1 medium）</h2><h3 id="第10题-正则表达式匹配"><a href="#第10题-正则表达式匹配" class="headerlink" title="第10题 正则表达式匹配"></a>第10题 正则表达式匹配</h3><p><img src="10.png" alt="第10题 正则表达式匹配"></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>本题可以用递归求解，但时空复杂度很高。</p>
<p>考虑到本题符合动态规划的两个基本要求：（1）重叠子问题，（2）最优子结构。所以本题可以使用动态规划来求解。</p>
<p>解决可递归问题的三种方法：</p>
<ul>
<li>递归：自顶向下，代码简单，但是复杂度高，可能会进行重复的计算，同时会使用大量的栈空间。</li>
<li>备忘录：自顶向下，将递归中的子问题求解结果保存起来，防止重复计算，降低了时间复杂度，但栈空间的消耗依然存在。</li>
<li>动态规划：自底向上，使用状态矩阵，由子问题通过状态转移方程递推出最后的结果。</li>
</ul>
<p>本题中，可以使用状态矩阵$dp(i,j)$表示text[i:]和pattern[j:]是否能匹配。我们可以用更短的字符串匹配问题来表示原本的问题。</p>
<ul>
<li><p>当首字母匹配且第二个字母为”*”时，可以尝试转移到匹配0次（目标串不变，模式串变）或1次（目标串变，模式串不变，因为此时可以多次匹配）的状态矩阵。</p>
</li>
<li><p>当首字母不匹配且第二个字母为”*”时，转移到匹配0次（目标串不变，模式串变）的状态矩阵。</p>
</li>
<li><p>首字母匹配且第二个字母不为”*”时，转移到首字母匹配1次（目标串和模式串都变）的状态矩阵。</p>
</li>
<li><p>否则，当前状态为False，即无法匹配。</p>
</li>
<li><p>$dp(-1,-1)$说明此时模式串和目标串完成了全匹配，可以成功，默认为True。</p>
</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span> <span class="token comment" spellcheck="true">#两个字符串都为空必然匹配</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#为什么i从len(text))开始，而j从len(pattern)-1开始：字符串为空，正则表达式不为空，可能匹配成功（存在*），而正则表达式为空，字符串不为空，必然不可能匹配成功</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                f_match<span class="token operator">=</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">and</span><span class="token punctuation">(</span>pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">in</span> <span class="token punctuation">[</span>text<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'.'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#第一个对i的限制条件是为了防止后面访问text[i]时数组越界</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">and</span><span class="token punctuation">(</span>pattern<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> f_match<span class="token punctuation">:</span>
                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">or</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> f_match<span class="token punctuation">:</span>
                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第11题-盛最多水的容器"><a href="#第11题-盛最多水的容器" class="headerlink" title="第11题 盛最多水的容器"></a>第11题 盛最多水的容器</h3><p><img src="11.png" alt="第11题 盛最多水的容器"></p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h4><p>双指针法（这种从两端向内收缩的双指针我叫做双侧指针，如第3题中滑动窗口的同一侧出发的指针我叫做快慢指针）。</p>
<p>由于容器的容积只与短板有关，我们可以使用两个指针从数组的两侧每一次向内收缩短板，计算当前的容积，直到两个指针相交。</p>
<p>为什么只收缩短板：如果收缩长板，那么移动后的板长要么小于移动前的短板长度，要么大于短板长度，前者会使容积变小，后者会使容积不变，所以我们只有移动短板才可能使容积变大。</p>
<ul>
<li><p>时间复杂度：$O(N)$</p>
</li>
<li><p>空间复杂度：$O(1)$</p>
</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxArea</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        max_v<span class="token operator">=</span><span class="token number">0</span>
        left<span class="token operator">=</span><span class="token number">0</span>
        right<span class="token operator">=</span>len<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
            v<span class="token operator">=</span>min<span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span>
            <span class="token keyword">if</span> v<span class="token operator">></span>max_v<span class="token punctuation">:</span>
                max_v<span class="token operator">=</span>v
            <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                left<span class="token operator">+=</span><span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                right<span class="token operator">-=</span><span class="token number">1</span>
        <span class="token keyword">return</span> max_v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-3-5-（4-medium）"><a href="#2020-3-5-（4-medium）" class="headerlink" title="2020.3.5 （4 medium）"></a>2020.3.5 （4 medium）</h2><h3 id="第12题-整数转罗马数字"><a href="#第12题-整数转罗马数字" class="headerlink" title="第12题 整数转罗马数字"></a>第12题 整数转罗马数字</h3><p><img src="12.png" alt="第12题 整数转罗马数字"></p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路:"></a>思路:</h4><p>贪心算法，每次取当前能够匹配的最大罗马数字进行选择。类似于用最少的纸币凑出整数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">intToRoman</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中</span>
        <span class="token comment" spellcheck="true"># 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想</span>
        nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
        romans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"M"</span><span class="token punctuation">,</span> <span class="token string">"CM"</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">,</span> <span class="token string">"CD"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token string">"XC"</span><span class="token punctuation">,</span> <span class="token string">"L"</span><span class="token punctuation">,</span> <span class="token string">"XL"</span><span class="token punctuation">,</span> <span class="token string">"X"</span><span class="token punctuation">,</span> <span class="token string">"IX"</span><span class="token punctuation">,</span> <span class="token string">"V"</span><span class="token punctuation">,</span> <span class="token string">"IV"</span><span class="token punctuation">,</span> <span class="token string">"I"</span><span class="token punctuation">]</span>

        index <span class="token operator">=</span> <span class="token number">0</span>
        res <span class="token operator">=</span> <span class="token string">''</span>
        <span class="token keyword">while</span> index <span class="token operator">&lt;</span> <span class="token number">13</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># 注意：这里是等于号，表示尽量使用大的"面值"</span>
            <span class="token keyword">while</span> num <span class="token operator">>=</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>
                res <span class="token operator">+=</span> romans<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
                num <span class="token operator">-=</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
            index <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第15题-三数之和"><a href="#第15题-三数之和" class="headerlink" title="第15题 三数之和"></a>第15题 三数之和</h3><p><img src="15.png" alt="第15题 三数之和"></p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路:"></a>思路:</h4><p>在一个有序数组中求解两个数之和，可以使用暴力遍历的方法，但时间复杂度很高。在这里，我们可以使用双侧指针法，先在数组两端各固定一个指针。当两数之和小于target时，左指针加1（由于是有序数组，会使和变大），当两数之和大于target时，右指针减1，等于target时，保存结果，并左右指针同时向内收缩。</p>
<p>那么，知道了两数之和问题的解决方案后，我们可以求解三数之和（本质上，任意n数之和都可以采取相同的方法）。我们先对数组进行排序，然后固定一个数，便可将问题转化为两数之和，接着对于该数之后的所有数进行两数之和的求解。求解完成后，我们可以接着固定下一个数，直到求出所有结果。</p>
<p>要注意的问题：</p>
<ul>
<li><p>结果的去重（求解两数之和时，相同的数字不应重复使用。同时，固定的数若等于上个数，则他的所有情况都被上个数的遍历所包含，也可以跳过）。</p>
</li>
<li><p>性能的提升（剪枝，当右指针的数小于0时或者固定的数大于0时，三数之和必定不等于0，因为此时三个数都大于0或者都小于0）</p>
</li>
<li><p>时间复杂度：$O(N^2)+O(NlogN)=O(N^2)$</p>
</li>
<li><p>空间复杂度：$O(1)$</p>
</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    public static List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> threeSum<span class="token punctuation">(</span>int<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans <span class="token operator">=</span> new ArrayList<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Arrays<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 排序</span>
        int len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">|</span><span class="token operator">|</span> len <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token punctuation">;</span> i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token operator">//</span> 如果当前数字大于<span class="token number">0</span>，则三数之和一定大于<span class="token number">0</span>，所以结束循环
            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token operator">//</span> 去重
            int L <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
            int R <span class="token operator">=</span> len<span class="token number">-1</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>L <span class="token operator">&lt;</span> R<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                int sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    ans<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span>asList<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;</span>R <span class="token operator">&amp;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>L<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> L<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span> <span class="token operator">//</span> 去重
                    <span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;</span>R <span class="token operator">&amp;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">[</span>R<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>R<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> R<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">;</span> <span class="token operator">//</span> 去重
                    L<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span>
                    R<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;</span>R <span class="token operator">&amp;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>L<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                        L<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span> <span class="token operator">//</span> 去重<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    L<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;</span>R <span class="token operator">&amp;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">[</span>R<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>R<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                        R<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">;</span> <span class="token operator">//</span> 去重
                    <span class="token punctuation">}</span> <span class="token operator">//</span> 去重
                    R<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>        
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第16题-最接近的三数之和"><a href="#第16题-最接近的三数之和" class="headerlink" title="第16题 最接近的三数之和"></a>第16题 最接近的三数之和</h3><p><img src="16.png" alt="第16题 最接近的三数之和"></p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路:"></a>思路:</h4><p>与第15题几乎没有区别，只是双指针收缩时，每次记录当前的三数之和，看与结果的差值是否为当前最小，最小则修改当前的最接近的三数之和。当差值为0时可以直接返回。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">threeSumClosest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
        closest<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
        diff<span class="token operator">=</span>abs<span class="token punctuation">(</span>closest<span class="token operator">-</span>target<span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">continue</span>
            L<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span>
            R<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;</span>R<span class="token punctuation">)</span><span class="token punctuation">:</span>
                summa<span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>R<span class="token punctuation">]</span>
                <span class="token keyword">if</span> abs<span class="token punctuation">(</span>summa<span class="token operator">-</span>target<span class="token punctuation">)</span><span class="token operator">&lt;</span>diff<span class="token punctuation">:</span>
                    closest<span class="token operator">=</span>summa
                    diff<span class="token operator">=</span>abs<span class="token punctuation">(</span>closest<span class="token operator">-</span>target<span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>summa<span class="token operator">></span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    R<span class="token operator">-=</span><span class="token number">1</span>
                <span class="token keyword">elif</span> <span class="token punctuation">(</span>summa<span class="token operator">&lt;</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    L<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token keyword">return</span> summa
        <span class="token keyword">return</span> closest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第18题-四数之和"><a href="#第18题-四数之和" class="headerlink" title="第18题 四数之和"></a>第18题 四数之和</h3><p><img src="18.png" alt="第18题 四数之和"></p>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路:"></a>思路:</h4><p>任意n数之和都求解，都可以先固定一个数，转化为n-1数之和问题，逐步转化，直到最后变为求解二数之和。这里的四数之和也是类似的道理，其去重的思想与三数之和也是一样的。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    public static List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> fourSum<span class="token punctuation">(</span>int<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span>int target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans <span class="token operator">=</span> new ArrayList<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Arrays<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">//</span> 排序
        int len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">|</span><span class="token operator">|</span> len <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token number">-3</span> <span class="token punctuation">;</span> i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">//</span>多固定了一个数，将问题转化为内部的三数之和
            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token operator">//</span> 去重
            <span class="token keyword">for</span> <span class="token punctuation">(</span>int j <span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token number">-2</span><span class="token punctuation">;</span>j<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">></span> i<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&amp;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token operator">//</span> 去重
                int L <span class="token operator">=</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
                int R <span class="token operator">=</span> len<span class="token number">-1</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span>L <span class="token operator">&lt;</span> R<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    int sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>
                        ans<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span>asList<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;</span>R <span class="token operator">&amp;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>L<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> L<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span> <span class="token operator">//</span> 去重
                        <span class="token keyword">while</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;</span>R <span class="token operator">&amp;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">[</span>R<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>R<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> R<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">;</span> <span class="token operator">//</span> 去重
                        L<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span>
                        R<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> L<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span>
                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> R<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>        
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-3-6-（2-medium）"><a href="#2020-3-6-（2-medium）" class="headerlink" title="2020.3.6 （2 medium）"></a>2020.3.6 （2 medium）</h2><h3 id="第17题-电话号码的字母组合"><a href="#第17题-电话号码的字母组合" class="headerlink" title="第17题 电话号码的字母组合"></a>第17题 电话号码的字母组合</h3><p><img src="17.png" alt="第17题 电话号码的字母组合"></p>
<h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1:"></a>思路1:</h4><p>打表+队列，类似于BFS。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">letterCombinations</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> digits<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>
        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'2'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'f'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'4'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'g'</span><span class="token punctuation">,</span><span class="token string">'h'</span><span class="token punctuation">,</span><span class="token string">'i'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'5'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'j'</span><span class="token punctuation">,</span><span class="token string">'k'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'6'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'m'</span><span class="token punctuation">,</span><span class="token string">'n'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'7'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'q'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span><span class="token string">'s'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'8'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'t'</span><span class="token punctuation">,</span><span class="token string">'u'</span><span class="token punctuation">,</span><span class="token string">'v'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'9'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'w'</span><span class="token punctuation">,</span><span class="token string">'x'</span><span class="token punctuation">,</span><span class="token string">'y'</span><span class="token punctuation">,</span><span class="token string">'z'</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> char <span class="token keyword">in</span> digits<span class="token punctuation">:</span>
            <span class="token keyword">if</span> result<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                result<span class="token operator">=</span>dic<span class="token punctuation">[</span>char<span class="token punctuation">]</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                l<span class="token operator">=</span>len<span class="token punctuation">(</span>result<span class="token punctuation">)</span>
                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    st<span class="token operator">=</span>result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
                    result<span class="token operator">=</span>result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#出队</span>
                    <span class="token keyword">for</span> c <span class="token keyword">in</span> dic<span class="token punctuation">[</span>char<span class="token punctuation">]</span><span class="token punctuation">:</span>
                        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st<span class="token operator">+</span>c<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#入队</span>
        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>时间复杂度:$O(3^M+4^N)$</p>
<h4 id="思路2-1"><a href="#思路2-1" class="headerlink" title="思路2:"></a>思路2:</h4><p>这里也可以使用回溯+递归的方法，将其看作是一个类似于全排列的问题。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">letterCombinations</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> digits<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        :type digits: str
        :rtype: List[str]
        """</span>
        phone <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'2'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                 <span class="token string">'3'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                 <span class="token string">'4'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'g'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                 <span class="token string">'5'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'j'</span><span class="token punctuation">,</span> <span class="token string">'k'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                 <span class="token string">'6'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'m'</span><span class="token punctuation">,</span> <span class="token string">'n'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                 <span class="token string">'7'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token string">'q'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                 <span class="token string">'8'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'t'</span><span class="token punctuation">,</span> <span class="token string">'u'</span><span class="token punctuation">,</span> <span class="token string">'v'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                 <span class="token string">'9'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">]</span><span class="token punctuation">}</span>

        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>combination<span class="token punctuation">,</span> next_digits<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># if there is no more digits to check</span>
            <span class="token keyword">if</span> len<span class="token punctuation">(</span>next_digits<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
                <span class="token comment" spellcheck="true"># the combination is done</span>
                output<span class="token punctuation">.</span>append<span class="token punctuation">(</span>combination<span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true"># if there are still digits to check</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token comment" spellcheck="true"># iterate over all letters which map </span>
                <span class="token comment" spellcheck="true"># the next available digit</span>
                <span class="token keyword">for</span> letter <span class="token keyword">in</span> phone<span class="token punctuation">[</span>next_digits<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    <span class="token comment" spellcheck="true"># append the current letter to the combination</span>
                    <span class="token comment" spellcheck="true"># and proceed to the next digits</span>
                    backtrack<span class="token punctuation">(</span>combination <span class="token operator">+</span> letter<span class="token punctuation">,</span> next_digits<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">//</span>这里可以看作是进行了回溯，因为直接使用了新的字符串，所以不用恢复状态 
        output <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> digits<span class="token punctuation">:</span>
            backtrack<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> digits<span class="token punctuation">)</span>
        <span class="token keyword">return</span> output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第19题-删除链表的倒数第N个节点"><a href="#第19题-删除链表的倒数第N个节点" class="headerlink" title="第19题 删除链表的倒数第N个节点"></a>第19题 删除链表的倒数第N个节点</h3><p><img src="19.png" alt="第19题 删除链表的倒数第N个节点"></p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>快慢指针法+dummy head。</p>
<p>快指针在前遍历链表，慢指针在后用于保存快指针的前第N个节点。当快指针遍历到链表的尾部，则可以使用慢指针删除节点。这里需要注意，当要删除的节点是第一个节点时，若使用题目中给出的头指针，需要分类讨论进行操作。为了不进行分类讨论，我们在链表开头处添加一个空的头结点（dummy head）。</p>
<ul>
<li><p>时间复杂度:$O(N)$</p>
</li>
<li><p>空间复杂度:$O(1)$</p>
</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span>
<span class="token comment" spellcheck="true"># class ListNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>
        fore_head<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        fore_head<span class="token punctuation">.</span>next<span class="token operator">=</span>head
        p<span class="token operator">=</span>fore_head
        back_n<span class="token operator">=</span>fore_head
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next
            <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                n<span class="token operator">-=</span><span class="token number">1</span>
            <span class="token keyword">elif</span> <span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">//</span>n减到<span class="token number">0</span>时，才能移动慢指针，否则说明前第n个元素越界
                back_n<span class="token operator">=</span>back_n<span class="token punctuation">.</span>next
        back_n<span class="token punctuation">.</span>next<span class="token operator">=</span>back_n<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
        <span class="token keyword">return</span> fore_head<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-3-7-（1-medium-1-hard）"><a href="#2020-3-7-（1-medium-1-hard）" class="headerlink" title="2020.3.7 （1 medium 1 hard）"></a>2020.3.7 （1 medium 1 hard）</h2><h3 id="第22题-括号生成"><a href="#第22题-括号生成" class="headerlink" title="第22题 括号生成"></a>第22题 括号生成</h3><p><img src="22.png" alt="第22题 括号生成"></p>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路:"></a>思路:</h4><p>二叉树的先根遍历+剪枝。使用count记录当前字符串内左括号个数减去右括号个数的值，当count&lt;0或者count&gt;n，n为剩余的目标括号对数时，进行剪枝。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">generateParenthesis</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>
        count<span class="token operator">=</span><span class="token number">0</span>
        st<span class="token operator">=</span><span class="token string">''</span>
        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">dp</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span>n<span class="token punctuation">,</span>st<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>count<span class="token operator">&lt;=</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#剪枝</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#满足要求</span>
                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st<span class="token punctuation">)</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#先根遍历</span>
                    dp<span class="token punctuation">(</span>count<span class="token number">-1</span><span class="token punctuation">,</span>n<span class="token number">-1</span><span class="token punctuation">,</span>st<span class="token operator">+</span><span class="token string">')'</span><span class="token punctuation">)</span>
                    dp<span class="token punctuation">(</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>st<span class="token operator">+</span><span class="token string">'('</span><span class="token punctuation">)</span>
        dp<span class="token punctuation">(</span>count<span class="token punctuation">,</span>n<span class="token punctuation">,</span>st<span class="token punctuation">)</span>
        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第23题-合并K个排序链表"><a href="#第23题-合并K个排序链表" class="headerlink" title="第23题 合并K个排序链表"></a>第23题 合并K个排序链表</h3><p><img src="23.png" alt="第23题 合并K个排序链表"></p>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路:"></a>思路:</h4><p>分治法，类似于标准归并排序的思想。先将相邻的链表两两合并，得到个数为原来一半的新链表，接着继续两两合并，重复直到只剩下最后一个链表，即为最终的结果。</p>
<p>两两合并的方法，采用的是双指针法，即两个链表各设置一个指针，用于比较和插入结果链表。</p>
<ul>
<li>时间复杂度：$O(NlogK)$，N是所有链表中元素的总和，K是链表个数。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span>
<span class="token comment" spellcheck="true"># class ListNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lists<span class="token punctuation">:</span> List<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>list1<span class="token punctuation">,</span>list2<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#两两合并</span>
            p<span class="token operator">=</span>list1
            q<span class="token operator">=</span>list2
            head<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
            m<span class="token operator">=</span>head
            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> p<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                    m<span class="token punctuation">.</span>next<span class="token operator">=</span>p
                    m<span class="token operator">=</span>m<span class="token punctuation">.</span>next
                    p<span class="token operator">=</span>p<span class="token punctuation">.</span>next
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    m<span class="token punctuation">.</span>next<span class="token operator">=</span>q
                    m<span class="token operator">=</span>m<span class="token punctuation">.</span>next
                    q<span class="token operator">=</span>q<span class="token punctuation">.</span>next
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">==</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
                m<span class="token punctuation">.</span>next<span class="token operator">=</span>q
            <span class="token keyword">elif</span> <span class="token punctuation">(</span>q<span class="token operator">==</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
                m<span class="token punctuation">.</span>next<span class="token operator">=</span>p
            <span class="token keyword">return</span> head<span class="token punctuation">.</span>next
        amount <span class="token operator">=</span> len<span class="token punctuation">(</span>lists<span class="token punctuation">)</span>
        interval <span class="token operator">=</span> <span class="token number">1</span>
        <span class="token keyword">while</span> interval <span class="token operator">&lt;</span> amount<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#两两合并</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> amount <span class="token operator">-</span> interval<span class="token punctuation">,</span> interval <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> merge<span class="token punctuation">(</span>lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> lists<span class="token punctuation">[</span>i <span class="token operator">+</span> interval<span class="token punctuation">]</span><span class="token punctuation">)</span>
            interval <span class="token operator">*=</span> <span class="token number">2</span>
        <span class="token keyword">return</span> lists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">if</span> amount <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">else</span> lists<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为什么不使用逐一合并的算法呢？那样合并的过程写起来会很简单？</p>
<ul>
<li><p>逐一合并的时间复杂度：$O(NK)$</p>
</li>
<li><p>因为这里的两两排序实际上运用了分治法的思想，逐一合并的话，每一次合并在最坏的情况下都需要比较N个节点，而两两合并，每一轮合并的最坏情况才需要比较N个节点。逐一合并需要进行（K-1）次，而两两合并仅需要进行（logN）轮，所以时间复杂度大大降低。</p>
</li>
</ul>
<p><img src="23-2.png" alt="分治法"></p>
<h2 id="2020-3-8-（1-hard-1-medium）"><a href="#2020-3-8-（1-hard-1-medium）" class="headerlink" title="2020.3.8 （1 hard 1 medium）"></a>2020.3.8 （1 hard 1 medium）</h2><h3 id="第24题-两两交换链表中的节点"><a href="#第24题-两两交换链表中的节点" class="headerlink" title="第24题 两两交换链表中的节点"></a>第24题 两两交换链表中的节点</h3><p><img src="24.png" alt="第24题 两两交换链表中的节点"></p>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路:"></a>思路:</h4><p>本质上就是两个一组翻转链表。可以使用头插法+dummy head。使用三个指针pre、p、q，将q结点插入至p结点之前，即完成了一次交换。然后移动指针至下两个节点处，继续交换。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span>
<span class="token comment" spellcheck="true"># class ListNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>
        h<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#dummy head </span>
        h<span class="token punctuation">.</span>next<span class="token operator">=</span>head
        pre<span class="token operator">=</span>h
        p<span class="token operator">=</span>head
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">==</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> head
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            q<span class="token operator">=</span>p<span class="token punctuation">.</span>next
            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token operator">and</span><span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
                p<span class="token punctuation">.</span>next<span class="token operator">=</span>q<span class="token punctuation">.</span>next
                q<span class="token punctuation">.</span>next<span class="token operator">=</span>p
                pre<span class="token punctuation">.</span>next<span class="token operator">=</span>q
                <span class="token comment" spellcheck="true">#两个一组翻转链表</span>
                pre<span class="token operator">=</span>p
                p<span class="token operator">=</span>p<span class="token punctuation">.</span>next
                <span class="token keyword">if</span> p<span class="token operator">!=</span>None<span class="token punctuation">:</span>
                    q<span class="token operator">=</span>p<span class="token punctuation">.</span>next
                <span class="token comment" spellcheck="true">#移动至下两个节点进行操作   </span>
        <span class="token keyword">return</span> h<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第25题-K-个一组翻转链表"><a href="#第25题-K-个一组翻转链表" class="headerlink" title="第25题  K 个一组翻转链表"></a>第25题  K 个一组翻转链表</h3><p><img src="25.png" alt="第25题  K 个一组翻转链表"></p>
<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路:"></a>思路:</h4><p>上一题的扩展，使用dummy head+头插法即可。</p>
<ul>
<li>pre指针：当前组的第一个节点的前一个节点，用于插入元素。</li>
<li>q指针： 要插到头部的那个节点。</li>
<li>p指针： q节点的前一个节点，用于删除q节点。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span>
<span class="token comment" spellcheck="true"># class ListNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>
        h<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        h<span class="token punctuation">.</span>next<span class="token operator">=</span>head
        pre<span class="token operator">=</span>h
        p<span class="token operator">=</span>head
        count<span class="token operator">=</span><span class="token number">0</span>
        t<span class="token operator">=</span>pre<span class="token punctuation">.</span>next
        <span class="token keyword">while</span><span class="token punctuation">(</span>t<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#统计当前链表的长度</span>
            count<span class="token operator">+=</span><span class="token number">1</span>
            t<span class="token operator">=</span>t<span class="token punctuation">.</span>next
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">==</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> head
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            q<span class="token operator">=</span>p<span class="token punctuation">.</span>next
            <span class="token keyword">while</span> <span class="token punctuation">(</span>pre<span class="token operator">!=</span>None<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">&lt;</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当前链表的剩余长度是否可以进行翻转</span>
                    <span class="token keyword">return</span> h<span class="token punctuation">.</span>next
                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    p<span class="token punctuation">.</span>next<span class="token operator">=</span>q<span class="token punctuation">.</span>next
                    q<span class="token punctuation">.</span>next<span class="token operator">=</span>pre<span class="token punctuation">.</span>next
                    pre<span class="token punctuation">.</span>next<span class="token operator">=</span>q 
                    q<span class="token operator">=</span>p<span class="token punctuation">.</span>next  
                    <span class="token comment" spellcheck="true">#当前组内的节点进行头插法翻转</span>
                pre<span class="token operator">=</span>p
                p<span class="token operator">=</span>pre<span class="token punctuation">.</span>next
                <span class="token keyword">if</span> p<span class="token operator">==</span>None<span class="token punctuation">:</span>
                    <span class="token keyword">return</span> h<span class="token punctuation">.</span>next
                q<span class="token operator">=</span>p<span class="token punctuation">.</span>next
                count<span class="token operator">-=</span>k
                <span class="token comment" spellcheck="true">#指针移动至下一组开始处</span>
        <span class="token keyword">return</span> h<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-3-9-（3-easy）"><a href="#2020-3-9-（3-easy）" class="headerlink" title="2020.3.9 （3 easy）"></a>2020.3.9 （3 easy）</h2><h3 id="第26题-删除排序数组中的重复项"><a href="#第26题-删除排序数组中的重复项" class="headerlink" title="第26题 删除排序数组中的重复项"></a>第26题 删除排序数组中的重复项</h3><p><img src="26.png" alt="第26题 删除排序数组中的重复项"></p>
<h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路:"></a>思路:</h4><p>快慢指针法，慢指针指向当前数组内无重复的子序列的最后一项，快指针用于遍历整个数组。</p>
<ul>
<li>当快指针指向的元素与慢指针指向的元素不相等时，将该元素加入至慢指针维护的无重复子序列中，慢指针和快指针都加1。</li>
<li>当元素相等时，快指针直接遍历下一个元素。</li>
<li>时间复杂度：$O(N)$</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        slow<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> fast <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token operator">!=</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                slow<span class="token operator">+=</span><span class="token number">1</span>
                nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span>
        <span class="token keyword">return</span> slow<span class="token operator">+</span><span class="token number">1</span><span class="token comment" spellcheck="true">#由于慢指针指向的是子序列最后一项的下标，子序列长度需要加1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第27题-移除元素"><a href="#第27题-移除元素" class="headerlink" title="第27题 移除元素"></a>第27题 移除元素</h3><p><img src="27.png" alt="第27题 移除元素"></p>
<h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路:"></a>思路:</h4><p>同样使用快慢指针法，快指针用于遍历，慢指针维护一个没有target元素的子序列，指向该子序列末尾的后一个元素。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">removeElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> val<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        slow<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> fast <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token operator">!=</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>
                nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span>
                slow<span class="token operator">+=</span><span class="token number">1</span>
        <span class="token keyword">return</span> slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里，慢指针与26题有一些区别，27题的慢指针指向的是符合要求的子序列的后一项，而26题是最后一项。这是因为26题中，单个元素不可能重复，而27题中，单个元素也可能是需要被移除的。</p>
<h3 id="第28题-实现-strStr"><a href="#第28题-实现-strStr" class="headerlink" title="第28题 实现 strStr()"></a>第28题 实现 strStr()</h3><p><img src="27.png" alt="第28题 实现 strStr()"></p>
<h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路:"></a>思路:</h4><p>KMP算法，具体可以看这里：<a href="/2020/03/17/kmp-suan-fa">KMP算法总结</a></p>
<h2 id="2020-3-10-（1-hard-1-medium）"><a href="#2020-3-10-（1-hard-1-medium）" class="headerlink" title="2020.3.10 （1 hard 1 medium）"></a>2020.3.10 （1 hard 1 medium）</h2><h3 id="第29题-两数相除"><a href="#第29题-两数相除" class="headerlink" title="第29题 两数相除"></a>第29题 两数相除</h3><p><img src="29.png" alt="第29题 两数相除"></p>
<h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路:"></a>思路:</h4><p>我们最初很容易可以想到使用累减法来解决除法问题，但这会很慢，所以我们需要使用递归方法加速累减。</p>
<p>递归的具体过程是，在递归函数内部，我们在保证当前除数不大于被除数的情况下，使除数不断翻倍，并记录倍数。当除数即将大于当前被除数时，我们停止翻倍，并记录下当前的倍数，加到商上。此时，我们将除数减去当前的被除数，剩余的结果重复之前的过程，直到剩余的数小于原始的除数。</p>
<p>本质上，这题的思想类似于快速幂算法，都是使用翻倍来加速，利用二分思想优化至logN级别的时间复杂度。因为一个一个减肯定不如翻倍翻倍减快速。</p>
<p>特别的，这道题还需要考虑补码的机制问题，当被除数等于$-2^31$时，商最大只能等于$2^31-1$。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">divide</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dividend<span class="token punctuation">:</span> int<span class="token punctuation">,</span> divisor<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">if</span> dividend<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#防止除数为0</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token keyword">if</span> divisor<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#除数为1，直接返回结果，加速运算</span>
            <span class="token keyword">return</span> dividend
        <span class="token keyword">if</span> divisor<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#除数为-1，直接返回结果的负数，加速运算</span>
            <span class="token keyword">if</span> dividend<span class="token operator">==</span><span class="token operator">-</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#考虑integer的溢出</span>
                <span class="token keyword">return</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span><span class="token operator">-</span><span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token operator">-</span>dividend
        flag<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dividend<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>divisor<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dividend<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>divisor<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#考虑符号</span>
            flag<span class="token operator">=</span><span class="token number">1</span>
        dividend<span class="token operator">=</span>abs<span class="token punctuation">(</span>dividend<span class="token punctuation">)</span>
        divisor<span class="token operator">=</span>abs<span class="token punctuation">(</span>divisor<span class="token punctuation">)</span>
        <span class="token keyword">def</span> <span class="token function">div</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#递归求解</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">&lt;</span>divisor<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> result
            count<span class="token operator">=</span><span class="token number">1</span>
            result<span class="token operator">+=</span>count
            b<span class="token operator">=</span>divisor
            a<span class="token operator">-=</span>b
            <span class="token keyword">while</span> <span class="token punctuation">(</span>b<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token operator">&lt;=</span>a<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#翻倍累减</span>
                count<span class="token operator">+=</span>count
                result<span class="token operator">+=</span>count
                b<span class="token operator">+=</span>b
                a<span class="token operator">-=</span>b
            <span class="token keyword">return</span> div<span class="token punctuation">(</span>result<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#尾递归，减少栈空间调用</span>
        <span class="token keyword">return</span> flag<span class="token operator">*</span><span class="token punctuation">(</span>div<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>dividend<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第30题-串联所有单词的子串"><a href="#第30题-串联所有单词的子串" class="headerlink" title="第30题 串联所有单词的子串"></a>第30题 串联所有单词的子串</h3><p><img src="30.png" alt="第30题 串联所有单词的子串"></p>
<h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路:"></a>思路:</h4><p>滑动窗口法+哈希表。</p>
<p>由于题目中提到了所有单词等长，那么我们对于n个长度为k的单词可以维护一个长度为k*n的滑动窗口。接着，我们利用哈希表建立words列表中的单词和单词数目的映射。然后，我们可以使用滑动窗口进行滑动匹配，每次移动一个单词的长度。对于窗口内部，我们统计每k长度的字符串，若出现了不在哈希表的键中的字符串，或者字符串出现的次数大于哈希表中对应的值时，说明此窗口失配，进行下一次匹配，否则，记录下窗口起始位置。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> words<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> s<span class="token operator">==</span><span class="token string">""</span> <span class="token operator">or</span> words<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#目标串或者待匹配列表为空</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> w <span class="token keyword">in</span> words<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#建哈希表（字典）</span>
            <span class="token keyword">if</span> w <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                dic<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                dic<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
        l<span class="token operator">=</span>len<span class="token punctuation">(</span>words<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        window<span class="token operator">=</span>l<span class="token operator">*</span>len<span class="token punctuation">(</span>words<span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span>window<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#滑动匹配</span>
            end<span class="token operator">=</span>i<span class="token operator">+</span>window
            tmp<span class="token operator">=</span>dic<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
            flag<span class="token operator">=</span><span class="token number">1</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span>end<span class="token punctuation">,</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>
                w<span class="token operator">=</span>s<span class="token punctuation">[</span>j<span class="token punctuation">:</span>j<span class="token operator">+</span>l<span class="token punctuation">]</span>
                <span class="token keyword">if</span> w <span class="token operator">not</span> <span class="token keyword">in</span> tmp<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    flag<span class="token operator">=</span><span class="token number">0</span>
                    <span class="token keyword">break</span>
                tmp<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>
                <span class="token keyword">if</span> tmp<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>
                    flag<span class="token operator">=</span><span class="token number">0</span>
                    <span class="token keyword">break</span>
            <span class="token keyword">if</span> flag<span class="token punctuation">:</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-3-11-（2-medium-1-hard）"><a href="#2020-3-11-（2-medium-1-hard）" class="headerlink" title="2020.3.11 （2 medium 1 hard）"></a>2020.3.11 （2 medium 1 hard）</h2><h3 id="第31题-下一个排列"><a href="#第31题-下一个排列" class="headerlink" title="第31题 下一个排列"></a>第31题 下一个排列</h3><p><img src="31.png" alt="第31题 下一个排列"></p>
<h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路:"></a>思路:</h4><p>核心思想：</p>
<ul>
<li>我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。</li>
<li>我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：</li>
</ul>
<ol>
<li>在尽可能靠右的低位进行交换，需要从后向前查找</li>
<li>将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换</li>
<li>将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列</li>
</ol>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">nextPermutation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Do not return anything, modify nums in-place instead.
        """</span>
        <span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#交换数组中的两个元素</span>
            temp<span class="token operator">=</span>nums<span class="token punctuation">[</span>a<span class="token punctuation">]</span>
            nums<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>b<span class="token punctuation">]</span>
            nums<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token operator">=</span>temp
        p<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>p<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>从后向前遍历，找到从后向前看的第一个下降的位置
                min_pos<span class="token operator">=</span>p
                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>p<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#搜索最小的大数并交换</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>p<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        min_pos<span class="token operator">=</span>i
                        <span class="token keyword">break</span>
                swap<span class="token punctuation">(</span>min_pos<span class="token punctuation">,</span>p<span class="token number">-1</span><span class="token punctuation">)</span>
                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>int<span class="token punctuation">(</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span>p<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#原地翻转，将大数后所有数重置为升序</span>
                    swap<span class="token punctuation">(</span>p<span class="token operator">+</span>i<span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                p<span class="token operator">-=</span><span class="token number">1</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果为降序数组，则重置为升序数组</span>
            nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>这类题一定要把情况自己模拟一遍，寻找下一个转移的规律。</strong></p>
<h3 id="第32题-最长有效括号"><a href="#第32题-最长有效括号" class="headerlink" title="第32题 最长有效括号"></a>第32题 最长有效括号</h3><p><img src="32.png" alt="第32题 最长有效括号"></p>
<h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路:"></a>思路:</h4><p>双向滑动窗口。</p>
<p>使用双指针维护一个滑动窗口。先从左向右滑动窗口，左右指针初始为0，使用一个变量count来存储当前窗口内左括号数量减去右括号数量的值。右指针不断向前遍历，当遍历到当前窗口内count&lt;0时，将左右指针都移动到当前右指针的下一个位置，重置窗口，当count==0时，使用当前窗口长度比较并尝试更新最大长度，当count&gt;0时，右指针继续向前遍历。</p>
<p>上述滑动完成后，再反向从右往左滑动一次窗口。此时的结果即为最大长度。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">longestValidParentheses</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        p<span class="token operator">=</span><span class="token number">0</span>
        q<span class="token operator">=</span><span class="token number">0</span>
        count<span class="token operator">=</span><span class="token number">0</span>
        max_len<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"("</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                count<span class="token operator">+=</span><span class="token number">1</span>
            <span class="token keyword">elif</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                count<span class="token operator">-=</span><span class="token number">1</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                q<span class="token operator">+=</span><span class="token number">1</span>
                p<span class="token operator">=</span>q
                count<span class="token operator">=</span><span class="token number">0</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">></span>max_len<span class="token punctuation">:</span>
                        max_len<span class="token operator">=</span>q<span class="token operator">-</span>p<span class="token operator">+</span><span class="token number">1</span>
                q<span class="token operator">+=</span><span class="token number">1</span>
        <span class="token comment" spellcheck="true">#从左向右滑动</span>
        p<span class="token operator">=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>
        q<span class="token operator">=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>
        count<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"("</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                count <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">elif</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                count <span class="token operator">-=</span> <span class="token number">1</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                p<span class="token operator">-=</span> <span class="token number">1</span>
                q <span class="token operator">=</span> p
                count <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">-</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> max_len<span class="token punctuation">:</span>
                        max_len <span class="token operator">=</span> q <span class="token operator">-</span> p <span class="token operator">+</span> <span class="token number">1</span>
                p<span class="token operator">-=</span> <span class="token number">1</span>
        <span class="token comment" spellcheck="true">#从右向左滑动</span>
        <span class="token keyword">return</span> max_len<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第33题-搜索旋转排序数组"><a href="#第33题-搜索旋转排序数组" class="headerlink" title="第33题 搜索旋转排序数组"></a>第33题 搜索旋转排序数组</h3><p><img src="33.png" alt="第33题 搜索旋转排序数组"></p>
<h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路:"></a>思路:</h4><p>由于题目要求时间复杂度在logN级别，所以必须是用二分法进行查找。但我们知道二分查找只适用于有序数组，所以我们需要使用嵌套二分。</p>
<p>首先，我们将数组从中间一分为二，根据旋转排序数组的性质，必然至少有一半有序。我们先判断左半数组是否有序，若有序，判断目标是否在它的范围内，若在，则在左半数组中二分查找，而不在，则去右半数组中二分查找。否则，即为右半数组有序，若目标在范围内，则在右半数组中二分，否则去左半数组中二分。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        left<span class="token operator">=</span><span class="token number">0</span>
        right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
            mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>
            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#中间数为目标</span>
                <span class="token keyword">return</span> mid
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#左半数组有序</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#目标在左半数组中</span>
                    right<span class="token operator">=</span>mid<span class="token number">-1</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#右半数组有序</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#目标在右半数组中</span>
                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    right<span class="token operator">=</span>mid<span class="token number">-1</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-3-12-（2-medium-1-hard）"><a href="#2020-3-12-（2-medium-1-hard）" class="headerlink" title="2020.3.12 （2 medium 1 hard）"></a>2020.3.12 （2 medium 1 hard）</h2><h3 id="第34题-在排序数组中查找元素的第一个和最后一个位置"><a href="#第34题-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="第34题 在排序数组中查找元素的第一个和最后一个位置"></a>第34题 在排序数组中查找元素的第一个和最后一个位置</h3><p><img src="41.png" alt="第34题 在排序数组中查找元素的第一个和最后一个位置"></p>
<h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路:"></a>思路:</h4><p>由于时间复杂度控制在logN级别，所以很明显需要使用二分查找。</p>
<p>我们以二分查找获取左边界为例进行说明。首先，我们使用的是常规二分查找的框架，即比较目标与当前区间的中位数。不过常规二分查找是当目标大于中位数时进入右区间查找，小于中位数时进入左区间查找，等于中位数时返回当前中位数的位置。不同的是，此时我们需要查找的是元素的第一个位置。所以，我们需要进行这样的修改：当中位数等于目标时，目标元素的起始位置很明显要么在中位数处，要么在中位数左侧区间，此时我们直接进入左区间查找即可，其余的做法和常规二分查找一样。你可能会疑惑万一第一个位置就是中位数怎么办。不用担心，当遍历完左区间后无法再次找到目标元素，此时会在左区间的末尾尝试进入右区间，又回到了我们原先的中位数处。</p>
<p>二分查找右边界的方法同理，只是将中位数等于目标时改为进入右区间查找即可。</p>
<p>注意，当得到左右边界后还要判定是否合法。</p>
<p>通过两次二分，我们可以在$O(logN)$的时间复杂度内完成查找。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">searchRange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> nums<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>

        <span class="token keyword">def</span> <span class="token function">getLeftBound</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#查找左边界</span>
            left<span class="token operator">=</span><span class="token number">0</span>
            right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
                mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">>=</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    right<span class="token operator">=</span>mid<span class="token number">-1</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#左边界合法</span>
                <span class="token keyword">return</span> left
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>

        <span class="token keyword">def</span> <span class="token function">getRightBound</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#查找右边界</span>
            left<span class="token operator">=</span><span class="token number">0</span>
            right<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
                mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    right<span class="token operator">=</span>mid<span class="token number">-1</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>right<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#右边界合法</span>
                <span class="token keyword">return</span> right
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>

        <span class="token keyword">return</span> <span class="token punctuation">[</span>getLeftBound<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">,</span>getRightBound<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第36题-有效的数独"><a href="#第36题-有效的数独" class="headerlink" title="第36题 有效的数独"></a>第36题 有效的数独</h3><p><img src="36.png" alt="第36题 有效的数独"></p>
<h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路:"></a>思路:</h4><p>使用三个二维数组，分别存放每一行、每一列、每一个子数独当前放置的值。依次遍历这81个格子，每次遍历时将非空格子中的数放入对应的行、列、子数独的列表中。若出现了重复，则说明当前数独无效。</p>
<ul>
<li>时间复杂度：$O(1)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isValidSudoku</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        cols<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        rows<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        sons<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'.'</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">in</span> cols<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">in</span> rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">in</span> sons<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>j<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        <span class="token keyword">return</span> <span class="token boolean">False</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        cols<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
                        rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
                        sons<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>j<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第37题-解数独"><a href="#第37题-解数独" class="headerlink" title="第37题 解数独"></a>第37题 解数独</h3><p><img src="37.png" alt="第37题 解数独"></p>
<h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路:"></a>思路:</h4><p>递归+回溯。类似的问题还有走迷宫、皇后问题、全排列等，本质的思路都是去使用回溯算法递归的尝试每种可能的情况。</p>
<p>回溯算法模板如下：</p>
<blockquote>
<p>def backtrack(…):<br> if (符合结束条件):<br>      保存结果<br>  else:<br>      for 选择 in 选择列表：<br>          if 选择合法：<br>              进行选择<br>              backtrack(…)#递归进入下一个位置进行选择<br>              撤销选择</p>
</blockquote>
<p>本题中，我们对每一个格子进行遍历，如果当前格子非空，我们便在“1”到“9”中选择合法的数字填入当前格子，并进入下一个格子继续选择。如果一直到最后一个格子都可以成功填入数字，则说明解完了数独，可以返回真。如果当前格子无法填入任何数字，则需要回溯至上一层递归函数，去恢复数独的状态，并选择下一个数字尝试填入。</p>
<p>判定当前数独矩阵是否合法，参考第36题即可。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">solveSudoku</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Do not return anything, modify board in-place instead.
        """</span>
        cols<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        rows<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        sons<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

        <span class="token keyword">def</span> <span class="token function">could_place</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#是否可以在当前格子放置value数字</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token keyword">in</span> cols<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>value <span class="token keyword">in</span> rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>value <span class="token keyword">in</span> sons<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>j<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>

        <span class="token keyword">def</span> <span class="token function">place</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#放置数字</span>
            cols<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
            rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
            sons<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>j<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
            board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>value

        <span class="token keyword">def</span> <span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#移除数字</span>
            cols<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>remove<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
            rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>remove<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
            sons<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>j<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>remove<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
            board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"."</span>

        <span class="token keyword">def</span> <span class="token function">DFS</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#回溯函数</span>
            <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">8</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#结束递归条件</span>
               <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"."</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当前格子是否为空</span>
                <span class="token keyword">for</span> value <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历选择</span>
                    value<span class="token operator">=</span>str<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>could_place<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果选择合法</span>
                        place<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#进行选择</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#判断是否走到行尾</span>
                            <span class="token keyword">if</span> <span class="token operator">not</span><span class="token punctuation">(</span>DFS<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果当前可以递归找到解，那么直接返回真，不需要再继续选择，否则回溯继续选择。</span>
                                remove<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>value<span class="token punctuation">)</span>
                            <span class="token keyword">else</span><span class="token punctuation">:</span>
                                <span class="token keyword">return</span> <span class="token boolean">True</span>
                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                            <span class="token keyword">if</span> <span class="token operator">not</span><span class="token punctuation">(</span>DFS<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                                remove<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>value<span class="token punctuation">)</span>
                            <span class="token keyword">else</span><span class="token punctuation">:</span>
                                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">return</span> DFS<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token keyword">return</span> DFS<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>

        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#统计已经存在的数</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'.'</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">in</span> cols<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">in</span> rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">in</span> sons<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>j<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        <span class="token keyword">return</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        cols<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
                        rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
                        sons<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>j<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
        DFS<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-3-13-（2-medium）"><a href="#2020-3-13-（2-medium）" class="headerlink" title="2020.3.13 （2 medium）"></a>2020.3.13 （2 medium）</h2><h3 id="第39题-组合总和"><a href="#第39题-组合总和" class="headerlink" title="第39题 组合总和"></a>第39题 组合总和</h3><p><img src="39.png" alt="第39题 组合总和"></p>
<h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路:"></a>思路:</h4><p>递归回溯算法+剪枝</p>
<p>递归组合分解，每次选择候选数组中的一个元素，用目标值减去它。</p>
<ul>
<li>若得到的结果大于0，说明还可以继续分解，将当前选择的元素加入至路径列表，并尝试继续分解。</li>
<li>如果当前结果等于0，说明分解成功，将当前选择的元素加入至路径列表，并将当前路径列表加入至结果列表。</li>
<li>如果当前结果小于0，说明无法再分解，特别地，当候选数组升序时，后面的元素很明显也无法分解，需要跳出循环。</li>
</ul>
<p><img src="39-1.png" alt="回溯法"><br>此外，有可能出现重复的结果，即虽然路径不同，但元素相同。考虑到这一问题，尝试进行剪枝：</p>
<ul>
<li>记录下当前选择的元素的下标，下一次选择元素从该下标开始。<br><img src="39-2.png" alt="剪枝"></li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">combinationSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> candidates<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        candidates<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">def</span> <span class="token function">back</span><span class="token punctuation">(</span>re<span class="token punctuation">,</span>index<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>index<span class="token punctuation">,</span>len<span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历选择</span>
                num<span class="token operator">=</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                target_now<span class="token operator">=</span>target<span class="token operator">-</span>num
                <span class="token keyword">if</span> target_now<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>
                    <span class="token keyword">break</span>
                re<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#选择</span>
                <span class="token keyword">if</span> target_now<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                    res<span class="token operator">=</span>re<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>res<span class="token punctuation">)</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    back<span class="token punctuation">(</span>re<span class="token punctuation">,</span>i<span class="token punctuation">,</span>target_now<span class="token punctuation">)</span>
                re<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#回溯恢复</span>
        back<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span>
        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第40题-组合总和2"><a href="#第40题-组合总和2" class="headerlink" title="第40题 组合总和2"></a>第40题 组合总和2</h3><p><img src="40.png" alt="第40题 组合总和2"></p>
<h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路:"></a>思路:</h4><p>和上一题类似，依然使用剪枝+递归回溯的思路来做。</p>
<p>有两个区别，一个是候选数组可能会出现重复，我们采用三数之和问题里类似的剪枝思路进行去重。第二个区别是数字不能重复使用，所以递归进行下一次元素的选择时，要从当前元素下标的下一个开始。</p>
<p><img src="40-1.png" alt="剪枝过程"></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">combinationSum2</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> candidates<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        candidates<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">def</span> <span class="token function">back</span><span class="token punctuation">(</span>re<span class="token punctuation">,</span>index<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>index<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>index<span class="token punctuation">,</span>len<span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> i<span class="token operator">!=</span>index <span class="token operator">and</span> <span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>candidates<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#去重</span>
                        <span class="token keyword">continue</span>
                    target_now<span class="token operator">=</span>target<span class="token operator">-</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>target_now<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        <span class="token keyword">break</span>
                    re<span class="token punctuation">.</span>append<span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>target_now<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>re<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        back<span class="token punctuation">(</span>re<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>target_now<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#从下一元素开始遍历，防止数字重复使用</span>
                    re<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
        back<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span>
        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-3-14-（2-hard-1-medium）"><a href="#2020-3-14-（2-hard-1-medium）" class="headerlink" title="2020.3.14 （2 hard 1 medium）"></a>2020.3.14 （2 hard 1 medium）</h2><h3 id="第41题-缺失的第一个正数"><a href="#第41题-缺失的第一个正数" class="headerlink" title="第41题 缺失的第一个正数"></a>第41题 缺失的第一个正数</h3><p><img src="41.png" alt="第41题 缺失的第一个正数"></p>
<h4 id="思路-23"><a href="#思路-23" class="headerlink" title="思路:"></a>思路:</h4><p>我们很容易想到利用哈希表（即字典）进行统计，然后去寻找第一个缺失的正数。但是考虑到题目的要求为时间复杂度$O(N)$以及常数级别的空间复杂度，我们可以考虑将数组自身作为一个哈希表，对应的哈希函数为:</p>
<p>$$f(nums[i])=nums[i]-1$$</p>
<p>通过哈希函数，将可以进行映射的数组元素映射到对应位置上，然后依次遍历寻找第一个映射不正确的位置即可。</p>
<p>复杂度分析：</p>
<ul>
<li><p>时间复杂度：$O(N)$，这里$N$是数组的长度。<br>说明：while 循环不会每一次都把数组里面的所有元素都看一遍。如果有一些元素在这一次的循环中被交换到了它们应该在的位置，那么在后续的遍历中，由于它们已经在正确的位置上了，代码再执行到它们的时候，就会被跳过。最极端的一种情况是，在第 1 个位置经过这个 while 就把所有的元素都看了一遍，这个所有的元素都被放置在它们应该在的位置，那么 for 循环后面的部分的 while 的循环体都不会被执行。平均下来，每个数只需要看一次就可以了，while 循环体被执行很多次的情况不会每次都发生。这样的复杂度分析的方法叫做<strong>均摊复杂度分析</strong>。</p>
</li>
<li><p>空间复杂度：$O(1)$。</p>
</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">firstMissingPositive</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>pos1<span class="token punctuation">,</span>pos2<span class="token punctuation">)</span><span class="token punctuation">:</span>
            nums<span class="token punctuation">[</span>pos1<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>pos2<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>pos2<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>pos1<span class="token punctuation">]</span>

        size<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>size<span class="token punctuation">)</span><span class="token operator">and</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当当前位置的数字可以进行哈希映射，并且不在对应位置时，与对应位置的数字交换。如果重复了或者无法映射（不在范围内），则不映射。</span>
                swap<span class="token punctuation">(</span>i<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>

        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#寻找第一个不符合映射规则的位置</span>
            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span>

        <span class="token keyword">return</span> size<span class="token operator">+</span><span class="token number">1</span><span class="token comment" spellcheck="true">#都符合，那么就输出下一个正数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注:为什么使用nums[i]!=nums[nums[i]-1]来判断而不是i!=nums[i]-1？</p>
<p>因为后者无法处理重复的数字。</p>
<h3 id="第42题-接雨水"><a href="#第42题-接雨水" class="headerlink" title="第42题 接雨水"></a>第42题 接雨水</h3><p><img src="42.png" alt="第42题 接雨水"></p>
<h4 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h4><p>双指针+左右各一次遍历。从左向右遍历时，保证左指针指向的是短板。右指针不断向前遍历，每次右指针遇到长板后，计算此时所形成的容器的容积，再将左指针移到右指针处，右指针继续向前遍历。直到右指针遍历到数组末尾。然后再用相同的方式反向搜索一遍即可。将所有容积相加即为答案。</p>
<ul>
<li><p>时间复杂度:两次遍历，$O(N)$。</p>
</li>
<li><p>空间复杂度：$O(1)$。</p>
</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">trap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        left<span class="token operator">=</span><span class="token number">0</span>
        right<span class="token operator">=</span>left<span class="token operator">+</span><span class="token number">1</span>
        water<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#从左向右</span>
            <span class="token keyword">if</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">>=</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">:</span>
                width<span class="token operator">=</span>right<span class="token operator">-</span>left<span class="token number">-1</span>
                tmp<span class="token operator">=</span><span class="token number">0</span>
                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#减去被柱子占用的体积</span>
                    tmp<span class="token operator">-=</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                tmp<span class="token operator">+=</span>width<span class="token operator">*</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span>
                water<span class="token operator">+=</span>tmp
                left<span class="token operator">=</span>right
            right<span class="token operator">+=</span><span class="token number">1</span>
        right<span class="token operator">=</span>len<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>
        left<span class="token operator">=</span>right<span class="token number">-1</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#从右向左</span>
            <span class="token keyword">if</span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">></span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>
                width<span class="token operator">=</span>right<span class="token operator">-</span>left<span class="token number">-1</span>
                tmp<span class="token operator">=</span><span class="token number">0</span>
                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    tmp<span class="token operator">-=</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                tmp<span class="token operator">+=</span>width<span class="token operator">*</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span>
                water<span class="token operator">+=</span>tmp
                right<span class="token operator">=</span>left
            left<span class="token operator">-=</span><span class="token number">1</span>
        <span class="token keyword">return</span> water<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>实际上，这里并不需要两次遍历，因为从左向右和从右向左的遍历都会在最高的柱子处停下。所以我们可以同时从两侧开始逼近，每次让左右指针较小的那个移动。</p>
<p>同时，我们可以维护一个left_max和right_max，即左右指针当前遍历到的最高柱。利用它们可以计算当前格子的积水。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">trap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        left_max<span class="token operator">=</span><span class="token number">0</span>
        right_max<span class="token operator">=</span><span class="token number">0</span>
        left<span class="token operator">=</span><span class="token number">0</span>
        right<span class="token operator">=</span>len<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>
        water<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>
            <span class="token keyword">if</span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#确保不会越过山顶</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">>=</span>left_max<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    left_max<span class="token operator">=</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    water<span class="token operator">+=</span>left_max<span class="token operator">-</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#利用max变量求解当前格的积水</span>
                left<span class="token operator">+=</span><span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">>=</span>right_max<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    right_max<span class="token operator">=</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    water<span class="token operator">+=</span>right_max<span class="token operator">-</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span>
                right<span class="token operator">-=</span><span class="token number">1</span>
        <span class="token keyword">return</span> water<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>数组必有一个 ”山顶“（若有多个高度相同山顶，任取一个即可）。</p>
<p>根据”木桶原理“，山顶左侧的元素的盛水量 ，由左侧最大值决定；山顶右侧元素的盛水量，由右侧最大值决定。</p>
<p>双指针法的两个指针最终会停在 “山顶” 处。</p>
<h3 id="第43题-字符串相乘"><a href="#第43题-字符串相乘" class="headerlink" title="第43题 字符串相乘"></a>第43题 字符串相乘</h3><p><img src="43.png" alt="第43题 字符串相乘"><br>大数乘法问题，采取模拟竖式计算的方式求解。使用两个数组来存放两个数字字符串，数组的低位存数字字符串的低位。将第1个数组的第i位与第2个数组的第j位相乘，放入结果数组的第i+j位上。计算完成后，遍历结果数组，将所有大于9的进行进位操作。再反向遍历去掉最末尾的0。最后反向拼接成字符串输出即可。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">multiply</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num1<span class="token punctuation">:</span> str<span class="token punctuation">,</span> num2<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>
        numLi1<span class="token operator">=</span><span class="token punctuation">[</span>int<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> num1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
        numLi2<span class="token operator">=</span><span class="token punctuation">[</span>int<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> num2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
        len1<span class="token operator">=</span>len<span class="token punctuation">(</span>numLi1<span class="token punctuation">)</span>
        len2<span class="token operator">=</span>len<span class="token punctuation">(</span>numLi2<span class="token punctuation">)</span>
        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>len1<span class="token operator">+</span>len2<span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len1<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#模拟两个数字的每一位相乘</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len2<span class="token punctuation">)</span><span class="token punctuation">:</span>
                res<span class="token punctuation">[</span>i<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token operator">+=</span>numLi1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>numLi2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len1<span class="token operator">+</span>len2<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#进位操作</span>
            <span class="token keyword">if</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">9</span><span class="token punctuation">:</span>
                res<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+=</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#10</span>
                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">%=</span><span class="token number">10</span>  
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#去除结果开头的0</span>
            <span class="token keyword">if</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span> <span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">break</span>
        res<span class="token operator">=</span><span class="token punctuation">[</span>str<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> res<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度:$O(MN)$</li>
<li>空间复杂度:$O(M+N)$</li>
</ul>
<h2 id="2020-3-15-（2-hard）"><a href="#2020-3-15-（2-hard）" class="headerlink" title="2020.3.15 （2 hard）"></a>2020.3.15 （2 hard）</h2><h3 id="第44题-通配符匹配"><a href="#第44题-通配符匹配" class="headerlink" title="第44题 通配符匹配"></a>第44题 通配符匹配</h3><p><img src="44.png" alt="第44题 通配符匹配"></p>
<h4 id="思路-25"><a href="#思路-25" class="headerlink" title="思路:"></a>思路:</h4><p>类似于第十题，可以采用相同的动态规划方法处理，甚至比第十题简单一些。由子串的匹配转移到当前串的匹配，直到转移至目标串和模式串的匹配。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> p<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#动态规划</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"*"</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">or</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">and</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"?"</span> <span class="token operator">or</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度:$O(MN)$</li>
<li>空间复杂度:$O(MN)$</li>
</ul>
<h4 id="更好的思路："><a href="#更好的思路：" class="headerlink" title="更好的思路："></a>更好的思路：</h4><p>有一种更好的思路来进行匹配，降低了时空复杂度，使用的是回溯和贪心的思想。具体看这里:<a href="https://leetcode-cn.com/problems/wildcard-matching/solution/tong-pei-fu-pi-pei-by-leetcode/" target="_blank" rel="noopener">40题解</a></p>
<h3 id="第45题-跳跃游戏2"><a href="#第45题-跳跃游戏2" class="headerlink" title="第45题 跳跃游戏2"></a>第45题 跳跃游戏2</h3><p><img src="45.png" alt="第45题 跳跃游戏2"></p>
<h4 id="思路-26"><a href="#思路-26" class="headerlink" title="思路:"></a>思路:</h4><p>贪心思路。在当前可以跳到的下一跳候选位置中，选择继续跳跃能够到达最远位置的候选位置，贪心地进行跳跃。当即将跳到数组末尾或者超过数组末尾时，返回当前步数加1，否则继续跳跃。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">jump</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        now<span class="token operator">=</span><span class="token number">0</span><span class="token comment" spellcheck="true">#当前位置</span>
        count<span class="token operator">=</span><span class="token number">0</span><span class="token comment" spellcheck="true">#步数</span>
        l<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token comment" spellcheck="true">#数组末尾位置</span>
        <span class="token keyword">if</span> l<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> count
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> now<span class="token operator">+</span>nums<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">>=</span>l<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#即将到达末尾</span>
                <span class="token keyword">return</span> count<span class="token operator">+</span><span class="token number">1</span>
            farthest<span class="token operator">=</span><span class="token number">0</span>
            next<span class="token operator">=</span><span class="token number">0</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>now<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>now<span class="token operator">+</span>nums<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#贪心地选择能够抵达更远地方的下一跳位置</span>
                farthest_now<span class="token operator">=</span>i<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                <span class="token keyword">if</span> farthest_now<span class="token operator">></span>farthest<span class="token punctuation">:</span>
                    farthest<span class="token operator">=</span>farthest_now
                    next<span class="token operator">=</span>i
            now<span class="token operator">=</span>next
            count<span class="token operator">+=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-3-16-（4-medium）"><a href="#2020-3-16-（4-medium）" class="headerlink" title="2020.3.16 （4 medium）"></a>2020.3.16 （4 medium）</h2><h3 id="第46题-全排列"><a href="#第46题-全排列" class="headerlink" title="第46题 全排列"></a>第46题 全排列</h3><p><img src="46.png" alt="第46题 全排列"></p>
<h4 id="思路-27"><a href="#思路-27" class="headerlink" title="思路:"></a>思路:</h4><p>深度优先搜索+回溯。</p>
<p>为了防止重复遍历数字，使用一个已访问矩阵来存储数字是否已被访问。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">permute</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> nums<span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>re<span class="token punctuation">)</span><span class="token operator">==</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>re<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        re<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>
                        dfs<span class="token punctuation">(</span>re<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                        re<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">False</span>
        dfs<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的是，一般回溯法中将路径列表添加至结果时，需要添加一个深拷贝，而不能是引用。否则它将跟随回溯变化。</p>
<h3 id="第47题-全排列2"><a href="#第47题-全排列2" class="headerlink" title="第47题 全排列2"></a>第47题 全排列2</h3><p><img src="47.png" alt="第47题 全排列2"></p>
<h4 id="思路-28"><a href="#思路-28" class="headerlink" title="思路:"></a>思路:</h4><p>与上一题基础的全排列类似，我们依然使用的是DFS+backtrack算法，但是在这里我们需要进行剪枝处理，去重。</p>
<p>去重的思路是：先排序，对于多个未访问的连续的相同数字，我们每次只选择第一个进行深度优先搜索，防止重复的搜索。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">permuteUnique</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> nums<span class="token punctuation">]</span>
        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>re<span class="token punctuation">)</span><span class="token operator">==</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>re<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">and</span> visited<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#剪枝处理</span>
                        <span class="token keyword">continue</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        re<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>
                        dfs<span class="token punctuation">(</span>re<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                        re<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">False</span>
        dfs<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第48题-旋转图像"><a href="#第48题-旋转图像" class="headerlink" title="第48题 旋转图像"></a>第48题 旋转图像</h3><p><img src="48.png" alt="第48题 旋转图像"></p>
<h4 id="思路-29"><a href="#思路-29" class="headerlink" title="思路:"></a>思路:</h4><p>先对数组进行转置，再对其进行左右翻转。</p>
<p>需要进行原地修改。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Do not return anything, modify matrix in-place instead.
        """</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                tmp<span class="token operator">=</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>tmp
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                tmp<span class="token operator">=</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token operator">-</span>j<span class="token number">-1</span><span class="token punctuation">]</span>
                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token operator">-</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">=</span>tmp
        <span class="token keyword">return</span> matrix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第49题-字母异位词分组"><a href="#第49题-字母异位词分组" class="headerlink" title="第49题 字母异位词分组"></a>第49题 字母异位词分组</h3><p><img src="49.png" alt="第49题 字母异位"></p>
<h4 id="思路-30"><a href="#思路-30" class="headerlink" title="思路:"></a>思路:</h4><p>使用哈希表进行求解。将每个单词的字母按照字典序进行排序，作为哈希表的key，那么字母异位词必然会放入同一个key中。哈希表的value为对应key的字母异位词组成的列表。在最后输出values组成的列表即可。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> strs<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">for</span> word <span class="token keyword">in</span> strs<span class="token punctuation">:</span>
            tmp<span class="token operator">=</span>tuple<span class="token punctuation">(</span>sorted<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> tmp <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                dic<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span>word<span class="token punctuation">]</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                dic<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>word<span class="token punctuation">)</span>
        <span class="token keyword">return</span> list<span class="token punctuation">(</span>dic<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>实际上，还可以不用对单词进行排序，仅统计二十六个字母出现的次数，也能达到相同的效果，将时间复杂度由$O(NKlogK)$降为$O(NK)$</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> strs<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">for</span> word <span class="token keyword">in</span> strs<span class="token punctuation">:</span>
            tmp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> ch <span class="token keyword">in</span> word<span class="token punctuation">:</span>
                tmp<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token operator">-</span>ord<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>
            tmp<span class="token operator">=</span>tuple<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>
            <span class="token keyword">if</span> tmp <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                dic<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span>word<span class="token punctuation">]</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                dic<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>word<span class="token punctuation">)</span>
        <span class="token keyword">return</span> list<span class="token punctuation">(</span>dic<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-3-17-（1-medium-1-hard）"><a href="#2020-3-17-（1-medium-1-hard）" class="headerlink" title="2020.3.17 （1 medium 1 hard）"></a>2020.3.17 （1 medium 1 hard）</h2><h3 id="第50题-Pow（x-n）"><a href="#第50题-Pow（x-n）" class="headerlink" title="第50题 Pow（x,n）"></a>第50题 Pow（x,n）</h3><p><img src="50.png" alt="第50题 Pow（x,n）"></p>
<h4 id="思路-31"><a href="#思路-31" class="headerlink" title="思路:"></a>思路:</h4><p>快速幂算法，采用递归的思路，通过二分法进行加速，将时间复杂度从累乘法的$O(N)$减少到$O(logN)$。基本思想是将$X^n$用两个$X^/frac{n}{2}$表示，这里需要对n的奇偶性进行分类讨论，如果是奇数，无法被2整除的话，还需要再乘以一个x。不断向下二分递归求解，直到将问题转化为求解$X^1$和$X^0$，再层层回退求解结果。</p>
<p>具体思路有些类似于第29题两数相除，本质思想都是使用递归二分进行加速。</p>
<p>特别地，当n为负数时，可以将$X^n$转化为$/frac{1}{X}^{-n}$求解。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">myPow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> float<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">fastpow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token number">1</span>
            <span class="token keyword">if</span> n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>
                half<span class="token operator">=</span>fastpow<span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                    <span class="token keyword">return</span> half<span class="token operator">*</span>half
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token keyword">return</span> x<span class="token operator">*</span>half<span class="token operator">*</span>half
        <span class="token keyword">if</span> n<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>
            x<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span>x
            n<span class="token operator">=</span><span class="token operator">-</span>n
        <span class="token keyword">return</span> fastpow<span class="token punctuation">(</span>x<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>特别地，需要注意Integer类型的补码机制问题，必要时可以采用long，不过python没有这个烦恼。</p>
<p>也可以使用非递归方式进行求解。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">myPow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> float<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>
        <span class="token keyword">if</span> n<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>
            x<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span>x
            n<span class="token operator">=</span><span class="token operator">-</span>n
        result<span class="token operator">=</span><span class="token number">1</span>
        <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">1.0</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                result<span class="token operator">*=</span><span class="token number">2</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                result<span class="token operator">=</span>result<span class="token operator">*</span>result<span class="token operator">*</span>x
            n<span class="token operator">//=</span><span class="token number">2</span>
        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第51题-N皇后"><a href="#第51题-N皇后" class="headerlink" title="第51题 N皇后"></a>第51题 N皇后</h3><p><img src="51.png" alt="第51题 N皇后"></p>
<h4 id="思路-32"><a href="#思路-32" class="headerlink" title="思路:"></a>思路:</h4><p>和解数独和全排列等题目类似，依然是使用回溯算法进行递归求解。</p>
<p>在这个问题中，我们将棋盘看作是一个二维数组，按行进行递归，按列进行选择，每行选择一列放置皇后。如果每一行都能放置一个皇后，则可以将当前棋盘加入至结果数组。</p>
<p>特别地，我们需要判断当前位置是否可以放置一个皇后。由于皇后会攻击同行、同列、四个对角线上的棋子，所以我们需要保证当前行、当前列、当前四个对角线上没有别的皇后。前两个很好判断，对角线可以使用两个皇后的横坐标与纵坐标的差值绝对值是否相等来判断。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">solveNQueens</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">couldplace</span><span class="token punctuation">(</span>chessboard<span class="token punctuation">,</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#是否可以放置</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> chessboard<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>col <span class="token operator">or</span> abs<span class="token punctuation">(</span>i<span class="token operator">-</span>row<span class="token punctuation">)</span><span class="token operator">==</span>abs<span class="token punctuation">(</span>chessboard<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">return</span> <span class="token boolean">False</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>

        <span class="token keyword">def</span> <span class="token function">trans</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#将棋盘转化为输出格式</span>
            result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> li<span class="token punctuation">:</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'Q'</span><span class="token operator">+</span><span class="token string">'.'</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> result

        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">back</span><span class="token punctuation">(</span>chessboard<span class="token punctuation">,</span>row<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#递归回溯</span>
            <span class="token keyword">if</span> row<span class="token operator">>=</span>n<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当前行数若超过棋盘范围，则已放置完，可将当前棋盘加入结果数组</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>chessboard<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#进行选择</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>couldplace<span class="token punctuation">(</span>chessboard<span class="token punctuation">,</span>row<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        chessboard<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token operator">=</span>i
                        back<span class="token punctuation">(</span>chessboard<span class="token punctuation">,</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
                        chessboard<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token comment" spellcheck="true">#回溯</span>
        chessboard<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>
        back<span class="token punctuation">(</span>chessboard<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>trans<span class="token punctuation">(</span>result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里，我使用了一种优化方法，每一次并没有存储真实的棋盘，而是开了一个二维数组，每个数组放置当前行的皇后位置。最后将其转化为输出格式即可。</p>
<h2 id="2020-3-18-（1-easy-2-medium）"><a href="#2020-3-18-（1-easy-2-medium）" class="headerlink" title="2020.3.18 （1 easy 2 medium）"></a>2020.3.18 （1 easy 2 medium）</h2><h3 id="第53题-最大子序和"><a href="#第53题-最大子序和" class="headerlink" title="第53题 最大子序和"></a>第53题 最大子序和</h3><p><img src="53.png" alt="第53题 最大子序和"></p>
<h4 id="思路-33"><a href="#思路-33" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划，状态矩阵dp[i]为以元素nums[i]结尾的子数组的最大连续和，转移方程为dp[i]=（1）nums[i]（if dp[i-1]&lt;=0） （2）dp[i-1]+nums[i]（if dp[i-1]&gt;0）。因为当前只有前面的连续子数组最大和为正数，才能对当前连续子数组最大和产生正贡献，否则只会使其变小。</p>
<p>特别地，为了节约空间，我们可以将nums列表原地修改为dp列表。</p>
<ul>
<li>时间复杂度：$O(N)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        max_sum<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>
                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>
            max_sum<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>max_sum<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#比较当前连续子数组和是否大于全局最大值</span>
        <span class="token keyword">return</span> max_sum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第54题-螺旋矩阵"><a href="#第54题-螺旋矩阵" class="headerlink" title="第54题 螺旋矩阵"></a>第54题 螺旋矩阵</h3><p><img src="54.png" alt="第54题 螺旋矩阵"></p>
<h4 id="思路-34"><a href="#思路-34" class="headerlink" title="思路:"></a>思路:</h4><p>按圈模拟指针的变化。这一类题目需要自己寻找一下指针变化的规律。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        level<span class="token operator">=</span><span class="token number">0</span><span class="token comment" spellcheck="true">#圈数</span>
        row<span class="token operator">=</span><span class="token number">0</span>
        col<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">if</span> matrix<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        result<span class="token operator">=</span><span class="token punctuation">[</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">]</span>
        count<span class="token operator">=</span><span class="token number">1</span><span class="token comment" spellcheck="true">#步数</span>
        row_nums<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span>
        col_nums<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        size<span class="token operator">=</span>row_nums<span class="token operator">*</span>col_nums
        <span class="token keyword">while</span> count<span class="token operator">&lt;</span>size<span class="token punctuation">:</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col_nums<span class="token operator">-</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>
                col<span class="token operator">+=</span><span class="token number">1</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>
                count<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>
                    <span class="token keyword">return</span> result
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>row_nums<span class="token operator">-</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>
                row<span class="token operator">+=</span><span class="token number">1</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>
                count<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>
                    <span class="token keyword">return</span> result
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col_nums<span class="token operator">-</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>
                col<span class="token operator">-=</span><span class="token number">1</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>
                count<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>
                    <span class="token keyword">return</span> result
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>row_nums<span class="token operator">-</span>level<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                row<span class="token operator">-=</span><span class="token number">1</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>
                count<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">if</span> count<span class="token operator">>=</span>size<span class="token punctuation">:</span>
                    <span class="token keyword">return</span> result
            <span class="token comment" spellcheck="true">#模拟顺时针的遍历，这里写的比较冗余，实际上可以使用列表+取余的方式简化增量的计算。</span>
            level<span class="token operator">+=</span><span class="token number">1</span>
            col<span class="token operator">+=</span><span class="token number">1</span>
            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>
            count<span class="token operator">+=</span><span class="token number">1</span>
        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第55题-跳跃游戏"><a href="#第55题-跳跃游戏" class="headerlink" title="第55题 跳跃游戏"></a>第55题 跳跃游戏</h3><p><img src="55.png" alt="第55题 跳跃游戏"></p>
<h4 id="思路-35"><a href="#思路-35" class="headerlink" title="思路:"></a>思路:</h4><p>我们基于这样的一个假设：如果能跳到位置i，那么位置i之前的所有位置0，1…i-1都能跳到。</p>
<p>那么问题已经迎刃而解了，我们遍历每一个位置，如果当前位置无法被跳到（大于当前所能到达的最远位置），则说明后面的所有位置都无法跳到，自然也就无法到达数组的末尾。如果当前位置可以跳到，将其所能到达的最远位置与当前最远位置比较，取最大值进行更新当前最远位置。</p>
<p>时间复杂度：$O(N)$</p>
<p>空间复杂度: $O(1)$</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">canJump</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        farthest<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> i<span class="token operator">></span>farthest<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
            farthest<span class="token operator">=</span>max<span class="token punctuation">(</span>farthest<span class="token punctuation">,</span>i<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以和跳跃游戏2一样采用贪心算法求解，不过时间复杂度会高一些。</p>
<h2 id="2020-3-19-（2-medium-1-hard）"><a href="#2020-3-19-（2-medium-1-hard）" class="headerlink" title="2020.3.19 （2 medium 1 hard）"></a>2020.3.19 （2 medium 1 hard）</h2><h3 id="第56题-合并区间"><a href="#第56题-合并区间" class="headerlink" title="第56题 合并区间"></a>第56题 合并区间</h3><p><img src="56.png" alt="第56题 合并区间"></p>
<h4 id="思路-36"><a href="#思路-36" class="headerlink" title="思路:"></a>思路:</h4><p>先按每个区间的左边界，为所有区间进行升序排序。接着，遍历每个区间，若当前区间的右边界大于或等于下一区间的左边界，那么说明二者有重复，可以进行合并。合并后，新区间的左边界为当前区间的左边界（升序排序），有边界为两个区间右边界的最大值（两种情况）。将下一区间原地修改为合并后的新区间，可以节约空间，并将当前区间置空。完成后，继续向前遍历。</p>
<p>最后，将所有空列表进行删除处理，返回最终的列表即可。</p>
<p>时间复杂度：$O(N)$</p>
<p>空间复杂度：$O(1)$</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> intervals<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>
            intervals<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">>=</span>intervals<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    intervals<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
                    intervals<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>intervals<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                    intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    intervals<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> intervals<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第57题-插入区间"><a href="#第57题-插入区间" class="headerlink" title="第57题 插入区间"></a>第57题 插入区间</h3><p><img src="57.png" alt="第57题 插入区间"></p>
<h4 id="思路-37"><a href="#思路-37" class="headerlink" title="思路:"></a>思路:</h4><p>二分查找插入位置，插入新区间，然后采用上一题的思路进行合并。插入需要耗费$O(logN)$，合并需要耗费$O(N)$，总时间复杂度为$O(NlogN)$。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> intervals<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> newInterval<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>
            left<span class="token operator">=</span><span class="token number">0</span>
            right<span class="token operator">=</span>len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
                mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">return</span> mid
                <span class="token keyword">elif</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    right<span class="token operator">=</span>mid<span class="token number">-1</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>
            <span class="token keyword">return</span> left
        insert_pos<span class="token operator">=</span>search<span class="token punctuation">(</span>newInterval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        intervals<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>insert_pos<span class="token punctuation">,</span>newInterval<span class="token punctuation">)</span>
        <span class="token keyword">if</span> len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">>=</span>intervals<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    intervals<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
                    intervals<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>intervals<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                    intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    intervals<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> intervals<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>还可以使用贪心算法，先将新区间插入至插入位置，并将其与前一个区间尝试合并。再向后遍历，尝试合并，直到无法进行合并。</p>
<h3 id="第60题-第k个排列"><a href="#第60题-第k个排列" class="headerlink" title="第60题 第k个排列"></a>第60题 第k个排列</h3><p><img src="60.png" alt="第60题 第k个排列"></p>
<h4 id="思路-38"><a href="#思路-38" class="headerlink" title="思路:"></a>思路:</h4><p>DFS算法，因为n！种排列本质是由n组n-1！排列组合而成，根据这一性质，我们可以得知当前的偏移值在哪一组n-1！中，从而计算得到当前位置上应填入的数字，接着取余数获取新的偏移值，不断递归，直到获取最终结果。</p>
<p>这里的DFS不需要进行回溯，因为每一位数字只有一个是符合条件的，不需要恢复状态去进行下一个选择。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">getPermutation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#求解n!</span>
            result<span class="token operator">=</span><span class="token number">1</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                result<span class="token operator">*=</span>i
            <span class="token keyword">return</span> result

        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>k<span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> result
            f<span class="token operator">=</span>factorial<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span>
            base<span class="token operator">=</span>k<span class="token operator">//</span>f
            offset<span class="token operator">=</span>k<span class="token operator">%</span>f
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>visited<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> base<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#第base个未访问过的元素，即为当前位置上应该填入的数字</span>
                        result<span class="token operator">+=</span>str<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
                        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>
                        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span>offset<span class="token punctuation">,</span>result<span class="token punctuation">)</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        base<span class="token operator">-=</span><span class="token number">1</span>

        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>n<span class="token punctuation">,</span>k<span class="token number">-1</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#这里数组从0开始，需要将k减1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-3-20-（4-medium）"><a href="#2020-3-20-（4-medium）" class="headerlink" title="2020.3.20 （4 medium）"></a>2020.3.20 （4 medium）</h2><h3 id="第61题-旋转链表"><a href="#第61题-旋转链表" class="headerlink" title="第61题 旋转链表"></a>第61题 旋转链表</h3><p><img src="61.png" alt="第61题 旋转链表"></p>
<h4 id="思路-39"><a href="#思路-39" class="headerlink" title="思路:"></a>思路:</h4><p>快慢指针法+头插法。</p>
<p>先统计链表的长度L，令K=K%L，放置进行重复的旋转。再使用快慢指针定位链表最后K个元素的起始位置和终止位置，并将这K个元素插入至链表头部即可。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span>
<span class="token comment" spellcheck="true"># class ListNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>
        dummyhead<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        dummyhead<span class="token punctuation">.</span>next<span class="token operator">=</span>head
        fast<span class="token operator">=</span>slow<span class="token operator">=</span>dummyhead
        l<span class="token operator">=</span><span class="token number">0</span>
        p<span class="token operator">=</span>dummyhead
        <span class="token keyword">if</span> head<span class="token operator">!=</span>None<span class="token punctuation">:</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
                p<span class="token operator">=</span>p<span class="token punctuation">.</span>next
                l<span class="token operator">+=</span><span class="token number">1</span>
            k<span class="token operator">%=</span>l
            <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>k<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next
                    k<span class="token operator">-=</span><span class="token number">1</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next
                    fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next
            fast<span class="token punctuation">.</span>next<span class="token operator">=</span>dummyhead<span class="token punctuation">.</span>next
            dummyhead<span class="token punctuation">.</span>next<span class="token operator">=</span>slow<span class="token punctuation">.</span>next
            slow<span class="token punctuation">.</span>next<span class="token operator">=</span>None
        <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以将原先的链表修改成一个环，再从原倒数第K%L个元素处断开环，新得到的链表即为旋转后链表。</p>
<h3 id="第62题-不同路径"><a href="#第62题-不同路径" class="headerlink" title="第62题 不同路径"></a>第62题 不同路径</h3><p><img src="62.png" alt="第62题 不同路径"></p>
<h4 id="思路-40"><a href="#思路-40" class="headerlink" title="思路:"></a>思路:</h4><p>我的最初思路想当然地考虑到了DFS+回溯算法，这也是这一类走迷宫问题的常用算法。</p>
<p>但是，我很快观察到，这道题里有重叠的子问题，那么使用递归将非常缓慢。例如，从位置（0，1）和位置（1，0）都可以走到位置（1，1），如果我们使用递归，将重复从位置（1，1）向下搜索可行解两次，导致了不必要的时间消耗。</p>
<p>解决重叠子问题的方法就是动态规划。这道题里，我们的状态矩阵dp[i][j]为到达网格中（i，j）位置的路径数目，转移方程为：</p>
<ol>
<li>dp[i][j]=1,if i==0 and j==0;</li>
<li>dp[i][j]=dp[i-1][j],if i&gt;0 and j==0;</li>
<li>dp[i][j]=dp[i][j-1],if j&gt;0 and i==0;</li>
<li>dp[i][j]=dp[i-1][j]+dp[i][j-1],if i&gt;0 and j&gt;0.</li>
</ol>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#状态矩阵</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#状态转移</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>
                <span class="token keyword">elif</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                <span class="token keyword">elif</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第63题-不同路径2"><a href="#第63题-不同路径2" class="headerlink" title="第63题 不同路径2"></a>第63题 不同路径2</h3><p><img src="63.png" alt="第63题 不同路径"></p>
<h4 id="思路-41"><a href="#思路-41" class="headerlink" title="思路:"></a>思路:</h4><p>思路与上一题基本一致，唯一的区别在于当状态矩阵转移到有障碍物的位置时，应将状态矩阵该位置修改为0.因为很明显该位置有了障碍物后不可达。</p>
<p>特别地，我们可以将题目提供的数组原地修改为状态矩阵，便可只适用常数级别的额外空间。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">uniquePathsWithObstacles</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> obstacleGrid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">if</span> obstacleGrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#初始位置有障碍物，并不可能到达终点</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        obstacleGrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>obstacleGrid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>obstacleGrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">or</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#将有障碍物的位值设为不可达</span>
                    obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#状态转移</span>
                    <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                        obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>obstacleGrid<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                    <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>
                        obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>
                    <span class="token keyword">elif</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>
                        obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>obstacleGrid<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
        <span class="token keyword">return</span> obstacleGrid<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第64题-最小路径和"><a href="#第64题-最小路径和" class="headerlink" title="第64题 最小路径和"></a>第64题 最小路径和</h3><p><img src="64.png" alt="第64题 最小路径和"></p>
<h4 id="思路-42"><a href="#思路-42" class="headerlink" title="思路:"></a>思路:</h4><p>与62、63题思路基本一致，仍然是动态规划的思想。转移方程略有不同，核心是当前位置上的数字加上上方位置和左侧位置的路径和的最小值。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                    grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+=</span>grid<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>
                    grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+=</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>
                <span class="token keyword">elif</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>
                    grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+=</span>min<span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>grid<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> grid<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-3-29-（1-medium-1-hard）"><a href="#2020-3-29-（1-medium-1-hard）" class="headerlink" title="2020.3.29 （1 medium 1 hard）"></a>2020.3.29 （1 medium 1 hard）</h2><h3 id="第72题-编辑距离"><a href="#第72题-编辑距离" class="headerlink" title="第72题 编辑距离"></a>第72题 编辑距离</h3><p><img src="72.png" alt="第72题 编辑距离"></p>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>动态规划的经典模板题之一，设dp[i] [j]为word1的前i个字符调整至word2的前j个字符所需的最少操作数目。则dp转移方程为：</p>
<ul>
<li>dp[i] [j]=0，if i==0 and j==0（空字符串到空字符串，不需要编辑）</li>
<li>dp[i] [j]=i，if i&gt;0 and j==0（word1的前i个字符调整至空字符串，需要删除i次）</li>
<li>dp[i] [j]=j，if i==0 and j&gt;0（空字符串调整至word2的前j个字符串，需要添加j次）</li>
<li>dp[i] [j]=dp[i-1] [j-1]，if i&gt;0 and j&gt;0 and word1[i-1]==word2[j-1] （如果word1的第i个字符和word2的第j个字符相等，那么这一位上不需要操作，直接看word1的前i-1个字符调整至word2的前j-1个字符需要几步即可）</li>
<li>dp[i] [j]=min（dp[i-1] [j]，dp[i] [j-1], dp[i-1] [j-1]）+1，if i&gt;0 and j&gt;0 and word1[i-1]!=word2[j-1] （如果word1的第i个字符和word2的第j个字符不相等，那我们假设当前的匹配是由添加、删除、替换一个字符而来的，比较三者操作前的状态需要的最少操作数目，选取最小值加上当前这一步，作为当前的最少操作数目）</li>
</ul>
<blockquote>
<p>以 word1 为 “horse”，word2 为 “ros”，且 dp[5] [3] 为例，即要将 word1的前 5 个字符转换为 word2的前 3 个字符，也就是将 horse 转换为 ros，因此有：</p>
<p>(1) dp[i-1] [j-1]，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 2 个字符 ro，然后将第五个字符 word1[4]（因为下标基数以 0 开始） 由 e 替换为 s（即替换为 word2 的第三个字符，word2[2]）</p>
<p>(2) dp[i] [j-1]，即先将 word1 的前 5 个字符 horse 转换为 word2 的前 2 个字符 ro，然后在末尾补充一个 s，即插入操作</p>
<p>(3) dp[i-1] [j]，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 3 个字符 ros，然后删除 word1 的第 5 个字符</p>
</blockquote>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word1<span class="token punctuation">:</span> str<span class="token punctuation">,</span> word2<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>word2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>word1<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>word1<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>word2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>
                <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>j
                <span class="token keyword">elif</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> word1<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span>word2<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度: $O(MN)$。</li>
<li>空间复杂度：$O(MN)$。</li>
<li>这一题有些类似于通识符匹配的那道题。</li>
</ul>
<h3 id="第75题-颜色分类"><a href="#第75题-颜色分类" class="headerlink" title="第75题 颜色分类"></a>第75题 颜色分类</h3><p><img src="75.png" alt="第75题 颜色分类"></p>
<h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>三路快排的思想。使用三个指针curr，p0，p2。curr用于遍历数组，p0用于表示全0区间的右边界的下一个位置，p2用于表示全2区间的左边界的下一个位置。具体扫描算法如下：</p>
<ul>
<li>当curr小于p2时（说明所有元素尚且没有被扫描完）：<ul>
<li>如果nums[curr]==0，那么将nums[curr]与nums[p0]交换，并且curr加1，p0加1，相当于全0区间向右扩展了，且由于当前数必然是1或者0，所以可以向后继续遍历（因为之前的元素都已经被遍历过，如果是2会被交换到后面去）。</li>
<li>如果nums[curr]==2，那么将nums[curr]与nums[p2]交换，并且p2减1，相当于全2区间向左扩展了。由于此时交换过来的数字我们不知道是0、1还是2，所以curr不能加一，还需要继续判断当前元素。</li>
<li>如果nums[curr]==1，那么直接使curr加1，向后继续遍历。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">sortColors</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Do not return anything, modify nums in-place instead.
        """</span>
        curr<span class="token punctuation">,</span>p0<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>
        p2<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token operator">&lt;=</span>p2<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>p0<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>p0<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span>
                curr<span class="token operator">+=</span><span class="token number">1</span>
                p0<span class="token operator">+=</span><span class="token number">1</span>
            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
                curr<span class="token operator">+=</span><span class="token number">1</span>
            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">:</span>
                nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>curr<span class="token punctuation">]</span>
                p2<span class="token operator">-=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度: $O(N)$。</li>
<li>空间复杂度：$O(1)$。</li>
<li>这道题既有些像快排，使用指针维护区间的思想也有些像26题和27题。</li>
</ul>
<h2 id="2020-3-30-（1-medium-1-hard）"><a href="#2020-3-30-（1-medium-1-hard）" class="headerlink" title="2020.3.30 （1 medium 1 hard）"></a>2020.3.30 （1 medium 1 hard）</h2><h3 id="第76题-最小覆盖子串"><a href="#第76题-最小覆盖子串" class="headerlink" title="第76题 最小覆盖子串"></a>第76题 最小覆盖子串</h3><p><img src="76.png" alt="第76题 最小覆盖子串"></p>
<h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><p>经典的滑动窗口题，类似的题目还有 <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">无重复字符的最长子串</a> 、 <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">找到字符串中所有字母异位词</a> 等。基本思路都是使用双指针维护一个符合题目要求的滑动区间。</p>
<p>本题中，我们使用双指针left和right，right负责向前遍历搜索，如果区间[left：right+1]包含了T中所有的字母，我们尝试移动left，保证当前区间仍然包含T中所有的字母。如果left移动后区间不符合要求，我们记录当前区间，将其与最小覆盖子串比较，更新最小覆盖子串。然后，right继续向前搜索，直到最后一个字符。</p>
<ul>
<li>时间复杂度：$O(M+N)$, M为s长度，N为t长度。 在最坏的情况下，可能会对S中的每个元素遍历两遍，左指针和右指针各一遍。 </li>
<li>空间复杂度：$O(1)$。最多128个字符。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">minWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>
        left<span class="token operator">=</span><span class="token number">0</span>
        right<span class="token operator">=</span><span class="token number">0</span>
        count_t<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#哈希表统计t中每个字符出现的次数</span>
        <span class="token keyword">for</span> ch <span class="token keyword">in</span> t<span class="token punctuation">:</span>
            <span class="token keyword">if</span> ch <span class="token operator">not</span> <span class="token keyword">in</span> count_t<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                count_t<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                count_t<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>
        formed<span class="token operator">=</span><span class="token number">0</span><span class="token comment" spellcheck="true">#已覆盖的字符数（指的是不重复的字符）</span>
        min_length<span class="token operator">=</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span>
        min_st<span class="token operator">=</span><span class="token string">""</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#右区间遍历搜索s的所有字符</span>
            <span class="token keyword">if</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token keyword">in</span> count_t<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> count_t<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当前字符所有出现次数被完全覆盖</span>
                    formed<span class="token operator">+=</span><span class="token number">1</span>
                count_t<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>
            <span class="token keyword">if</span> formed<span class="token operator">==</span>len<span class="token punctuation">(</span>count_t<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#完全覆盖了t中所有的字符</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#左区间收缩，尝试寻找最小覆盖字串</span>
                    <span class="token keyword">if</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token keyword">in</span> count_t<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        count_t<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>
                        <span class="token keyword">if</span> count_t<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#失去匹配</span>
                            formed<span class="token operator">-=</span><span class="token number">1</span>
                            left<span class="token operator">+=</span><span class="token number">1</span>
                            <span class="token keyword">break</span>
                    left<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">if</span> right<span class="token operator">-</span>left<span class="token operator">&lt;</span>min_length<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#记录失配前的最小子串，更新当前最小覆盖字串</span>
                        min_length<span class="token operator">=</span>right<span class="token operator">-</span>left
                        min_st<span class="token operator">=</span>s<span class="token punctuation">[</span>left<span class="token number">-1</span><span class="token punctuation">:</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
            right<span class="token operator">+=</span><span class="token number">1</span>
        <span class="token keyword">return</span> min_st<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第79题-单词搜索"><a href="#第79题-单词搜索" class="headerlink" title="第79题 单词搜索"></a>第79题 单词搜索</h3><p><img src="79.png" alt="第79题 单词搜索"></p>
<h4 id="思路-43"><a href="#思路-43" class="headerlink" title="思路:"></a>思路:</h4><p>DFS模板题，剑指Offer原题，基本思路就是从每一个单元格开始向上下左右四个方向递归深搜，如果当前单元格不越界且匹配，那么继续搜索下一个字符。考虑到不能搜索重复的单元格，需要使用visited矩阵进行判断，并对其回溯。为了减少空间复杂度，可以原地修改board为visited。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">exist</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>    
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> index<span class="token operator">==</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> index<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span>word<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    tmp<span class="token punctuation">,</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token boolean">False</span>
                    <span class="token keyword">if</span> dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> dfs<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token number">-1</span><span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> dfs<span class="token punctuation">(</span>row<span class="token number">-1</span><span class="token punctuation">,</span>col<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        <span class="token keyword">return</span> <span class="token boolean">True</span>
                    board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span>tmp
            <span class="token keyword">return</span> <span class="token boolean">False</span>

        <span class="token keyword">if</span> len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-3-31（2-hard）"><a href="#2020-3-31（2-hard）" class="headerlink" title="2020.3.31（2 hard）"></a>2020.3.31（2 hard）</h2><h3 id="第84题-柱状图中最大的矩形"><a href="#第84题-柱状图中最大的矩形" class="headerlink" title="第84题 柱状图中最大的矩形"></a>第84题 <a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">柱状图中最大的矩形</a></h3><p><img src="84.png" alt="第84题 柱状图中最大的矩形"></p>
<h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>由于矩形的面积和区间内最小高度的柱子有关，我们先尝试基本做法动态规划，DP求解数组中每一个区间的最小高度，然后乘以区间的宽度，尝试更新当前最大面积。尝试后发现超时，时间复杂度为$O(n^2)$。</p>
<p>为了减少时间复杂度，我们可以尝试分治法。通过观察，可以发现，最大面积矩形存在于以下几种情况：</p>
<ol>
<li><p>确定了最矮柱子以后，矩形的宽尽可能往两边延伸。</p>
</li>
<li><p>在最矮柱子左边的最大面积矩形（子问题）。</p>
</li>
<li><p>在最矮柱子右边的最大面积矩形（子问题）。</p>
</li>
</ol>
<p>找到了划分子问题的方法，我们可以尝试分治算法求解。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> heights<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> left<span class="token operator">></span>right <span class="token operator">or</span> left<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">or</span> right<span class="token operator">>=</span>len<span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token number">0</span>
            tmp<span class="token operator">=</span>heights<span class="token punctuation">[</span>left<span class="token punctuation">:</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
            min_height<span class="token operator">=</span>min<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>
            min_pos<span class="token operator">=</span>tmp<span class="token punctuation">.</span>index<span class="token punctuation">(</span>min_height<span class="token punctuation">)</span><span class="token operator">+</span>left
            <span class="token keyword">return</span> max<span class="token punctuation">(</span>min_height<span class="token operator">*</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>max<span class="token punctuation">(</span>recur<span class="token punctuation">(</span>left<span class="token punctuation">,</span>min_pos<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>recur<span class="token punctuation">(</span>min_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> recur<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然而，我们发现，虽然分治法的平均时间复杂度为$O(nlogn)$，但依然存在着缺陷，即假如数组有序，那么分治法将退化为暴力算法，时间复杂度为$O(n^2)$。</p>
<p>为了进一步优化，我们需要尝试以空间换时间的算法。我们知道，这道题还有一种暴力的思路，就是类似于最小回文子串问题的中心扩展法，即“ 依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度多少。 ”</p>
<p><img src="84-2.png" alt="暴力求解"></p>
<p>这个算法的核心思想是找到每个高度的柱子左侧和右侧的第一个高度小于它的柱子，利用他们所夹的区间和当前柱子的高度即可得到当前高度的矩形的最大面积。时间复杂度为$O(n^2)$。</p>
<p>那么有没有办法优化它呢？我们可以使用一个单调栈来解决这个问题。</p>
<ul>
<li>栈中存放当前高度数组的下标，并在当前高度数组的两端增加高度为0的哨兵，以减少判断。</li>
<li>遍历高度数组，维持当前栈的非递减性。如果当前高度小于栈顶下标的高度，那么说明栈顶元素必然被当前高度和之前某个高度夹在中间，根据我们之前的中心扩散算法，可以得到该栈顶元素代表的高度的矩阵的最大面积。具体的做法是：栈顶元素不断出栈，查看它出栈后的栈顶元素是否小于它，小于则找到了左边界，然后利用我们当前遍历到的高度作为右边界，计算当前矩阵最大面积，尝试更新结果。</li>
<li>继续上述过程，直到当前高度大于或等于栈顶下标高度，此时，将当前高度入栈，继续向前并遍历。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> heights<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        heights<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>heights<span class="token operator">+</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#引入哨兵</span>
        res<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">while</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>heights<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#此时栈顶下标高度的矩形的面积可被确定</span>
                now<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">while</span> heights<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">==</span>heights<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#寻找左边界，即第一个小于栈顶元素的高度</span>
                    stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                res<span class="token operator">=</span>max<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">-</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>heights<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#更新结果</span>
            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#当前下标入栈（为什么是下标，因为我们要计算矩形的宽度）</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(n)$，每个元素都要出栈、入栈各一次。</li>
<li>空间复杂度：$O(n)$，维护一个单调栈。</li>
</ul>
<h3 id="85题-最大矩形"><a href="#85题-最大矩形" class="headerlink" title="85题 最大矩形"></a>85题 <a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">最大矩形</a></h3><p><img src="85.png" alt="第85题 最大矩形"></p>
<h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><p>基本思路是将求解矩阵中的最大矩形转化为84题中的柱状图中的最大矩形，然后再使用84题的单调栈方法求解。对于矩阵的每一个位置，我们可以求解其位置上“1”的高度，然后对于矩阵中的每一行，我们可以计算出当前行上”1“矩阵的最大面积，并尝试更新结果。</p>
<ul>
<li>时间复杂度：$O(MN)$，计算高度时遍历一次矩阵，计算最大面积时再遍历一次矩阵，共2MN次。</li>
<li>空间复杂度：$O(N)$，每一次求解每行的最大面积时，需要使用一个与列数大小相等的单调栈。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maximalRectangle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">getLargestArea</span><span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token punctuation">:</span>
            heights<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>heights<span class="token operator">+</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
            stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
            res<span class="token operator">=</span><span class="token number">0</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>heights<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>heights<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    now<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                    <span class="token keyword">while</span> <span class="token punctuation">(</span>heights<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">==</span>heights<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                    res<span class="token operator">=</span>max<span class="token punctuation">(</span>heights<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">-</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
            <span class="token keyword">return</span> res

        res<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                    matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>int<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span> <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'0'</span> <span class="token keyword">else</span> <span class="token number">1</span><span class="token operator">+</span>matrix<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            res<span class="token operator">=</span>max<span class="token punctuation">(</span>getLargestArea<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-4-1-（3-medium）"><a href="#2020-4-1-（3-medium）" class="headerlink" title="2020.4.1 （3 medium）"></a>2020.4.1 （3 medium）</h2><h3 id="94题-二叉树的中序遍历"><a href="#94题-二叉树的中序遍历" class="headerlink" title="94题 二叉树的中序遍历"></a>94题 <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></h3><p><img src="94.png" alt="第94题"></p>
<h5 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h5><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="非递归解法"><a href="#非递归解法" class="headerlink" title="非递归解法"></a>非递归解法</h5><p>思路：使用辅助栈。只要弄懂了递归的过程，就可以使用栈来模拟。</p>
<p>每到一个节点 A，因为根的访问在中间，将 A 入栈。然后遍历左子树，接着访问 A，最后遍历右子树。在访问完 A 后，A 就可以出栈了。因为 A 和其左子树都已经访问完成。</p>
<p>二叉树的先序、中序、后序遍历的非递归解法都是使用一个辅助栈来暂存需要回过头来访问的节点，从而代替递归函数的返回过程。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        p<span class="token operator">=</span>root
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">or</span> stack<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历左子树，不断将当前节点入栈，因为要遍历完左子树才能访问</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
                p<span class="token operator">=</span>p<span class="token punctuation">.</span>left
            p<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#遍历完左子树后，取出栈顶元素，进行访问</span>
            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            p<span class="token operator">=</span>p<span class="token punctuation">.</span>right<span class="token comment" spellcheck="true">#继续遍历右子树</span>
        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(N)$，所有节点各入栈出栈一次。</li>
<li>空间复杂度：$O(N)$，最坏情况下需要大小为N的辅助栈。</li>
</ul>
<h3 id="144题-二叉树的前序遍历"><a href="#144题-二叉树的前序遍历" class="headerlink" title="144题 二叉树的前序遍历"></a>144题 <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历</a></h3><p><img src="144.png" alt="第144题"></p>
<h5 id="递归解法-1"><a href="#递归解法-1" class="headerlink" title="递归解法"></a>递归解法</h5><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        preorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="非递归解法-1"><a href="#非递归解法-1" class="headerlink" title="非递归解法"></a>非递归解法</h5><p>思路：依然使用辅助栈，先将当前节点的右孩子入栈保存，然后访问当前节点，接着遍历当前节点的左孩子。遍历完左子树后，继续遍历右子树。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        p<span class="token operator">=</span>root
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">or</span> stack<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#先访问当前节点</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#暂存右孩子至栈中，等遍历完左子树开始访问</span>
                p<span class="token operator">=</span>p<span class="token punctuation">.</span>left<span class="token comment" spellcheck="true">#遍历左孩子</span>
            p<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#遍历完左子树后，开始遍历右子树</span>
        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="145题-二叉树的后序遍历"><a href="#145题-二叉树的后序遍历" class="headerlink" title="145题 二叉树的后序遍历"></a>145题 二叉树的后序遍历</h3><p><img src="145.png" alt="第145题"></p>
<h5 id="递归解法-2"><a href="#递归解法-2" class="headerlink" title="递归解法"></a>递归解法</h5><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>
                postorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                postorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        postorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="非递归解法-2"><a href="#非递归解法-2" class="headerlink" title="非递归解法"></a>非递归解法</h5><p>思路：我们知道，二叉树的后序遍历是“左-右-根”，而二叉树的逆前序遍历是“右-左-根”，所以我们可以使用辅助栈实现二叉树的逆前序遍历后，再将结果翻转，即为后序遍历。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        p<span class="token operator">=</span>root
        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">or</span> stack<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                p<span class="token operator">=</span>p<span class="token punctuation">.</span>right
            p<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> result<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-4-2-（2-medium-1easy）"><a href="#2020-4-2-（2-medium-1easy）" class="headerlink" title="2020.4.2 （2 medium 1easy）"></a>2020.4.2 （2 medium 1easy）</h2><h3 id="96题-不同的二叉搜索树"><a href="#96题-不同的二叉搜索树" class="headerlink" title="96题 不同的二叉搜索树"></a>96题 <a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">不同的二叉搜索树</a></h3><p><img src="96.png" alt="第96题"></p>
<h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><p>动态规划求解，DFS太耗费时间。我们设状态矩阵DP[i]为1..i为节点的二叉搜索树的数目，f[i]为以i为根节点的二叉搜索树数目，则有：</p>
<ul>
<li>DP[i]=f[1]+f[2]+…+f[i]，即计算以1到i的每个节点为根节点的二叉搜索树数目之和。</li>
<li>f[j]=DP[j-1]*DP[i-j]，即以j为根节点的二叉搜索树，左侧有j-1个节点，右侧有i-j个节点，又因为j+1到i为节点的二叉搜索树数目与1到i-j的二叉搜索树一致，所以可以用DP[i-j]来代替。则左右两边子树组合数目为DP[j-1]乘以DP[i-j]。</li>
<li>则动态规划转移方程为：DP[i]=DP[0] <em> DP[i-1]+DP[1] </em> DP[i-2]+…+DP[i] * DP[0]</li>
<li>这个动态规划方程在数学上有一个名字，叫做“卡特兰数”</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">numTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token comment" spellcheck="true">#注意，这里的0个数组成的二叉搜索树数目为1，这是因为左子树为空也合法。</span>
        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>dp<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="98题-验证二叉搜索树"><a href="#98题-验证二叉搜索树" class="headerlink" title="98题 验证二叉搜索树"></a>98题 <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a></h3><p><img src="98.png" alt="第98题"></p>
<h4 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h4><p>我们知道，如果我们中序遍历二叉搜索树，那么得到的序列必然是递增的，我们就可以通过这一性质验证二叉搜索树。我们中序遍历二叉搜索树，并且记录下当前中序遍历得到的序列的最后一个元素值，如果当前元素值大于它，说明满足二叉搜索树的性质，可以继续递归判断。如果非递增了，就返回False。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>last_value<span class="token operator">=</span>None
        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#我们认为空子树是二叉搜索树，方便递归</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">if</span> inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历左子树，看是否满足递增</span>
                <span class="token keyword">if</span> self<span class="token punctuation">.</span>last_value<span class="token operator">==</span>None <span class="token operator">or</span> root<span class="token punctuation">.</span>val<span class="token operator">></span>self<span class="token punctuation">.</span>last_value<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#看当前节点是否满足递增</span>
                    self<span class="token punctuation">.</span>last_value<span class="token operator">=</span>root<span class="token punctuation">.</span>val
                    <span class="token keyword">if</span> inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#看右子树是否满足递增</span>
                        <span class="token keyword">return</span> <span class="token boolean">True</span><span class="token comment" spellcheck="true">#如果左中右都满足，返回True</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token comment" spellcheck="true">#如果有一项不满足，返回False</span>
        <span class="token keyword">return</span> inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="101题-对称二叉树"><a href="#101题-对称二叉树" class="headerlink" title="101题 对称二叉树"></a>101题 <a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">对称二叉树</a></h3><p><img src="101.png" alt="第101题"></p>
<h4 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer类似题，递归求解法，我们知道，两个节点对称的条件为：</p>
<ol>
<li>两个节点均为空。</li>
<li>两个节点均不为空，且节点a的值等于节点b的值，且节点a的左子树和节点b的右子树镜像，节点b的左子树和节点a的右子树镜像。</li>
</ol>
<p>当根节点非空时，我们递归判断左右子树是否对称即可。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> a<span class="token operator">==</span>None <span class="token operator">and</span> b<span class="token operator">==</span>None<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">if</span> a<span class="token operator">!=</span>None <span class="token operator">and</span> b<span class="token operator">!=</span>None<span class="token punctuation">:</span>
                <span class="token keyword">return</span> a<span class="token punctuation">.</span>val<span class="token operator">==</span>b<span class="token punctuation">.</span>val <span class="token operator">and</span> match<span class="token punctuation">(</span>a<span class="token punctuation">.</span>left<span class="token punctuation">,</span>b<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">and</span> match<span class="token punctuation">(</span>a<span class="token punctuation">.</span>right<span class="token punctuation">,</span>b<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">return</span> match<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<h2 id="2020-4-3-（2-medium-1easy）"><a href="#2020-4-3-（2-medium-1easy）" class="headerlink" title="2020.4.3 （2 medium 1easy）"></a>2020.4.3 （2 medium 1easy）</h2><h3 id="第104题-二叉树的最大深度"><a href="#第104题-二叉树的最大深度" class="headerlink" title="第104题 二叉树的最大深度"></a>第104题 <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a></h3><p><img src="104.png" alt="第104题"></p>
<h4 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h4><p>数据结构基本题，剑指offer二叉树原题，递归搜索即可。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第105题-从前序与中序遍历序列构造二叉树"><a href="#第105题-从前序与中序遍历序列构造二叉树" class="headerlink" title="第105题  从前序与中序遍历序列构造二叉树"></a>第105题 <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener"> 从前序与中序遍历序列构造二叉树</a></h3><p><img src="105.png" alt="第105题"></p>
<h4 id="思路：-10"><a href="#思路：-10" class="headerlink" title="思路："></a>思路：</h4><p>数据结构基本题，剑指offer二叉树原题，分治法即可。</p>
<ul>
<li>前序遍历确定当前子树的根节点。</li>
<li>中序遍历确定左右子树节点数目。</li>
<li>根据左右子树节点数目，从前序、中序遍历中切分出左、右子树的前序、中序遍历，分治法确定当前节点左右孩子。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>preL<span class="token punctuation">,</span>preR<span class="token punctuation">,</span>inL<span class="token punctuation">,</span>inR<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> preL<span class="token operator">></span>preR <span class="token operator">or</span> inL<span class="token operator">></span>inR<span class="token punctuation">:</span>
                <span class="token keyword">return</span> None
            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preL<span class="token punctuation">]</span><span class="token punctuation">)</span>
            in_pos<span class="token operator">=</span>inorder<span class="token punctuation">[</span>inL<span class="token punctuation">:</span>inR<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preL<span class="token punctuation">]</span><span class="token punctuation">)</span>
            root<span class="token punctuation">.</span>left<span class="token operator">=</span>build<span class="token punctuation">(</span>preL<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>preL<span class="token operator">+</span>in_pos<span class="token punctuation">,</span>inL<span class="token punctuation">,</span>inL<span class="token operator">+</span>in_pos<span class="token number">-1</span><span class="token punctuation">)</span>
            root<span class="token punctuation">.</span>right<span class="token operator">=</span>build<span class="token punctuation">(</span>preL<span class="token operator">+</span>in_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>preR<span class="token punctuation">,</span>inL<span class="token operator">+</span>in_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>inR<span class="token punctuation">)</span>
            <span class="token keyword">return</span> root
        <span class="token keyword">return</span> build<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>preorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>inorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第114题-二叉树展开为链表"><a href="#第114题-二叉树展开为链表" class="headerlink" title="第114题 二叉树展开为链表"></a>第114题 <a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表</a></h3><p><img src="114.png" alt="第114题"></p>
<h4 id="思路：-11"><a href="#思路：-11" class="headerlink" title="思路："></a>思路：</h4><p>我自己的方法有些类似于剑指Offer中的二叉树转双向链表。</p>
<ul>
<li>使用一个全局变量tail作为指针，指向当前已生成链表中的最后一个节点。</li>
<li>先序遍历二叉树，每次修改tail指针的左节点为当前节点，即使用left指针模拟链表的next指针。</li>
<li>调整链表，使用right指针模拟next指针，并将left指针置空。（为什么不直接用right指针模拟？因为先序遍历是根-左-右的顺序，对左孩子的遍历可能导致根节点的right指针被覆盖，导致无法继续遍历右孩子）</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">flatten</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Do not return anything, modify root in-place instead.
        """</span>
        self<span class="token punctuation">.</span>tail<span class="token operator">=</span>None
        <span class="token keyword">def</span> <span class="token function">flat</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            <span class="token keyword">if</span> self<span class="token punctuation">.</span>tail<span class="token operator">!=</span>None<span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>left<span class="token operator">=</span>root
            self<span class="token punctuation">.</span>tail<span class="token operator">=</span>root
            flat<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            flat<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">def</span> <span class="token function">change</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token operator">=</span>None<span class="token punctuation">,</span>root<span class="token punctuation">.</span>left
            change<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>         
        flat<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        change<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<h2 id="2020-4-4-（2-hard-1easy）"><a href="#2020-4-4-（2-hard-1easy）" class="headerlink" title="2020.4.4 （2 hard 1easy）"></a>2020.4.4 （2 hard 1easy）</h2><h3 id="124题-二叉树中的最大路径和"><a href="#124题-二叉树中的最大路径和" class="headerlink" title="124题  二叉树中的最大路径和"></a>124题 <a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener"> 二叉树中的最大路径和</a></h3><p><img src="124.png" alt="第124题"></p>
<h4 id="思路：-12"><a href="#思路：-12" class="headerlink" title="思路："></a>思路：</h4><p>我的思路是递归求解，先给出代码：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>max_sum<span class="token operator">=</span>root<span class="token punctuation">.</span>val
        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token number">0</span>
            left_sum<span class="token operator">=</span>max<span class="token punctuation">(</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
            right_sum<span class="token operator">=</span>max<span class="token punctuation">(</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
            now_path_sum<span class="token operator">=</span>root<span class="token punctuation">.</span>val<span class="token operator">+</span>left_sum<span class="token operator">+</span>right_sum
            self<span class="token punctuation">.</span>max_sum<span class="token operator">=</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>max_sum<span class="token punctuation">,</span>now_path_sum<span class="token punctuation">)</span>
            <span class="token keyword">return</span> root<span class="token punctuation">.</span>val<span class="token operator">+</span>max<span class="token punctuation">(</span>left_sum<span class="token punctuation">,</span>right_sum<span class="token punctuation">)</span>
        recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>max_sum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果当前节点为空，我们的递归函数返回0，表示经过该节点的最大路径和为0。</p>
<p>接着我们递归计算左子树和右子树，如果递归函数返回值大于0，说明加上它有可能会使当前节点路径和变大，否则不走路径和小于0的子树。</p>
<p>当前节点的最大路径和即为当前节点的值加上左子树和0的最大值加上右子树和0的最大值，加上后即可尝试更新当前二叉树的最大路径和。</p>
<p>接下来是进行返回，也是本题中最容易出错的地方！返回值不是当前节点的最大路径和，而是只能走一边的子树，因为二叉树的节点不能被重复访问！</p>
<h3 id="128题-最长连续序列"><a href="#128题-最长连续序列" class="headerlink" title="128题  最长连续序列"></a>128题 <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener"> 最长连续序列</a></h3><p><img src="128.png" alt="第128题"></p>
<h4 id="思路：-13"><a href="#思路：-13" class="headerlink" title="思路："></a>思路：</h4><p>我们先从暴力算法想起，暴力算法的做法是遍历数组中的每一个数，查看他的下一个数是否在数组中，如果在，那么就再查看下一个数，直到出现不在数组中的数，记录下当前长度并尝试更新最大长度。由于数组无序，所以每次查找都需要$O(n)$的时间复杂度，最坏情况下（即数组降序），需要的时间复杂度为$O(n^3)$。</p>
<p>为了优化至$O(n)$的时间复杂度，首先，我们可以建立辅助的数据结构——哈希表。这里，我们使用哈希集合，hashset和hashmap的区别在于，hashset只存key不存value，而hashmap存了键值对。我们知道，哈希集合的查找时间复杂度仅需$O(1)$（直接哈希函数），所以此时的时间复杂度已经降为$O(n^2)$。</p>
<p>为了进一步优化，我们进行剪枝操作，当我们访问到num，假如num-1已经在hashset中，那么我们就不对他进行向后搜索。即：我们现在只对序列开头的数进行向后搜索。因为我们使用的是hashset，所以判断num-1是否存在依然很快。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        hashset<span class="token operator">=</span>set<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        first_num<span class="token operator">=</span><span class="token number">0</span>
        max_length<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>
            <span class="token keyword">if</span> num<span class="token number">-1</span> <span class="token operator">not</span> <span class="token keyword">in</span> hashset<span class="token punctuation">:</span>
                length<span class="token operator">=</span><span class="token number">1</span>
                <span class="token keyword">while</span> num<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">in</span> hashset<span class="token punctuation">:</span>
                    num<span class="token operator">+=</span><span class="token number">1</span>
                    length<span class="token operator">+=</span><span class="token number">1</span>
                max_length<span class="token operator">=</span>max<span class="token punctuation">(</span>length<span class="token punctuation">,</span>max_length<span class="token punctuation">)</span>
        <span class="token keyword">return</span> max_length<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<h3 id="136题-只出现一次的数字"><a href="#136题-只出现一次的数字" class="headerlink" title="136题 只出现一次的数字"></a>136题 <a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">只出现一次的数字</a></h3><p><img src="136.png" alt="第136题"></p>
<h4 id="思路：-14"><a href="#思路：-14" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，异或运算，一个数异或自身为0，异或0为自身。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        result<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>
            result<span class="token operator">^</span><span class="token operator">=</span>num
        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-4-5-（2-medium-1easy）"><a href="#2020-4-5-（2-medium-1easy）" class="headerlink" title="2020.4.5 （2 medium 1easy）"></a>2020.4.5 （2 medium 1easy）</h2><h3 id="139题-单词拆分"><a href="#139题-单词拆分" class="headerlink" title="139题 单词拆分"></a>139题 <a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">单词拆分</a></h3><p><img src="139.png" alt="第139题"></p>
<h4 id="思路：-15"><a href="#思路：-15" class="headerlink" title="思路："></a>思路：</h4><p>这类题最常见的解法就是动态规划法了。类似的问题还有：正则表达式匹配等。</p>
<p>我在一开始却尝试了DFS，递归超时了。<strong>类似的题目是不能用DFS的！必然超时！希望自己以后能记住这个教训！因为这道题存在着重叠子问题，就像走迷宫问题一样，假设字符串s的前 i 个字符的匹配可以通过多条路径得到，那么它们从第 i 个字符往后的路径都是相同的，如果使用递归，由于无法记录递归过程中的状态，会产生大量的重复计算。</strong>解决的方案可以是带备忘录的递归，但动态规划显然更加有效。</p>
<p>我们使用DP求解。DP状态矩阵dp[i]为s的前i个字符是否匹配。转移方程为：遍历wordDict中的word，dp[i]=dp[i-len（word）]（if i-len（word）&gt;=0 and dp[i-len（word）] and s[i-len（word）:i]==word）。即假如前i个字符的末尾存在wordDict中的某个单词，且去除该单词后，前i-len（word）个字符也能拆分，说明前i个字符可以被拆分。</p>
<ul>
<li>时间复杂度：$O(n^2)$</li>
<li>空间复杂度：$O(n)$</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> wordDict<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        sorted<span class="token punctuation">(</span>wordDict<span class="token punctuation">,</span>key<span class="token operator">=</span>len<span class="token punctuation">,</span>reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> word <span class="token keyword">in</span> wordDict<span class="token punctuation">:</span>
                start<span class="token operator">=</span>i<span class="token operator">-</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span>
                <span class="token keyword">if</span> start<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> dp<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>start<span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token operator">==</span>word<span class="token punctuation">:</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>
                    <span class="token keyword">break</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="141题-环形链表"><a href="#141题-环形链表" class="headerlink" title="141题 环形链表"></a>141题 <a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表</a></h3><p><img src="141.png" alt="第141题"></p>
<h4 id="思路：-16"><a href="#思路：-16" class="headerlink" title="思路："></a>思路：</h4><p>hashset存放已经访问过的节点，遍历链表，如果访问到已存在hashset中的节点时，返回True，即存在环，否则将当前节点加入hashset，继续向前遍历。</p>
<ul>
<li>时间复杂度：$O(n)$，哈希表的查找为$O(1)$</li>
<li>空间复杂度：$O(n)$</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span>
<span class="token comment" spellcheck="true"># class ListNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        nodes<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>
        p<span class="token operator">=</span>head
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> p <span class="token keyword">in</span> nodes<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            nodes<span class="token punctuation">.</span>add<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next
        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了更进一步的优化时间复杂度和空间复杂度，我们可以原地修改链表，对访问过的节点的值设为”visited“，如果遍历到已访问节点，return True。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span>
<span class="token comment" spellcheck="true"># class ListNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        p<span class="token operator">=</span>head
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> p<span class="token punctuation">.</span>val<span class="token operator">==</span><span class="token string">"visited"</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            p<span class="token punctuation">.</span>val<span class="token operator">=</span><span class="token string">"visited"</span>
            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next
        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<h3 id="142题-环形链表-II"><a href="#142题-环形链表-II" class="headerlink" title="142题 环形链表 II"></a>142题 <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">环形链表 II</a></h3><p><img src="142.png" alt="第142题"></p>
<p>这道题要求我们不能原地修改链表，所以141题中的第二种方法就不能使用，只能使用哈希集合的方法。但是，有没有方法能够不使用额外的数据结构呢？</p>
<p>我们可以使用Floyd算法，采用快慢指针的做法求出环形链表的环入口节点。</p>
<ul>
<li>定义双指针fast、slow，均指向head节点。</li>
<li>fast、slow向前遍历，fast每次走两步，slow每次走一步。</li>
<li>假如fast走到了None，说明链表无环，直接返回None。</li>
<li>否则，fast和slow必然会在环中的某一个节点处相遇，此时，fast节点走过的路程为f，slow节点走过的路程为s，环的长度为b，则必有：（1）f=2s（因为快指针每次走两步，慢指针走一步，快指针的路程必然是慢指针的两倍），（2）f=s+nb（要想相遇，快指针必然比慢指针多走了n圈）。二者相减，得：s=nb，f=2nb。</li>
<li>我们知道，想要从起点走到环入口，需要走a+nb，其中，a是指从链表起点到环入口的步数，nb为在环中转圈的步数。所以，我们已有：s=nb，只要让慢指针再走a步，即可到达环入口节点。</li>
<li>我们可以移动fast到头节点，让快指针和慢指针每次都走一步，最终，快慢指针将在环入口处相遇，此时:f=a,s=a+nb。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span>
<span class="token comment" spellcheck="true"># class ListNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>
        fast<span class="token operator">=</span>head
        slow<span class="token operator">=</span>head
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> fast<span class="token operator">==</span>None <span class="token operator">or</span> fast<span class="token punctuation">.</span>next<span class="token operator">==</span>None <span class="token operator">or</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>
                <span class="token keyword">return</span> None
            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
            slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next
            <span class="token keyword">if</span> fast<span class="token operator">==</span>slow<span class="token punctuation">:</span>
                <span class="token keyword">break</span>
        fast<span class="token operator">=</span>head
        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token operator">!=</span>slow<span class="token punctuation">)</span><span class="token punctuation">:</span>
            fast<span class="token punctuation">,</span>slow<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">,</span>slow<span class="token punctuation">.</span>next
        <span class="token keyword">return</span> slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<h2 id="2020-4-6-（3-medium）"><a href="#2020-4-6-（3-medium）" class="headerlink" title="2020.4.6 （3 medium）"></a>2020.4.6 （3 medium）</h2><h3 id="146题-LRU缓存机制"><a href="#146题-LRU缓存机制" class="headerlink" title="146题 LRU缓存机制"></a>146题 <a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LRU缓存机制</a></h3><p><img src="146.png" alt="第146题"></p>
<h4 id="思路：-17"><a href="#思路：-17" class="headerlink" title="思路："></a>思路：</h4><p>基本思路是使用一个类似于队列的数据结构，我们将最近使用的键值对放置到队首，这样队尾键值对必然是最近最少使用的。当添加新的键值对，而缓存已满时，我们需要将队尾的键值对出队，并将新的键值对添加到队首，从而实现了LRU缓存机制。</p>
<p>特别地，题目要求我们使用$O(1)$级别的时间复杂度，我们很容易便想到了哈希表，其查找节点的时间复杂度为$O(1)$（类似于为链表中的节点建立索引）。更进一步，我们需要修改原先的队列为双向链表，因为只有双向链表可以保证删除节点的时间复杂度在$O(1)$，而我们需要在以下两种情况进行删除节点操作（插入节点都是在头部，均为$O(1)$：</p>
<ul>
<li>当我们需要进行get操作时，需要将被访问的键值对的节点移动到双向链表开头，需要先删除，再插入。</li>
<li>当我们需要进行put操作，而缓存已满时，需要将尾部键值对删除。</li>
</ul>
<p>所以，使用双向链表是必要的。特别地，为了减少插入、删除过程中的额外判断，我们使用链表中经常需要用到的伪头节点和伪尾节点。（如果直接使用字典，虽然python3中dictionary是有序的，但无法选择插入的位置）</p>
<p>算法的基本流程如下：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// key 映射到 Node(key, val)</span>
HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Node<span class="token operator">></span> map<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Node(k1, v1) &lt;-> Node(k2, v2)...</span>
DoubleList cache<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key 不存在<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        
        将数据 <span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> 提到开头；
        <span class="token keyword">return</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Node x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key 已存在<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        把旧的数据删除；
        将新节点 x 插入到开头；
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cache 已满<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            删除链表的最后一个数据腾位置；
            删除 map 中映射到该数据的键；
        <span class="token punctuation">}</span> 
        将新节点 x 插入到开头；
        map 中新建 key 对新节点 x 的映射；
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们自己实现双向链表、节点、以及调整节点至开头，插入节点至开头，删除尾部节点操作后，完整的代码如下：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>key<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>key<span class="token operator">=</span>key
        self<span class="token punctuation">.</span>val<span class="token operator">=</span>val
        self<span class="token punctuation">.</span>next<span class="token operator">=</span>None
        self<span class="token punctuation">.</span>prev<span class="token operator">=</span>None

<span class="token keyword">class</span> <span class="token class-name">LinkedList</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>head<span class="token operator">=</span>Node<span class="token punctuation">(</span>None<span class="token punctuation">,</span>None<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>tail<span class="token operator">=</span>Node<span class="token punctuation">(</span>None<span class="token punctuation">,</span>None<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token operator">=</span>self<span class="token punctuation">.</span>tail
        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev<span class="token operator">=</span>self<span class="token punctuation">.</span>head

    <span class="token keyword">def</span> <span class="token function">move_to_head</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next<span class="token operator">=</span>node<span class="token punctuation">.</span>next
        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev<span class="token operator">=</span>node<span class="token punctuation">.</span>prev
        node<span class="token punctuation">.</span>prev<span class="token operator">=</span>self<span class="token punctuation">.</span>head
        node<span class="token punctuation">.</span>next<span class="token operator">=</span>self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next
        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token operator">=</span>node
        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev<span class="token operator">=</span>node
        <span class="token keyword">return</span> node<span class="token punctuation">.</span>val

    <span class="token keyword">def</span> <span class="token function">add_to_head</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        node<span class="token punctuation">.</span>prev<span class="token operator">=</span>self<span class="token punctuation">.</span>head
        node<span class="token punctuation">.</span>next<span class="token operator">=</span>self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next
        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token operator">=</span>node
        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev<span class="token operator">=</span>node

    <span class="token keyword">def</span> <span class="token function">pop_tail</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        node<span class="token operator">=</span>self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev
        node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next<span class="token operator">=</span>self<span class="token punctuation">.</span>tail
        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev<span class="token operator">=</span>node<span class="token punctuation">.</span>prev
        <span class="token keyword">return</span> node<span class="token punctuation">.</span>key

<span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> capacity<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>capacity<span class="token operator">=</span>capacity
        self<span class="token punctuation">.</span>hashmap<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        self<span class="token punctuation">.</span>length<span class="token operator">=</span><span class="token number">0</span>
        self<span class="token punctuation">.</span>linkedlist<span class="token operator">=</span>LinkedList<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>hashmap<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>move_to_head<span class="token punctuation">(</span>self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>

    <span class="token keyword">def</span> <span class="token function">put</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">:</span> int<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>hashmap<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>val<span class="token operator">=</span>value
            self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>move_to_head<span class="token punctuation">(</span>self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">elif</span> self<span class="token punctuation">.</span>length<span class="token operator">&lt;</span>self<span class="token punctuation">.</span>capacity<span class="token punctuation">:</span>
            node<span class="token operator">=</span>Node<span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>add_to_head<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span>node
            self<span class="token punctuation">.</span>length<span class="token operator">+=</span><span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            node<span class="token operator">=</span>Node<span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>
            key_del<span class="token operator">=</span>self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>pop_tail<span class="token punctuation">(</span><span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>hashmap<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>key_del<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>linkedlist<span class="token punctuation">.</span>add_to_head<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span>node

<span class="token comment" spellcheck="true"># Your LRUCache object will be instantiated and called as such:</span>
<span class="token comment" spellcheck="true"># obj = LRUCache(capacity)</span>
<span class="token comment" spellcheck="true"># param_1 = obj.get(key)</span>
<span class="token comment" spellcheck="true"># obj.put(key,value)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后总结一下，我们维护一个链表，链表中数据从前至后依次为上次使用时间从近至远。为了减低时间复杂度，我们使用双向链表和哈希表减少调整链表所花费的时间。</p>
<h3 id="148题-排序链表"><a href="#148题-排序链表" class="headerlink" title="148题 排序链表"></a>148题 <a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">排序链表</a></h3><p><img src="148.png" alt="第148题"></p>
<h4 id="思路-44"><a href="#思路-44" class="headerlink" title="思路:"></a>思路:</h4><p>由于时间复杂度需要在$O(nlogn)$，所以可用的算法有：归并排序，快速排序，堆排序等。考虑到合并链表比较方便，所以我们在这里选用归并排序。</p>
<p>与常规的归并排序类似，我们进行递归合并。先调用自身函数归并排序左半部分和右半部分，再调用合并两个有序链表的函数归并左右部分。</p>
<p>这里需要注意的是，当前需要排序的是链表而非数组，所以我们无法通过下标运算直接得到中间节点，对当前链表进行二分划分。假如我们直接遍历链表得到长度再遍历长度的一半找到中间节点，则时间复杂度为$O(3n/2)$。为了优化，我们可以使用快慢指针法。让快指针每次走两步，慢指针每次走一步，当快指针走到链表终点时，慢指针必然位于中间节点。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span>
<span class="token comment" spellcheck="true"># class ListNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">sortList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">getMiddle</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> head<span class="token operator">==</span>None <span class="token operator">or</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>
                <span class="token keyword">return</span> head
            slow<span class="token operator">=</span>head
            fast<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
            <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token operator">!=</span>None <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
                slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next
                fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
            <span class="token keyword">return</span> slow

        <span class="token keyword">def</span> <span class="token function">mergeTwoList</span><span class="token punctuation">(</span>head1<span class="token punctuation">,</span>head2<span class="token punctuation">)</span><span class="token punctuation">:</span>
            dummyhead<span class="token operator">=</span>ListNode<span class="token punctuation">(</span>None<span class="token punctuation">)</span>
            p1<span class="token operator">=</span>dummyhead
            p2<span class="token operator">=</span>head1
            p3<span class="token operator">=</span>head2
            <span class="token keyword">while</span> <span class="token punctuation">(</span>p2<span class="token operator">!=</span>None <span class="token operator">and</span> p3<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> p2<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>p3<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                    p1<span class="token punctuation">.</span>next<span class="token operator">=</span>p2
                    p2<span class="token operator">=</span>p2<span class="token punctuation">.</span>next
                    p1<span class="token operator">=</span>p1<span class="token punctuation">.</span>next
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    p1<span class="token punctuation">.</span>next<span class="token operator">=</span>p3
                    p3<span class="token operator">=</span>p3<span class="token punctuation">.</span>next
                    p1<span class="token operator">=</span>p1<span class="token punctuation">.</span>next
            p1<span class="token punctuation">.</span>next<span class="token operator">=</span>p2 <span class="token keyword">if</span> p2<span class="token operator">!=</span>None <span class="token keyword">else</span> p3
            <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next

        <span class="token keyword">if</span> head<span class="token operator">==</span>None <span class="token operator">or</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>
            <span class="token keyword">return</span> head
        mid<span class="token operator">=</span>getMiddle<span class="token punctuation">(</span>head<span class="token punctuation">)</span>
        tmp<span class="token operator">=</span>mid<span class="token punctuation">.</span>next
        mid<span class="token punctuation">.</span>next<span class="token operator">=</span>None
        head1<span class="token operator">=</span>self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>head<span class="token punctuation">)</span>
        head2<span class="token operator">=</span>self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>
        <span class="token keyword">return</span> mergeTwoList<span class="token punctuation">(</span>head1<span class="token punctuation">,</span>head2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="152题-乘积最大子数组"><a href="#152题-乘积最大子数组" class="headerlink" title="152题 乘积最大子数组"></a>152题 <a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">乘积最大子数组</a></h3><p><img src="152.png" alt="第152题"></p>
<h4 id="思路-45"><a href="#思路-45" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划，类似于最大连续子序和问题。我们使用dp[i]表示前i个数字中子数组的最大乘积。动态规划转移方程为：</p>
<blockquote>
<p>maxDP[i + 1] = max(maxDP[i] <em> A[i + 1], A[i + 1],minDP[i] </em> A[i + 1])<br>minDP[i + 1] = min(minDP[i] <em> A[i + 1], A[i + 1],maxDP[i] </em> A[i + 1])<br>dp[i + 1] = max(dp[i], maxDP[i + 1])</p>
</blockquote>
<p>在这里，maxDP[i] 是以第i个数字结尾的子数组的最大乘积，minDP[i]是以第i个数字结尾的子数组的最小乘积。之所以我们需要保留最小乘积，是因为考虑到第i+1个数字是负数的情况。</p>
<p>由于我们发现，所有的动态规划转移方程都只需要用到前一个状态，所以我们只需要使用三个变量即可代替状态矩阵（滚动数组法优化DP空间的思想）</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxProduct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        imax<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        imin<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        max_product<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>
                imax<span class="token punctuation">,</span>imin<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>imin<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>imax<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                imax<span class="token punctuation">,</span>imin<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>imax<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>imin<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            max_product<span class="token operator">=</span>max<span class="token punctuation">(</span>imax<span class="token punctuation">,</span>max_product<span class="token punctuation">)</span>
        <span class="token keyword">return</span> max_product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的是，imax和imin必须同步更新，因为imin的更新需要使用到imax的值，如果imax的值先被改变，结果将出错。</p>
<h2 id="2020-4-7-（4-easy）"><a href="#2020-4-7-（4-easy）" class="headerlink" title="2020.4.7 （4 easy）"></a>2020.4.7 （4 easy）</h2><h3 id="155题-最小栈"><a href="#155题-最小栈" class="headerlink" title="155题 最小栈"></a>155题 <a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">最小栈</a></h3><p><img src="155.png" alt="第155题"></p>
<h4 id="思路：-18"><a href="#思路：-18" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，我们可以使用一个辅助栈，存放栈内前i个元素中的最小值，以空间换时间。</p>
<ul>
<li>时间复杂度：$O(1)$。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MinStack</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        initialize your data structure here.
        """</span>
        self<span class="token punctuation">.</span>stack1<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>stack2<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack2<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>min<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>

    <span class="token keyword">def</span> <span class="token function">getMin</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>


<span class="token comment" spellcheck="true"># Your MinStack object will be instantiated and called as such:</span>
<span class="token comment" spellcheck="true"># obj = MinStack()</span>
<span class="token comment" spellcheck="true"># obj.push(x)</span>
<span class="token comment" spellcheck="true"># obj.pop()</span>
<span class="token comment" spellcheck="true"># param_3 = obj.top()</span>
<span class="token comment" spellcheck="true"># param_4 = obj.getMin()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="160题-相交链表"><a href="#160题-相交链表" class="headerlink" title="160题 相交链表"></a>160题 <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">相交链表</a></h3><p><img src="160.png" alt="第160题"></p>
<h4 id="思路：-19"><a href="#思路：-19" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，我们最容易想到的方法是采用哈希表的方式，记录下A、B链表中的每一个节点，找到第一个重复的节点返回。但有没有方法可以不使用额外的空间呢？答案是有的，我们可以使用双指针法，这有些类似于环形链表142题。</p>
<p>我们创建指针p指向headA，指针q指向headB，使二者向前遍历链表A和B。当p遍历到链表A结尾时，令p=headB，当q遍历到链表B结尾时，令q=headA。如果链表A和链表B存在相交点时，p和q继续向后遍历，必然会在相交点处相等。如果不存在相交点，p和q继续向后遍历，必然会同时遍历到链表结尾。</p>
<p>原理：</p>
<p><img src="160-1.png" alt="第160题示意图"></p>
<p>假如相交，则a+b+c必然等于c+b+a！p指针和q指针在链表相交点处必然走过相同的路程。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span>
<span class="token comment" spellcheck="true"># class ListNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> headA<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> headB<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>
        <span class="token keyword">if</span> headA<span class="token operator">==</span>None <span class="token operator">or</span> headB<span class="token operator">==</span>None<span class="token punctuation">:</span>
            <span class="token keyword">return</span> None
        p<span class="token operator">=</span>headA
        q<span class="token operator">=</span>headB
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> p<span class="token punctuation">.</span>next<span class="token operator">==</span>None <span class="token operator">and</span> q<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>
                <span class="token keyword">return</span> None
            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next <span class="token keyword">if</span> p<span class="token punctuation">.</span>next<span class="token operator">!=</span>None <span class="token keyword">else</span> headB
            q<span class="token operator">=</span>q<span class="token punctuation">.</span>next <span class="token keyword">if</span> q<span class="token punctuation">.</span>next<span class="token operator">!=</span>None <span class="token keyword">else</span> headA
        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="169题-多数元素"><a href="#169题-多数元素" class="headerlink" title="169题 多数元素"></a>169题 <a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">多数元素</a></h3><p><img src="169.png" alt="第169题"></p>
<h4 id="思路：-20"><a href="#思路：-20" class="headerlink" title="思路："></a>思路：</h4><p>常规的做法有：（1）哈希表记录各元素出现的次数，选择出现次数最多的元素（时：$O(n)$，空：$O(n)$）（2）排序法，取中值。（时：$O(nlogn)$，空：$O(1)$）</p>
<p>为了获得最优的时空复杂度，我们还可以使用投票算法：</p>
<ul>
<li>如果我们把众数记为 +1，把其他数记为 -1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。 </li>
<li>我们遍历数组，使用count记录下当前投票和。如果count等于0，那么就更新候选人。接着进行投票，如果当前值等于候选人，count加1，否则count减1。</li>
<li>投票算法证明：<ol>
<li>如果候选人不是maj（多数元素） 则 maj,会和其他非候选人一起反对 会反对候选人,所以候选人一定会下台(maj==0时发生换届选举)</li>
<li>如果候选人是maj , 则maj 会支持自己，其他候选人会反对，同样因为maj 票数超过一半，所以maj 一定会成功当选</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        count<span class="token operator">=</span><span class="token number">0</span>
        candidate<span class="token operator">=</span>None
        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>
            <span class="token keyword">if</span> count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                candidate<span class="token operator">=</span>num
            count<span class="token operator">+=</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">if</span> num<span class="token operator">==</span>candidate <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> candidate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h3 id="198题-打家劫舍"><a href="#198题-打家劫舍" class="headerlink" title="198题 打家劫舍"></a>198题 <a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">打家劫舍</a></h3><p><img src="198.png" alt="第198题"></p>
<h4 id="思路：-21"><a href="#思路：-21" class="headerlink" title="思路："></a>思路：</h4><p>动态规划模板题，有些类似于01背包问题。动态规划状态矩阵dp[i]用于表示偷前i家的最大金额，转移方程为：</p>
<ul>
<li>dp[i]=max（dp[i-1]，dp[i-2]+nums[i]）</li>
</ul>
<p>即考虑偷当前这家和不偷当前这家的收益谁更大，选择最大收益。（偷这家就不能偷上一家）</p>
<p>由于只用到前两个状态，所以我们可以使用滚动数组的思想进行空间优化。</p>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        a<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        b<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            a<span class="token punctuation">,</span>b<span class="token operator">=</span>b<span class="token punctuation">,</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>
        <span class="token keyword">return</span> b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-4-8（3-medium-1-easy）"><a href="#2020-4-8（3-medium-1-easy）" class="headerlink" title="2020.4.8（3 medium 1 easy）"></a>2020.4.8（3 medium 1 easy）</h2><h3 id="200题-岛屿数量"><a href="#200题-岛屿数量" class="headerlink" title="200题 岛屿数量"></a>200题 <a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">岛屿数量</a></h3><p><img src="200.png" alt="第200题"></p>
<h4 id="思路：-22"><a href="#思路：-22" class="headerlink" title="思路："></a>思路：</h4><p>DFS模板题，使用一个visited矩阵来存放某个位置是否已被访问过。</p>
<p>遍历grid矩阵，每次遇到尚未被访问的岛屿时，将计数变量加1，再使用DFS遍历该岛屿的所有土地，并标记为已访问，访问过的土地或者水域都不会进行访问。这样，将会把该岛屿的所有土地都访问一次，然后终止递归。最后，所有的岛屿将被遍历一次，计数变量的值即为岛屿数。</p>
<p>特别地，为了减少空间占用，我们还可以原地修改grid矩阵来表示已访问过。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">numIslands</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> row<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">or</span> row<span class="token operator">>=</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span> <span class="token operator">or</span> col<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">or</span> col<span class="token operator">>=</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            <span class="token keyword">if</span> grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"1"</span><span class="token punctuation">:</span>
                grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"0"</span>
                dfs<span class="token punctuation">(</span>row<span class="token number">-1</span><span class="token punctuation">,</span>col<span class="token punctuation">)</span>
                dfs<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>col<span class="token punctuation">)</span>
                dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token number">-1</span><span class="token punctuation">)</span>
                dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        islands<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"1"</span><span class="token punctuation">:</span>
                    islands<span class="token operator">+=</span><span class="token number">1</span>
                    dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span>
        <span class="token keyword">return</span> islands<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(mn)$。</li>
<li>空间复杂度：$O(mn)$，递归栈。</li>
</ul>
<p>这道题还可以用<a href="https://blog.csdn.net/qq_41593380/article/details/81146850" target="_blank" rel="noopener">并查集</a>来做。基本思路就是将连同的陆地合并到同一个集合中，最后统计集合数目即可。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List


<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">numIslands</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>

        <span class="token keyword">class</span> <span class="token class-name">UnionFind</span><span class="token punctuation">:</span>

            <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>count <span class="token operator">=</span> n
                self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>

            <span class="token keyword">def</span> <span class="token function">get_count</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> self<span class="token punctuation">.</span>count

            <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>
                now<span class="token operator">=</span>p
                <span class="token keyword">while</span> p <span class="token operator">!=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    p <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span>
                <span class="token keyword">while</span> now <span class="token operator">!=</span> p<span class="token punctuation">:</span>
                    now<span class="token punctuation">,</span>self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">=</span>self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">,</span>p
                <span class="token keyword">return</span> p

            <span class="token keyword">def</span> <span class="token function">is_connected</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>

            <span class="token keyword">def</span> <span class="token function">union</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>
                p_root <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
                q_root <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>
                <span class="token keyword">if</span> p_root <span class="token operator">!=</span> q_root<span class="token punctuation">:</span>
                    self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>q_root<span class="token punctuation">]</span><span class="token operator">=</span>p_root
                    self<span class="token punctuation">.</span>count<span class="token operator">-=</span><span class="token number">1</span>

        row <span class="token operator">=</span> len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true"># 特判</span>
        <span class="token keyword">if</span> row <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        col <span class="token operator">=</span> len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

        <span class="token keyword">def</span> <span class="token function">get_index</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> x <span class="token operator">*</span> col <span class="token operator">+</span> y

        <span class="token comment" spellcheck="true"># 注意：我们不用像 DFS 和 BFS 一样，4 个方向都要尝试，只要看一看右边和下面就可以了</span>
        directions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token comment" spellcheck="true"># 多开一个空间，把水域 "0" 都归到这个虚拟的老大上</span>
        dummy_node <span class="token operator">=</span> row <span class="token operator">*</span> col

        <span class="token comment" spellcheck="true"># 多开的一个空间就是那个虚拟的空间</span>
        uf <span class="token operator">=</span> UnionFind<span class="token punctuation">(</span>dummy_node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment" spellcheck="true"># 如果是水域，都连到那个虚拟的空间去</span>
                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">:</span>
                    uf<span class="token punctuation">.</span>union<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> dummy_node<span class="token punctuation">)</span>
                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">:</span>
                    <span class="token comment" spellcheck="true"># 向下向右如果都是陆地，即 "1"，就要合并一下</span>
                    <span class="token keyword">for</span> direction <span class="token keyword">in</span> directions<span class="token punctuation">:</span>
                        new_x <span class="token operator">=</span> i <span class="token operator">+</span> direction<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
                        new_y <span class="token operator">=</span> j <span class="token operator">+</span> direction<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
                        <span class="token keyword">if</span> new_x <span class="token operator">&lt;</span> row <span class="token operator">and</span> new_y <span class="token operator">&lt;</span> col <span class="token operator">and</span> grid<span class="token punctuation">[</span>new_x<span class="token punctuation">]</span><span class="token punctuation">[</span>new_y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">:</span>
                            uf<span class="token punctuation">.</span>union<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> get_index<span class="token punctuation">(</span>new_x<span class="token punctuation">,</span> new_y<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true"># 不要忘记把那个虚拟结点减掉</span>
        <span class="token keyword">return</span> uf<span class="token punctuation">.</span>get_count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>顾名思义，并查集的主要操作有两个，分别是并和查。类似于这种最小连通子树的问题，我们使用图结构未免过于复杂，所以并查集能够很好的解决这一问题。</p>
<p>我们使用一个数组parent存放每个节点的父节点。</p>
<ul>
<li>查操作：如果节点A的父节点是自身，那么他就是所在树的根节点，否则向上递归搜索，直到找到所在树的根节点。（查询每个节点所在子树的根节点，如果A和B所在子树的根节点相同，则说明它们是连通的）</li>
<li>特别地，为了进行路径压缩，我们在查操作递归查找到根节点后，将递归路径上的所有节点的父节点设置为根节点，从而确保所有的节点都可以在两步之内找到根节点。</li>
<li>并操作：合并节点A和节点B所在的子树。具体做法是：查找A所在子树的根节点，查找B所在子树的根节点，修改A的根节点的父节点为B的根节点。</li>
<li>初始情况下，我们设定每一个位置都是一个集合（子树），并查集的count数为总位置数目加1（有一个虚拟节点）。然后我们遍历所有位置，如果当前位置是陆地，则合并右方和下方的陆地至当前位置的子树，每次合并后将count数减1，说明集合数减1。如果当前位置是水域，则将其合并到伪节点下。</li>
<li>最后，我们将并查集内的集合数目减1，即为岛屿数目（其中有一个集合是水域的集合）。</li>
</ul>
<h3 id="206题-反转链表"><a href="#206题-反转链表" class="headerlink" title="206题 反转链表"></a>206题 <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a></h3><p><img src="206.png" alt="第206题"></p>
<h4 id="思路：-23"><a href="#思路：-23" class="headerlink" title="思路："></a>思路：</h4><p>可以使用头插法，遍历链表中的每个节点都插入到头部即可。</p>
<p>也可以使用快慢指针法，慢指针开始时指向None，快指针指向Head。每次将快指针的next指向慢指针，即实现了反转。然后将快慢指针同时向前移动一个节点，继续修改快指针的next。、</p>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span>
<span class="token comment" spellcheck="true"># class ListNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>
        p<span class="token operator">=</span>None
        q<span class="token operator">=</span>head
        <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">!=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
            tmp<span class="token punctuation">,</span>q<span class="token punctuation">.</span>next<span class="token operator">=</span>q<span class="token punctuation">.</span>next<span class="token punctuation">,</span>p
            p<span class="token punctuation">,</span>q<span class="token operator">=</span>q<span class="token punctuation">,</span>tmp
        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="207题-课程表"><a href="#207题-课程表" class="headerlink" title="207题  课程表"></a>207题 <a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener"> 课程表</a></h3><p><img src="207.png" alt="第207题"></p>
<h4 id="思路：-24"><a href="#思路：-24" class="headerlink" title="思路："></a>思路：</h4><p>这是一个有向图找环路的问题，基本的思路是拓扑排序。</p>
<p>我们每次找到一个入度为0的节点，将其从图上删除，并删除以它为起点的所有边，修改相应的边终点的入度。循环执行上述操作，直到图中不存在节点，说明无环。如果无法将节点全部清空，说明存在环。</p>
<ul>
<li>时间复杂度：$O(N + M)$： 遍历一个图需要访问所有节点和所有临边；</li>
<li>空间复杂度：$O(N + M)$： 为建立邻接表所需额外空间。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">canFinish</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> numCourses<span class="token punctuation">:</span> int<span class="token punctuation">,</span> prerequisites<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        indegree<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>numCourses<span class="token punctuation">)</span><span class="token punctuation">]</span>
        hashmap<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>numCourses<span class="token punctuation">)</span><span class="token punctuation">:</span>
            hashmap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> edge <span class="token keyword">in</span> prerequisites<span class="token punctuation">:</span>
            indegree<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>
            hashmap<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">while</span> hashmap<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果还剩下节点，那么继续删除节点</span>
            flag<span class="token operator">=</span><span class="token boolean">False</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>indegree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                    flag<span class="token operator">=</span><span class="token boolean">True</span>
                    <span class="token keyword">for</span> next <span class="token keyword">in</span> hashmap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
                        indegree<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>
                    indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>
                    hashmap<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
            <span class="token keyword">if</span> flag<span class="token operator">==</span><span class="token boolean">False</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果不存在入度为0的节点，那么说明必然存在环路</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span><span class="token comment" spellcheck="true">#节点可以被全部删除，说明无环</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="215题-数组中的第K个最大元素"><a href="#215题-数组中的第K个最大元素" class="headerlink" title="215题 数组中的第K个最大元素"></a>215题 <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">数组中的第K个最大元素</a></h3><p><img src="215.png" alt="第215题"></p>
<h4 id="思路：-25"><a href="#思路：-25" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，两种做法：快速选择法和辅助堆。具体解析可见剑指Offer的博客。</p>
<p>辅助堆：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        heap<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span>
        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>heap<span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>heap<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(nlogk)$，堆的插入、删除都需要$O(logk)$，最坏情况下，每个数字都要入堆出堆一次。</li>
<li>空间复杂度：$O(k)$，辅助堆。</li>
</ul>
<p>快速选择：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#和快速排序中的分治一样，将当前区间首部的枢纽元素调整至正确的位置</span>
            i<span class="token operator">=</span>left<span class="token operator">+</span><span class="token number">1</span>
            j<span class="token operator">=</span>right
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>right <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    i<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>j<span class="token operator">></span>left <span class="token operator">and</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">>=</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    j<span class="token operator">-=</span><span class="token number">1</span>
                <span class="token keyword">if</span> i<span class="token operator">&lt;</span>j<span class="token punctuation">:</span>
                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>
                    <span class="token keyword">break</span>
            <span class="token keyword">return</span> j

        <span class="token keyword">def</span> <span class="token function">quickSelect</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#快速选择算法</span>
            m<span class="token operator">=</span>partition<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>
            <span class="token keyword">if</span> m<span class="token operator">==</span>k<span class="token punctuation">:</span>
                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span>
            <span class="token keyword">elif</span> m<span class="token operator">></span>k<span class="token punctuation">:</span>
                <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span>left<span class="token punctuation">,</span>m<span class="token number">-1</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>k<span class="token punctuation">)</span>

        random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#非常重要！</span>
        <span class="token keyword">if</span> k<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> k<span class="token operator">></span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> nums
        <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span>k<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的是：如果数组有序，那么快速选择法的时间复杂度会大幅提高。（原理和快排一样，当数组有序时，会退化成冒泡排序，时间复杂度升至$O(MN)$）所以我们需要提前随机打乱数组。</p>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h2 id="2020-4-9（2-medium-2-easy）"><a href="#2020-4-9（2-medium-2-easy）" class="headerlink" title="2020.4.9（2 medium 2 easy）"></a>2020.4.9（2 medium 2 easy）</h2><h3 id="221题-最大正方形"><a href="#221题-最大正方形" class="headerlink" title="221题  最大正方形"></a>221题 <a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener"> 最大正方形</a></h3><p><img src="221.png" alt="第221题"></p>
<h4 id="思路：-26"><a href="#思路：-26" class="headerlink" title="思路："></a>思路：</h4><p>动态规划算法，但很难想到。我们使用状态矩阵dp[i] [j]来表示以第i行第j列的1为右下角顶点的正方形的边长，则动态规划转移方程为：</p>
<ul>
<li>dp[i] [j]=0 （if grid[i] [j]==0）</li>
<li>dp[i] [j]=min(dp[i-1] [j], dp[i] [j-1], dp[i-1] [j-1]) （if grid[i] [j]==1）</li>
</ul>
<p>为什么当格子为1时，动态规划转移方程会是那样呢？</p>
<p>事实上，可以画图自己推导一遍，和木桶短板原理类似：</p>
<p><img src="221-1.png" alt="dp原理"></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maximalSquare</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        m<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"1"</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#只有行号、列号都大于0时，我们才可以使用dp转移方程</span>
                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>
                    m<span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span>
        <span class="token keyword">return</span> m<span class="token operator">*</span>m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(mn)$。</li>
<li>空间复杂度：$O(mn)$。</li>
</ul>
<p>这道题我们可以进一步压缩状态矩阵（很多Dp题目都可以，状态转移只要和之前的有限个状态有关即可。如果我们不需要用到之前的状态，就可以不保存他们）</p>
<h3 id="226题-翻转二叉树"><a href="#226题-翻转二叉树" class="headerlink" title="226题 翻转二叉树"></a>226题 <a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">翻转二叉树</a></h3><p><img src="226.png" alt="第226题"></p>
<h4 id="思路：-27"><a href="#思路：-27" class="headerlink" title="思路："></a>思路：</h4><p>递归翻转，翻转当前根节点的左右孩子，同时递归翻转左右孩子的左右孩子，直到当前节点为空。</p>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>
        <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>
            root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>invertTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>invertTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以非递归，使用一个辅助队列即可，稍微复杂一些：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>
        queue<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span>
        <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token operator">!=</span>None<span class="token punctuation">:</span>
                node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>node<span class="token punctuation">.</span>right<span class="token operator">=</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span>node<span class="token punctuation">.</span>left
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="234题-回文链表"><a href="#234题-回文链表" class="headerlink" title="234题 回文链表"></a>234题 <a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">回文链表</a></h3><p><img src="234.png" alt="第234题"></p>
<h4 id="思路：-28"><a href="#思路：-28" class="headerlink" title="思路："></a>思路：</h4><p>如果我们单纯的使用辅助的数据结构，题目将会很容易解决，例如，我们可以使用另一个链表存放翻转过的链表，再比较二者遍历是否完全相等。也可以将链表存放进数组中，使用双指针从两端遍历。</p>
<p>但是，为了获得$O(1)$的时间复杂度，我们必须原地对链表进行修改。</p>
<p>具体流程如下：</p>
<ul>
<li>先使用快慢指针法找到链表的中间位置。</li>
<li>然后使用快慢指针法将链表的后半部分翻转。</li>
<li>然后将快指针移动到head，快慢指针同时向中间遍历，如果出现了val不相等，则不是回文链表，如果直到快慢指针某一个为空时，均相等，则是回文链表。</li>
</ul>
<p><img src="234-1.png" alt="第234题"></p>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span>
<span class="token comment" spellcheck="true"># class ListNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        <span class="token keyword">if</span> head<span class="token operator">==</span>None<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">if</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>None<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token comment" spellcheck="true">##特判</span>

        fast<span class="token operator">=</span>head<span class="token punctuation">.</span>next
        slow<span class="token operator">=</span>head
        <span class="token keyword">while</span> fast<span class="token operator">!=</span>None <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span>
            slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next
            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
        <span class="token comment" spellcheck="true">##找到中间位置</span>

        fast<span class="token operator">=</span>slow<span class="token punctuation">.</span>next
        slow<span class="token punctuation">.</span>next<span class="token operator">=</span>None
        <span class="token keyword">while</span> fast<span class="token operator">!=</span>None<span class="token punctuation">:</span>
            tmp<span class="token operator">=</span>fast<span class="token punctuation">.</span>next
            fast<span class="token punctuation">.</span>next<span class="token operator">=</span>slow
            slow<span class="token operator">=</span>fast
            fast<span class="token operator">=</span>tmp
        <span class="token comment" spellcheck="true">##翻转后半部分</span>

        fast<span class="token operator">=</span>head
        <span class="token keyword">while</span> fast<span class="token operator">!=</span>None <span class="token operator">and</span> slow<span class="token operator">!=</span>None<span class="token punctuation">:</span>
            <span class="token keyword">if</span> fast<span class="token punctuation">.</span>val<span class="token operator">!=</span>slow<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
            fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next
            slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next
        <span class="token comment" spellcheck="true">##</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="236题-二叉树的最近公共祖先"><a href="#236题-二叉树的最近公共祖先" class="headerlink" title="236题 二叉树的最近公共祖先"></a>236题 <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">二叉树的最近公共祖先</a></h3><p><img src="236.png" alt="第236题"></p>
<h4 id="思路：-29"><a href="#思路：-29" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题。递归法，我们可以直接使用题目给出的函数框架进行先根递归：</p>
<ul>
<li>如果当前节点为空，必然不是公共祖先，返回None。</li>
<li>如果当前节点的值是p或者q的值，那么可能是公共祖先，返回当前节点。</li>
<li>我们从左右子树中递归搜索：<ul>
<li>如果左右子树均返回了节点，说明p和q分布在当前节点的两侧，则当前节点必然是他们的最近祖先。</li>
<li>如果只有左子树返回了节点，那么公共祖先必然在左子树中，返回该节点。</li>
<li>如果只有右子树返回了节点，那么公共祖先必然右左子树中，返回该节点。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>
            <span class="token keyword">return</span> None
        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>p<span class="token punctuation">.</span>val <span class="token operator">or</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
            <span class="token keyword">return</span> root
        leftNode<span class="token operator">=</span>self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>
        rightNode<span class="token operator">=</span>self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>
        <span class="token keyword">if</span> leftNode<span class="token operator">!=</span>None <span class="token operator">and</span> rightNode<span class="token operator">!=</span>None<span class="token punctuation">:</span>
            <span class="token keyword">return</span> root
        <span class="token keyword">if</span> rightNode<span class="token operator">!=</span>None<span class="token punctuation">:</span>
            <span class="token keyword">return</span> rightNode
        <span class="token keyword">if</span> leftNode<span class="token operator">!=</span>None<span class="token punctuation">:</span>
            <span class="token keyword">return</span> leftNode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-4-10（3-medium-1-hard）"><a href="#2020-4-10（3-medium-1-hard）" class="headerlink" title="2020.4.10（3 medium 1 hard）"></a>2020.4.10（3 medium 1 hard）</h2><h3 id="238题-除自身以外数组的乘积"><a href="#238题-除自身以外数组的乘积" class="headerlink" title="238题 除自身以外数组的乘积"></a>238题 <a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">除自身以外数组的乘积</a></h3><p><img src="238.png" alt="第238题"></p>
<h4 id="思路：-30"><a href="#思路：-30" class="headerlink" title="思路："></a>思路：</h4><p>首先，我们注意到题目要求我们不能使用除法，所以我们无法通过求所有数的乘积后挨个进行除法的方式获取结果。此外，题目要求我们使用$O(n)$的时间复杂度，所以我们也不能使用暴力两层循环的方式。</p>
<p>较好的思路是使用类似于动态规划的思想，先顺序DP求出前缀乘积数组L（L[i]=L[i-1]*nums[i-1])，再倒序DP求出后缀乘积数组R，对于第i个位置的结果res[i]=L[i]*R[i]。</p>
<p>更进一步，我们可以减少空间复杂度。由于结果数组不算额外空间，我们可以将L数组存入res数组，再倒序计算R数组。因为此时R数组不需要保存所有的状态，只需要保存一个状态用于转移，所以我们只需要用一个变量保存它即可。</p>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">productExceptSelf</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> nums<span class="token punctuation">]</span>
        res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>res<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>
        R<span class="token operator">=</span><span class="token number">1</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*=</span>R
            R<span class="token operator">=</span>R<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="239题-滑动窗口最大值"><a href="#239题-滑动窗口最大值" class="headerlink" title="239题 滑动窗口最大值"></a>239题 <a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">滑动窗口最大值</a></h3><p><img src="239.png" alt="第239题"></p>
<h4 id="思路：-31"><a href="#思路：-31" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题。为了获得线性时间复杂度，我们需要维护一个单调双向队列。</p>
<ul>
<li>队列中存放的是数组元素的下标。</li>
<li>队列中的元素单调递减，队首元素为当前窗口内最大的元素下标，第二个元素为在队首元素下标之后第二大的元素下标（一定要在队首元素之后！如果在队首元素下标之前，那么它将比队首元素更早被移出窗口，不可能成为继续滑动窗口后的最大元素），第三个元素为在第二个元素下标之后第三大的元素下标。依次类推。</li>
<li>我们遍历nums数组中的所有元素下标i，如果此时双向队列为空，我们直接将i入队。否则，我们计算i-k的值与队首元素下标值是否相等，相等则说明此时队首元素下标值已经被恰好移出窗口，我们需要将其出队。接着，我们需要调整双向队列，使其保持递减的性质。并将队列中比nums[i]小的元素下标值出队。（因为此时元素i不仅比他们大，而且还在它们的后面，所以它们再也不可能是某个滑动窗口的最大值了，可以删掉）</li>
<li>当i大于等于k-1时，说明此时窗口大小达到要求，可以开始统计滑动窗口的最大值。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        dequeue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> dequeue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> i<span class="token operator">-</span>k<span class="token operator">==</span>dequeue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    dequeue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">while</span> dequeue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>dequeue<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    dequeue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            dequeue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
            <span class="token keyword">if</span> i<span class="token operator">>=</span>k<span class="token number">-1</span><span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>dequeue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(k)$。</li>
</ul>
<h3 id="74题-搜索二维矩阵"><a href="#74题-搜索二维矩阵" class="headerlink" title="74题 搜索二维矩阵"></a>74题 <a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">搜索二维矩阵</a></h3><p><img src="74.png" alt="第74题"></p>
<h4 id="思路：-32"><a href="#思路：-32" class="headerlink" title="思路："></a>思路：</h4><p>剑指Offer原题，我们观察这个二维矩阵，可以发现它其实可以转化为二叉搜索树来进行查询。</p>
<ul>
<li>我们从右上角开始查询，可以发现，当前元素左侧的元素都比自己小，下方的元素都比自己大。所以，我们可以使用二叉搜索树的思想：如果目标元素比当前元素大，向下方搜索，否则向左侧搜索。</li>
<li>当搜索到边界仍然无法找到target，我们可以返回False。找到了target，我们可以返回True。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">searchMatrix</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        <span class="token keyword">if</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        row<span class="token operator">=</span><span class="token number">0</span>
        col<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">while</span> <span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>
                row<span class="token operator">+=</span><span class="token number">1</span>
            <span class="token keyword">elif</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>
                col<span class="token operator">-=</span><span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(m+n)$，最多需要走到左下角位置。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h3 id="240题-搜索二维矩阵-II"><a href="#240题-搜索二维矩阵-II" class="headerlink" title="240题 搜索二维矩阵 II"></a>240题 <a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">搜索二维矩阵 II</a></h3><p><img src="240.png" alt="第240题"></p>
<h4 id="思路：-33"><a href="#思路：-33" class="headerlink" title="思路："></a>思路：</h4><p>与74题非常类似，只是从左下角开始搜索而已。此外，还可以使用二分查找的方法，因为每行都是有序的，不过时间复杂度远远高于之前的方法。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">searchMatrix</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """</span>
        row<span class="token operator">=</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>
        col<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">while</span> <span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>
                col<span class="token operator">+=</span><span class="token number">1</span>
            <span class="token keyword">elif</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>
                row<span class="token operator">-=</span><span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-4-11（1-easy-2-medium-1-hard）"><a href="#2020-4-11（1-easy-2-medium-1-hard）" class="headerlink" title="2020.4.11（1 easy 2 medium 1 hard）"></a>2020.4.11（1 easy 2 medium 1 hard）</h2><h3 id="279题-完全平方数"><a href="#279题-完全平方数" class="headerlink" title="279题 完全平方数"></a>279题 <a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">完全平方数</a></h3><p><img src="279.png" alt="第279题"></p>
<h4 id="思路：-34"><a href="#思路：-34" class="headerlink" title="思路："></a>思路：</h4><p>这道题的基本解法和剪绳子问题类似，是一个类似于完全背包问题的动态规划问题。状态矩阵dp[i]用于保存数字i的最小完全平方数。转移方程为：dp[i]=min(dp[i],dp[i-j**2]+1)（j从1到i的平方根）（自底向上，递归是自顶向下）</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> math
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">numSquares</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>int<span class="token punctuation">(</span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(n\sqrt{n})$，两层循环。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<p>以下图为例。我们知道，动态规划算法是从记忆化递归转变而来的，属于DFS的思想。但是，这道题使用BFS更好，因为我们要求的不是节点为0时的最大深度，而是最小深度，所以从上至下逐层递归（BFS）比每次走到树的底部（DFS）更为合适。</p>
<p><img src="279-1.png" alt></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> math
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">numSquares</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        queue<span class="token operator">=</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span>
        tmpSet<span class="token operator">=</span>set<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>
        res<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            res<span class="token operator">+=</span><span class="token number">1</span>
            l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>
                now<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>int<span class="token punctuation">(</span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    tmp<span class="token operator">=</span>now<span class="token operator">-</span>j<span class="token operator">*</span>j
                    <span class="token keyword">if</span> tmp<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                        <span class="token keyword">return</span> res
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        <span class="token keyword">if</span> tmp <span class="token operator">not</span> <span class="token keyword">in</span> tmpSet<span class="token punctuation">:</span>
                            tmpSet<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>
                            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>
        <span class="token keyword">return</span> n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们使用BFS，同时，为了防止对相同值的重复搜索，我们可以对树进行剪枝。使用临时哈希集合来保存已搜索过的值，防止重复搜素。当我们找到了第一个被完全平方数拆分至0的节点，返回其深度，即为最小完全平方数目。</p>
<h3 id="283题-移动零"><a href="#283题-移动零" class="headerlink" title="283题 移动零"></a>283题 <a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零</a></h3><p><img src="283.png" alt="第283题"></p>
<h4 id="思路：-35"><a href="#思路：-35" class="headerlink" title="思路："></a>思路：</h4><p>基本思路可以采用冒泡排序，两层循环，时间复杂度很高，为$O(n^2)$。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Do not return anything, modify nums in-place instead.
        """</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
        <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>较好的思路是使用快慢双指针，有些类似于之前做过的数组去除某个元素和去重的问题。我们使用慢指针来维护一个无零的区间（指向该区间的后一个元素），快指针来对数组元素进行遍历。如果当前值非零，那么就与慢指针指向的元素交换，慢指针加一。（慢指针如果停在某个位置，而不是和快指针同步向前遍历，说明此时必然遇到了0，所以交换后，零元素必然向末尾靠近）</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Do not return anything, modify nums in-place instead.
        """</span>
        slow<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> fast <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>
                nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span>
                slow<span class="token operator">+=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(n)$，一次循环。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h3 id="287题-寻找重复数"><a href="#287题-寻找重复数" class="headerlink" title="287题 寻找重复数"></a>287题 <a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">寻找重复数</a></h3><p><img src="287.png" alt="第287题"></p>
<h4 id="思路：-36"><a href="#思路：-36" class="headerlink" title="思路："></a>思路：</h4><p>这道题可以用的思路很多，但大多数被题目条件所限制：</p>
<ul>
<li>最简单的是哈希表，value存放key出现的次数，如果出现了次数等于2的数字，那么必然是重复数。时间复杂度为$O(n)$，空间复杂度为$O(n)$。但题目不给使用额外空间。</li>
<li>我们还可以使用排序的方法，对数组进行排序。接着再遍历数组，如果当前值和下一个值相等，那么是重复的。时间复杂度为$O(nlogn)$，空间复杂度为$O(1)$。</li>
</ul>
<p>实际上，这道题可以看作是一个链表找环路的问题。我们可以把数组的下标看作是节点的地址，数组的值看作是next指针，由于重复值的next相同，所以它们必然会产生环路，我们只要找到环路的入口地址即可（由于环路入口地址必然被入度大于1，即元素值出现次数大于1，即为重复元素）。接着的具体解题思路和之前做过的142题类似。使用快慢指针，快指针每次走2步，慢指针每次走1步，二者相遇后，再让慢指针回到链表头部。二者每次走1步，相遇时即为链表入口。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        slow<span class="token operator">=</span><span class="token number">0</span>
        fast<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            slow<span class="token operator">=</span>nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span>
            fast<span class="token operator">=</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">]</span>
            <span class="token keyword">if</span> slow<span class="token operator">==</span>fast<span class="token punctuation">:</span>
                <span class="token keyword">break</span>
        slow<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">while</span> slow<span class="token operator">!=</span>fast<span class="token punctuation">:</span>
            slow<span class="token operator">=</span>nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span>
            fast<span class="token operator">=</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span>
        <span class="token keyword">return</span> slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="297题-二叉树的序列化与反序列化"><a href="#297题-二叉树的序列化与反序列化" class="headerlink" title="297题 二叉树的序列化与反序列化"></a>297题 <a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">二叉树的序列化与反序列化</a></h3><p><img src="297.png" alt="第297题"></p>
<h4 id="思路：-37"><a href="#思路：-37" class="headerlink" title="思路："></a>思路：</h4><p>剑指offer原题，数据结构课原题，有两种做法：（1）DFS（先根遍历，栈）（2）BFS（层次遍历，队列）</p>
<ul>
<li>DFS的做法：<ul>
<li>序列化：先序遍历将当前节点的val存入字符串。</li>
<li>反序列化：将字符串切割成数组。使用先序遍历再次遍历，需要使用外层变量index来记录当前已访问的元素下标。（也可以使用队列来做，本质都是一样的）。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode(object):</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""Encodes a tree to a single string.

        :type root: TreeNode
        :rtype: str
        """</span>
        data<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>
                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>
                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        preorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token string">","</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>data<span class="token punctuation">)</span>     

    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""Decodes your encoded data to tree.

        :type data: str
        :rtype: TreeNode
        """</span>
        data<span class="token operator">=</span>data<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>index<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>index<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"*"</span><span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>index<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">return</span> None
            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>index<span class="token operator">+=</span><span class="token number">1</span>
            root<span class="token punctuation">.</span>left<span class="token operator">=</span>build<span class="token punctuation">(</span><span class="token punctuation">)</span>
            root<span class="token punctuation">.</span>right<span class="token operator">=</span>build<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> root
        <span class="token triple-quoted-string string">'''
        def build(queue): 
            now=queue.pop(0)
            if now=="*":
            return None
            root=TreeNode(int(now))
            root.left=build(queue)
            root.right=build(queue) return root
        queue=data.split(",")
        return build(queue)
        '''</span>
        <span class="token keyword">return</span> build<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true"># Your Codec object will be instantiated and called as such:</span>
<span class="token comment" spellcheck="true"># codec = Codec()</span>
<span class="token comment" spellcheck="true"># codec.deserialize(codec.serialize(root))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>BFS的做法：<ul>
<li>序列化：使用辅助队列层次遍历，将节点存入data字符串中保存。</li>
<li>反序列化：先将data字符串切割成数组。然后使用index指针遍历数组，将待处理节点放入一个队列保存。每次将一个节点出队，使移动index指针，使index指向的元素生成它的左右孩子，再将非空的左右孩子入队保存（因为它们也需要处理，尝试生成左右孩子）。开始时使用data数组的首个元素构建root节点，将root入队，index初始值设为1。最后将root返回即可。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode(object):</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""Encodes a tree to a single string.

        :type root: TreeNode
        :rtype: str
        """</span>
        data<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        queue<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span>
        <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token operator">==</span>None<span class="token punctuation">:</span>
                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token string">","</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>data<span class="token punctuation">)</span>


    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""Decodes your encoded data to tree.

        :type data: str
        :rtype: TreeNode
        """</span>
        data<span class="token operator">=</span>data<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>
        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        index<span class="token operator">=</span><span class="token number">1</span>
        <span class="token keyword">if</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"*"</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> None
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            root<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> index<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>
            node<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">"*"</span><span class="token punctuation">:</span>
                node<span class="token punctuation">.</span>left<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            index<span class="token operator">+=</span><span class="token number">1</span>
            <span class="token keyword">if</span> data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">"*"</span><span class="token punctuation">:</span>
                node<span class="token punctuation">.</span>right<span class="token operator">=</span>TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            index<span class="token operator">+=</span><span class="token number">1</span>
        <span class="token keyword">return</span> root

<span class="token comment" spellcheck="true"># Your Codec object will be instantiated and called as such:</span>
<span class="token comment" spellcheck="true"># codec = Codec()</span>
<span class="token comment" spellcheck="true"># codec.deserialize(codec.serialize(root)) </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-4-12（2-medium-1-hard）"><a href="#2020-4-12（2-medium-1-hard）" class="headerlink" title="2020.4.12（2 medium 1 hard）"></a>2020.4.12（2 medium 1 hard）</h2><h3 id="300题-最长上升子序列"><a href="#300题-最长上升子序列" class="headerlink" title="300题 最长上升子序列"></a>300题 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长上升子序列</a></h3><p><img src="300.png" alt="300题"></p>
<h4 id="思路：-38"><a href="#思路：-38" class="headerlink" title="思路："></a>思路：</h4><p>首先，我们可以通过$O(n^2)$的时间复杂度来解决这道题。与最大连续子序列类似，我们可以使用动态规划的方法，dp[i]表示以第i个数字结尾的子序列的最大长度。转移方程：dp[i]=max（dp[i]，dp[j]+1）(if j&lt;i and nums[j]&lt;nums[i])。也就是说，如果第i个数大于在它之前的第j个数，那么它就可以接在以第j个数结尾的最长上升子序列后形成一个更长的上升子序列。我们只需要找到第i个数和之前每个数结尾的最长上升子序列形成的子序列的最大长度即可。</p>
<ul>
<li>时间复杂度：$O(n^2)$。</li>
<li>空间复杂度：$O(n)$，无法进行状态压缩，因为要用到之前每个状态。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> nums<span class="token punctuation">]</span>
        res<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
            res<span class="token operator">=</span>max<span class="token punctuation">(</span>res<span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了获取题目要求的$O(nlogn)$的时间复杂度，我们必须要用到二分查找。那么怎么进行二分查找呢？</p>
<ul>
<li>首先，我们继续使用动态规划的方法。不过状态矩阵的含义要进行改变，dp[i]表示长度为i的上升子序列的最小结尾值。</li>
<li>我们遍历nums矩阵，每次遍历时，在当前的dp矩阵中二分查找nums[j]的插入位置，如果插入位置处的dp[i]大于nums[j]，即可将dp[j]修改为nums[j]，说明长度为i的上升子序列的最小结尾值可以更新了。如果插入位置等于len（dp），说明nums[j]比当前所有长度的序列的最小结尾值都大，可以接在它们的后面形成更长的上升子序列，我们将nums[j]加入到dp的末尾。</li>
<li>当我们遍历完nums[j]后，所得dp数组的长度即为上升序列的最大长度。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Dynamic programming + Dichotomy.</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> <span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> dp<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                left<span class="token operator">=</span><span class="token number">0</span>
                right<span class="token operator">=</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>
                flag<span class="token operator">=</span><span class="token number">0</span>
                <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>
                    mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>
                    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
                        flag<span class="token operator">=</span><span class="token number">1</span>
                        <span class="token keyword">break</span>
                    <span class="token keyword">elif</span> dp<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
                        left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        right<span class="token operator">=</span>mid<span class="token number">-1</span>
                <span class="token keyword">if</span> flag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> left<span class="token operator">==</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">:</span>
                        dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                    <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>dp<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">:</span>
                        dp<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">return</span> len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="301题-删除无效的括号"><a href="#301题-删除无效的括号" class="headerlink" title="301题 删除无效的括号"></a>301题 <a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/" target="_blank" rel="noopener">删除无效的括号</a></h3><p><img src="301.png" alt="301题"></p>
<h4 id="思路：-39"><a href="#思路：-39" class="headerlink" title="思路："></a>思路：</h4><p>由于这道题需要的是删除的次数最小，所以BFS很明显比DFS划算，就像昨天做过的最小完全平方数问题一样， 从上至下逐层搜索很明显比每次搜索到底部划算。</p>
<p><img src="301-1.png" alt="BFS"></p>
<p>树的每层都是对上一层节点删掉某个括号后得到的新字符串，为了防止重复搜索，这里对重复的字符串进行去重。如果某一层中出现了某个合法的括号串，那么返回该层所有合法的括号串。否则，继续向下层遍历。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">removeInvalidParentheses</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>
        queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
            count<span class="token operator">=</span><span class="token number">0</span>
            <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>
                <span class="token keyword">if</span> ch<span class="token operator">==</span><span class="token string">"("</span><span class="token punctuation">:</span>
                    count<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">elif</span> ch<span class="token operator">==</span><span class="token string">")"</span><span class="token punctuation">:</span>
                    count<span class="token operator">-=</span><span class="token number">1</span>
                <span class="token keyword">if</span> count<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>
                    <span class="token keyword">return</span> <span class="token boolean">False</span>
            <span class="token keyword">if</span> count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>

        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>
            res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>
                nowStr<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> isValid<span class="token punctuation">(</span>nowStr<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nowStr<span class="token punctuation">)</span>
                <span class="token keyword">if</span> res<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nowStr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        newStr<span class="token operator">=</span>nowStr<span class="token punctuation">[</span><span class="token punctuation">:</span>j<span class="token punctuation">]</span><span class="token operator">+</span>nowStr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
                        <span class="token keyword">if</span> newStr <span class="token operator">not</span> <span class="token keyword">in</span> queue<span class="token punctuation">:</span>
                            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>newStr<span class="token punctuation">)</span>
            <span class="token keyword">if</span> res<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述代码在python3下运行超时，所以我们要进一步优化，使用集合来完成去重剪枝操作。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">removeInvalidParentheses</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>
        level<span class="token operator">=</span><span class="token punctuation">{</span>s<span class="token punctuation">}</span>
        <span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
            count<span class="token operator">=</span><span class="token number">0</span>
            <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>
                <span class="token keyword">if</span> ch<span class="token operator">==</span><span class="token string">"("</span><span class="token punctuation">:</span>
                    count<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">elif</span> ch<span class="token operator">==</span><span class="token string">")"</span><span class="token punctuation">:</span>
                    count<span class="token operator">-=</span><span class="token number">1</span>
                <span class="token keyword">if</span> count<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>
                    <span class="token keyword">return</span> <span class="token boolean">False</span>
            <span class="token keyword">if</span> count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            l<span class="token operator">=</span>len<span class="token punctuation">(</span>level<span class="token punctuation">)</span>
            res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> st <span class="token keyword">in</span> level<span class="token punctuation">:</span>
                <span class="token keyword">if</span> isValid<span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>st<span class="token punctuation">)</span>
            <span class="token keyword">if</span> res<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> res
            nextlevel<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span> st <span class="token keyword">in</span> level<span class="token punctuation">:</span>
                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> <span class="token string">"()"</span><span class="token punctuation">:</span>
                        nextlevel<span class="token punctuation">.</span>add<span class="token punctuation">(</span>st<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token operator">+</span>st<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            level<span class="token operator">=</span>nextlevel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="309题-最佳买卖股票时机含冷冻期"><a href="#309题-最佳买卖股票时机含冷冻期" class="headerlink" title="309题 最佳买卖股票时机含冷冻期"></a>309题 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">最佳买卖股票时机含冷冻期</a></h3><p><img src="309.png" alt="309题"></p>
<h4 id="思路：-40"><a href="#思路：-40" class="headerlink" title="思路："></a>思路：</h4><p>动态规划求解股票问题。每天存在三种状态：</p>
<ul>
<li>持仓：hold，指继续持有股票</li>
<li>空仓：sold，指卖出所有股票</li>
<li>冷冻期：rest，指什么也不做</li>
</ul>
<p>转换关系（一共有3乘3共9种转换的可能，只有以下几种可能且值得被比较）：</p>
<ul>
<li>sold：<ul>
<li>前一天hold，当日卖出股票</li>
</ul>
</li>
<li>hold： 可由两个情况转换来<ul>
<li>前一天hold，当日rest</li>
<li>前一天rest，当日买入股票变为hold（前一天sold转移不到hold，因为卖出股票后必须经历一天冷冻期）</li>
</ul>
</li>
<li>rest：<ul>
<li>前一天sold，当日必须rest</li>
<li>前一天rest，当日继续rest</li>
</ul>
</li>
</ul>
<p>所以:</p>
<ul>
<li>sold[i] = hold[i-1] + price[i];</li>
<li>hold[i] = max(hold[i-1], rest[i-1] - price[i])</li>
<li>rest[i] = max(rest[i-1], sold[i-1])</li>
</ul>
<p>特别地，由于只用到前面有限个状态，我们可以进行状态压缩。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">if</span> prices<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        sold<span class="token operator">=</span><span class="token number">0</span>
        hold<span class="token operator">=</span><span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        rest<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> price <span class="token keyword">in</span> prices<span class="token punctuation">:</span>
            sold<span class="token punctuation">,</span>hold<span class="token punctuation">,</span>rest<span class="token operator">=</span>hold<span class="token operator">+</span>price<span class="token punctuation">,</span>max<span class="token punctuation">(</span>hold<span class="token punctuation">,</span>rest<span class="token operator">-</span>price<span class="token punctuation">)</span><span class="token punctuation">,</span>max<span class="token punctuation">(</span>rest<span class="token punctuation">,</span>sold<span class="token punctuation">)</span>
        <span class="token keyword">return</span> max<span class="token punctuation">(</span>sold<span class="token punctuation">,</span>hold<span class="token punctuation">,</span>rest<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-4-13（1-medium-1-hard）"><a href="#2020-4-13（1-medium-1-hard）" class="headerlink" title="2020.4.13（1 medium 1 hard）"></a>2020.4.13（1 medium 1 hard）</h2><h3 id="312题-戳气球"><a href="#312题-戳气球" class="headerlink" title="312题 戳气球"></a>312题 <a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">戳气球</a></h3><p><img src="312.png" alt="312题"></p>
<h4 id="思路：-41"><a href="#思路：-41" class="headerlink" title="思路："></a>思路：</h4><p>首先，我想到的是简单的DFS，暴力求解，时间复杂度很高，为$O(N!)$：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token operator">+</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>maxres<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> count<span class="token operator">==</span>n<span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>maxres<span class="token operator">=</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxres<span class="token punctuation">,</span>res<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
                        tmp<span class="token operator">=</span>nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
                        dfs<span class="token punctuation">(</span>res<span class="token operator">+</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>tmp<span class="token punctuation">)</span><span class="token punctuation">,</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
                        nums<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>i<span class="token punctuation">,</span>tmp<span class="token punctuation">)</span>
        dfs<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>maxres<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了优化递归回溯算法，我们通常需要用到的是动态规划或者备忘录。为了使用它们，首先我们需要定义状态矩阵和划分子问题。</p>
<p>这里，我们定义dp[i] [j]为从第i个气球到第j个气球这个区间所能获得的最大硬币数量。按照我们的惯性思维，我们会先选区间内的一个气球被戳破，然后去求解该气球左侧区间的最大硬币数和右侧区间的最大硬币数之和。但是这道题里这样做是不行的，因为当你戳破了一个气球后，左区间右侧和右区间左侧的气球发生了改变，导致结果发生了改变。所以这样划分状态间互相产生了依赖，也就是说，我们无法保证动态规划的无后效性。</p>
<p>所以，我们需要重新定义子问题。我们先选取区间内的一个气球k，现在不是让它最先被戳破了，而是让它在这个区间内最后被戳破。这样，保证了dp[i] [k-1] 和 dp[k+1] [j] 两侧的气球始终不变，保证了状态矩阵的稳定。从而状态转移方程为：</p>
<p>dp[i] [j]=dp [i] [k-1] + dp[k+1] [j] + nums[k]*nums[i-1]*nums[j+1]</p>
<p>因为k气球是i到j区间内最后被扎破的，所以i到k-1和k+1到j的气球已经全部被扎破了，此时，k气球左侧和右侧的气球便一定是i-1和j+1气球。</p>
<p>考虑到这道题自顶向下求解比较容易理解，我们采用带备忘录的递归来做。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token operator">+</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
        n<span class="token operator">=</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> i<span class="token operator">></span>j <span class="token operator">or</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> j<span class="token operator">==</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>
                <span class="token keyword">return</span> <span class="token number">0</span>
            <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            nowMax<span class="token operator">=</span><span class="token number">0</span>
            <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                nowMax<span class="token operator">=</span>max<span class="token punctuation">(</span>nowMax<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>recur<span class="token punctuation">(</span>i<span class="token punctuation">,</span>k<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span>recur<span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>nowMax
            <span class="token keyword">return</span> nowMax
        <span class="token keyword">return</span> recur<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了进一步优化我们还是使用动态规划，这里用的是区间DP，从小区间向大区间转移。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>
                j <span class="token operator">=</span> i <span class="token operator">+</span> k
                <span class="token keyword">for</span> t <span class="token keyword">in</span> range<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>(这里的dp[i] [j] 表示的区间为（i，j），和我之前用的不太一样，不包括第i个和第j个气球。)</p>
<h3 id="第322题-零钱兑换"><a href="#第322题-零钱兑换" class="headerlink" title="第322题 零钱兑换"></a>第322题 <a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">零钱兑换</a></h3><p><img src="322.png" alt="322题"></p>
<h4 id="思路：-42"><a href="#思路：-42" class="headerlink" title="思路："></a>思路：</h4><p>与前两天刚做过的最小完全平方数组合那道题非常像，可以用DFS和BFS来遍历情况，由于我们需要取的是最小的组合，所以用BFS很明显更好。</p>
<p>我们使用辅助队列来进行BFS，再使用一个hashset来辅助我们去重（hashset查找元素时间复杂度为$O(1)$，优于直接列表查询）。</p>
<p>我们按层对队列中的金额使用硬币面值进行拆分，得到的新金额入队（重复的不入，如果在此之前已经入过队，说明必然更早完成凑成总金额，小于0的也不入）。如果成功拆分得到0，则将层数返回，即为最小硬币数目。如果无法拆分得到0，返回-1.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> coins<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> amount<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">if</span> amount<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        hashset<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>
        queue<span class="token operator">=</span><span class="token punctuation">[</span>amount<span class="token punctuation">]</span>
        level<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">while</span> queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            level<span class="token operator">+=</span><span class="token number">1</span>
            l<span class="token operator">=</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>
                now<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">for</span> coin <span class="token keyword">in</span> coins<span class="token punctuation">:</span>
                    tmp<span class="token operator">=</span>now<span class="token operator">-</span>coin
                    <span class="token keyword">if</span> tmp<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                        <span class="token keyword">return</span> level
                    <span class="token keyword">if</span> tmp <span class="token operator">not</span> <span class="token keyword">in</span> hashset <span class="token operator">and</span> tmp<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>
                        hashset<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>
                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-4-13（3-medium）"><a href="#2020-4-13（3-medium）" class="headerlink" title="2020.4.13（3 medium）"></a>2020.4.13（3 medium）</h2><h3 id="337题-打家劫舍-III"><a href="#337题-打家劫舍-III" class="headerlink" title="337题 打家劫舍 III"></a>337题 <a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">打家劫舍 III</a></h3><p><img src="337.png" alt="337题"></p>
<h4 id="思路：-43"><a href="#思路：-43" class="headerlink" title="思路："></a>思路：</h4><p>打家劫舍问题在不久前刚做过1和2，基本思路就是使用动态规划，类似于背包问题。当前状态有两种可能的隐状态转移而来，分别是偷当前这家和不偷当前这家。具体到本问题，假设偷当前这家人，那么只能从二叉树当前节点的孙子节点处继续偷；如果不偷当前这家人，那么可以从孩子节点开始偷。</p>
<p>特别地，由于二叉树的遍历采用递归比较容易理解，所以这题我们暂时不用DP来做，使用带备忘录的递归。备忘录采用哈希表实现，key为节点，value为以该节点为根节点的子树中所能偷到的最大金额。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        dic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token number">0</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                do_now<span class="token operator">=</span>root<span class="token punctuation">.</span>val
                do_next<span class="token operator">=</span><span class="token number">0</span>
                <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token operator">!=</span>None<span class="token punctuation">:</span>
                    do_next<span class="token operator">+=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>left<span class="token punctuation">]</span>
                    do_now<span class="token operator">+=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">]</span>
                    do_now<span class="token operator">+=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right<span class="token punctuation">]</span>
                <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token operator">!=</span>None<span class="token punctuation">:</span>
                    do_next<span class="token operator">+=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>right <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>right<span class="token punctuation">]</span>
                    do_now<span class="token operator">+=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left<span class="token punctuation">]</span>
                    do_now<span class="token operator">+=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right<span class="token punctuation">]</span>
                dic<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>do_next<span class="token punctuation">,</span>do_now<span class="token punctuation">)</span>
                <span class="token keyword">return</span> dic<span class="token punctuation">[</span>root<span class="token punctuation">]</span>
        <span class="token keyword">return</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="338题-比特位计数"><a href="#338题-比特位计数" class="headerlink" title="338题  比特位计数"></a>338题 <a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener"> 比特位计数</a></h3><p><img src="338.png" alt="338题"></p>
<h4 id="思路：-44"><a href="#思路：-44" class="headerlink" title="思路："></a>思路：</h4><p>动态规划思想，dp[i]为数字i的二进制中1的数目。分析比特位转移的规律，可以发现：</p>
<ul>
<li>如果i是偶数，那么dp[i]=dp[i//2]。左移，末尾补0，例如dp[4]=1（100）等于dp[2]=1（10）。</li>
<li>如果i是奇数，那么dp[i]=dp[i-1]+1。此时无需进位，直接加1即可。</li>
</ul>
<p>上述规律是因为，二进制数，偶数最低位都为0，奇数最低位都为1。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">countBits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> i<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span>
        <span class="token keyword">return</span> dp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="附：二进制数有多少个1"><a href="#附：二进制数有多少个1" class="headerlink" title="附：二进制数有多少个1"></a>附：二进制数有多少个1</h4><p>一个数字n，求他的二进制形式有多少个1，可以使用位运算的方式来进行。通过与运算(n)&amp;(n-1)，可以做到每次去除n的最后一位1，更新n，重复计算直到n为0。计算的次数即为n中1的个数。</p>
<p>所以我们也可以根据上述性质进行动态规划：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">countBits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token operator">&amp;</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">return</span> dp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="347题-前-K-个高频元素"><a href="#347题-前-K-个高频元素" class="headerlink" title="347题 前 K 个高频元素"></a>347题 <a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">前 K 个高频元素</a></h3><p><img src="347.png" alt="347题"></p>
<h4 id="思路：-45"><a href="#思路：-45" class="headerlink" title="思路："></a>思路：</h4><p>最简单的方法很明显是哈希表记录下每个元素出现的次数，然后对哈希表中的元素按照出现次数进行排序，选取前k个值。</p>
<p>只要我们用哈希表记录下了每个元素出现次数，那么选取出现次数的前k大值就转变为了我们常做的前k大（小）问题。</p>
<p>可以使用堆或者快速选择法进行解决。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """</span> 
        count <span class="token operator">=</span> collections<span class="token punctuation">.</span>Counter<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>   
        <span class="token keyword">return</span> heapq<span class="token punctuation">.</span>nlargest<span class="token punctuation">(</span>k<span class="token punctuation">,</span> count<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span>count<span class="token punctuation">.</span>get<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（python中重写堆的比较方法比较麻烦，就直接调用它的封装好的函数）</p>
<p>除此之外，我们还可以使用一个不基于比较的排序方法——计数排序，它是桶排序的一种，以空间来换时间。已知数值的区间，我们可以建立一个与区间大小相等的列表list。如果一个数出现的次数为n，那么就在list[n]处新添这个数的值。最后遍历计数区间，从大到小输出k个数即可。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        hashtable<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>
            hashtable<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">if</span> num <span class="token operator">not</span> <span class="token keyword">in</span> hashtable<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> hashtable<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        li<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> key <span class="token keyword">in</span> hashtable<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            li<span class="token punctuation">[</span>hashtable<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> l <span class="token keyword">in</span> li<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> num <span class="token keyword">in</span> l<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>
                <span class="token keyword">if</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">==</span>k<span class="token punctuation">:</span>
                    <span class="token keyword">return</span> res
        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-4-14（3-medium）"><a href="#2020-4-14（3-medium）" class="headerlink" title="2020.4.14（3 medium）"></a>2020.4.14（3 medium）</h2><h3 id="394题-字符串解码"><a href="#394题-字符串解码" class="headerlink" title="394题 字符串解码"></a>394题 <a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">字符串解码</a></h3><p><img src="394.png" alt="394题"></p>
<h4 id="思路：-46"><a href="#思路：-46" class="headerlink" title="思路："></a>思路：</h4><p>类似的问题，包括带有括号的算式计算，这里的括号是可以嵌套的。针对这种嵌套的子问题，我们可以使用两种思路来解决，分别是：（1）辅助栈（2）递归。</p>
<p>首先我们来看辅助栈的解法。我们先设立两个关键的遍历mul和res，分别用于存储当前中括号内的结果和该结果的乘数。我们每次遍历原始的字符串s，然后分四种情况讨论：</p>
<ul>
<li>当s[i]为数字时，将其添加到当前乘数mul的末尾；</li>
<li>当s[i]为字母时，将其添加到当前结果res的末尾；</li>
<li>当s[i]为”[“时，说明需要进入下一个嵌套的中括号内部进行处理，将当前的res和mul入栈保存，并清空它们;</li>
<li>当s[i]为”]”时，说明当前中括号内部的字符串已经处理完毕，即为res。我们从栈顶取出一组res和mul，即为当前中括号外部的中括号内目前的res和mul，使用mul对当前res进行重复拼接，在拼接到外层res的末尾，继续向后计算。</li>
</ul>
<p>遍历完s后，res的结果即为最终结果。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">decodeString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>
        res<span class="token operator">=</span><span class="token string">""</span>
        mul<span class="token operator">=</span><span class="token number">0</span>
        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        i<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">while</span> i <span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token string">'0'</span><span class="token operator">&lt;=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token string">'9'</span><span class="token punctuation">:</span>
                mul<span class="token operator">=</span>mul<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>int<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">elif</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'['</span><span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>mul<span class="token punctuation">,</span>res<span class="token punctuation">]</span><span class="token punctuation">)</span>
                res<span class="token operator">=</span><span class="token string">""</span>
                mul<span class="token operator">=</span><span class="token number">0</span>
            <span class="token keyword">elif</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">']'</span><span class="token punctuation">:</span>
                tmp<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                res<span class="token operator">=</span>tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>res<span class="token operator">*</span>tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
                mul<span class="token operator">=</span><span class="token number">0</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                res<span class="token operator">+=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            i<span class="token operator">+=</span><span class="token number">1</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>稍加修改，即可得到递归写法。此处为了防止重复遍历，当遍历到”]”时，返回当前的res和当前的索引。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">decodeString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>
            res<span class="token punctuation">,</span> multi <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span>
            <span class="token keyword">while</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> <span class="token string">'0'</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token string">'9'</span><span class="token punctuation">:</span>
                    multi <span class="token operator">=</span> multi <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> int<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token keyword">elif</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'['</span><span class="token punctuation">:</span>
                    i<span class="token punctuation">,</span> tmp <span class="token operator">=</span> dfs<span class="token punctuation">(</span>s<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
                    res <span class="token operator">+=</span> multi <span class="token operator">*</span> tmp
                    multi <span class="token operator">=</span> <span class="token number">0</span>
                <span class="token keyword">elif</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">']'</span><span class="token punctuation">:</span>
                    <span class="token keyword">return</span> i<span class="token punctuation">,</span> res
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    res <span class="token operator">+=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                i <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">return</span> res
        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="399-题-除法求值"><a href="#399-题-除法求值" class="headerlink" title="399 题 除法求值"></a>399 题 <a href="https://leetcode-cn.com/problems/evaluate-division/" target="_blank" rel="noopener">除法求值</a></h3><p><img src="399.png" alt="399题"></p>
<h4 id="思路：-47"><a href="#思路：-47" class="headerlink" title="思路："></a>思路：</h4><p>这道题，我们可以将其转化为图论问题。以等式中出现的每一个变量为顶点，有根据等式建立有向带权图，有向边的含义为起点是终点的几倍。例如“a/b=3”，那么我们就可以建立节点a和接点b，边a-&gt;b的权值为3，边b-&gt;a的权值为1/3。</p>
<p>所以，除法求值的问题转化为有向带权图的搜索问题，我们可以采用BFS和DFS两类做法来解决。例如：已知 a / b = 2.0, b / c = 3.0 ，我们可以根据上述等式建图，当求解a/c时，只需要将顶点a到顶点c路径上的权值累乘即可。</p>
<p>这里我们使用DFS来解决。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">calcEquation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> equations<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> values<span class="token punctuation">:</span> List<span class="token punctuation">[</span>float<span class="token punctuation">]</span><span class="token punctuation">,</span> queries<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>float<span class="token punctuation">]</span><span class="token punctuation">:</span>
        graph<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#使用defaultdict较为方便，不需要判断key是否在dict的keys中，如果不在的话defaultdict会按照构造函数给定的参数自动为其赋值</span>
        weights<span class="token operator">=</span>defaultdict<span class="token punctuation">(</span><span class="token punctuation">)</span>
        visited<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">for</span> idx<span class="token punctuation">,</span>eq <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>equations<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#enumerate方法可以额外返回迭代对象每个元素的数组下标</span>
            graph<span class="token punctuation">[</span>eq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>eq<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            graph<span class="token punctuation">[</span>eq<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>eq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            weights<span class="token punctuation">[</span>tuple<span class="token punctuation">(</span>eq<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">=</span>values<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>
            weights<span class="token punctuation">[</span>tuple<span class="token punctuation">(</span>eq<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span>values<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>

        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> start <span class="token operator">not</span> <span class="token keyword">in</span> graph<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">or</span> end <span class="token operator">not</span> <span class="token keyword">in</span> graph<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#出现了未在等式中出现的变量，直接返回0</span>
                <span class="token keyword">return</span> <span class="token number">0</span>
            <span class="token keyword">if</span> start<span class="token operator">==</span>end<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#被除数与除数相等</span>
                <span class="token keyword">return</span> <span class="token number">1.0</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span> <span class="token keyword">in</span> weights<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#被除数与除数直接相连</span>
                <span class="token keyword">return</span> weights<span class="token punctuation">[</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> nextV <span class="token keyword">in</span> graph<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#深度优先搜索</span>
                <span class="token keyword">if</span> nextV <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#防止重复遍历，进入环路</span>
                    visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>nextV<span class="token punctuation">)</span>
                    res<span class="token operator">=</span>dfs<span class="token punctuation">(</span>nextV<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token operator">*</span>weights<span class="token punctuation">[</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>nextV<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#继续深搜</span>
                    <span class="token keyword">if</span> res<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#一旦出现了合法结果，就返回</span>
                        weights<span class="token punctuation">[</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">=</span>res<span class="token comment" spellcheck="true">#将被除数和除数修改为直接相连，方便以后的搜索</span>
                        visited<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>nextV<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#注意：这里如果不加回溯的话，由于return直接跳出，将导致回溯错误</span>
                        <span class="token keyword">return</span> res
                    visited<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>nextV<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#回溯</span>
            <span class="token keyword">return</span> <span class="token number">0</span>

        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> query <span class="token keyword">in</span> queries<span class="token punctuation">:</span>
            r<span class="token operator">=</span>dfs<span class="token punctuation">(</span>query<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>query<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>r <span class="token keyword">if</span> r<span class="token operator">!=</span><span class="token number">0</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#为什么用0不直接用-1标识不合法结果：除法运算必然结果不为0，但结果可能为-1.</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这题还可以用带权的并查集来解决。</p>
<h3 id="406-题-根据身高重建队列"><a href="#406-题-根据身高重建队列" class="headerlink" title="406 题 根据身高重建队列"></a>406 题 <a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">根据身高重建队列</a></h3><p><img src="406.png" alt="406题"></p>
<h4 id="思路：-48"><a href="#思路：-48" class="headerlink" title="思路："></a>思路：</h4><p>假设所有人都一样高，即（h，k）中的k均相同，那么重建队列将会很简单，直接将对应的人放在k位置处即可。</p>
<p>现在，每个人的高度可能不同。但上述方案也是可行的，因为个子矮的人相对于个子高的人是不可见的，所以我们只需要从高到低将每个人插入到对应位置即可。如果产生了碰撞，那么个子高的人会向后移动，事实上这对个子高的人的有序性不会产生影响，因为无论你在他之前插入多少矮个子的人，对他都是不可见的。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">reconstructQueue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> people<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        people<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> person <span class="token keyword">in</span> people<span class="token punctuation">:</span>
            people<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>person<span class="token punctuation">)</span>
            people<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>person<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>person<span class="token punctuation">)</span>
        <span class="token keyword">return</span> people<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(n^2)$，排序需要&amp;O(nlogn)&amp;，而移动需要插入和删除各一次。由于这里是列表，而不是链表，所以移动需要&amp;O(n^2)&amp;的时间复杂度。</li>
<li>空间复杂度：$O(1)$，原地修改。</li>
</ul>
<h2 id="2020-4-16-（2-medium-2-easy）"><a href="#2020-4-16-（2-medium-2-easy）" class="headerlink" title="2020.4.16 （2 medium 2 easy）"></a>2020.4.16 （2 medium 2 easy）</h2><h3 id="416题-分割等和子集"><a href="#416题-分割等和子集" class="headerlink" title="416题 分割等和子集"></a>416题 <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">分割等和子集</a></h3><p><img src="416.png" alt="416题"></p>
<h4 id="思路：-49"><a href="#思路：-49" class="headerlink" title="思路："></a>思路：</h4><h5 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h5><p>这道题是0-1背包问题的扩展，首先，我们来看0-1背包问题：</p>
<blockquote>
<p>假设有n个重量为W1，W2，W3….Wn，价值为V1，V2，V3…..Vn的物品，需要放入一个容量为C的背包，每个物品最多被选中1次（0-1背包），问能放入物品的最大价值是多少？</p>
</blockquote>
<p>这道题是一道非常经典的动态规划题，其状态矩阵可能需要思考一段时间后才能定义出来。在本题中，动态规划的状态矩阵为dp[i] [j]，其中，i表示前i个物品，j表示容量为j，该状态矩阵的含义是前i个物品放入容量为j的背包中所能放入的最大价值。</p>
<p>我们知道，每一个物品只有两种选择：放或者不放。所以，动态规划转移时，当前状态有两种选择：</p>
<ul>
<li>dp[i-1] [j] （不放第i个物品，此时，总价值不变，前i-1个物品所能放入的背包容量仍然是j）</li>
<li>dp[i-1] [j-Wi]+Vi （放置第j个物品，此时总价值加上第j个物品的价值，但前i-1个物品所能放入的背包容量被占用了Wi的大小）</li>
</ul>
<p>我们只需要在每次转移时，从上述两个可能的源状态中选取最大的那个即可。特别地，当j&lt;Wi时，只能选择第一种源状态。当i==0时，也需要特判，直接初始化即可，如果dp[0] [j]大于等于W0就等于V0，否则，等于0。</p>
<pre class="line-numbers language-python"><code class="language-python">w<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
v<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">,</span><span class="token number">63</span><span class="token punctuation">]</span>
c<span class="token operator">=</span><span class="token number">10</span>
dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#0号物品的特判</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">>=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token number">0</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> j<span class="token operator">>=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>假如我们需要找到最大价值的子集具体是哪些物品，可以从动态规划矩阵的最后一个位置进行回溯，回溯的具体方法是：看dp[i] [j] 等于 dp[i-1] [j] 还是 dp[i-1] [j-Wi]+Vi ，即可知第i个物品有没有被放入最大价值子集。</p>
<pre class="line-numbers language-python"><code class="language-python">i<span class="token operator">=</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span>
j<span class="token operator">=</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
        i<span class="token operator">-=</span><span class="token number">1</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#因为转移时只有两种可能，所以直接用else即可</span>
        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#此时，i号物品被放入最大价值子集</span>
        j<span class="token operator">-=</span><span class="token punctuation">[</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>
        i<span class="token operator">-=</span><span class="token number">1</span>
    <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">break</span>
<span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#0号元素需要特判</span>
    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们知道，动态规划时，如果每个状态只和之前有限个状态有关，那么可以采用滚动数组的方式进行空间优化，01背包问题也可以这么做。由于dp[i] [j]的转移只和  dp[i-1] [j] 和 dp[i-1] [j-Wi]+Vi 有关，所以我们只需要存储一维列表即可。我们使用一维列表存放原状态矩阵上一行的值，然后从后向前计算，更新这个一维列表，即计算当前行的值。之所以从后向前，是因为前面的值在后面的计算中可能需要用到，这样做可以防止它们在被使用之前被覆盖。</p>
<pre class="line-numbers language-python"><code class="language-python">w<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
v<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">,</span><span class="token number">63</span><span class="token punctuation">]</span>
c<span class="token operator">=</span><span class="token number">10</span>
dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#需要先初始化0号物品的情况，0号物品可以正向计算</span>
    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">>=</span>w<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token number">0</span>
i<span class="token operator">=</span><span class="token number">1</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> j<span class="token operator">>=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="回到本题"><a href="#回到本题" class="headerlink" title="回到本题"></a>回到本题</h5><p>我们再次分析本题，发现本题可以抽象成为一个01背包问题：第i个物品的价值和重量等于nums[i]，背包最大容量等于sum（nums）//2，求解最大价值子集，使其等于背包容量（即总和的一半）。</p>
<p>特别地，sum（nums）如果为奇数，必然找不到两个等和子集。一旦找到等于sum（nums）//2的价值时，可以提前退出。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">canPartition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        
        c<span class="token operator">=</span>sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        <span class="token keyword">if</span> c<span class="token operator">%</span><span class="token number">2</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            c<span class="token operator">//=</span><span class="token number">2</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#需要先初始化0号物品的情况，0号物品可以正向计算</span>
            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">>=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> j<span class="token operator">>=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>c<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了进一步进行优化，减少计算量，我们进一步抽象原本的问题。现在，动态规划状态矩阵 dp[i] [j] 是一个布尔值，代表nums的前i个数字是否可以拥有一个子集，值与j相等。则动态规划转移方程为：</p>
<ul>
<li>dp[i] [j]=dp[i-1] [j] or dp[i-1] [j-nums[i]]</li>
</ul>
<p>也就是说，如果（1）选择第i个数字（2）不选第i个数字 两种情况中有一个可以在前i个数字中构造一个子集 等于j，那么dp[i] [j] 就可以为真。</p>
<p>特别地，dp[i] [0] 始终为真。因为所有数字都是正整数，所以它们的和必然大于0，我们这里让dp[i] [0] 为真是让其作为一个哨兵元素，试想当nums[i]==j时，我们可以通过这个哨兵元素，得到dp[i] [j]= dp[i-1] [0]=True，从而不需要做额外的判断。</p>
<p>如果某一行的dp[i] [c]为真，说明前i个数字中存在子集和为c，可以说存在等和子集。</p>
<p>如果需要求解等和子集的内容，我们可以通过回溯指针实现，和01背包类似。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">canPartition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        
        c<span class="token operator">=</span>sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        <span class="token keyword">if</span> c<span class="token operator">%</span><span class="token number">2</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            c<span class="token operator">//=</span><span class="token number">2</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#需要先初始化0号物品的情况，0号物品可以正向计算</span>
            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span> <span class="token keyword">if</span> j<span class="token operator">==</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token boolean">False</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>            
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> j<span class="token operator">>=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">or</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>
                <span class="token keyword">if</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样，直接进行布尔运算，比计算数值更快速。</p>
<h3 id="437题-路径总和-III"><a href="#437题-路径总和-III" class="headerlink" title="437题 路径总和 III"></a>437题 <a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">路径总和 III</a></h3><p><img src="437.png" alt="437题"></p>
<h4 id="思路：-50"><a href="#思路：-50" class="headerlink" title="思路："></a>思路：</h4><p>最简单的方法是使用双层循环，以树中的每一个节点为起点，进行DFS，寻找路径和等于目标值的路径。这一方法也叫做双重递归。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#第一层递归</span>
            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>
                dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#以树中每个节点为起点进行递归</span>
                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                preorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

        self<span class="token punctuation">.</span>res<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>pathsum<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#第二层递归</span>
            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>
                pathsum<span class="token operator">+=</span>root<span class="token punctuation">.</span>val<span class="token comment" spellcheck="true">#记录下截止到当前节点的路径和</span>
                <span class="token keyword">if</span> pathsum<span class="token operator">==</span>sum<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#当路径和为sum时，结果数目加1</span>
                    self<span class="token punctuation">.</span>res<span class="token operator">+=</span><span class="token number">1</span>
                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>pathsum<span class="token punctuation">)</span>
                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>pathsum<span class="token punctuation">)</span>
                pathsum<span class="token operator">-=</span>root<span class="token punctuation">.</span>val<span class="token comment" spellcheck="true">#回溯</span>

        preorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>很明显，这样效率很低，因为会产生许多子树的重复遍历。</p>
<p>较好的思路是使用前缀和的方法。我们知道，任何一个有序数组的某一个区间[i，j]的和都可以由 j 的前缀和减去 i 的前缀和得到（第 i 的数字的前缀和指的是第0个数字+第1个数字+…+第 i 个数字），同理，本题中各路径和也可以由前缀和得到。我们通过记忆化递归的方法，使用备忘录记录下每个节点的前缀和，可以防止重复的递归。</p>
<p>求解节点 i 到 节点 j 的路径和，只需使用 j 的前缀和减去 i 的前缀和即可，这里的前缀和指的是根节点到当前节点处的路径上节点值总和。</p>
<p>我们使用前序遍历搜索，记录下当前路径列表和当前前缀和。然后将当前节点的前缀和与路径列表上每一个节点的前缀和相减，查看是否有路径和等于目标值。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        ht<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        self<span class="token punctuation">.</span>res<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>path<span class="token punctuation">,</span>pathsum<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>
                pathsum<span class="token operator">+=</span>root<span class="token punctuation">.</span>val
                <span class="token keyword">if</span> pathsum<span class="token operator">==</span>sum<span class="token punctuation">:</span>
                    self<span class="token punctuation">.</span>res<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">if</span> root <span class="token operator">not</span> <span class="token keyword">in</span> ht<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    ht<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token operator">=</span>pathsum<span class="token comment" spellcheck="true">#前缀和备忘录</span>
                <span class="token keyword">for</span> node <span class="token keyword">in</span> path<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历路径列表，采用前缀和相减的方式计算路径和</span>
                    <span class="token keyword">if</span> pathsum<span class="token operator">-</span>ht<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token operator">==</span>sum<span class="token punctuation">:</span>
                        self<span class="token punctuation">.</span>res<span class="token operator">+=</span><span class="token number">1</span>
                path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#理论上，这个路径添加应该放在开头，但是因为自身路径和相减没有意义，所以放在这里更好</span>
                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>path<span class="token punctuation">,</span>pathsum<span class="token punctuation">)</span>
                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>path<span class="token punctuation">,</span>pathsum<span class="token punctuation">)</span>
                path<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#回溯</span>
                pathsum<span class="token operator">-=</span>root<span class="token punctuation">.</span>val
        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="438题-找到字符串中所有字母异位词"><a href="#438题-找到字符串中所有字母异位词" class="headerlink" title="438题 找到字符串中所有字母异位词"></a>438题 <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">找到字符串中所有字母异位词</a></h3><p><img src="438.png" alt="438题"></p>
<h4 id="思路：-51"><a href="#思路：-51" class="headerlink" title="思路："></a>思路：</h4><p>和第76题有些许相似，都是使用滑动窗口法。</p>
<p>使用两个指针start，end在待匹配串s上滑动区间[start,end)。其中，end=start+len（p）。</p>
<p>使用哈希表hashtable存放模式串p中的所有字母及其出现的次数。使用哈希表now存放当前滑动区间内的所有字母及其出现次数。</p>
<p>在s串上进行滑动匹配：</p>
<ul>
<li>如果now为空，说明滑动区间在起始位置或者刚刚被整体挪动过多个位置，此时需要重新统计当前滑动区间内的字母和出现次数。这里的统计采用倒序的方式，当倒序遍历到一个不在模式串p中的字母时，整体挪动滑动区间至该字母后面（所有包含此字母的区间都不必访问了），并清空now。否则将其使用哈希表now对当前字母进行统计。</li>
<li>如果now不为空，说明是由前一个滑动区间向后滑动一个位置得到，此时不需要整体更新，只需要将新遍历到的字母（end-1位置）加入到哈希表now即可。如果新遍历到的字母不在模式串p中，那么依然移动区间至新字母后。</li>
<li>如果当前区间内未出现不在模式串p中的字母，那么就尝试将当前区间统计哈希表now与模式串统计哈希表hashtable进行比较，如果相等，则将start加入到结果数组中。此时，无论是否相等，我们都需要将当前区间向前滑动一个位置。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> copy
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findAnagrams</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> p<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        l<span class="token operator">=</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
        hashtable<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">for</span> ch <span class="token keyword">in</span> p<span class="token punctuation">:</span>
            <span class="token keyword">if</span> ch <span class="token operator">not</span> <span class="token keyword">in</span> hashtable<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                hashtable<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                hashtable<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>
        start<span class="token operator">=</span><span class="token number">0</span>
        end<span class="token operator">=</span>start<span class="token operator">+</span>l
        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        now<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">while</span> end<span class="token operator">&lt;=</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
            flag<span class="token operator">=</span><span class="token boolean">False</span>
            <span class="token keyword">if</span> now<span class="token operator">==</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">:</span>
                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>end<span class="token number">-1</span><span class="token punctuation">,</span>start<span class="token number">-1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> hashtable<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        flag<span class="token operator">=</span><span class="token boolean">True</span>
                        start<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span>
                        end<span class="token operator">=</span>start<span class="token operator">+</span>l
                        now<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
                        <span class="token keyword">break</span>
                    <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> now<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        now<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        now<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> s<span class="token punctuation">[</span>end<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token keyword">in</span> hashtable<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> s<span class="token punctuation">[</span>end<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token keyword">in</span> now<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        now<span class="token punctuation">[</span>s<span class="token punctuation">[</span>end<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        now<span class="token punctuation">[</span>s<span class="token punctuation">[</span>end<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    start<span class="token operator">=</span>end
                    end<span class="token operator">=</span>start<span class="token operator">+</span>l
                    now<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
                    flag<span class="token operator">=</span><span class="token boolean">True</span>
            <span class="token keyword">if</span> <span class="token operator">not</span> flag<span class="token punctuation">:</span>
                <span class="token keyword">if</span> now<span class="token operator">==</span>hashtable<span class="token punctuation">:</span>
                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>start<span class="token punctuation">)</span>
                now<span class="token punctuation">[</span>s<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>
                start<span class="token operator">+=</span><span class="token number">1</span>
                end<span class="token operator">+=</span><span class="token number">1</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="448题-找到所有数组中消失的数字"><a href="#448题-找到所有数组中消失的数字" class="headerlink" title="448题  找到所有数组中消失的数字"></a>448题 <a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener"> 找到所有数组中消失的数字</a></h3><p><img src="448.png" alt="448题"></p>
<h4 id="思路：-52"><a href="#思路：-52" class="headerlink" title="思路："></a>思路：</h4><p>和之前做过的第41题类似，采用原地哈希映射的方式，将数字i映射到数组下标为i-1的位置上。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findDisappearedNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>pos1<span class="token punctuation">,</span>pos2<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#一定要这样交换！python的机制问题，否则会出错。</span>
            nums<span class="token punctuation">[</span>pos1<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>pos2<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>pos2<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>pos1<span class="token punctuation">]</span>

        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">while</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                swap<span class="token punctuation">(</span>i<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>

        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> i<span class="token operator">!=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-4-17-（2-medium，3-easy）"><a href="#2020-4-17-（2-medium，3-easy）" class="headerlink" title="2020.4.17 （2 medium，3 easy）"></a>2020.4.17 （2 medium，3 easy）</h2><h3 id="461题-汉明距离"><a href="#461题-汉明距离" class="headerlink" title="461题 汉明距离"></a>461题 汉明距离</h3><p><img src="461.png" alt="461题"></p>
<h4 id="思路：-53"><a href="#思路：-53" class="headerlink" title="思路："></a>思路：</h4><p>比较简单，可以用按位异或+统计1的个数的方法来进行汉明距离的统计。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">,</span> y<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        x<span class="token operator">=</span>x<span class="token operator">^</span>y
        res<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">while</span> x<span class="token punctuation">:</span>
            x<span class="token operator">&amp;</span><span class="token operator">=</span>x<span class="token number">-1</span>
            res<span class="token operator">+=</span><span class="token number">1</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="494题-目标和"><a href="#494题-目标和" class="headerlink" title="494题 目标和"></a>494题 <a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">目标和</a></h3><p><img src="494.png" alt="494题"></p>
<h4 id="思路：-54"><a href="#思路：-54" class="headerlink" title="思路："></a>思路：</h4><p>这道题，我的思路是使用BFS 的方法，进行所有计算路径的遍历，同时在遍历过程中，合并和重复的路径，防止重复遍历。</p>
<p>有点类似于之前的完全平方和问题和找零钱问题。不过这道题与找零钱的不同之处在于：找零钱只需要知道是否有组合，本题还需要知道组合的数目。所以本题要用到哈希表存放当前层的和以及每个和的组合数目。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> S<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        ht<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#初始情况下，哈希表中只有一个0（为什么不用队列，因为哈希表按key存取，合并相同和的组合更方便）</span>
        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历数组中所有数</span>
            tmp<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
            <span class="token keyword">for</span> key <span class="token keyword">in</span> list<span class="token punctuation">(</span>ht<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#遍历1...num所有的和</span>
                newnums<span class="token operator">=</span><span class="token punctuation">[</span>key<span class="token operator">+</span>num<span class="token punctuation">,</span>key<span class="token operator">-</span>num<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#每个和与当前数的+和-进行相加</span>
                <span class="token keyword">for</span> newnum <span class="token keyword">in</span> newnums<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#结果存入临时哈希表</span>
                    <span class="token keyword">if</span> newnum <span class="token operator">not</span> <span class="token keyword">in</span> tmp<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        tmp<span class="token punctuation">[</span>newnum<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">*</span>ht<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        tmp<span class="token punctuation">[</span>newnum<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span><span class="token operator">*</span>ht<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
            ht<span class="token operator">=</span>tmp<span class="token comment" spellcheck="true">#更新本层BFS后的哈希表</span>
        <span class="token keyword">return</span> ht<span class="token punctuation">[</span>S<span class="token punctuation">]</span> <span class="token keyword">if</span> S <span class="token keyword">in</span> ht<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token comment" spellcheck="true">#返回最后一层结果中，key（即和）为S的组合数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此外，我们还可以使用01背包的动态规划解法。假设动态规划状态矩阵dp[i] [j]为前 i 个数字和为 j 一共有多少种情况，则动态规划转移方程为：</p>
<ul>
<li>dp[i] [j] = dp[j-nums[i]] + dp[j+nums[i]]</li>
</ul>
<p>也就是说，上述动态规划转移方程考虑了是否选取当前数字的两种情况，进行状态转移。</p>
<p>这里的 j 的范围是数组nums所有数字之和可能的值域，即[-sum，sum]，特别的，由于每层状态的转移只依赖上一层状态，所以我们可以进行状态压缩。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> S<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        summa<span class="token operator">=</span>sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        <span class="token keyword">if</span> summa<span class="token operator">&lt;</span>abs<span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果数组元素之和小于S，必不可能计算出S</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token operator">-</span>summa<span class="token punctuation">,</span>summa<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#从[-sum,sum]共2*sum+1个元素，dp[sum]即为和为0的情况</span>
        dp<span class="token punctuation">[</span>summa<span class="token operator">+</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
        dp<span class="token punctuation">[</span>summa<span class="token operator">-</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            next<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token operator">-</span>summa<span class="token punctuation">,</span>summa<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#需要注意！这里的本层元素依赖的上一层元素，其上一层的j可能大于也可能小于当前层的j，所以无法只用一个数组通过倒序（like 01背包模板）遍历的方式更新，要使用辅助数组，和上面BFS解法的辅助哈希表类似。</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                add<span class="token operator">=</span>dp<span class="token punctuation">[</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token comment" spellcheck="true">#考虑越界的情况</span>
                minus<span class="token operator">=</span>dp<span class="token punctuation">[</span>j<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>j<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token number">0</span>
                next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>add<span class="token operator">+</span>minus
            dp<span class="token operator">=</span>next
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>summa<span class="token operator">+</span>S<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="538题-二叉搜索树转换为累加树"><a href="#538题-二叉搜索树转换为累加树" class="headerlink" title="538题 二叉搜索树转换为累加树"></a>538题 <a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">二叉搜索树转换为累加树</a></h3><p><img src="538.png" alt="538题"></p>
<h4 id="思路：-55"><a href="#思路：-55" class="headerlink" title="思路："></a>思路：</h4><p>我们知道，二叉搜索树的中序遍历（左、中、右）得到的节点，其val是依次递增的，同理，反向中序遍历（右、中、左）得到的节点，其val依次递减。</p>
<p>这样我们将反向中序遍历所得到的节点的val依次累加并更新当前节点的val，即可使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 </p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">convertBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>s<span class="token operator">=</span><span class="token number">0</span><span class="token comment" spellcheck="true">#用于记录遍历到当前节点前的所有节点值得累加和</span>
        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>
                recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                root<span class="token punctuation">.</span>val<span class="token operator">+=</span>self<span class="token punctuation">.</span>s
                self<span class="token punctuation">.</span>s<span class="token operator">=</span>root<span class="token punctuation">.</span>val
                recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="543题-二叉树的直径"><a href="#543题-二叉树的直径" class="headerlink" title="543题 二叉树的直径"></a>543题 <a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">二叉树的直径</a></h3><p><img src="543.png" alt="543题"></p>
<h4 id="思路：-56"><a href="#思路：-56" class="headerlink" title="思路："></a>思路：</h4><p>可以后序遍历来做。</p>
<p>以当前节点为根节点的子树，其最大直径上的节点数为：递归搜索左子树返回的值加上递归搜索右子树返回的值再加1。递归函数的返回值的含义是：以当前节点为一个端点的路径的最大节点数。它与最大直径的区别在于：最大直径路径只需要经过root即可，返回的路径需要以root为端点。具体为什么这么做是因为如果直接返回当前节点的最大直径路径，无法与上一层节点组成有效路径，会出现环路。</p>
<p>我们每次递归时，尝试用当前子树的最大直径路径上的节点数更新全局变量Self.max_d。最后将他的值减去1，即为最大直径路径上的边数。此外，还需要对空树进行特判。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">diameterOfBinaryTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>max_d<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> root<span class="token operator">==</span>None<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token number">0</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                left<span class="token operator">=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                right<span class="token operator">=</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                self<span class="token punctuation">.</span>max_d<span class="token operator">=</span>max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>max_d<span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">+</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>max<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>
        recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>max_d<span class="token number">-1</span> <span class="token keyword">if</span> root<span class="token operator">!=</span>None <span class="token keyword">else</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-4-18-（2-medium，2-easy）"><a href="#2020-4-18-（2-medium，2-easy）" class="headerlink" title="2020.4.18 （2 medium，2 easy）"></a>2020.4.18 （2 medium，2 easy）</h2><h3 id="560题-和为K的子数组"><a href="#560题-和为K的子数组" class="headerlink" title="560题 和为K的子数组"></a>560题 <a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">和为K的子数组</a></h3><p><img src="560.png" alt="560题"></p>
<h4 id="思路：-57"><a href="#思路：-57" class="headerlink" title="思路："></a>思路：</h4><p>一开始想用区间DP，发现超时了。</p>
<p>联想到我们前几天做过的寻找二叉树中路径和为k的路径这一问题，我们不难想到本题也可以用前缀和来解决。子数组nums[i：j]可以通过前缀和prefixsum[j]-prefixsum[i]求解。比较它的值是否为k即可。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">subarraySum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        prefixsum<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        prefixsum<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        res<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>prefixsum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            prefixsum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>prefixsum<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>prefixsum<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>prefixsum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> prefixsum<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span>prefixsum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>k<span class="token punctuation">:</span>
                    res<span class="token operator">+=</span><span class="token number">1</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(n^2)$。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<p>由于我们比较的对象为：prefixsum[j]-prefixsum[i]==k，可以转化为prefixsum[j]-k=prefixsum[i]，所以我们只需要在每次统计前缀和prefixsum[j]时，顺便看是否已经有统计到的前缀和prefixsum[i]等于此时的前缀和prefixsum[j]减去k即可。特别地，对于prefixsum[j]-k=prefixsum[i]，j 之前可能有多个 i 符合该条件。我们可以使用哈希表来进行优化。</p>
<p>哈希表ht的key为前缀和的值，value为目前有几个前缀和等于key。我们只需要为结果加上ht[prefixsum[j]-k]即可。每次遍历数组需要对哈希表进行更新。</p>
<pre class="line-numbers language-PYTHON"><code class="language-PYTHON">class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        prefixsum=0
        ht={0:1}
        res=0
        for num in nums:
            prefixsum+=num
            if prefixsum-k in ht.keys():
                res+=ht[prefixsum-k]
            if prefixsum in ht.keys():
                ht[prefixsum]+=1
            else:
                ht[prefixsum]=1
        return res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样，可以将时间复杂度降为$O(n)$。</p>
<h3 id="581题-最短无序连续子数组"><a href="#581题-最短无序连续子数组" class="headerlink" title="581题 最短无序连续子数组"></a>581题 <a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">最短无序连续子数组</a></h3><p><img src="581.png" alt="581题"></p>
<h4 id="思路：-58"><a href="#思路：-58" class="headerlink" title="思路："></a>思路：</h4><p>我们知道，一个单调递增的序列，其每个数字都大于之前所有数字，也就是大于它们的最大值。一个单调递减的序列，其每个数字小于之前所有数字。</p>
<p>本题中，我们只需要正向遍历数组，找到不符合单调递增性质的最后一个数字，作为最短无序连续数组的右边界。接着反向遍历数组，找到不符合单调递减性质的最后一个数字，作为左边界。即可找到结果。</p>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findUnsortedSubarray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        max_now<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        right<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>max_now<span class="token punctuation">:</span>
                right<span class="token operator">=</span>i
            max_now<span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>max_now<span class="token punctuation">)</span>
        min_now<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        left<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>min_now<span class="token punctuation">:</span>
                left<span class="token operator">=</span>i
            min_now<span class="token operator">=</span>min<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>min_now<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span> <span class="token keyword">if</span> right<span class="token operator">-</span>left<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token keyword">else</span> right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>本质上是在维护一个单调栈。</p>
<h3 id="617题-合并二叉树"><a href="#617题-合并二叉树" class="headerlink" title="617题 合并二叉树"></a>617题 <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">合并二叉树</a></h3><p><img src="617.png" alt="617题"></p>
<h4 id="思路：-59"><a href="#思路：-59" class="headerlink" title="思路："></a>思路：</h4><p>我们采用递归的方式对二叉树进行合并，将t2子树合并到t1子树上去。如果t1子树为空，那么直接返回t2子树。如果t2子树为空，那么直接返回t1子树。否则，将t2节点的值加到t1上，然后分别合并二者的左子树和右子树。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> t1<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> t2<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>
        <span class="token keyword">if</span> t1<span class="token operator">==</span>None<span class="token punctuation">:</span>
            <span class="token keyword">return</span> t2
        <span class="token keyword">elif</span> t2<span class="token operator">==</span>None<span class="token punctuation">:</span>
            <span class="token keyword">return</span> t1
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            t1<span class="token punctuation">.</span>val<span class="token operator">+=</span>t2<span class="token punctuation">.</span>val
            t1<span class="token punctuation">.</span>left<span class="token operator">=</span>self<span class="token punctuation">.</span>mergeTrees<span class="token punctuation">(</span>t1<span class="token punctuation">.</span>left<span class="token punctuation">,</span>t2<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            t1<span class="token punctuation">.</span>right<span class="token operator">=</span>self<span class="token punctuation">.</span>mergeTrees<span class="token punctuation">(</span>t1<span class="token punctuation">.</span>right<span class="token punctuation">,</span>t2<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            <span class="token keyword">return</span> t1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="621题-任务调度器"><a href="#621题-任务调度器" class="headerlink" title="621题 任务调度器"></a>621题 <a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">任务调度器</a></h3><p><img src="621.png" alt="621题"></p>
<h4 id="思路：-60"><a href="#思路：-60" class="headerlink" title="思路："></a>思路：</h4><p>可以采用找规律的数学解法。</p>
<p>因为相同任务必须要有时间片为 n 的间隔，所以我们先把出现次数最多的任务 A 安排上（当然你也可以选择任务 B）。例子中 n = 2，那么任意两个任务 A 之间都必须间隔 2 个单位的时间：</p>
<blockquote>
<p>A -&gt; (单位时间) -&gt; (单位时间) -&gt; A -&gt; (单位时间) -&gt; (单位时间) -&gt; A</p>
</blockquote>
<p>中间间隔的单位时间可以用来安排别的任务，也可以处于“待命”状态。当然，为了使总任务时间最短，我们要尽可能地把单位时间分配给其他任务。现在把任务 B 安排上：</p>
<blockquote>
<p>A -&gt; B -&gt; (单位时间) -&gt; A -&gt; B -&gt; (单位时间) -&gt; A -&gt; B</p>
</blockquote>
<p>很容易观察到，前面两个 A 任务一定会固定跟着 2 个单位时间的间隔。最后一个 A 之后是否还有任务跟随取决于是否存在与任务 A 出现次数相同的任务。</p>
<p>所以整体的解题步骤如下：</p>
<ol>
<li>计算每个任务出现的次数</li>
<li>找出出现次数最多的任务，假设出现次数为 x</li>
<li>计算至少需要的时间 (x - 1) * (n + 1)，记为 min_time</li>
<li>计算出现次数为 x 的任务总数 count，计算最终结果为 min_time + count。特别注意，这里的最终结果必须大于任务数目，因为最小时间是任务数目（无拥塞）。</li>
</ol>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">leastInterval</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tasks<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        task_table<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> len<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span>
        <span class="token keyword">for</span> task <span class="token keyword">in</span> tasks<span class="token punctuation">:</span>
            <span class="token keyword">if</span> task <span class="token keyword">in</span> task_table<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                task_table<span class="token punctuation">[</span>task<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                task_table<span class="token punctuation">[</span>task<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
        max_times<span class="token operator">=</span>max<span class="token punctuation">(</span>list<span class="token punctuation">(</span>task_table<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        res<span class="token operator">=</span><span class="token punctuation">(</span>max_times<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        res<span class="token operator">+=</span>list<span class="token punctuation">(</span>task_table<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>count<span class="token punctuation">(</span>max_times<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res <span class="token keyword">if</span> res<span class="token operator">>=</span>len<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span> <span class="token keyword">else</span> len<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-4-19-（2-medium）"><a href="#2020-4-19-（2-medium）" class="headerlink" title="2020.4.19 （2 medium）"></a>2020.4.19 （2 medium）</h2><h3 id="647题-回文子串"><a href="#647题-回文子串" class="headerlink" title="647题 回文子串"></a>647题 <a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">回文子串</a></h3><p><img src="647.png" alt="647题"></p>
<h4 id="思路：-61"><a href="#思路：-61" class="headerlink" title="思路："></a>思路：</h4><p>中心扩展法，类似于求解最大回文子串问题，只需要稍微修改一下，每一次扩展时将计数变量加1即可。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">countSubstrings</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">centerexpand</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>
            res<span class="token operator">=</span><span class="token number">0</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>i <span class="token operator">and</span> j<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                res<span class="token operator">+=</span><span class="token number">1</span>
                i<span class="token operator">-=</span><span class="token number">1</span>
                j<span class="token operator">+=</span><span class="token number">1</span>
            <span class="token keyword">return</span> res

        res<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            res1<span class="token operator">=</span>centerexpand<span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span>
            res2<span class="token operator">=</span>centerexpand<span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> res1<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>
                res<span class="token operator">+=</span>res1
            <span class="token keyword">if</span> res2<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>
                res<span class="token operator">+=</span>res2
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h3 id="739题-每日温度"><a href="#739题-每日温度" class="headerlink" title="739题 每日温度"></a>739题 <a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">每日温度</a></h3><p><img src="739.png" alt="739题"></p>
<h4 id="思路：-62"><a href="#思路：-62" class="headerlink" title="思路："></a>思路：</h4><p>使用单调栈来做。这题使用一个单调递减栈，栈内存放天数和该天的温度，温度从栈底到栈顶依次单调递减。遍历数组T。如果第i天的温度小于等于栈顶元素的温度，那么直接将（i，T（i））入栈。如果大于栈顶元素温度，说明此时必然是第一次高过此温度，则可以将栈顶元素的天数j的结果记录为：res[j]=i-j。</p>
<p>也就是说，我们的单调递减栈存放的是尚未有温度升高超过的各天和它们的温度。每次向后遍历一天，查看当天气温是否比栈顶最低气温高，是则将二者天数差值保存进结果数组，并且将栈顶元素出栈，比较当天气温与栈中第二低的气温；否则入栈保存，继续向后遍历。</p>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> T<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        stack<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> stack<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">or</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">while</span> stack<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    j<span class="token operator">=</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
                    res<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">-</span>j
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-4-20-（3-easy，1-medium）"><a href="#2020-4-20-（3-easy，1-medium）" class="headerlink" title="2020.4.20 （3 easy，1 medium）"></a>2020.4.20 （3 easy，1 medium）</h2><h3 id="88题-合并两个有序数组"><a href="#88题-合并两个有序数组" class="headerlink" title="88题 合并两个有序数组"></a>88题 <a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">合并两个有序数组</a></h3><p><img src="88.png" alt="88题"></p>
<h4 id="思路：-63"><a href="#思路：-63" class="headerlink" title="思路："></a>思路：</h4><p>这道题是经典的归并排序问题，可以使用双指针法来做。</p>
<p>唯一需要注意的是，本题将第一个数组原地修改为结果数组，如果从前向后归并排序，那么可能会将第一个数组中尚未被遍历到的数字覆盖掉。为了解决这一问题，我们可以从后向前归并排序。指针p指向数组nums1最后一个非零元素，q指向nums2最后一个非零元素，r指向nums1的尾部。具体流程如代码所示：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Do not return anything, modify nums1 in-place instead.
        """</span>
        p<span class="token operator">=</span>m<span class="token number">-1</span>
        q<span class="token operator">=</span>n<span class="token number">-1</span>
        r<span class="token operator">=</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> q<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#将p和q中较大的数字放在r上</span>
                nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span>
                q<span class="token operator">-=</span><span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span>
                p<span class="token operator">-=</span><span class="token number">1</span>
            r<span class="token operator">-=</span><span class="token number">1</span>
        <span class="token keyword">while</span> q<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#因为如果是nums1的前面有数字没有被遍历完，由于是原地修改nums1，所以此时无需移动，也就没有必要判断nums1未遍历完的情况，只需要判断nums2未遍历完的情况。</span>
            nums1<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>nums2<span class="token punctuation">[</span>q<span class="token punctuation">]</span>
            r<span class="token operator">-=</span><span class="token number">1</span>
            q<span class="token operator">-=</span><span class="token number">1</span>
        <span class="token keyword">return</span> nums1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="122题-买卖股票的最佳时机-II"><a href="#122题-买卖股票的最佳时机-II" class="headerlink" title="122题 买卖股票的最佳时机 II"></a>122题<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener"> 买卖股票的最佳时机 II</a></h3><p><img src="122.png" alt="122题"></p>
<h4 id="思路：-64"><a href="#思路：-64" class="headerlink" title="思路："></a>思路：</h4><p>所有的买卖股票问题本质上都可以使用动态规划来解决。状态矩阵dp[i] [j]为第 i 天的第 j 个选择总收益。本题中，存在两种选择：（特别地，在有冷冻期的那道题，我们需要特别讨论冷冻状态）</p>
<ul>
<li>当日持仓（持有股票）：有前一日持仓，当日继续持仓和前一日空仓，当日买入股票持仓两种情况。由于需要得到的是最大利润，所以我们选取两种情况各自所能获得的最大利润作为当日状态。</li>
<li>当日空仓（不持有股票）：有前一日空仓，当日继续空仓和前一日持仓，当日卖出股票空仓两种情况。由于需要得到的是最大利润，所以我们选取两种情况各自所能获得的最大利润作为当日状态。</li>
</ul>
<p>得到了DP矩阵和转移方程，我们就可以求解。通过动态规划，我们可以获得最后一天持仓和空仓的最大收益。由于最后一天持仓无法卖出，必然小于空仓的收益，所以我们直接返回最后一天空仓的收益即可。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<p>特别地，本题还可以用贪心算法来做。假设我们是一个特别保守的股票交易员，一旦当前买入的股票第二天能够赚钱，就迅速买入并在第二天卖出。如下图所示，也就是统计所有上升的小段。</p>
<p><img src="122-1.png" alt="122题"></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        res<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>prices<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                res<span class="token operator">+=</span>prices<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h3 id="217题-存在重复元素"><a href="#217题-存在重复元素" class="headerlink" title="217题 存在重复元素"></a>217题 <a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener">存在重复元素</a></h3><p><img src="217.png" alt="217题"></p>
<h4 id="思路：-65"><a href="#思路：-65" class="headerlink" title="思路："></a>思路：</h4><p>可以使用哈希集合来存放已出现过的数字。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">containsDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        hs<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>
            <span class="token keyword">if</span> num <span class="token operator">not</span> <span class="token keyword">in</span> hs<span class="token punctuation">:</span>
                hs<span class="token punctuation">.</span>add<span class="token punctuation">(</span>num<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="230题-二叉搜索树中第K小的元素"><a href="#230题-二叉搜索树中第K小的元素" class="headerlink" title="230题 二叉搜索树中第K小的元素"></a>230题 <a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">二叉搜索树中第K小的元素</a></h3><p><img src="230.png" alt="230题"></p>
<h4 id="思路：-66"><a href="#思路：-66" class="headerlink" title="思路："></a>思路：</h4><p>通过中序遍历二叉搜素树，可以获得它的升序序列。使用类变量count存放当前遍历的次数，如果达到k，那么返回当前节点的元素值（剪枝）。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">kthSmallest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>res<span class="token operator">=</span>None
        self<span class="token punctuation">.</span>count<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>
                <span class="token keyword">if</span> self<span class="token punctuation">.</span>res<span class="token operator">!=</span>None<span class="token punctuation">:</span>
                    <span class="token keyword">return</span>
                inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                self<span class="token punctuation">.</span>count<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">if</span> self<span class="token punctuation">.</span>count<span class="token operator">==</span>k<span class="token punctuation">:</span>
                    self<span class="token punctuation">.</span>res<span class="token operator">=</span>root<span class="token punctuation">.</span>val
                <span class="token keyword">if</span> self<span class="token punctuation">.</span>res<span class="token operator">!=</span>None<span class="token punctuation">:</span>
                    <span class="token keyword">return</span>
                inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-4-21-（4-easy）"><a href="#2020-4-21-（4-easy）" class="headerlink" title="2020.4.21 （4 easy）"></a>2020.4.21 （4 easy）</h2><h3 id="231题-2的幂"><a href="#231题-2的幂" class="headerlink" title="231题 2的幂"></a>231题 <a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">2的幂</a></h3><p><img src="231.png" alt="231题"></p>
<h4 id="思路：-67"><a href="#思路：-67" class="headerlink" title="思路："></a>思路：</h4><p>简单题，当n小于1时，不可能是2的幂，当n大于等于1时，如果能被2持续整除而没有余数，直到等于1，说明它是2的幂。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        <span class="token keyword">if</span> n<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">while</span> n<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
            n<span class="token operator">=</span>n<span class="token operator">//</span><span class="token number">2</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(logN)$</li>
</ul>
<p>但同时，我们可以使用位运算的极简解法。我们知道：n&amp;（n-1）是去除n的二进制中最后一位1（之前的位运算题目有涉及）。同时，假设一个数是2的幂，那么它的二进制数必然只有最高位为1。所以，n&amp;（n-1）必然等于0。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        <span class="token keyword">return</span> n<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> n<span class="token operator">&amp;</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(1)$</li>
</ul>
<h3 id="235题-二叉搜索树的最近公共祖先"><a href="#235题-二叉搜索树的最近公共祖先" class="headerlink" title="235题 二叉搜索树的最近公共祖先"></a>235题 <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a></h3><p><img src="235.png" alt="235题"></p>
<h4 id="思路：-68"><a href="#思路：-68" class="headerlink" title="思路："></a>思路：</h4><p>简单题，剑指Offer原题。由于本题是一个二叉搜索树，分类讨论的情况为：</p>
<ul>
<li><p>如果root的值位于p、q值之间，说明root必然是它们的最近公共祖先。</p>
</li>
<li><p>如果root的值均大于p、q，说明p、q必在root的左子树，递归查找。</p>
</li>
<li><p>如果root的值均小于p、q，说明p、q必在root的右子树，递归查找。</p>
</li>
<li><p>如果root的值等于p的值或者q的值，说明root必然是它们的最近公共祖先 （<strong>一个节点也可以是它自己的祖先</strong>） 。</p>
</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>p<span class="token punctuation">.</span>val <span class="token operator">or</span> root<span class="token punctuation">.</span>val<span class="token operator">==</span>q<span class="token punctuation">.</span>val <span class="token punctuation">:</span>
            <span class="token keyword">return</span> root
        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">></span>p<span class="token punctuation">.</span>val <span class="token operator">and</span> root<span class="token punctuation">.</span>val<span class="token operator">></span>q<span class="token punctuation">.</span>val <span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>
        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>p<span class="token punctuation">.</span>val <span class="token operator">and</span> root<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>q<span class="token punctuation">.</span>val <span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>
        <span class="token keyword">if</span> q<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>p<span class="token punctuation">.</span>val <span class="token operator">or</span> p<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
            <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="237题-删除链表中的节点"><a href="#237题-删除链表中的节点" class="headerlink" title="237题 删除链表中的节点"></a>237题 <a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">删除链表中的节点</a></h3><p><img src="237.png" alt="237题"></p>
<h4 id="思路：-69"><a href="#思路：-69" class="headerlink" title="思路："></a>思路：</h4><p>这道题并没有给出链表的头节点，我一开始以为题目出错了。因为常规的删除节点方法都需要用到被删除节点的前一个节点。</p>
<p>但其实删除链表的节点也可以不使用前一个节点，而是将当前节点值与后一个节点交换。这样，删除当前节点就转变为删除当前节点的下一个节点，也就可以使用常规方法修改前一个节点的next指针删除节点了。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span>
<span class="token comment" spellcheck="true"># class ListNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """</span>
        node<span class="token punctuation">.</span>val<span class="token operator">=</span>node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val
        node<span class="token punctuation">.</span>next<span class="token operator">=</span>node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="292题-Nim-游戏"><a href="#292题-Nim-游戏" class="headerlink" title="292题 Nim 游戏"></a>292题 <a href="https://leetcode-cn.com/problems/nim-game/" target="_blank" rel="noopener">Nim 游戏</a></h3><p><img src="292.png" alt="292题"></p>
<h4 id="思路：-70"><a href="#思路：-70" class="headerlink" title="思路："></a>思路：</h4><p>一开始，我想到了动态规划解法。dp[i]为石头数为 i 时，玩家能否获胜。转移方程为：</p>
<ul>
<li>dp[i] = True，if i &lt;=3</li>
<li>dp[i] = not(dp[i-1] and dp[i-2] and dp[i-3]) ,if i&gt;3</li>
</ul>
<p>当 i 大于3时，我们需要看当前的玩家拿走1、2或3个石头后，对方剩余的石头数能否获胜。如果三种情况下对方均能获胜，则dp [i]为False，否则为 True。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">canWinNim</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> i<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">not</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">and</span> dp<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span> <span class="token operator">and</span> dp<span class="token punctuation">[</span>i<span class="token number">-3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是，这在python下会超时。</p>
<p>我们继续分析：由状态转移方程可以得知：只要dp[i-1]或dp[i-2]或dp[i-3]中存在一个为假，则dp[i]为真。所以，dp[i]为假，必然导致dp[i+1]、dp[i+2]、dp[i+3]为真。由于dp[i+1]、dp[i+2]、dp[i+3]为真，所以dp[i+4]必然为假。</p>
<p>综上所述，我们发现规律：当 i 被4整除时，必然失败，否则必然获胜。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">canWinNim</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        <span class="token keyword">return</span> n<span class="token operator">%</span><span class="token number">4</span><span class="token operator">!=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>该问题又叫巴比博弈，设最多能拿M块石头，共有N块石头，则结果的真假为N%（M+1）！=0。</p>
<h2 id="2020-4-22-（2-medium-2-easy）"><a href="#2020-4-22-（2-medium-2-easy）" class="headerlink" title="2020.4.22 （2 medium 2 easy）"></a>2020.4.22 （2 medium 2 easy）</h2><h3 id="89题-格雷编码"><a href="#89题-格雷编码" class="headerlink" title="89题 格雷编码"></a>89题 格雷编码</h3><p><img src="89.png" alt="89题"></p>
<h4 id="思路：-71"><a href="#思路：-71" class="headerlink" title="思路："></a>思路：</h4><p>一开始尝试了深搜+回溯，貌似超时了。于是，我们想到使用动态规划法去优化。</p>
<p>这道题的动态规划状态比较特殊。我们使用每一个不同位数时的格雷编码数组，去递归下一个位数时的格雷编码数组。</p>
<p>那么动态规划是如何转移的呢？格雷编码是采用镜像反射法递推的。</p>
<p>根据信息论的知识，去除最高位后，格雷码本身是镜像对称的。我们只需要将第 i 位时刻的格雷编码，倒序后进行拼接，前半部分补全0，后半部分补全1，即可。</p>
<p><img src="89-1.png" alt="89题"></p>
<p>二进制的最高位补0，意味着不变，补1，意味着加上2的当前位数减1次方。这里，我们可以使用一个变量head来进行补1操作，并通过移位运算进行更新。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">grayCode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        head<span class="token operator">=</span><span class="token number">1</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            res<span class="token operator">+=</span><span class="token punctuation">[</span>x<span class="token operator">+</span>head <span class="token keyword">for</span> x <span class="token keyword">in</span> res<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
            head<span class="token operator">&lt;&lt;</span><span class="token operator">=</span><span class="token number">1</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="344-题-反转字符串"><a href="#344-题-反转字符串" class="headerlink" title="344 题 反转字符串"></a>344 题 <a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">反转字符串</a></h3><p><img src="344.png" alt="344题"></p>
<h4 id="思路：-72"><a href="#思路：-72" class="headerlink" title="思路："></a>思路：</h4><p>没什么好说的，简单题，双指针法即可。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Do not return anything, modify s in-place instead.
        """</span>
        l<span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">while</span> l<span class="token operator">&lt;</span>r<span class="token punctuation">:</span>
            s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span>
            l<span class="token operator">+=</span><span class="token number">1</span>
            r<span class="token operator">-=</span><span class="token number">1</span>
        <span class="token keyword">return</span> s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="557题-反转字符串中的单词-III"><a href="#557题-反转字符串中的单词-III" class="headerlink" title="557题 反转字符串中的单词 III"></a>557题 <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">反转字符串中的单词 III</a></h3><p><img src="557.png" alt="557题"></p>
<h4 id="思路：-73"><a href="#思路：-73" class="headerlink" title="思路："></a>思路：</h4><p>我的思路是：首先，遍历字符串，使用变量L记录一个单词的开始。每当遇到空格，我们就将L到当前字符前一个位置的字符串进行翻转，即翻转了一个单词，并修改L为当前字符下一个位置，即新单词的开头。需要注意的是，最后一个单词由于末尾没有空格，需要遍历完成后单独翻转。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">reverseWords</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">reverse</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">while</span> l<span class="token operator">&lt;</span>r<span class="token punctuation">:</span>
                s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span>
                l<span class="token operator">+=</span><span class="token number">1</span>
                r<span class="token operator">-=</span><span class="token number">1</span>

        <span class="token keyword">if</span> s<span class="token operator">==</span><span class="token string">""</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token string">""</span>
        s<span class="token operator">=</span>list<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
        l<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">" "</span><span class="token punctuation">:</span>
                reverse<span class="token punctuation">(</span>l<span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">)</span>
                l<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span>
        reverse<span class="token punctuation">(</span>l<span class="token punctuation">,</span>i<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="71题-简化路径"><a href="#71题-简化路径" class="headerlink" title="71题 简化路径"></a>71题 <a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">简化路径</a></h3><p><img src="71.png" alt="71题"></p>
<h4 id="思路：-74"><a href="#思路：-74" class="headerlink" title="思路："></a>思路：</h4><p>我们使用一个地址栈来保存当前所在的路径各级目录。将题目给出的原路径按照“/”进行分割，即可得到原始的各目录操作。</p>
<p>接下来对每个目录操作进行处理：</p>
<ul>
<li>如果当前操作为”..”，则将地址栈中的栈顶目录出栈，也就是等于从当前目录返回上级目录。需要注意的是，如果栈为空，那么直接跳过即可。</li>
<li>如果当前操作为”.”，那么什么也不做，保持在当前目录。特别注意，由于切片机制，可能会出现全空的目录操作，对于这种情况，我们也直接continue。</li>
<li>如果当前操作为其他，说明它们必定是下一级目录的名称，直接将其入栈保存即可，相当于执行了cd命令。</li>
</ul>
<p>最后，我们将地址栈中的各级目录使用”/“进行拼接。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">simplifyPath</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> path<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>
        li<span class="token operator">=</span>path<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
        now_path<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> op <span class="token keyword">in</span> li<span class="token punctuation">:</span>
            <span class="token keyword">if</span> op<span class="token operator">==</span><span class="token string">".."</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> now_path <span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    now_path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">elif</span> op <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">continue</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                now_path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>op<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token string">"/"</span><span class="token operator">+</span><span class="token string">"/"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>now_path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度：$O(len(path))$</li>
</ul>
<h2 id="2020-5-1-（5-easy-1-medium）"><a href="#2020-5-1-（5-easy-1-medium）" class="headerlink" title="2020.5.1 （5 easy 1 medium）"></a>2020.5.1 （5 easy 1 medium）</h2><h3 id="225题-用队列实现栈"><a href="#225题-用队列实现栈" class="headerlink" title="225题  用队列实现栈"></a>225题  <a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">用队列实现栈</a></h3><p><img src="225.png" alt="225题"></p>
<h4 id="思路：-75"><a href="#思路：-75" class="headerlink" title="思路："></a>思路：</h4><p>我们知道，队列的特性是：先进先出，它的pop操作在头部，push操作在尾部。而栈的特性是先进后出，它的push和pop操作都在尾部。</p>
<p>为了用队列来模拟栈，我们有如下几种方式：</p>
<ul>
<li><p>使用辅助队列修改入队操作，确保新入队的元素位于队首。这样，我们实现了栈的后进先出特性，相当于模拟了栈。我们可以这么操作：</p>
<ul>
<li>先将新元素入辅助队列</li>
<li>再将主队列中所有的元素入辅助队列</li>
<li>交换辅助队列和主队列（减少判断）</li>
</ul>
<p><img src="225-2.png" alt="225-1"></p>
</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Initialize your data structure here.
        """</span>
        self<span class="token punctuation">.</span>queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>helper <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Push element x onto stack.
        """</span>
        self<span class="token punctuation">.</span>helper<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
        <span class="token keyword">while</span> self<span class="token punctuation">.</span>queue<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>helper<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>helper<span class="token punctuation">,</span> self<span class="token punctuation">.</span>queue <span class="token operator">=</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">,</span> self<span class="token punctuation">.</span>helper

    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Removes the element on top of the stack and returns that element.
        """</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>


    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Get the top element.
        """</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Returns whether the stack is empty.
        """</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>使用辅助队列修改出队操作，将最后一个元素之前的所有元素先入辅助队列保存，再取出最后一个元素。这样，我们也实现了栈的后进先出特性，相当于模拟了栈。我们可以这么操作：</p>
<ul>
<li>先将队列中除了队尾元素的所有元素入辅助队列</li>
<li>队尾元素出队，作为结果</li>
<li>交换辅助队列和主队列（减少判断）</li>
</ul>
<p><img src="225-1.png" alt="225-2"></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Initialize your data structure here.
        """</span>
        self<span class="token punctuation">.</span>queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>helper <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Push element x onto stack.
        """</span>
        self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Removes the element on top of the stack and returns that element.
        """</span>
        <span class="token keyword">while</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>helper<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        res <span class="token operator">=</span> self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>queue<span class="token punctuation">,</span> self<span class="token punctuation">.</span>helper <span class="token operator">=</span> self<span class="token punctuation">.</span>helper<span class="token punctuation">,</span> self<span class="token punctuation">.</span>queue
        <span class="token keyword">return</span> res

    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Get the top element.
        """</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#这里要修改一下</span>

    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Returns whether the stack is empty.
        """</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<ul>
<li><p>为了不使用额外空间，我们可以只用主队列进行原地修改。具体的思路是这样的：</p>
<ul>
<li>入队操作时，先记录下当前的队列长度L，将新元素入队。</li>
<li>接着将队首元素出队，再入队。重复L次，相当于不使用额外空间的第一种方法。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Initialize your data structure here.
        """</span>
        self<span class="token punctuation">.</span>queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Push element x onto stack.
        """</span>
        L <span class="token operator">=</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
        <span class="token keyword">while</span> L<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            L<span class="token operator">-=</span><span class="token number">1</span>

    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Removes the element on top of the stack and returns that element.
        """</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Get the top element.
        """</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Returns whether the stack is empty.
        """</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="面试题-10-01-合并排序的数组"><a href="#面试题-10-01-合并排序的数组" class="headerlink" title="面试题 10.01. 合并排序的数组"></a><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/" target="_blank" rel="noopener">面试题 10.01. 合并排序的数组</a></h3><p><img src="10.1.png" alt="10.1"></p>
<h4 id="思路：-76"><a href="#思路：-76" class="headerlink" title="思路："></a>思路：</h4><p>这道题因为是合并两个排序链表，我们很容易想到mergesort的mergetwolist部分。但是，这道题有一个问题就是如果使用双指针正向合并的话，会导致一些元素尚且没有被访问到即被覆盖，所以我们要进行逆向双指针法从后向前，从大到小排序。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> B<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Do not return anything, modify A in-place instead.
        """</span>
        r <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token comment" spellcheck="true">#r指针用于存放逆向放入元素的位置</span>
        m <span class="token operator">-=</span> <span class="token number">1</span>
        n <span class="token operator">-=</span> <span class="token number">1</span> 
        <span class="token keyword">while</span> m<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> n<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> A<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;</span> B<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">:</span>
                A<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> B<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
                n <span class="token operator">-=</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                A<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>m<span class="token punctuation">]</span>
                m <span class="token operator">-=</span> <span class="token number">1</span>
            r <span class="token operator">-=</span> <span class="token number">1</span>
        <span class="token keyword">if</span> m<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果是B数组放完了，即n&lt;0，我们不需要再调整A数组了，所以不必判断</span>
            <span class="token keyword">while</span> n<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">:</span>
                A<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> B<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
                r <span class="token operator">-=</span> <span class="token number">1</span>
                n <span class="token operator">-=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="994题-腐烂的橘子"><a href="#994题-腐烂的橘子" class="headerlink" title="994题 腐烂的橘子"></a>994题 <a href="https://leetcode-cn.com/problems/rotting-oranges/" target="_blank" rel="noopener">腐烂的橘子</a></h3><p><img src="994.png" alt="994"></p>
<h4 id="思路：-77"><a href="#思路：-77" class="headerlink" title="思路："></a>思路：</h4><p>有点像元胞自动机中的生命游戏。我们使用类似于BFS的思路进行解题。</p>
<p>我们使用两个辅助队列进行BFS。每一时刻的bad队列中存放的是当前所有腐烂的橘子位置，fresh队列中存放的是当前所有新鲜橘子的位置。特别地，为了防止重复搜索，我们将隔了一个时刻的腐烂橘子丢弃。</p>
<p>我们每次从bad队列中出队一个腐烂的橘子，用它的四个正方向坐标从fresh队列中取出新鲜橘子放入bad队列，相当于把它们“污染”了。然后将这个腐烂的橘子丢弃。如果最后没有新鲜的橘子了，即fresh队列为空，我们就可以返回当前的时刻数。如果fresh队列不为空，但bad队列已经为空，说明此时必然不可能全部腐烂，返回-1.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">orangesRotting</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        fresh <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        bad <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        offset <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">:</span>
                    bad<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token keyword">elif</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
                    fresh<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
        time <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span> fresh<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            L <span class="token operator">=</span> len<span class="token punctuation">(</span>bad<span class="token punctuation">)</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">:</span>
                pos <span class="token operator">=</span> bad<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">for</span> off <span class="token keyword">in</span> offset<span class="token punctuation">:</span>
                    row <span class="token operator">=</span> pos<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> off<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
                    col <span class="token operator">=</span> pos<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> off<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
                    <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>row<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>col<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">[</span>row<span class="token punctuation">,</span>col<span class="token punctuation">]</span> <span class="token keyword">in</span> fresh<span class="token punctuation">:</span>
                        fresh<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token punctuation">[</span>row<span class="token punctuation">,</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>
                        bad<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>row<span class="token punctuation">,</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>
            time <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">if</span> fresh<span class="token operator">!=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">and</span> bad<span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">return</span> time<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="1103-分糖果-II"><a href="#1103-分糖果-II" class="headerlink" title="1103 分糖果 II"></a>1103 <a href="https://leetcode-cn.com/problems/distribute-candies-to-people/" target="_blank" rel="noopener">分糖果 II</a></h3><p><img src="1103.png" alt="1103"></p>
<h4 id="思路：-78"><a href="#思路：-78" class="headerlink" title="思路："></a>思路：</h4><p>使用取余运算来模拟循环访问，暴力分糖，直到糖分完。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">distributeCandies</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> candies<span class="token punctuation">:</span> int<span class="token punctuation">,</span> num_people<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>num_people<span class="token punctuation">)</span><span class="token punctuation">]</span>
        s <span class="token operator">=</span> <span class="token number">1</span>
        i <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span> candies<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>
            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> s
            candies <span class="token operator">-=</span> s
            <span class="token keyword">if</span> candies <span class="token operator">></span> s<span class="token punctuation">:</span>
                s <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#不足以再分一次，就将剩下的糖果全部分光</span>
                s <span class="token operator">=</span> candies
            i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> num_people
        <span class="token keyword">return</span> ans<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以使用数学方法，等差数列进行推导。</p>
<h3 id="409题-最长回文串"><a href="#409题-最长回文串" class="headerlink" title="409题 最长回文串"></a>409题 <a href="https://leetcode-cn.com/problems/longest-palindrome/" target="_blank" rel="noopener">最长回文串</a></h3><p><img src="409.png" alt="409"></p>
<h4 id="思路：-79"><a href="#思路：-79" class="headerlink" title="思路："></a>思路：</h4><p>贪心思想。统计一下小于每个字符出现次数的最大偶数之和（回文串必须是左右对称的），如果由字符出现次数为奇数，那么还需再加1即可（回文串长度为奇数时，中心的字符可以只出现一次）。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        dic <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>
        <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>
            dic<span class="token punctuation">[</span>ch<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
        res <span class="token operator">=</span> <span class="token number">0</span>
        flag <span class="token operator">=</span> <span class="token boolean">True</span>
        <span class="token keyword">for</span> key <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            res <span class="token operator">+=</span> dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">//</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">2</span>
            <span class="token keyword">if</span> flag <span class="token operator">and</span> dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
                res <span class="token operator">+=</span> <span class="token number">1</span>
                flag <span class="token operator">=</span> <span class="token boolean">False</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="876题-链表的中间结点"><a href="#876题-链表的中间结点" class="headerlink" title="876题 链表的中间结点"></a>876题 <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">链表的中间结点</a></h3><p><img src="876.png" alt="876"></p>
<h4 id="思路：-80"><a href="#思路：-80" class="headerlink" title="思路："></a>思路：</h4><p>最简单的方法是先遍历一次得到长度，再遍历二分之长度次得到中间节点。但那肯定不是我们想要的。</p>
<p>好的方法是使用快慢指针法，快指针的速度是慢指针的两倍，这样当快指针走完链表时，慢指针一定指向链表的中间节点。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span>
<span class="token comment" spellcheck="true"># class ListNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">middleNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>
        slow<span class="token punctuation">,</span> fast <span class="token operator">=</span> head<span class="token punctuation">,</span> head
        <span class="token keyword">while</span> fast<span class="token operator">!=</span>None <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>None<span class="token punctuation">:</span>
            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next
            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
        <span class="token keyword">return</span> slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="1013题-将数组分成和相等的三个部分"><a href="#1013题-将数组分成和相等的三个部分" class="headerlink" title="1013题 将数组分成和相等的三个部分"></a>1013题 <a href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/" target="_blank" rel="noopener">将数组分成和相等的三个部分</a></h3><p><img src="1013.png" alt="1013"></p>
<h4 id="思路：-81"><a href="#思路：-81" class="headerlink" title="思路："></a>思路：</h4><p>首先，我们求解数组总和，如果它不是3的倍数，直接返回False。</p>
<p>接着，我们以当前数组总和的三分之一作为目标，分别从左右两侧寻找 i 和 j ，使其能在头尾各构成区间达到数组总和的三分之一，如果 i 小于 j 且和 j 之间存在大于1的空间，则数组必然能划分为三个和相等的部分。</p>
<p>我们寻找i 和 j 时使用贪心的思想，一旦找到立马跳出循环。因为这样可以使中间的区间[i+1：j]尽可能地大。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">canThreePartsEqualSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        s <span class="token operator">=</span> sum<span class="token punctuation">(</span>A<span class="token punctuation">)</span>
        <span class="token keyword">if</span> s<span class="token operator">%</span><span class="token number">3</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        tar <span class="token operator">=</span> s<span class="token operator">//</span><span class="token number">3</span>
        now <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            now <span class="token operator">+=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            <span class="token keyword">if</span> now <span class="token operator">==</span> tar<span class="token punctuation">:</span>
                <span class="token keyword">break</span>
        now <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            now <span class="token operator">+=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token keyword">if</span> now <span class="token operator">==</span> tar<span class="token punctuation">:</span>
                <span class="token keyword">break</span>
        <span class="token keyword">return</span> i<span class="token operator">&lt;</span>j<span class="token number">-1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="面试题-17-16-按摩师"><a href="#面试题-17-16-按摩师" class="headerlink" title="面试题 17.16. 按摩师"></a><a href="https://leetcode-cn.com/problems/the-masseuse-lcci/" target="_blank" rel="noopener">面试题 17.16. 按摩师</a></h3><p><img src="17.16.png" alt="17.16"></p>
<h4 id="思路：-82"><a href="#思路：-82" class="headerlink" title="思路："></a>思路：</h4><p>很明显，这道题和买卖股票问题还有打家劫舍问题类似，都是时刻+状态的二维动态规划问题。dp[i] [0] 为 i 时刻接受预约的总最大预约时长，dp[i] [1] 为 i 时刻拒绝预约的总最大预约时长。转移方程为：</p>
<ul>
<li>dp[i] [0] = dp[i-1] [1] + nums[i] ，因为无法连续接受预约，所以上一时刻必须是拒绝预约的状态</li>
<li>dp[i] [1] = max（dp[i-1] [0]，dp[i-1] [1]），拒绝预约，此时刻将不会增加时长，我们在上一时刻的两个状态中选取最大的时长。</li>
</ul>
<p>特别地，由于只依赖有限个状态，我们可以使用滚动数组进行DP状态压缩。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">massage</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        accept <span class="token operator">=</span> <span class="token number">0</span>
        refuse <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>
            refuse<span class="token punctuation">,</span> accept <span class="token operator">=</span> max<span class="token punctuation">(</span>accept<span class="token punctuation">,</span>refuse<span class="token punctuation">)</span><span class="token punctuation">,</span> refuse <span class="token operator">+</span> num
        <span class="token keyword">return</span> max<span class="token punctuation">(</span>accept<span class="token punctuation">,</span>refuse<span class="token punctuation">)</span>

<span class="token triple-quoted-string string">"""
time    0   1   2   3
accept  1   2   4   3
refuse  0   1   2   4
"""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-5-2-（2-easy-3-medium）"><a href="#2020-5-2-（2-easy-3-medium）" class="headerlink" title="2020.5.2 （2 easy 3 medium）"></a>2020.5.2 （2 easy 3 medium）</h2><h3 id="199题-二叉树的右视图"><a href="#199题-二叉树的右视图" class="headerlink" title="199题 二叉树的右视图"></a>199题 <a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">二叉树的右视图</a></h3><p><img src="199.png" alt="199"></p>
<h4 id="思路：-83"><a href="#思路：-83" class="headerlink" title="思路："></a>思路：</h4><p>这道题，本质上我们要求的只是每一层节点最右边的值，那么我们很容易就会想到BFS，因为它是按层来遍历的。</p>
<p>我们只需要每次将该层最右的节点值放入结果列表即可。</p>
<pre class="line-numbers language-PYTHON"><code class="language-PYTHON"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        res = []
        if root!=None:
            queue = [root]
            while queue!=[]:
                L = len(queue)
                for i in range(L):
                    node = queue.pop(0)
                    if node.left!=None:
                        queue.append(node.left)
                    if node.right!=None:
                        queue.append(node.right)
                    if i==L-1:
                        res.append(node.val)
        return res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同样，一般能用BFS解决的题目都可以用DFS解决。我们知道，先根遍历，每层的最左侧节点必然最先被访问。那么我们只需要对先根遍历稍作修改即可，改为“根-右-左”，即可访问每层最右节点。</p>
<p>我们在DFS的时候记录下当前的层数，如果当前层数大于res数组长度，说明该层还没有被访问过，记录下首个访问的节点即可。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> root<span class="token operator">!=</span>None<span class="token punctuation">:</span>
                <span class="token keyword">if</span> depth<span class="token operator">></span>len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="1106题-拼写单词"><a href="#1106题-拼写单词" class="headerlink" title="1106题 拼写单词"></a>1106题 <a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/" target="_blank" rel="noopener">拼写单词</a></h3><p><img src="1106.png" alt="1106"></p>
<h4 id="思路：-84"><a href="#思路：-84" class="headerlink" title="思路："></a>思路：</h4><p>这题较为简单的做法是使用哈希表计数来做，看单词的字符和数目是否能在chars中得到满足。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">countCharacters</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> words<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">,</span> chars<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>
            dic <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>
            <span class="token keyword">for</span> ch <span class="token keyword">in</span> word<span class="token punctuation">:</span>
                dic<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>
            <span class="token keyword">return</span> dic
        dic <span class="token operator">=</span> count<span class="token punctuation">(</span>chars<span class="token punctuation">)</span>
        res <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> word <span class="token keyword">in</span> words<span class="token punctuation">:</span>
            word_dic <span class="token operator">=</span> count<span class="token punctuation">(</span>word<span class="token punctuation">)</span>
            flag <span class="token operator">=</span> <span class="token boolean">True</span>
            <span class="token keyword">for</span> key <span class="token keyword">in</span> word_dic<span class="token punctuation">:</span>
                <span class="token keyword">if</span> key <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">or</span> dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">&lt;</span>word_dic<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    flag <span class="token operator">=</span> <span class="token boolean">False</span>
                    <span class="token keyword">break</span>
            <span class="token keyword">if</span> flag<span class="token punctuation">:</span>
                res <span class="token operator">+=</span> len<span class="token punctuation">(</span>word<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个简洁的写法是这样的：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">countCharacters</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> words<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">,</span> chars<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        ans <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> w <span class="token keyword">in</span> words<span class="token punctuation">:</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> w<span class="token punctuation">:</span>
                <span class="token keyword">if</span> w<span class="token punctuation">.</span>count<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">></span> chars<span class="token punctuation">.</span>count<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">break</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                ans<span class="token operator">+=</span>len<span class="token punctuation">(</span>w<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里使用到了Python语言的语法机制： 当 for 循环被 break 中断后，其后的 else 语句就不执行了 ； for 循环正常执行结束后，else 语句里面的内容也会正常执行。 </p>
<p>但是不推荐这样写，容易混乱，别人也不方便看。</p>
<h3 id="151题-翻转字符串里的单词"><a href="#151题-翻转字符串里的单词" class="headerlink" title="151题 翻转字符串里的单词"></a>151题 <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">翻转字符串里的单词</a></h3><p><img src="151.png" alt="151"></p>
<h4 id="思路：-85"><a href="#思路：-85" class="headerlink" title="思路："></a>思路：</h4><p>python比较简单，直接split后翻转拼接即可。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">reverseWords</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>s<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这个调函数的时间复杂度在底层也是$O(n)$的。</p>
<p>如果想自己从底层实现的话，可以考虑一下先根据下标原地翻转字符串，然后根据空格切分出每个单词，并将其挨个翻转即可。时间复杂度应该也是类似的，我就不实现了。</p>
<h3 id="892-三维形体的表面积"><a href="#892-三维形体的表面积" class="headerlink" title="892  三维形体的表面积"></a>892 <a href="https://leetcode-cn.com/problems/surface-area-of-3d-shapes/" target="_blank" rel="noopener"> 三维形体的表面积</a></h3><p><img src="892.png" alt="892"></p>
<h4 id="思路：-86"><a href="#思路：-86" class="headerlink" title="思路："></a>思路：</h4><p>遍历一下每个格子，统计该格子的立方体表面积，然后看四个正方向上是否有立方体，如果有那么必然会导致当前立方体的该方向上的侧面积被覆盖，被覆盖的大小和二者高度的最小值有关。</p>
<ul>
<li>时间复杂度：$O(n^2)$</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">surfaceArea</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        v <span class="token operator">=</span> <span class="token number">0</span>
        offsets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>
                    v <span class="token operator">+=</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">*</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                    <span class="token keyword">for</span> offset <span class="token keyword">in</span> offsets<span class="token punctuation">:</span>
                        new_i <span class="token operator">=</span> i <span class="token operator">+</span> offset<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
                        new_j <span class="token operator">=</span> j <span class="token operator">+</span> offset<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
                        <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>new_i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>new_j<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> grid<span class="token punctuation">[</span>new_i<span class="token punctuation">]</span><span class="token punctuation">[</span>new_j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>
                            v <span class="token operator">-=</span> min<span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> grid<span class="token punctuation">[</span>new_i<span class="token punctuation">]</span><span class="token punctuation">[</span>new_j<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695 岛屿的最大面积"></a>695 <a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">岛屿的最大面积</a></h3><p><img src="695.png" alt="695"></p>
<h4 id="思路：-87"><a href="#思路：-87" class="headerlink" title="思路："></a>思路：</h4><p>和岛屿数目类似，这种题目主要就两类做法：（1）搜索：DFS或者BFS（2）并查集</p>
<p>我写了一下DFS的解法，岛屿题的DFS都不需要回溯，因为每个格子最多只需要访问一遍就好了。</p>
<ul>
<li>时间复杂度：$O(n^2)$</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxAreaOfIsland</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        offsets<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>
                grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
                s <span class="token operator">+=</span> <span class="token number">1</span>
                <span class="token keyword">for</span> offset <span class="token keyword">in</span> offsets<span class="token punctuation">:</span>
                    new_row <span class="token operator">=</span> row <span class="token operator">+</span> offset<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
                    new_col <span class="token operator">=</span> col <span class="token operator">+</span> offset<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
                    <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>new_row<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>new_col<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                        s <span class="token operator">=</span> dfs<span class="token punctuation">(</span>new_row<span class="token punctuation">,</span>new_col<span class="token punctuation">,</span>s<span class="token punctuation">)</span>
            <span class="token keyword">return</span> s

        maxS <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                maxS <span class="token operator">=</span> max<span class="token punctuation">(</span>dfs<span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>maxS<span class="token punctuation">)</span>
        <span class="token keyword">return</span> maxS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-5-3-（4easy-1medium）"><a href="#2020-5-3-（4easy-1medium）" class="headerlink" title="2020.5.3 （4easy 1medium）"></a>2020.5.3 （4easy 1medium）</h2><h3 id="100题-相同的树"><a href="#100题-相同的树" class="headerlink" title="100题 相同的树"></a>100题 <a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">相同的树</a></h3><p><img src="100.png" alt="100"></p>
<h4 id="思路-46"><a href="#思路-46" class="headerlink" title="思路:"></a>思路:</h4><p>先序遍历判断即可，先判断当前根节点是否相等或同时为空，然后递归判断左子树和右子树是否相等。</p>
<ul>
<li>时间复杂度：$O(n)$，n为节点数，每个节点都访问一次</li>
<li>时间复杂度:最优情况（完全平衡二叉树）时为 $O(log(n))$，最坏情况下（完全不平衡二叉树）时为 $O(n)$，用于维护递归栈。</li>
</ul>
<p>也可以使用层次遍历，非递归地判断，本质上一样的。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span>
<span class="token comment" spellcheck="true"># class TreeNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.left = None</span>
<span class="token comment" spellcheck="true">#         self.right = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> q<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        <span class="token keyword">if</span> p<span class="token operator">==</span>None <span class="token operator">and</span> q<span class="token operator">==</span>None<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">elif</span> p<span class="token operator">!=</span>None <span class="token operator">and</span> q<span class="token operator">!=</span>None <span class="token operator">and</span> p<span class="token punctuation">.</span>val<span class="token operator">==</span>q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>isSameTree<span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">,</span>q<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>isSameTree<span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">,</span>q<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="202题-快乐数"><a href="#202题-快乐数" class="headerlink" title="202题 快乐数"></a>202题 <a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">快乐数</a></h3><p><img src="202.png" alt="202"></p>
<h4 id="思路：-88"><a href="#思路：-88" class="headerlink" title="思路："></a>思路：</h4><p>模拟即可，同时用一个哈希集合存放已经生成过的数，如果产生了重复的数字，那么必然是进入了死循环。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isHappy</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        hs <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> n <span class="token keyword">in</span> hs<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
            <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            hs<span class="token punctuation">.</span>add<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
            next_n <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token keyword">while</span> n<span class="token punctuation">:</span>
                next_n <span class="token operator">+=</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span>
                n <span class="token operator">=</span> n <span class="token operator">//</span> <span class="token number">10</span>
            <span class="token keyword">return</span> test<span class="token punctuation">(</span>next_n<span class="token punctuation">)</span>
        <span class="token keyword">return</span> test<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="836题-矩形重叠"><a href="#836题-矩形重叠" class="headerlink" title="836题 矩形重叠"></a>836题 <a href="https://leetcode-cn.com/problems/rectangle-overlap/" target="_blank" rel="noopener">矩形重叠</a></h3><p><img src="836.png" alt="836"></p>
<h4 id="思路：-89"><a href="#思路：-89" class="headerlink" title="思路："></a>思路：</h4><p>这题我们需要用逆向思维求解，如果直接讨论矩形重叠的情况可能会比较复杂：需要讨论一个矩形的四个顶点分别在另一个矩形内部，或者包含这个矩形的情况。</p>
<p>如果我们直接讨论矩形不重叠的情况，将变得容易许多：</p>
<ul>
<li>第一个矩形位于第二个矩形左侧且不相交，需要满足第一个矩形右边的横坐标小于等于第二个矩形左边的横坐标。</li>
<li>第一个矩形位于第二个矩形右侧且不相交，需要满足第一个矩形左边的横坐标大于等于第二个矩形右边的横坐标。</li>
<li>第一个矩形位于第二个矩形上方且不相交，需要满足第一个矩形下边的纵坐标大于等于第二个矩形下边的纵坐标。</li>
<li>第一个矩形位于第二个矩形下方且不相交，需要满足第一个矩形上边的纵坐标小于等于第二个矩形下边的纵坐标。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isRectangleOverlap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> rec1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> rec2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token operator">not</span><span class="token punctuation">(</span>rec1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>rec2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">or</span> rec1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">>=</span>rec2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">or</span> rec1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">>=</span>rec2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">or</span> rec1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>rec2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="289题-生命游戏"><a href="#289题-生命游戏" class="headerlink" title="289题 生命游戏"></a>289题 <a href="https://leetcode-cn.com/problems/game-of-life/" target="_blank" rel="noopener">生命游戏</a></h3><p><img src="289.png" alt="289"></p>
<h4 id="思路：-90"><a href="#思路：-90" class="headerlink" title="思路："></a>思路：</h4><p>这题没什么复杂的，需要讨论清楚情况。</p>
<p>特别地，我们可以使用额外的状态来进行标记，从而两次遍历实现原地修改数组。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">gameOfLife</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        Do not return anything, modify board in-place instead.
        -1:当前时刻存活，下一时刻死亡
        -2：当前时刻死亡，下一时刻存活
        """</span>
        offsets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

        <span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>
            res <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token keyword">for</span> offset <span class="token keyword">in</span> offsets<span class="token punctuation">:</span>
                new_i<span class="token punctuation">,</span> new_j <span class="token operator">=</span> i <span class="token operator">+</span> offset<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> j <span class="token operator">+</span> offset<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
                <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>new_i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>new_j<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> board<span class="token punctuation">[</span>new_i<span class="token punctuation">]</span><span class="token punctuation">[</span>new_j<span class="token punctuation">]</span> <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    res<span class="token operator">+=</span><span class="token number">1</span>
            <span class="token keyword">return</span> res

        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                res <span class="token operator">=</span> count<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span>
                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">and</span> res<span class="token operator">==</span><span class="token number">3</span><span class="token punctuation">:</span>
                    board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span>
                <span class="token keyword">elif</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> res<span class="token operator">&lt;</span><span class="token number">2</span> <span class="token operator">or</span> res<span class="token operator">></span><span class="token number">3</span><span class="token punctuation">:</span>
                        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
                    board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
                <span class="token keyword">elif</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">:</span>
                    board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="1071题-字符串的最大公因子"><a href="#1071题-字符串的最大公因子" class="headerlink" title="1071题 字符串的最大公因子"></a>1071题 <a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/" target="_blank" rel="noopener">字符串的最大公因子</a></h3><p><img src="1071.png" alt="1071"></p>
<h4 id="思路：-91"><a href="#思路：-91" class="headerlink" title="思路："></a>思路：</h4><p>简单的做法是直接求出二者长度的所有公因数，然后从公因数从大到小截取子串暴力判断。</p>
<p>实际上根据数学推导，我们可以得知两个性质：</p>
<ul>
<li><strong>如果存在一个符合要求的字符串 <code>X</code>，那么也一定存在一个符合要求的字符串 <code>X&#39;</code>，它的长度为 <code>str1</code>和 <code>str2</code> 长度的最大公约数</strong>。 </li>
<li><strong>如果 <code>str1</code> 和 <code>str2</code> 拼接后等于 <code>str2</code>和 <code>str1</code> 拼接起来的字符串（注意拼接顺序不同），那么一定存在符合条件的字符串 <code>X</code></strong>。 </li>
</ul>
<p>具体推导见 <a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/solution/zi-fu-chuan-de-zui-da-gong-yin-zi-by-leetcode-solu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/solution/zi-fu-chuan-de-zui-da-gong-yin-zi-by-leetcode-solu/</a> </p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> math
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">gcdOfStrings</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> str1<span class="token punctuation">:</span> str<span class="token punctuation">,</span> str2<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>
        <span class="token keyword">if</span> str1<span class="token operator">&lt;</span>str2<span class="token punctuation">:</span>
            str1<span class="token punctuation">,</span> str2 <span class="token operator">=</span> str2<span class="token punctuation">,</span> str1
        <span class="token keyword">if</span> str1 <span class="token operator">+</span> str2<span class="token operator">==</span>str2 <span class="token operator">+</span> str1<span class="token punctuation">:</span>
            <span class="token keyword">return</span> str2<span class="token punctuation">[</span><span class="token punctuation">:</span>math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>len<span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token string">""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-5-4-（5-easy-1-medium）"><a href="#2020-5-4-（5-easy-1-medium）" class="headerlink" title="2020.5.4 （5 easy 1 medium）"></a>2020.5.4 （5 easy 1 medium）</h2><h3 id="445题-两数相加-II"><a href="#445题-两数相加-II" class="headerlink" title="445题  两数相加 II"></a>445题 <a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener"> 两数相加 II</a></h3><p><img src="445.png" alt="445"></p>
<h4 id="思路：-92"><a href="#思路：-92" class="headerlink" title="思路："></a>思路：</h4><p>这道题如果可以先翻转链表，那么将变成简单的大数相加问题，只不过以链表形式实现。</p>
<p>但是题目的进阶要求我们不对链表进行翻转。为了减少时间复杂度，我们可以使用栈来实现倒序遍历（实际上，如果不使用辅助栈，我们也可以通过多次遍历对齐数位再计算，但会比较费时间）</p>
<p>我们先将数字存入栈中，然后按照常规大数加法进行求解。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span>
<span class="token comment" spellcheck="true"># class ListNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> l2<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">linkedlist2stack</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">:</span>
            stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            p <span class="token operator">=</span> head
            <span class="token keyword">while</span> p<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next
            <span class="token keyword">return</span> stack

        stack1<span class="token punctuation">,</span> stack2 <span class="token operator">=</span> linkedlist2stack<span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">,</span> linkedlist2stack<span class="token punctuation">(</span>l2<span class="token punctuation">)</span>
        res <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#dummy head</span>
        p <span class="token operator">=</span> res
        c <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span> stack1 <span class="token operator">or</span> stack2 <span class="token operator">or</span> c<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#当两个数字的所有数位没有被访问完，或者进位不为0时，循环计算当前最高位</span>
            a <span class="token operator">=</span> stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> stack1 <span class="token keyword">else</span> <span class="token number">0</span>
            b <span class="token operator">=</span> stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> stack2 <span class="token keyword">else</span> <span class="token number">0</span>
            now <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c
            c <span class="token operator">=</span> now <span class="token operator">//</span> <span class="token number">10</span>
            now <span class="token operator">%=</span> <span class="token number">10</span>
            q <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>now<span class="token punctuation">)</span>
            q<span class="token punctuation">.</span>next <span class="token operator">=</span> res<span class="token punctuation">.</span>next
            res<span class="token punctuation">.</span>next <span class="token operator">=</span> q
        <span class="token keyword">return</span> res<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="999题-可以被一步捕获的棋子数"><a href="#999题-可以被一步捕获的棋子数" class="headerlink" title="999题 可以被一步捕获的棋子数"></a>999题 <a href="https://leetcode-cn.com/problems/available-captures-for-rook/" target="_blank" rel="noopener">可以被一步捕获的棋子数</a></h3><p><img src="999.png" alt="999"></p>
<h4 id="思路：-93"><a href="#思路：-93" class="headerlink" title="思路："></a>思路：</h4><p>我们可以先找到白车，然后在四个正方向上做递归搜索，统计可以捕获的黑卒个数。</p>
<p>需要注意，像这种多方向搜索问题，一般可以使用方向数组简化代码。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">numRookCaptures</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        offsets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>offset<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>j<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'B'</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'p'</span><span class="token punctuation">:</span>
                    count<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    count <span class="token operator">=</span> search<span class="token punctuation">(</span>i<span class="token operator">+</span>offset<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>j<span class="token operator">+</span>offset<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>offset<span class="token punctuation">,</span>count<span class="token punctuation">)</span>
            <span class="token keyword">return</span> count

        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'R'</span><span class="token punctuation">:</span>
                    res <span class="token operator">=</span> <span class="token number">0</span>
                    <span class="token keyword">for</span> offset <span class="token keyword">in</span> offsets<span class="token punctuation">:</span>
                        res <span class="token operator">+=</span> search<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>offset<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> res
        <span class="token keyword">return</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="125题-验证回文串"><a href="#125题-验证回文串" class="headerlink" title="125题 验证回文串"></a>125题 <a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">验证回文串</a></h3><p><img src="125.png" alt="125"></p>
<h4 id="思路：-94"><a href="#思路：-94" class="headerlink" title="思路："></a>思路：</h4><p>先遍历原串，使用ascii码挑选出所有数字和字母，并将字母转小写。</p>
<p>判断一下新的字符串是否等于翻转后的结果即可知道它是否为回文串了。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        new_S <span class="token operator">=</span> <span class="token string">""</span>
        <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> ord<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span>ord<span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token operator">&lt;=</span>ord<span class="token punctuation">(</span><span class="token string">'z'</span><span class="token punctuation">)</span> <span class="token operator">or</span> ord<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span>ord<span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token operator">&lt;=</span>ord<span class="token punctuation">(</span><span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                new_S <span class="token operator">+=</span> ch
        <span class="token keyword">return</span> new_S<span class="token operator">==</span>new_S<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="69题-x-的平方根"><a href="#69题-x-的平方根" class="headerlink" title="69题  x 的平方根"></a>69题 <a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener"> x 的平方根</a></h3><p><img src="69.png" alt="69"></p>
<h4 id="思路：-95"><a href="#思路：-95" class="headerlink" title="思路："></a>思路：</h4><p>这道题其实蛮重要的，如果直接暴力迭代的话很简单，但优化的思想非常值得学习，特别是牛顿迭代法解决凸优化的数值解问题，涉及到了一些机器学习的知识。</p>
<p>首先，我们可以采用二分查找法优化暴力解决的时间复杂度。因为一个数的平方根必然不会大于它的1/2，我们只需要从0到它的1/2进行二分搜索即可。</p>
<p>如果找不到精确值，这里我们需要返回的是right，因为当区间最后缩到一个数时，这个数的平方如果大于目标数，结果四舍五入是当前数，left+1，right不变，那么就返回right。这个数的平方如果小于目标数，结果四舍五入是当前数减1，left不变，right-1，还是需要返回right。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
            left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> x<span class="token operator">//</span><span class="token number">2</span>
            <span class="token keyword">while</span> left<span class="token operator">&lt;=</span>right<span class="token punctuation">:</span>
                mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
                <span class="token keyword">if</span> mid <span class="token operator">*</span> mid<span class="token operator">==</span>x<span class="token punctuation">:</span>
                    <span class="token keyword">return</span> mid
                <span class="token keyword">elif</span> mid <span class="token operator">*</span> mid<span class="token operator">&lt;</span>x<span class="token punctuation">:</span>
                    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>
            <span class="token keyword">return</span> right

        <span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> x
        <span class="token keyword">return</span> binarySearch<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接着，我们可以尝试牛顿迭代法，和梯度下降类似，它也是通过不断迭代来逼近最小损失点。</p>
<p>我们需要先定义损失，本题中为预测值x的平方与a的差值，很明显，这个差值越小，x越接近a的平方根。</p>
<p><img src="69-1.png" alt="牛顿迭代法的推导"></p>
<p>上图为牛顿迭代法的推导。当f（x）小于某个阈值时，我们可以退出迭代。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        x0 <span class="token operator">=</span> <span class="token number">1</span>
        <span class="token keyword">while</span> abs<span class="token punctuation">(</span>x0<span class="token operator">*</span>x0<span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">:</span>
            x0 <span class="token operator">=</span> <span class="token punctuation">(</span>x0 <span class="token operator">+</span> x <span class="token operator">/</span> x0<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>
        <span class="token keyword">return</span> int<span class="token punctuation">(</span>x0<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="914题-卡牌分组"><a href="#914题-卡牌分组" class="headerlink" title="914题 卡牌分组"></a>914题 <a href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/" target="_blank" rel="noopener">卡牌分组</a></h3><p><img src="914.png" alt="914"></p>
<h4 id="思路：-96"><a href="#思路：-96" class="headerlink" title="思路："></a>思路：</h4><p>我们先使用哈希表，一次遍历求出每种数字的牌数。</p>
<ul>
<li>如果只存在一种数字，那么看该数字的牌数是否大于1.</li>
<li>如果存在多种数字，求它们牌数的最大公因数，看是否大于1.（求解公因子可以使用python的math.gcd函数，也可以使用辗转相减法等方法）</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict
<span class="token keyword">import</span> math
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">hasGroupsSizeX</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> deck<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>
        dic <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> deck<span class="token punctuation">:</span>
            dic<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
        li <span class="token operator">=</span> list<span class="token punctuation">(</span>dic<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> len<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> li<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">1</span>
        gcd <span class="token operator">=</span> math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>li<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> li<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            gcd <span class="token operator">=</span> math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>gcd<span class="token punctuation">,</span>i<span class="token punctuation">)</span>
        <span class="token keyword">return</span> gcd<span class="token operator">></span><span class="token number">1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="118题-杨辉三角"><a href="#118题-杨辉三角" class="headerlink" title="118题 杨辉三角"></a>118题 <a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">杨辉三角</a></h3><p><img src="118.png" alt="118"></p>
<h4 id="思路：-97"><a href="#思路：-97" class="headerlink" title="思路："></a>思路：</h4><p>模拟一下即可，可以看作是一种动态规划。最外层的两个数字始终是1。当前层除了左右两侧的两个1以外，每一个数字都是上层的左上方和右上方的数的和。 </p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">generate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> numRows<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> numRows<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> numRows<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> numRows<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> numRows<span class="token operator">></span><span class="token number">2</span><span class="token punctuation">:</span>
            res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>numRows<span class="token punctuation">)</span><span class="token punctuation">:</span>
                lastRow <span class="token operator">=</span> res<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
                nowRow <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
                <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>lastRow<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    nowRow<span class="token punctuation">.</span>append<span class="token punctuation">(</span>lastRow<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>lastRow<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nowRow<span class="token operator">+</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2020-5-5-（3-medium，1-easy）"><a href="#2020-5-5-（3-medium，1-easy）" class="headerlink" title="2020.5.5 （3 medium，1 easy）"></a>2020.5.5 （3 medium，1 easy）</h2><h3 id="83题-删除排序链表中的重复元素"><a href="#83题-删除排序链表中的重复元素" class="headerlink" title="83题 删除排序链表中的重复元素"></a>83题 <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表中的重复元素</a></h3><p><img src="83.png" alt="83"></p>
<h4 id="思路：-98"><a href="#思路：-98" class="headerlink" title="思路："></a>思路：</h4><p>因为链表是有序的，我们只要比较相邻的两个节点，看它们值是否相等，相等则删掉后一个节点即可。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span>
<span class="token comment" spellcheck="true"># class ListNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>
        p <span class="token operator">=</span> head
        <span class="token keyword">while</span> p <span class="token operator">and</span> p<span class="token punctuation">.</span>next<span class="token punctuation">:</span>
            <span class="token keyword">if</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> p<span class="token punctuation">.</span>val<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#需要注意的是：这里删掉后一个节点之后，新的下一个节点也可能与当前节点重复，所以不能冒然移动指针，还要继续判断</span>
                p<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next
        <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="945题-使数组唯一的最小增量"><a href="#945题-使数组唯一的最小增量" class="headerlink" title="945题  使数组唯一的最小增量"></a>945题 <a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/" target="_blank" rel="noopener"> 使数组唯一的最小增量</a></h3><p><img src="945.png" alt="945"></p>
<h4 id="思路：-99"><a href="#思路：-99" class="headerlink" title="思路："></a>思路：</h4><p>我在一开始尝试了比较暴力的做法，很明显超时了。我们对每一个重复出现的数字，尝试将其不断加1直到其不在数组中，统计总加1的次数。时间复杂度应该是：$O(n^2)$</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">minIncrementForUnique</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        dic <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>
        repeat <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> A<span class="token punctuation">:</span>
            dic<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">if</span> dic<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>
                repeat<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
        count <span class="token operator">=</span> <span class="token number">0</span>
        hs <span class="token operator">=</span> set<span class="token punctuation">(</span>dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> repeat<span class="token punctuation">:</span>
            <span class="token keyword">while</span> i <span class="token keyword">in</span> hs<span class="token punctuation">:</span>
                i <span class="token operator">+=</span> <span class="token number">1</span>
                count <span class="token operator">+=</span> <span class="token number">1</span>
            hs<span class="token punctuation">.</span>add<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
        <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>后来，我想到了将时间复杂度降为$O(nlogn)$的办法。</p>
<ul>
<li>我们先对数组进行排序（$O(nlog)$）。</li>
<li>统计排序后的数组中的重复元素。</li>
<li>接着，我们从最小的元素值遍历到最大的元素值，即区间为[min（A），max（A）]。如果当前遍历到的值不在数组中且大于当前最小重复元素（因为只能加1），那么就可以从重复元素中选出一个最小的元素放再该位置上，需要移动的步数即为二者之差，省去了为每个数进行while循环找到插入位置的步骤。</li>
<li>如果还有重复元素没有合适的位置被插入，那么就在数组尾部进行插入。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">minIncrementForUnique</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token operator">not</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        A<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
        B <span class="token operator">=</span> set<span class="token punctuation">(</span>A<span class="token punctuation">)</span>
        repeat <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> A<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                repeat<span class="token punctuation">.</span>append<span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        count <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>A<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> B <span class="token operator">and</span> i <span class="token operator">></span> repeat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                count <span class="token operator">+=</span> i <span class="token operator">-</span> repeat<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token operator">not</span><span class="token punctuation">(</span>repeat<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">break</span>
        tail <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token keyword">while</span> repeat<span class="token punctuation">:</span>
            count <span class="token operator">+=</span> tail <span class="token operator">-</span> repeat<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
            tail <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这道题换句话说，就是需要把原数组映射到一个地址不冲突的区域，映射后的地址不小于原数组对应的元素。<br>比如 [3, 2, 1, 2, 1, 7] 就映射成了 [3, 2, 1, 4, 5, 7]。</p>
<p>我想了下，这道题目其实和解决 hash 冲突的线性探测法比较相似！<br>如果地址冲突了，会探测它的下一个位置，如果下一个位置还是冲突，继续向后看，直到第一个不冲突的位置为止。</p>
<p>关键点：因为直接线性探测可能会由于冲突导致反复探测耗时太长，因此我们可以考虑探测的过程中进行路径压缩。<br>怎么路径压缩呢？就是经过某条路径最终探测到一个空位置 x 后，将这条路径上的值都变成空位置所在的下标 x，那么假如下次探测的点又是这条路径上的点，则可以直接跳转到这次探测到的空位置 x，从 x 开始继续探测。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span> <span class="token punctuation">[</span><span class="token number">80000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minIncrementForUnique</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -1表示空位</span>
        <span class="token keyword">int</span> move <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 遍历每个数字a对其寻地址得到位置b, b比a的增量就是操作数。</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token operator">:</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token function">findPos</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> 
            move <span class="token operator">+=</span> b <span class="token operator">-</span> a<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> move<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 线性探测寻址（含路径压缩）</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findPos</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> b <span class="token operator">=</span> pos<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 如果a对应的位置pos[a]是空位，直接放入即可。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            pos<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>
            <span class="token keyword">return</span> a<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 否则向后寻址</span>
        <span class="token comment" spellcheck="true">// 因为pos[a]中标记了上次寻址得到的空位，因此从pos[a]+1开始寻址就行了（不需要从a+1开始）。</span>
        b <span class="token operator">=</span> <span class="token function">findPos</span><span class="token punctuation">(</span>b <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        pos<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 寻址后的新空位要重新赋值给pos[a]哦，路径压缩就是体现在这里。</span>
        <span class="token keyword">return</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="92题-反转链表-II"><a href="#92题-反转链表-II" class="headerlink" title="92题 反转链表 II"></a>92题 <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">反转链表 II</a></h3><p><img src="92.png" alt="92"></p>
<h4 id="思路：-100"><a href="#思路：-100" class="headerlink" title="思路："></a>思路：</h4><p>可以使用头插法解决反转链表问题。</p>
<p>我们先遍历找到链表的第m个位置，然后将第m+1到第n个节点插入至第m个节点之前即可。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span>
<span class="token comment" spellcheck="true"># class ListNode:</span>
<span class="token comment" spellcheck="true">#     def __init__(self, x):</span>
<span class="token comment" spellcheck="true">#         self.val = x</span>
<span class="token comment" spellcheck="true">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">reverseBetween</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>
        dummyhead <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token punctuation">)</span>
        dummyhead<span class="token punctuation">.</span>next <span class="token operator">=</span> head
        pre <span class="token operator">=</span> dummyhead
        p <span class="token operator">=</span> head
        count <span class="token operator">=</span> <span class="token number">1</span>
        <span class="token keyword">while</span> p <span class="token operator">!=</span> None<span class="token punctuation">:</span>
            <span class="token keyword">if</span> m <span class="token operator">&lt;=</span> count <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>
                q <span class="token operator">=</span> p<span class="token punctuation">.</span>next
                p<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
                q<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next
                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> q
                q <span class="token operator">=</span> p<span class="token punctuation">.</span>next
            <span class="token keyword">elif</span> count <span class="token operator">&lt;</span> m<span class="token punctuation">:</span>
                pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next
                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">break</span>
            count <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以使用反转链边常用的快慢双指针法翻转第m到n个节点，使用两个指针存储一下第m-1个节点和第m个节点。翻转完成后，调整一下上述两个节点的next指针即可。 <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode/</a> </p>
<h3 id="820题-单词的压缩编码"><a href="#820题-单词的压缩编码" class="headerlink" title="820题 单词的压缩编码"></a>820题 <a href="https://leetcode-cn.com/problems/short-encoding-of-words/" target="_blank" rel="noopener">单词的压缩编码</a></h3><p><img src="820.png" alt="820"></p>
<h4 id="思路：-101"><a href="#思路：-101" class="headerlink" title="思路："></a>思路：</h4><p>这道题的本质是：如果一个单词出现在另一个单词的尾部，我们可以只需要存储另一个单词，而当前单词只需要截取另一个单词的尾部即可获取。所以，我们要删除所有出现在另一个单词尾部的单词，剩下单词长度加上<code>#</code>的个数即为结果。</p>
<p>我们可以使用反转所有单词+排序的方式，按序进行比较。因为这样做，前缀相同的单词必然位于相邻的位置（字典序）</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">minimumLengthEncoding</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> words<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            words<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        words <span class="token operator">=</span> sorted<span class="token punctuation">(</span>words<span class="token punctuation">)</span>
        res <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> words<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>startswith<span class="token punctuation">(</span>words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">continue</span>
            res <span class="token operator">+=</span> len<span class="token punctuation">(</span>words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>
        res <span class="token operator">+=</span> len<span class="token punctuation">(</span>words<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>
        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这道题还可以用字典树，和求前缀子串类似，只不过本题是后缀。</p>

            </div>
            <hr />

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《LeetCode每日两题》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2020/03/13/leetcode-ti-jie-chi-xu-geng-xin/" property="cc:attributionName"
               rel="cc:attributionURL">
                HillZhang
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: 'uCuovwWUzxnygDdXy6SPs97E-gzGzoHsz',
        appKey: 'oroAoITTPFXepwWrR1qGq7b7',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '欢迎和我一起交流！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/03/17/kmp-suan-fa/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="KMP算法">
                        
                        <span class="card-title">KMP算法</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            前言本文整理了KMP算法的原理及代码，可以使用LEETCODE上的题目进行测试：28. 实现 strStr()。
从Brute-Force算法说起BF算法是最为简单的一种字符串匹配算法，它采用纯暴力匹配的思想。对于目标串S和模式串P，其基本
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2020-03-17
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/编程算法/" class="post-category" target="_blank">
                                    编程算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/算法/" target="_blank">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/02/16/sort-algorithms/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="十大经典排序算法整理汇总（附代码）">
                        
                        <span class="card-title">十大经典排序算法整理汇总（附代码）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2020-02-16
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/编程算法/" class="post-category" target="_blank">
                                    编程算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/算法/" target="_blank">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                    <a href="/tags/leetcode/" target="_blank">
                        <span class="chip bg-color">leetcode</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: HillZhang的博客<br />'
            + '作者: HillZhang<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2019-2020 ZhangYue. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">149.6k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/HillZhang1999" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:471791641@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>





    <a href="http://wpa.qq.com/msgrd?v=3&uin=471791641&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>





    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 80000;
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2020, 03, 11, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    

    <!-- 雪花特效 -->
    

</body>

</html>